{"className":"jfreerails.client.top.UserInputOnMapController","javaDoc":"/**\n* Handles key presses and mouse movements on the map - responsible for moving\n* the cursor etc.\n*\n* @author Luke\n*/","code":"/**\n* Handles key presses and mouse movements on the map - responsible for moving\n* the cursor etc.\n*\n* @author Luke\n*/\npublic class UserInputOnMapController extends KeyAdapter {\nprivate static final String JFREERAILS_CLIENT_SOUNDS_BUILDTRACK_WAV = \"/jfreerails/client/sounds/buildtrack.wav\";\nprivate static final Logger logger = Logger\n.getLogger(UserInputOnMapController.class.getName());\nprivate StationTypesPopup stationTypesPopup;\nprivate BuildIndustryJPopupMenu buildIndustryJPopupMenu = new BuildIndustryJPopupMenu();\nprivate MapViewJComponent mapView;\nprivate TrackMoveProducer trackBuilder;\nprivate DialogueBoxController dialogueBoxController;\nprivate final ModelRoot modelRoot;\nprivate final ActionRoot actionRoot;\nprivate final MouseInputAdapter mouseInputAdapter = new CursorMouseAdapter();\n/**\n* Used to determine if mouse clicks are on trains.\n*/\nprivate TrainRenderer trainRenderer;\nprivate BuildTrackController buildTrack;\nprivate SoundManager soundManager = SoundManager.getSoundManager();\nprivate boolean ignoreDragging = false;\npublic UserInputOnMapController(ModelRoot mr, ActionRoot ar) {\nmodelRoot = mr;\nactionRoot = ar;\n}\nprivate class CursorMouseAdapter extends MouseInputAdapter {\nprivate boolean pressedInside = false;\n@Override\npublic void mouseClicked(MouseEvent evt) {\nboolean isDoubleClick = evt.getClickCount() == 2;\nReadOnlyWorld w = modelRoot.getWorld();\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nif (SwingUtilities.isLeftMouseButton(evt)) {\nint x = evt.getX();\nint y = evt.getY();\nDouble time = (Double) modelRoot.getProperty(Property.TIME);\nint clickedTrain = -1;\n//Iterate in reverse order since later trains are rendered over earlier ones.\nfor (int i = w.size(principal, KEY.TRAINS) -1; i >= 0 ; i--) {\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS, i);\nTrainAccessor ta = new TrainAccessor(w, principal, i);\nTrainPositionOnMap pos = ta.findPosition(time);\nList<Map.Entry<Point, Step>> positions = trainRenderer.calcPositions(train, pos);\nboolean hit = trainRenderer.isHit(evt.getPoint(), train, positions);\nif(hit){\nclickedTrain = i;\nbreak;\n}\n}\nif (clickedTrain != -1) {\nmodelRoot.setProperty(Property.SELECTED_TRAIN, clickedTrain);\nif (isDoubleClick) {\ndialogueBoxController.showTrainOrders(clickedTrain);\n}\n} else {\nif (isDoubleClick) {\nImPoint cursorPosition = (ImPoint) modelRoot.getProperty(Property.CURSOR_POSITION);\ndialogueBoxController.showStationOrTerrainInfo(cursorPosition.x,\ncursorPosition.y);\n}\n}\n}\n}\n@Override\npublic void mousePressed(MouseEvent evt\n) {\nif (SwingUtilities.isLeftMouseButton(evt)) {\nignoreDragging = false;\nint x = evt.getX();\nint y = evt.getY();\nfloat scale = mapView.getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\n// only jump - no track building\nmoveCursorJump(new ImPoint(x / tileSize.width, y\n/ tileSize.height));\nmapView.requestFocus();\npressedInside = true;\n/*\n* Fix for bug [ 972866 ] Build track by dragging - only when\n* build track selected\n*/\nboolean isBuildTrackModeSet = trackBuilder\n.getTrackBuilderMode() == BUILD_TRACK;\nif (isBuildTrackModeSet) {\nbuildTrack.show();\n}\n} else if (SwingUtilities.isRightMouseButton(evt)) {\n// Cancel building track.\nbuildTrack.hide();\nignoreDragging = true;\nsetIgnoreKeyEvents(false);\n}\n}\n@Override\npublic void mouseDragged(MouseEvent evt\n) {\nBuildMode trackBuilderMode = trackBuilder.getTrackBuilderMode();\n/*\n* Fix for bug [ 972866 ] Build track by dragging - only when build\n* track selected\n* Fix for bug [1537413 ] Exception when building station.\n*/\nboolean trackBuildingOn = (trackBuilderMode == BUILD_TRACK)\n|| (trackBuilderMode == REMOVE_TRACK)\n|| (trackBuilderMode == UPGRADE_TRACK);\ntrackBuildingOn = trackBuildingOn\n&& (modelRoot.getProperty(ModelRoot.Property.CURSOR_MODE) == ModelRoot.Value.BUILD_TRACK_CURSOR_MODE);\nif (SwingUtilities.isLeftMouseButton(evt) && pressedInside\n&& trackBuildingOn && !ignoreDragging) {\nsetIgnoreKeyEvents(true);\nint x = evt.getX();\nint y = evt.getY();\nfloat scale = mapView.getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\nint tileX = x / tileSize.width;\nint tileY = y / tileSize.height;\n/*\n* See the javadoc for JComponent.setAutoscrolls(boolean\n* autoscrolls)\n*/\nassert mapView.getAutoscrolls();\n// Scroll view if necessary.\nif (!mapView.getVisibleRect().contains(x, y)) {\n/*\n* Making the rectangle we scroll to 2 tiles wide and\n* centered on x, y means that we scroll at least one tile.\n* This stops painfully slow scrolling in full screen mode\n* when the mouse cannot be dragged far from the viewport\n* since it hits the screen edge.\n*/\nRectangle r = new Rectangle(x - tileSize.width, y\n- tileSize.height, 2 * tileSize.width,\n2 * tileSize.height);\nmapView.scrollRectToVisible(r);\n}\nImPoint to = new ImPoint(\ntileX, tileY);\nbuildTrack.setProposedTrack(to, trackBuilder);\nmapView.requestFocus();\n}\n}\n@Override\npublic void mouseReleased(MouseEvent evt\n) {\nif (SwingUtilities.isLeftMouseButton(evt)) {\nignoreDragging = false;\nsetIgnoreKeyEvents(false);\n// build a railroad from x,y to current cursor position\nif (pressedInside && buildTrack.isBuilding()\n&& buildTrack.isBuildTrackSuccessful()) {\n// Fix for bug [ 997088 ]\n// Is current posisition different from original position?\nint x = evt.getX();\nint y = evt.getY();\nfloat scale = mapView.getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\nint tileX = x / tileSize.width;\nint tileY = y / tileSize.height;\nif (getCursorPosition().x != tileX\n|| getCursorPosition().y != tileY) {\n// copy WorldDifferences from buildTrack to World\nImPoint newPosition = buildTrack\n.updateWorld(trackBuilder);\nsetCursorPosition(newPosition);\n}\n}\npressedInside = false;\nbuildTrack.hide();\n}\n}\n}\nprivate void cursorOneTileMove(ImPoint oldPosition, Step vector) {\nboolean b = (modelRoot.getProperty(ModelRoot.Property.CURSOR_MODE) == ModelRoot.Value.BUILD_TRACK_CURSOR_MODE);\nif (null != trackBuilder && b) {\ntrackBuilder.setBuildTrackStrategy(getBts());\nMoveStatus ms = trackBuilder.buildTrack(oldPosition, vector);\nif (ms.ok) {\nsetCursorMessage(\"\");\nplayAppropriateSound();\n} else {\nsetCursorMessage(ms.message);\n}\n} else {\nlogger.warning(\"No track builder available!\");\n}\n}\nprivate void playAppropriateSound() {\nswitch (trackBuilder.getTrackBuilderMode()) {\ncase BUILD_TRACK:\ncase UPGRADE_TRACK:\nsoundManager.playSound(JFREERAILS_CLIENT_SOUNDS_BUILDTRACK_WAV, 0);\nbreak;\ncase REMOVE_TRACK:\nsoundManager.playSound(\"/jfreerails/client/sounds/removetrack.wav\",\n0);\nbreak;\ndefault:\n// do nothing\n}\n}\npublic void setup(MapViewJComponent mv, TrackMoveProducer trackBuilder,\nStationTypesPopup stPopup, ModelRoot mr, DialogueBoxController dbc,\nFreerailsCursor cursor, BuildTrackController buildTrack, TrainRenderer trainRenderer) {\nthis.dialogueBoxController = dbc;\nthis.mapView = mv;\nthis.stationTypesPopup = stPopup;\nthis.trackBuilder = trackBuilder;\nthis.buildTrack = buildTrack;\nthis.trainRenderer = trainRenderer;\nbuildIndustryJPopupMenu.setup(mr, null, null);\n/*\n* We attempt to remove listeners before adding them to prevent them\n* being added several times.\n*/\nmapView.removeMouseListener(mouseInputAdapter);\nmapView.addMouseListener(mouseInputAdapter);\nmapView.removeMouseMotionListener(mouseInputAdapter);\nmapView.addMouseMotionListener(mouseInputAdapter);\nmapView.removeKeyListener(this);\nmapView.addKeyListener(this);\n}\nprivate void cursorJumped(ImPoint to) {\n// if (trackBuilder.getTrackBuilderMode() ==\n// TrackMoveProducer.UPGRADE_TRACK) {\n// MoveStatus ms = trackBuilder.upgradeTrack(to);\n//\n// if (ms.ok) {\n// setCursorMessage(\"\");\n// playAppropriateSound();\n// } else {\n// setCursorMessage(ms.message);\n// }\n// }\n}\nprivate ImPoint getCursorPosition() {\nImPoint point = (ImPoint) modelRoot\n.getProperty(ModelRoot.Property.CURSOR_POSITION);\n// Check for null\npoint = null == point ? new ImPoint() : point;\nreturn point;\n}\nprivate void setCursorPosition(ImPoint p) {\n// Make a defensive copy.\nImPoint point = p;\nmodelRoot.setProperty(Property.CURSOR_POSITION, point);\n}\nprivate void setCursorMessage(String s) {\nmodelRoot.setProperty(Property.CURSOR_MESSAGE, s);\n}\n@Override\npublic void keyPressed(KeyEvent e) {\nint keyCode = e.getKeyCode();\nif (isIgnoreKeyEvents()) {\nif (keyCode == KeyEvent.VK_ESCAPE) {\nsetIgnoreKeyEvents(false);\n} else {\nreturn;\n}\n}\nImPoint cursorPosition = getCursorPosition();\nswitch (keyCode) {\ncase KeyEvent.VK_NUMPAD1:\nmoveCursorOneTile(Step.SOUTH_WEST);\nbreak;\ncase KeyEvent.VK_NUMPAD2:\nmoveCursorOneTile(Step.SOUTH);\nbreak;\n// @SonnyZ\ncase KeyEvent.VK_DOWN:\nif (e.getModifiers() == 2) {\nmoveCursorOneTile(Step.SOUTH);\n}\nbreak;\n// --\ncase KeyEvent.VK_NUMPAD3:\nmoveCursorOneTile(Step.SOUTH_EAST);\nbreak;\ncase KeyEvent.VK_NUMPAD4:\nmoveCursorOneTile(Step.WEST);\nbreak;\n// @SonnyZ\ncase KeyEvent.VK_LEFT:\nif (e.getModifiers() == 2) {\nmoveCursorOneTile(Step.WEST);\n}\nbreak;\n// --\ncase KeyEvent.VK_NUMPAD6:\nmoveCursorOneTile(Step.EAST);\nbreak;\n// @SonnyZ\ncase KeyEvent.VK_RIGHT:\nif (e.getModifiers() == 2) {\nmoveCursorOneTile(Step.EAST);\n}\nbreak;\n// --\ncase KeyEvent.VK_NUMPAD7:\nmoveCursorOneTile(Step.NORTH_WEST);\nbreak;\ncase KeyEvent.VK_NUMPAD8:\nmoveCursorOneTile(Step.NORTH);\nbreak;\n// @SonnyZ\ncase KeyEvent.VK_UP:\nif (e.getModifiers() == 2) {\nmoveCursorOneTile(Step.NORTH);\n}\nbreak;\n// --\ncase KeyEvent.VK_NUMPAD9:\nmoveCursorOneTile(Step.NORTH_EAST);\nbreak;\ncase KeyEvent.VK_F8: {\n// Check whether we can built a station here before proceeding.\nif (stationTypesPopup.canBuiltStationHere(cursorPosition.toPoint())) {\nfloat scale = mapView.getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\nint x = cursorPosition.x * tileSize.width;\nint y = cursorPosition.y * tileSize.height;\nstationTypesPopup.showMenu(mapView, x, y, cursorPosition\n.toPoint());\n} else {\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Can't\"\n+ \" build station here!\");\n}\nbreak;\n}\ncase KeyEvent.VK_BACK_SPACE:\nlogger.info(\"Undo building track currently not implemented.\");\n//\n// MoveStatus ms = trackBuilder.undoLastTrackMove();\n//\n// if (!ms.isOk()) {\n// setCursorMessage(ms.message);\n// }\nbreak;\ncase KeyEvent.VK_I: {\ndialogueBoxController.showStationOrTerrainInfo(cursorPosition.x,\ncursorPosition.y);\nbreak;\n}\ncase KeyEvent.VK_C: {\nmapView.centerOnTile(cursorPosition.toPoint());\nbreak;\n}\ncase KeyEvent.VK_B: {\nfloat scale = mapView.getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\nint x = cursorPosition.x * tileSize.width;\nint y = cursorPosition.y * tileSize.height;\nbuildIndustryJPopupMenu.setCursorLocation(cursorPosition.toPoint());\nbuildIndustryJPopupMenu.show(mapView, x, y);\nbreak;\n}\ncase KeyEvent.VK_ESCAPE: {\ncancelProposedBuild();\nbreak;\n}\n// @author SonnyZ\ncase KeyEvent.VK_X: {\n// modelRoot.setProperty(Property.QUICK_MESSAGE, keyCode + \" was\n// pressed!\");\ndialogueBoxController.showExitDialog();\nbreak;\n}\n// @SonnyZ\ncase KeyEvent.VK_S: {\nif (e.getModifiers() == 2) {\nServerControlModel cont = actionRoot.getServerControls();\n// String name = JOptionPane.showInputDialog(null, \"Saved Game\n// Name:\",\"Save\n// Game\",JOptionPane.QUESTION_MESSAGE,null,null,modelRoot.getPrincipal().getName()).toString();\n// modelRoot.setProperty(Property.QUICK_MESSAGE, name);\ncont.getSaveGameAction().actionPerformed(null);\n}\nbreak;\n}\n// @SonnyZ\ncase KeyEvent.VK_L: {\nif (e.getModifiers() == 2) {\nServerControlModel cont = actionRoot.getServerControls();\ncont.getLoadGameAction().actionPerformed(null);\n}\nbreak;\n}\n// @SonnyZ\ncase KeyEvent.VK_M: {\n// if the screen is not clicked after the broker screen is closed\n// and 'M' is pressed\n// again, the broker screen will never show up again.\ndialogueBoxController.showBrokerScreen();\nbreak;\n}\ncase KeyEvent.VK_F12: {\nSystem.out.println(\"Disable keyboard input!\");\nsetIgnoreKeyEvents(true);\nbreak;\n}\n}\n}\nprivate void cancelProposedBuild() {\nignoreDragging = true;\nbuildTrack.hide();\nStationBuildModel sbm = actionRoot.getStationBuildModel();\nsbm.getStationCancelAction().actionPerformed(\nnew ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"\"));\nsetIgnoreKeyEvents(false);\n}\nprivate void moveCursorJump(ImPoint tryThisPoint) {\nsetCursorMessage(\"\");\nif (legalRectangleContains(tryThisPoint)) {\nsetCursorPosition(tryThisPoint);\ncursorJumped(tryThisPoint);\n} else {\nthis.setCursorMessage(\"Illegal cursor position!\");\n}\n}\n/**\n* Checks whether specified point is in legal rectangle.\n*\n* @param tryThisPoint ImPoint\n* @return boolean\n*/\nprivate boolean legalRectangleContains(ImPoint tryThisPoint) {\nReadOnlyWorld world = modelRoot.getWorld();\nint width = world.getMapWidth();\nint height = world.getMapHeight();\nRectangle legalRectangle = new Rectangle(0, 0, width, height);\nreturn legalRectangle.contains(tryThisPoint.toPoint());\n}\nprivate void moveCursorOneTile(Step v) {\nsetCursorMessage(null);\nImPoint cursorMapPosition = this.getCursorPosition();\nImPoint tryThisPoint = new ImPoint(cursorMapPosition.x + v.getDx(),\ncursorMapPosition.y + v.getDy());\n/* Move the cursor. */\nif (legalRectangleContains(tryThisPoint)) {\nsetCursorPosition(tryThisPoint);\ncursorOneTileMove(cursorMapPosition, v);\n} else {\nthis.setCursorMessage(\"Illegal cursor position!\");\n}\n}\nprivate BuildTrackStrategy getBts() {\nBuildTrackStrategy bts = (BuildTrackStrategy) modelRoot\n.getProperty(ModelRoot.Property.BUILD_TRACK_STRATEGY);\nif (null == bts) {\nthrow new NullPointerException();\n}\nreturn bts;\n}\nprivate void setIgnoreKeyEvents(boolean ignoreKeyEvents) {\nmodelRoot.setProperty(Property.IGNORE_KEY_EVENTS, Boolean\n.valueOf(ignoreKeyEvents));\n}\nprivate boolean isIgnoreKeyEvents() {\nBoolean b = (Boolean) modelRoot.getProperty(Property.IGNORE_KEY_EVENTS);\nreturn b.booleanValue();\n}\n}"}
{"className":"jfreerails.client.top.BuildMenu","javaDoc":"/**\n* The menu that lets you select a track type.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* The menu that lets you select a track type.\n*\n* @author Luke Lindsay\n*/\nfinal public class BuildMenu extends javax.swing.JMenu {\nprivate static final long serialVersionUID = 3617850859305055542L;\npublic BuildMenu() {\nsuper();\n}\npublic void setup(ActionRoot actionRoot) {\nthis.removeAll();\nthis.setText(\"Build\");\nadd(actionRoot.getBuildTrainDialogAction());\n}\n}"}
{"className":"jfreerails.client.top.RenderersRootImpl","javaDoc":"/**\n* Implementation of RenderersRoot whose constructor loads graphics and provides\n* feed back using a FreerailsProgressMonitor.\n*\n* @author Luke\n*/","code":"/**\n* Implementation of RenderersRoot whose constructor loads graphics and provides\n* feed back using a FreerailsProgressMonitor.\n*\n* @author Luke\n*/\npublic class RenderersRootImpl implements RenderersRoot {\nprivate static final Logger logger = Logger.getLogger(RenderersRootImpl.class\n.getName());\nprivate final TileRendererList tiles;\nprivate final TrackPieceRendererList trackPieceViewList;\nprivate final ImageManager imageManager;\nprivate final ArrayList<TrainImages> wagonImages = new ArrayList<TrainImages>();\nprivate final ArrayList<TrainImages> engineImages = new ArrayList<TrainImages>();\npublic RenderersRootImpl(ReadOnlyWorld w, FreerailsProgressMonitor pm)\nthrows IOException {\nURL out = RenderersRootImpl.class.getResource(\"/experimental\");\nimageManager = new ImageManagerImpl(\"/jfreerails/client/graphics/\", out\n.getPath());\ntiles = loadNewTileViewList(w, pm);\ntrackPieceViewList = loadTrackViews(w, pm);\n//rr = new OldTrainImages(w, imageManager, pm);\nloadTrainImages(w, pm);\npreloadSounds(pm);\n}\nprivate void loadTrainImages(ReadOnlyWorld w, FreerailsProgressMonitor pm)\nthrows IOException {\n// Setup progress monitor..\nfinal int numberOfWagonTypes = w.size(SKEY.CARGO_TYPES);\nfinal int numberOfEngineTypes = w.size(SKEY.ENGINE_TYPES);\npm.nextStep(numberOfWagonTypes + numberOfEngineTypes);\nint progress = 0;\npm.setValue(progress);\n//Load wagon images.\nfor (int i = 0; i < numberOfWagonTypes; i++) {\nCargoType cargoType = (CargoType) w.get(SKEY.CARGO_TYPES, i);\nString name = cargoType.getName();\nTrainImages ti = new TrainImages(imageManager, name);\nwagonImages.add(ti);\npm.setValue(++progress);\n}\n//Load engine images\nfor (int i = 0; i < numberOfEngineTypes; i++) {\nEngineType engineType = (EngineType) w.get(SKEY.ENGINE_TYPES, i);\nString engineTypeName = engineType\n.getEngineTypeName();\nTrainImages ti = new TrainImages(imageManager, engineTypeName);\nengineImages.add(ti);\npm.setValue(++progress);\n}\n}\nprivate void preloadSounds(FreerailsProgressMonitor pm) {\n// Pre-load sounds..\nString[] soundsFiles = { \"/jfreerails/client/sounds/buildtrack.wav\",\n\"/jfreerails/client/sounds/cash.wav\",\n\"/jfreerails/client/sounds/removetrack.wav\",\n\"/jfreerails/client/sounds/whistle.wav\" };\npm.nextStep(soundsFiles.length);\nSoundManager sm = SoundManager.getSoundManager();\nfor (int i = 0; i < soundsFiles.length; i++) {\ntry {\nsm.addClip(soundsFiles[i]);\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n} catch (UnsupportedAudioFileException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n} catch (LineUnavailableException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\npm.setValue(i + 1);\n}\n}\nprivate TrackPieceRendererList loadTrackViews(ReadOnlyWorld w,\nFreerailsProgressMonitor pm) throws IOException {\nreturn new TrackPieceRendererList(w, imageManager, pm);\n}\nprivate TileRendererList loadNewTileViewList(ReadOnlyWorld w,\nFreerailsProgressMonitor pm) throws IOException {\nArrayList<TileRenderer> tileRenderers = new ArrayList<TileRenderer>();\n// Setup progress monitor..\nint numberOfTypes = w.size(SKEY.TERRAIN_TYPES);\npm.nextStep(numberOfTypes);\nint progress = 0;\npm.setValue(progress);\nfor (int i = 0; i < numberOfTypes; i++) {\nTerrainType t = (TerrainType) w.get(SKEY.TERRAIN_TYPES, i);\nint[] typesTreatedAsTheSame = new int[] { i };\nTileRenderer tr = null;\npm.setValue(++progress);\ntry {\n// XXX hack to make rivers flow into ocean and habours & occean\n// treat habours as the same type.\nTerrainType.Category thisTerrainCategory = t.getCategory();\nif (thisTerrainCategory.equals(TerrainType.Category.River)\n|| thisTerrainCategory\n.equals(TerrainType.Category.Ocean)) {\n// Count number of types with category \"water\"\nint count = 0;\nfor (int j = 0; j < numberOfTypes; j++) {\nTerrainType t2 = (TerrainType) w.get(\nSKEY.TERRAIN_TYPES, j);\nTerrainType.Category terrainCategory = t2.getCategory();\nif (terrainCategory.equals(TerrainType.Category.Ocean)\n|| terrainCategory.equals(thisTerrainCategory)) {\ncount++;\n}\n}\ntypesTreatedAsTheSame = new int[count];\ncount = 0;\nfor (int j = 0; j < numberOfTypes; j++) {\nTerrainType t2 = (TerrainType) w.get(\nSKEY.TERRAIN_TYPES, j);\nTerrainType.Category terrainCategory = t2.getCategory();\nif (terrainCategory.equals(TerrainType.Category.Ocean)\n|| terrainCategory.equals(thisTerrainCategory)) {\ntypesTreatedAsTheSame[count] = j;\ncount++;\n}\n}\n}\ntr = new RiverStyleTileRenderer(imageManager,\ntypesTreatedAsTheSame, t);\ntileRenderers.add(tr);\ncontinue;\n} catch (IOException io) {\n}\ntry {\ntr = new ForestStyleTileRenderer(imageManager,\ntypesTreatedAsTheSame, t);\ntileRenderers.add(tr);\ncontinue;\n} catch (IOException io) {\n}\ntry {\ntr = new ChequeredTileRenderer(imageManager,\ntypesTreatedAsTheSame, t);\ntileRenderers.add(tr);\ncontinue;\n} catch (IOException io) {\n}\ntry {\ntr = new StandardTileRenderer(imageManager,\ntypesTreatedAsTheSame, t);\ntileRenderers.add(tr);\ncontinue;\n} catch (IOException io) {\n// If the image is missing, we generate it.\nlogger\n.warning(\"No tile renderer for \"\n+ t.getTerrainTypeName());\nString filename = StandardTileRenderer.generateFilename(t\n.getTerrainTypeName());\nImage image = QuickRGBTileRendererList.createImageFor(t);\nimageManager.setImage(filename, image);\n// generatedImages.setImage(filename, image);\ntry {\ntr = new StandardTileRenderer(imageManager,\ntypesTreatedAsTheSame, t);\ntileRenderers.add(tr);\ncontinue;\n} catch (IOException io2) {\nio2.printStackTrace();\nthrow new IllegalStateException();\n}\n}\n}\n// XXXX add special tile renderer for habours\nTileRenderer oceanTileRenderer = null;\nfor (int j = 0; j < numberOfTypes; j++) {\nTerrainType t2 = (TerrainType) w.get(SKEY.TERRAIN_TYPES, j);\nString terrainName = t2.getTerrainTypeName();\nif (terrainName.equalsIgnoreCase(\"Ocean\")) {\noceanTileRenderer = tileRenderers.get(j);\nbreak;\n}\n}\nfor (int j = 0; j < numberOfTypes; j++) {\nTerrainType t2 = (TerrainType) w.get(SKEY.TERRAIN_TYPES, j);\nString terrainName = t2.getTerrainTypeName();\nif (terrainName.equalsIgnoreCase(\"Harbour\")) {\nTerrainType t = (TerrainType) w.get(SKEY.TERRAIN_TYPES, j);\nTileRenderer tr = new SpecialTileRenderer(imageManager,\nnew int[] { j }, t, oceanTileRenderer);\ntileRenderers.set(j, tr);\nbreak;\n}\n}\nreturn new TileRendererListImpl(tileRenderers);\n}\npublic TileRendererList getTileViewList() {\nreturn this.tiles;\n}\npublic TrackPieceRendererList getTrackPieceViewList() {\nreturn this.trackPieceViewList;\n}\npublic boolean validate(ReadOnlyWorld w) {\nboolean okSoFar = true;\nif (!this.tiles.validate(w)) {\nokSoFar = false;\n}\nif (!this.trackPieceViewList.validate(w)) {\nokSoFar = false;\n}\nreturn okSoFar;\n}\n// public OldTrainImages getTrainImages() {\n// return rr;\n// }\npublic ImageManager getImageManager() {\nreturn imageManager;\n}\npublic Image getImage(String relativeFilename) throws IOException {\nreturn imageManager.getImage(relativeFilename);\n}\npublic TileRenderer getTileViewWithNumber(int i) {\nreturn tiles.getTileViewWithNumber(i);\n}\npublic TrackPieceRenderer getTrackPieceView(int i) {\nreturn trackPieceViewList.getTrackPieceView(i);\n}\npublic TrainImages getWagonImages(int type) {\nreturn wagonImages.get(type);\n}\npublic TrainImages getEngineImages(int type) {\nreturn engineImages.get(type);\n}\npublic Image getScaledImage(String relativeFilename, int height) throws IOException {\nreturn imageManager.getScaledImage(relativeFilename, height);\n}\n}"}
{"className":"jfreerails.client.top.SynchronizedEventQueue","javaDoc":"/**\n* This event queue is synchronized on the MUTEX. This lets one control when\n* events can be dispatched.\n*\n* Note, changed to be a singleton to get it working on pre 1.4.2 VMs.\n*\n* @author Luke\n*\n*/","code":"/**\n* This event queue is synchronized on the MUTEX. This lets one control when\n* events can be dispatched.\n*\n* Note, changed to be a singleton to get it working on pre 1.4.2 VMs.\n*\n* @author Luke\n*\n*/\nfinal public class SynchronizedEventQueue extends EventQueue {\npublic static final Object MUTEX = new Object();\nprivate static final SynchronizedEventQueue instance = new SynchronizedEventQueue();\nprivate static boolean alreadyInUse = false;\n/** Enforce singleton property. */\nprivate SynchronizedEventQueue() {\n}\npublic static synchronized void use() {\nif (!alreadyInUse) {\n/* set up the synchronized event queue */\nEventQueue eventQueue = Toolkit.getDefaultToolkit()\n.getSystemEventQueue();\neventQueue.push(instance);\nalreadyInUse = true;\n}\n}\n@Override\nprotected void dispatchEvent(AWTEvent aEvent) {\nsynchronized (MUTEX) {\ntry {\nsuper.dispatchEvent(aEvent);\n} catch (Exception e) {\n/*\n* If something goes wrong, lets kill the game straight away to\n* avoid hard-to-track-down bugs.\n*/\nReportBugTextGenerator.unexpectedException(e);\n}\n}\n}\npublic static SynchronizedEventQueue getInstance() {\nreturn instance;\n}\n}"}
{"className":"jfreerails.client.top.QuickRGBTileRendererList","javaDoc":"/**\n* Simple implementation of TileRendererList, for testing purposes only.\n*\n* @author Luke\n*\n*/","code":"/**\n* Simple implementation of TileRendererList, for testing purposes only.\n*\n* @author Luke\n*\n*/\npublic class QuickRGBTileRendererList implements TileRendererList {\nprivate final int[] rgbValues;\nprivate final Image[] images;\nprivate final HashMap<Integer, Integer> rgb2index = new HashMap<Integer, Integer>();\nprivate final SimpleTileRenderer simpleTileRenderer = new SimpleTileRenderer();\nprivate static final java.awt.GraphicsConfiguration defaultConfiguration = java.awt.GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\npublic QuickRGBTileRendererList(ReadOnlyWorld w) {\nint numberOfTerrainTypes = w.size(SKEY.TERRAIN_TYPES);\nrgbValues = new int[numberOfTerrainTypes];\nimages = new Image[numberOfTerrainTypes];\nfor (int i = 0; i < numberOfTerrainTypes; i++) {\nTerrainType t = (TerrainType) w.get(SKEY.TERRAIN_TYPES, i);\nrgbValues[i] = t.getRGB();\nimages[i] = createImageFor(t);\nrgb2index.put(new Integer(t.getRGB()), new Integer(i));\n}\n}\npublic static Image createImageFor(TerrainType t) {\nImage image = defaultConfiguration.createCompatibleImage(\nConstants.TILE_SIZE, Constants.TILE_SIZE);\nColor c = new Color(t.getRGB());\nGraphics g = image.getGraphics();\ng.setColor(c);\ng.fillRect(0, 0, Constants.TILE_SIZE, Constants.TILE_SIZE);\ng.dispose();\nreturn image;\n}\npublic TileRenderer getTileViewWithNumber(int i) {\nthrow new UnsupportedOperationException();\n}\npublic TileRenderer getTileViewWithRGBValue(int rgb) {\nInteger i = rgb2index.get(new Integer(rgb));\nthis.simpleTileRenderer.setImage(images[i.intValue()]);\nreturn simpleTileRenderer;\n}\npublic boolean validate(ReadOnlyWorld world) {\nreturn true;\n}\nclass SimpleTileRenderer implements TileRenderer {\nImage i;\npublic SimpleTileRenderer() {\n}\npublic void setImage(Image i) {\nthis.i = i;\n}\npublic Image getDefaultIcon() {\nreturn i;\n}\npublic void renderTile(Graphics g, int renderX, int renderY, int mapX,\nint mapY, ReadOnlyWorld w) {\ng.drawImage(i, renderX, renderY, null);\n}\npublic void dumpImages(ImageManager imageManager) {\n// TODO Auto-generated method stub\nthrow new UnsupportedOperationException();\n}\n}\n}"}
{"className":"jfreerails.client.top.GUIComponentFactoryTestImpl","javaDoc":"/**\n* Implementation of GUIComponentFactory that returns 'blank' components - used\n* for testing the layout of ClientJFrame.\n*\n* @author Luke\n*/","code":"/**\n* Implementation of GUIComponentFactory that returns 'blank' components - used\n* for testing the layout of ClientJFrame.\n*\n* @author Luke\n*/\npublic class GUIComponentFactoryTestImpl implements GUIComponentFactory {\nprivate final JLabel datejLabel;\nprivate final JLabel cashjLabel;\nprivate final JTabbedPane trainsJPanel;\nprivate final JMenu displayMenu;\nprivate final JScrollPane mainMapView;\nprivate final JMenu buildMenu;\nprivate final JMenu gameMenu;\nprivate final JPanel mapOverview;\nprivate final JMenu helpMenu;\nprivate final JLabel messageJLabel;\nprivate final JMenu brokerMenu;\n/** Creates a new instance of GUIComponentFactoryTestImpl. */\npublic GUIComponentFactoryTestImpl() {\nJPanel mainmapjPanel;\ntrainsJPanel = new JTabbedPane();\ndatejLabel = new JLabel();\nmapOverview = new JPanel();\ncashjLabel = new JLabel();\nmainMapView = new JScrollPane();\nmainmapjPanel = new JPanel();\nmessageJLabel = new JLabel();\ngameMenu = new JMenu();\nbuildMenu = new JMenu();\ndisplayMenu = new JMenu();\nhelpMenu = new JMenu();\nbrokerMenu = new JMenu();\ntrainsJPanel.setBackground(new java.awt.Color(255, 51, 51));\ndatejLabel.setText(\"Jun, 1840\");\nmapOverview.setBackground(new java.awt.Color(0, 204, 255));\nmapOverview.setPreferredSize(new java.awt.Dimension(100, 100));\ncashjLabel.setText(\"$100,000\");\nmainmapjPanel.setBackground(new java.awt.Color(153, 244, 51));\nmainMapView.setViewportView(mainmapjPanel);\nmessageJLabel.setText(\"message\");\n}\npublic JMenu createReportsMenu() {\nreturn new JMenu(\"Reports\");\n}\npublic JMenu createBuildMenu() {\nreturn buildMenu;\n}\npublic JLabel createCashJLabel() {\nreturn cashjLabel;\n}\npublic JLabel createDateJLabel() {\nreturn datejLabel;\n}\npublic JMenu createDisplayMenu() {\nreturn displayMenu;\n}\npublic JMenu createGameMenu() {\nreturn gameMenu;\n}\npublic JMenu createHelpMenu() {\nreturn helpMenu;\n}\npublic JScrollPane createMainMap() {\nreturn mainMapView;\n}\npublic JPanel createOverviewMap() {\nreturn mapOverview;\n}\npublic JTabbedPane createTrainsJTabPane() {\nreturn trainsJPanel;\n}\npublic JMenu createBrokerMenu() {\nreturn brokerMenu;\n}\n}"}
{"className":"jfreerails.client.top.ClientJFrame","javaDoc":"/**\n* The JFrame that you see while you are playing the game.\n*\n* @author Luke\n*/","code":"/**\n* The JFrame that you see while you are playing the game.\n*\n* @author Luke\n*/\npublic class ClientJFrame extends javax.swing.JFrame {\nprivate static final long serialVersionUID = 3834868100742265142L;\nprivate GUIComponentFactory gUIComponentFactory;\n/** Creates new form ClientJFrame. */\npublic ClientJFrame(GUIComponentFactory gcf) {\nsetup(gcf);\n}\nprivate void setup(GUIComponentFactory gcf) {\nthis.gUIComponentFactory = gcf;\ninitComponents();\ngUIComponentFactory.createDateJLabel();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nrhsjPanel = new javax.swing.JPanel();\nmapOverview = gUIComponentFactory.createOverviewMap();\ntrainsJTabPane1 = gUIComponentFactory.createTrainsJTabPane();\nlhsjPanel = new javax.swing.JPanel();\nmainMapView = gUIComponentFactory.createMainMap();\nstatusjPanel = new javax.swing.JPanel();\ndatejLabel = gUIComponentFactory.createDateJLabel();\ncashjLabel = gUIComponentFactory.createCashJLabel();\njMenuBar1 = new javax.swing.JMenuBar();\ngameMenu = gUIComponentFactory.createGameMenu();\nbuildMenu = gUIComponentFactory.createBuildMenu();\nBrokerMenu1 = gUIComponentFactory.createBrokerMenu();\ndisplayMenu = gUIComponentFactory.createDisplayMenu();\nreportsMenu = gUIComponentFactory.createReportsMenu();\nhelpMenu = gUIComponentFactory.createHelpMenu();\ngetContentPane().setLayout(new java.awt.GridBagLayout());\naddWindowListener(new java.awt.event.WindowAdapter() {\n@Override\npublic void windowClosing(java.awt.event.WindowEvent evt) {\nexitForm(evt);\n}\n});\nrhsjPanel.setLayout(new java.awt.GridBagLayout());\nrhsjPanel.add(mapOverview, new java.awt.GridBagConstraints());\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridy = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nrhsjPanel.add(trainsJTabPane1, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weighty = 1.0;\ngetContentPane().add(rhsjPanel, gridBagConstraints);\nlhsjPanel.setLayout(new java.awt.GridBagLayout());\nmainMapView.setAlignmentX(0.0F);\nmainMapView.setAlignmentY(0.0F);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nlhsjPanel.add(mainMapView, gridBagConstraints);\nstatusjPanel.add(datejLabel);\nstatusjPanel.add(cashjLabel);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\nlhsjPanel.add(statusjPanel, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngetContentPane().add(lhsjPanel, gridBagConstraints);\ngameMenu.setText(\"Game\");\njMenuBar1.add(gameMenu);\nbuildMenu.setText(\"Build\");\njMenuBar1.add(buildMenu);\nBrokerMenu1.setText(\"Broker\");\njMenuBar1.add(BrokerMenu1);\ndisplayMenu.setText(\"Display\");\njMenuBar1.add(displayMenu);\nreportsMenu.setText(\"Reports\");\njMenuBar1.add(reportsMenu);\nhelpMenu.setText(\"Help\");\njMenuBar1.add(helpMenu);\nsetJMenuBar(jMenuBar1);\npack();\n}// GEN-END:initComponents\n/** Exit the Application. */\nprivate void exitForm(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_exitForm\nSystem.exit(0);\n}// GEN-LAST:event_exitForm\npublic static void main(String args[]) {\nnew ClientJFrame(new GUIComponentFactoryTestImpl()).setVisible(true);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JMenu BrokerMenu1;\nprivate javax.swing.JMenu buildMenu;\nprivate javax.swing.JLabel cashjLabel;\nprivate javax.swing.JLabel datejLabel;\nprivate javax.swing.JMenu displayMenu;\nprivate javax.swing.JMenu gameMenu;\nprivate javax.swing.JMenu helpMenu;\nprivate javax.swing.JMenuBar jMenuBar1;\nprivate javax.swing.JPanel lhsjPanel;\nprivate javax.swing.JScrollPane mainMapView;\nprivate javax.swing.JPanel mapOverview;\nprivate javax.swing.JMenu reportsMenu;\nprivate javax.swing.JPanel rhsjPanel;\nprivate javax.swing.JPanel statusjPanel;\nprivate javax.swing.JTabbedPane trainsJTabPane1;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.top.GUIComponentFactory","javaDoc":"/**\n* Defines methods that create the GUI components used by the game.\n*\n* @author Luke\n*/","code":"/**\n* Defines methods that create the GUI components used by the game.\n*\n* @author Luke\n*/\npublic interface GUIComponentFactory {\nJPanel createOverviewMap();\nJTabbedPane createTrainsJTabPane();\nJScrollPane createMainMap();\nJLabel createCashJLabel();\nJLabel createDateJLabel();\nJMenu createBuildMenu();\nJMenu createReportsMenu();\nJMenu createGameMenu();\nJMenu createDisplayMenu();\nJMenu createHelpMenu();\nJMenu createBrokerMenu();\n}"}
{"className":"jfreerails.client.top.BuildIndustryJPopupMenu","javaDoc":"/**\n* A JPopupMenu that displays the list of industries that can be built. This\n* class contains the code that generates and dispatches a ChangeTileMove when\n* the player clicks on the menu.\n*\n* @author Luke\n*\n*/","code":"/**\n* A JPopupMenu that displays the list of industries that can be built. This\n* class contains the code that generates and dispatches a ChangeTileMove when\n* the player clicks on the menu.\n*\n* @author Luke\n*\n*/\npublic class BuildIndustryJPopupMenu extends JPopupMenu implements View {\nprivate static final long serialVersionUID = 3689636912575165749L;\nprivate final Point cursorLocation = new Point();\npublic void setCursorLocation(Point p) {\ncursorLocation.x = p.x;\ncursorLocation.y = p.y;\n}\npublic void setup(final ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nthis.removeAll();\nfinal NonNullElements it = new NonNullElements(SKEY.TERRAIN_TYPES,\nmodelRoot.getWorld());\nwhile (it.next()) {\nTerrainType type = (TerrainType) it.getElement();\nfinal Money price = type.getBuildCost();\nif (null != price) {\nJMenuItem item = new JMenuItem(type.getDisplayName() + \" \"\n+ price);\nitem.addActionListener(new ActionListener() {\nprivate final int terrainType = it.getIndex();\npublic void actionPerformed(ActionEvent arg0) {\nMove m1 = new ChangeTileMove(modelRoot.getWorld(),\ncursorLocation, terrainType);\nTransaction t = new AddItemTransaction(\nTransaction.Category.INDUSTRIES, terrainType,\n1, price.changeSign());\nMove m2 = new AddTransactionMove(modelRoot\n.getPrincipal(), t);\nCompositeMove m3 = new CompositeMove(m1, m2);\nMoveStatus ms = modelRoot.doMove(m3);\nif (!ms.ok) {\nmodelRoot.setProperty(\nModelRoot.Property.CURSOR_MESSAGE,\nms.message);\n}\n}\n});\nadd(item);\n}\n}\n}\n}"}
{"className":"jfreerails.client.view.ConfirmExitJPanel","javaDoc":"/**\n* JPanel that displays confirmation of exiting, used when the exit menu item is\n* selected or x is pressed.\n*\n* @author SonnyZ\n*/","code":"/**\n* JPanel that displays confirmation of exiting, used when the exit menu item is\n* selected or x is pressed.\n*\n* @author SonnyZ\n*/\npublic class ConfirmExitJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 3256728398394110517L;\n/** Creates new form ConfirmExitJPanel. */\npublic ConfirmExitJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njPanel1 = new javax.swing.JPanel();\njLabel1 = new javax.swing.JLabel();\njPanel2 = new javax.swing.JPanel();\nconfirmExit = new javax.swing.JButton();\ncloseJButton = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(240, 140));\njLabel1.setText(\"Are you sure you want to Exit?\");\njLabel1.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);\njPanel1.add(jLabel1);\nadd(jPanel1, new java.awt.GridBagConstraints());\njPanel2.setLayout(new java.awt.GridBagLayout());\nconfirmExit.setText(\"Exit\");\nconfirmExit.setContentAreaFilled(false);\nconfirmExit.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nconfirmExitActionPerformed(evt);\n}\n});\njPanel2.add(confirmExit, new java.awt.GridBagConstraints());\ncloseJButton.setText(\"Cancel\");\njPanel2.add(closeJButton, new java.awt.GridBagConstraints());\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.ipadx = 15;\ngridBagConstraints.insets = new java.awt.Insets(3, 0, 0, 0);\nadd(jPanel2, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void confirmExitActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_confirmExitActionPerformed\nSystem.exit(0);\n}// GEN-LAST:event_confirmExitActionPerformed\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\ncloseJButton.setAction(closeAction);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton closeJButton;\nprivate javax.swing.JButton confirmExit;\nprivate javax.swing.JLabel jLabel1;\nprivate javax.swing.JPanel jPanel1;\nprivate javax.swing.JPanel jPanel2;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.SaveGameJPanel","javaDoc":"/**\n*\n* @author Luke\n*/","code":"/**\n*\n* @author Luke\n*/\npublic class SaveGameJPanel extends javax.swing.JPanel implements View{\nprivate static final long serialVersionUID = 4031907071040752589L;\n/** Creates new form SaveGameJPanel */\npublic SaveGameJPanel() {\ninitComponents();\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\njLabel1 = new javax.swing.JLabel();\nfileNameTextField = new javax.swing.JTextField();\noKButton = new javax.swing.JButton();\ncancelButton = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\njLabel1.setText(\"Please enter a name for the save game.\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(jLabel1, gridBagConstraints);\nfileNameTextField.setText(\"savegame\");\nfileNameTextField.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nfileNameTextFieldActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(fileNameTextField, gridBagConstraints);\noKButton.setText(\"OK\");\noKButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\noKButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(oKButton, gridBagConstraints);\ncancelButton.setText(\"Cancel\");\ncancelButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ncancelButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(cancelButton, gridBagConstraints);\n}\n// </editor-fold>//GEN-END:initComponents\nprivate void oKButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_oKButtonActionPerformed\nString filename = fileNameTextField.getText();\n// Save the current game using the string\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Saved game \"\n+ filename);\nMessage2Server message2 = new SaveGameMessage2Server(1,\nfilename + \".sav\");\nmodelRoot.sendCommand(message2);\nclose.actionPerformed(evt);\n}//GEN-LAST:event_oKButtonActionPerformed\nprivate void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed\nclose.actionPerformed(evt);\n}//GEN-LAST:event_cancelButtonActionPerformed\nprivate void fileNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileNameTextFieldActionPerformed\n// TODO add your handling code here:\nSystem.out.println(\"fileNameTextFieldActionPerformed\"+evt.toString());\n}//GEN-LAST:event_fileNameTextFieldActionPerformed\npublic void setup(ModelRoot m, RenderersRoot vl,\nAction closeAction) {\nthis.close = closeAction;\nthis.modelRoot = m;\n}\nModelRoot modelRoot;\nActionListener close;\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JButton cancelButton;\njavax.swing.JTextField fileNameTextField;\njavax.swing.JLabel jLabel1;\njavax.swing.JButton oKButton;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.TrainListJPanel","javaDoc":"/**\n* JPanel that displays a list of trains, used for the train list window and the\n* train roster tab.\n*\n* @author Luke\n*/","code":"/**\n* JPanel that displays a list of trains, used for the train list window and the\n* train roster tab.\n*\n* @author Luke\n*/\npublic class TrainListJPanel extends javax.swing.JPanel implements View, ModelRootListener {\nprivate static final long serialVersionUID = 3832905463863064626L;\nprivate ReadOnlyWorld world;\nprivate FreerailsPrincipal principal;\nprivate int lastNumberOfTrains = -1;\nprivate boolean rhsjTabPane = false; // if the train list is for the\n// rhsjTabPane then use the original\n// renderer, if not use the\n// trainsummaryjpanel\n/** Creates new form TrainListJPanel. */\npublic TrainListJPanel() {\ninitComponents();\n}\npublic TrainListJPanel(boolean isInRHSJTabPane) {\nthis();\nrhsjTabPane = isInRHSJTabPane;\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ntrainSummaryJPanel1 = new jfreerails.client.view.TrainSummaryJPanel();\ncloseJButton = new javax.swing.JButton();\nshowDetails = new javax.swing.JButton();\njScrollPane1 = new javax.swing.JScrollPane();\njList1 = new javax.swing.JList();\ntrainNumLabel = new javax.swing.JLabel();\ntrainHeadingLabel = new javax.swing.JLabel();\nmaintenanceLabel = new javax.swing.JLabel();\nincomeLabel = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(510, 300));\ncloseJButton.setText(\"Close\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(closeJButton, gridBagConstraints);\nshowDetails.setText(\"Show details\");\nshowDetails.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowDetailsActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(showDetails, gridBagConstraints);\njList1\n.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\njList1.setCellRenderer(trainSummaryJPanel1);\njList1.setDoubleBuffered(true);\njList1.addKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\njList1KeyPressed(evt);\n}\n});\njList1\n.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(\njavax.swing.event.ListSelectionEvent evt) {\njList1ValueChanged(evt);\n}\n});\njList1.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent evt) {\njList1MouseClicked(evt);\n}\n});\njScrollPane1.setViewportView(jList1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\ntrainNumLabel.setText(\"Train Number\");\ntrainNumLabel.setMaximumSize(new java.awt.Dimension(500, 500));\ntrainNumLabel.setPreferredSize(new java.awt.Dimension(100, 14));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);\nadd(trainNumLabel, gridBagConstraints);\ntrainHeadingLabel.setText(\"Headed For\");\ntrainHeadingLabel.setPreferredSize(new java.awt.Dimension(100, 14));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 5);\nadd(trainHeadingLabel, gridBagConstraints);\nmaintenanceLabel.setText(\"Maintenance YTD\");\nmaintenanceLabel.setPreferredSize(new java.awt.Dimension(100, 14));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 5);\nadd(maintenanceLabel, gridBagConstraints);\nincomeLabel.setText(\"Income YTD\");\nincomeLabel.setPreferredSize(new java.awt.Dimension(100, 14));\nadd(incomeLabel, new java.awt.GridBagConstraints());\n}// GEN-END:initComponents\nprivate void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {// GEN-FIRST:event_jList1ValueChanged\n// if a train is selected, enable the 'show details' button.\nif (jList1.getSelectedIndex() != -1) {\nthis.showDetails.setEnabled(true);\n} else {\nthis.showDetails.setEnabled(false);\n}\n}// GEN-LAST:event_jList1ValueChanged\nprivate void showDetailsActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showDetailsActionPerformed\nshowTrainDetails.actionPerformed(evt);\n}// GEN-LAST:event_showDetailsActionPerformed\nprivate void jList1MouseClicked(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_jList1MouseClicked\n// Add your handling code here:\nif (evt.getClickCount() == 2) {\nshowTrainDetails.actionPerformed(null);\n}\n}// GEN-LAST:event_jList1MouseClicked\nprivate void jList1KeyPressed(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_jList1KeyPressed\n// Add your handling code here:\nif (evt.getKeyCode() == KeyEvent.VK_ENTER) {\nshowTrainDetails.actionPerformed(null);\n}\n}// GEN-LAST:event_jList1KeyPressed\npublic void setup(final ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\nworld = mr.getWorld();\ntrainSummaryJPanel1.setup(mr, vl, null);\nif (rhsjTabPane) {\njList1.setModel(new World2ListModelAdapter(mr.getWorld(),\nKEY.TRAINS, mr.getPrincipal()));\nTrainListCellRenderer trainView = new TrainListCellRenderer(mr, vl);\njList1.setCellRenderer(trainView);\ntrainView.setHeight(trainViewHeight);\n}\nActionListener[] oldListeners = closeJButton.getActionListeners();\nfor (int i = 0; i < oldListeners.length; i++) {\ncloseJButton.removeActionListener(oldListeners[i]);\n}\ncloseJButton.addActionListener(closeAction);\nListSelectionListener[] old = jList1.getListSelectionListeners();\nfor(ListSelectionListener x : old){\njList1.removeListSelectionListener(x);\n}\njList1.addListSelectionListener(new ListSelectionListener() {\n@Override\npublic void valueChanged(ListSelectionEvent e) {\nint id = getSelectedTrainID();\nmr.setProperty(ModelRoot.Property.SELECTED_TRAIN, id);\n}\n});\nprincipal = mr.getPrincipal();\nModelRootImpl mri = (ModelRootImpl) mr;\nmri.addPropertyChangeListener(this);\n}\nvoid setShowTrainDetailsActionListener(ActionListener l) {\nshowTrainDetails = l;\n}\nprivate ActionListener showTrainDetails = new ActionListener() {\npublic void actionPerformed(ActionEvent arg0) {\n}\n};\nint getSelectedTrainID() {\n/*\n* Note, the selected index is not the train id since trains that have\n* been removed are not shown on the list.\n*/\nint row = jList1.getSelectedIndex();\nif (row == -1) {\nreturn -1;\n} else {\nreturn NonNullElements.row2index(world, KEY.TRAINS, principal, row);\n}\n}\n/** When the train list is shown on a tab we don't want the buttons. */\nvoid removeButtons() {\nthis.removeAll();\njava.awt.GridBagConstraints gridBagConstraints;\nsetLayout(new java.awt.GridBagLayout());\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton closeJButton;\nprivate javax.swing.JLabel incomeLabel;\nprivate javax.swing.JList jList1;\nprivate javax.swing.JScrollPane jScrollPane1;\nprivate javax.swing.JLabel maintenanceLabel;\nprivate javax.swing.JButton showDetails;\nprivate javax.swing.JLabel trainHeadingLabel;\nprivate javax.swing.JLabel trainNumLabel;\nprivate jfreerails.client.view.TrainSummaryJPanel trainSummaryJPanel1;\n// End of variables declaration//GEN-END:variables\nprivate int trainViewHeight = 50;\n@Override\npublic void setVisible(boolean aFlag) {\nif (aFlag && null != world) {\n// jList1.setModel(new World2ListModelAdapter(world,\n// KEY.TRAINS,principal));\n}\nsuper.setVisible(aFlag);\n}\npublic void setTrainViewHeight(int trainViewHeight) {\nthis.trainViewHeight = trainViewHeight;\n}\n@Override\npublic void paint(Graphics g) {\nif (null != world) {\nNonNullElements trains = new NonNullElements(KEY.TRAINS, world,\nprincipal);\nint newNumberOfTrains = trains.size();\nif (newNumberOfTrains != this.lastNumberOfTrains) {\njList1.setModel(new World2ListModelAdapter(world, KEY.TRAINS,\nprincipal));\nif (newNumberOfTrains > 0) {\njList1.setSelectedIndex(0);\n}\nlastNumberOfTrains = newNumberOfTrains;\n}\n}\nsuper.paint(g);\n}\n@Override\npublic void propertyChange(ModelRoot.Property p, Object oldValue, Object newValue) {\nif(ModelRoot.Property.SELECTED_TRAIN == p){\nif(!newValue.equals(this.getSelectedTrainID())){\n//update needed..\nTrainModel train = (TrainModel) world.get(principal, KEY.TRAINS, (int) newValue);\nthis.jList1.setSelectedValue(train, true);\n}\n}\n}\n}"}
{"className":"jfreerails.client.view.DialogueBoxController","javaDoc":"/**\n* This class is responsible for displaying dialogue boxes, adding borders to\n* them as appropriate, and returning focus to the last focus owner after a\n* dialogue box has been closed. It is also responsible for adding components\n* that need to update in response to moves to the MoveChainFork. Currently\n* dialogue boxes are not separate windows. Instead, they are drawn on the modal\n* layer of the main JFrames LayerPlane. This allows dialogue boxes with\n* transparent regions to be used.\n*\n* @author lindsal8\n* @author smackay\n*/","code":"/**\n* This class is responsible for displaying dialogue boxes, adding borders to\n* them as appropriate, and returning focus to the last focus owner after a\n* dialogue box has been closed. It is also responsible for adding components\n* that need to update in response to moves to the MoveChainFork. Currently\n* dialogue boxes are not separate windows. Instead, they are drawn on the modal\n* layer of the main JFrames LayerPlane. This allows dialogue boxes with\n* transparent regions to be used.\n*\n* @author lindsal8\n* @author smackay\n*/\npublic class DialogueBoxController implements WorldListListener {\nprivate static final Logger logger = Logger\n.getLogger(DialogueBoxController.class.getName());\nprivate final JButton closeButton = new JButton(\"Close\");\nprivate SelectEngineJPanel selectEngine;\nprivate final MyGlassPanel glassPanel;\nprivate NewsPaperJPanel newspaper;\nprivate SelectWagonsJPanel selectWagons;\nprivate HtmlJPanel showControls;\nprivate HtmlJPanel about;\nprivate HtmlJPanel how2play;\nprivate HtmlJPanel javaProperties;\nprivate TerrainInfoJPanel terrainInfo;\nprivate StationInfoJPanel stationInfo;\nprivate TrainDialogueJPanel trainDialogueJPanel;\nprivate ReadOnlyWorld world;\nprivate ModelRootImpl modelRoot;\nprivate RenderersRoot vl;\nprivate Component defaultFocusOwner = null;\nprivate final JFrame frame;\nprivate JInternalFrame dialogueJInternalFrame;\n/**\n* Use this Action to close a dialogue without performing any other\n* action.\n*/\nprivate final Action closeCurrentDialogue = new AbstractAction(\"Close\") {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\ncloseContent();\n}\n};\nprivate final Action selectEngineAction = new AbstractAction() {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nshowSelectWagons();\n}\n};\nprivate final ActionListener trainDetailsButtonActionListener = new ActionListener() {\npublic void actionPerformed(ActionEvent arg0) {\nshowTrainList();\n}\n};\nprivate final Action selectWagonsAction = new AbstractAction(\"Next\") {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, modelRoot\n.getWorld(), modelRoot.getPrincipal());\nif (wi.next()) {\nStationModel station = (StationModel) wi.getElement();\nImList<PlannedTrain> before = station.getProduction();\nint engineType = selectEngine.getEngineType();\nint[] wagonTypes = selectWagons.getWagons();\nImList<PlannedTrain> after = new ImList<PlannedTrain>(\nnew PlannedTrain(engineType, wagonTypes));\nMove m = new ChangeProductionAtEngineShopMove(before, after, wi\n.getIndex(), modelRoot.getPrincipal());\nmodelRoot.doMove(m);\n}\ncloseContent();\n}\n};\npublic DialogueBoxController(JFrame frame, ModelRootImpl mr) {\nthis.frame = frame;\nmodelRoot = mr;\n// Setup glass panel..\nglassPanel = new MyGlassPanel();\nglassPanel.setSize(frame.getSize());\nframe.getLayeredPane().add(glassPanel, JLayeredPane.MODAL_LAYER);\nglassPanel.revalidate();\nglassPanel.setVisible(false);\n// We need to resize the glass panel when its parent resizes.\nframe.getLayeredPane().addComponentListener(\nnew java.awt.event.ComponentAdapter() {\n@Override\npublic void componentResized(\njava.awt.event.ComponentEvent evt) {\nglassPanel.setSize(glassPanel.getParent().getSize());\nglassPanel.revalidate();\n}\n});\ncloseButton.addActionListener(closeCurrentDialogue);\nshowControls = new HtmlJPanel(DialogueBoxController.class\n.getResource(\"/jfreerails/client/view/game_controls.html\"));\nabout = new HtmlJPanel(DialogueBoxController.class\n.getResource(\"/jfreerails/client/view/about.htm\"));\nhow2play = new HtmlJPanel(DialogueBoxController.class\n.getResource(\"/jfreerails/client/view/how_to_play.htm\"));\nterrainInfo = new TerrainInfoJPanel();\nstationInfo = new StationInfoJPanel();\njavaProperties = new HtmlJPanel(ShowJavaProperties\n.getPropertiesHtmlString());\nDimension d = javaProperties.getPreferredSize();\nd.width += 50;\njavaProperties.setPreferredSize(d);\nnewspaper = new NewsPaperJPanel();\nselectWagons = new SelectWagonsJPanel();\nselectEngine = new SelectEngineJPanel();\ntrainDialogueJPanel = new TrainDialogueJPanel();\n}\n/**\n* Called when a new game is started or a game is loaded.\n* <p>\n* <b>Be extremely careful with the references of objects allocated in this\n* method to avoid memory leaks - see bug 967677 (OutOfMemoryError after\n* starting several new games). </b>\n* </p>\n*/\npublic void setup(ModelRootImpl mr, RenderersRoot vl) {\nthis.modelRoot = mr;\nthis.vl = vl;\nmodelRoot.addListListener(this); // When a new train gets built, we\n// show the train info etc\nthis.world = modelRoot.getWorld();\nif (world == null)\nthrow new NullPointerException();\nif (vl == null)\nthrow new NullPointerException();\n// Setup the various dialogue boxes.\n// setup the terrain info dialogue.\nterrainInfo.setup(world, vl);\n// setup the supply and demand at station dialogue.\nstationInfo.setup(modelRoot, vl, this.closeCurrentDialogue);\nmodelRoot.addListListener(stationInfo);\n// setup the 'show controls' dialogue\nshowControls.setup(this.modelRoot, vl, this.closeCurrentDialogue);\nabout.setup(this.modelRoot, vl, this.closeCurrentDialogue);\nhow2play.setup(this.modelRoot, vl, this.closeCurrentDialogue);\njavaProperties.setup(this.modelRoot, vl, this.closeCurrentDialogue);\n// Set up train orders dialogue\n// trainScheduleJPanel = new TrainScheduleJPanel();\n// trainScheduleJPanel.setup(w, vl);\n// moveChainFork.add(trainScheduleJPanel);\n// Set up select engine dialogue.\nselectEngine.setCancelButtonActionListener(this.closeCurrentDialogue);\nselectEngine.setup(modelRoot, vl, selectEngineAction);\nnewspaper.setup(modelRoot, vl, closeCurrentDialogue);\nselectWagons.setup(modelRoot, vl, selectWagonsAction);\ntrainDialogueJPanel.setup(modelRoot, vl, this.closeCurrentDialogue);\nmodelRoot.addListListener(trainDialogueJPanel);\ntrainDialogueJPanel\n.setTrainDetailsButtonActionListener(trainDetailsButtonActionListener);\ntrainDialogueJPanel\n.setCancelButtonActionListener(this.closeCurrentDialogue);\n}\npublic void showSaveGame(){\nSaveGameJPanel saveGameJPanel = new SaveGameJPanel();\nsaveGameJPanel.setup(modelRoot, vl, this.closeCurrentDialogue);\nshowContent(saveGameJPanel);\n}\npublic void showSelectSavedGame2Load(){\nMessage2Server refreshGames = new RefreshListOfGamesMessage2Server(2);\nmodelRoot.sendCommand(refreshGames);\nLoadGameJPanel loadGameJPane = new LoadGameJPanel();\nloadGameJPane.setup(modelRoot, vl, this.closeCurrentDialogue);\nshowContent(loadGameJPane);\n}\npublic void showTrainOrders() {\nWorldIterator wi = new NonNullElements(KEY.TRAINS, world, modelRoot\n.getPrincipal());\nif (!wi.next()) {\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Cannot\"\n+ \" show train orders since there are no\" + \" trains!\");\n} else {\ntrainDialogueJPanel.display(wi.getIndex());\nthis.showContent(trainDialogueJPanel);\n}\n}\npublic void showSelectEngine() {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, world, modelRoot\n.getPrincipal());\nif (!wi.next()) {\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Can't\"\n+ \" build train since there are no stations\");\n} else {\nshowContent(selectEngine);\n}\n}\npublic void showGameControls() {\nshowContent(this.showControls);\n}\npublic void showIncomeStatement() {\nIncomeStatementHtmlJPanel bs = new IncomeStatementHtmlJPanel();\nbs.setup(this.modelRoot, vl, this.closeCurrentDialogue);\nthis.showContent(bs);\n}\npublic void showBalanceSheet() {\nBalanceSheetHtmlJPanel bs = new BalanceSheetHtmlJPanel();\nbs.setup(this.modelRoot, vl, this.closeCurrentDialogue);\nthis.showContent(bs);\n}\npublic void showReportBug(){\nCopyableTextJPanel ct = new CopyableTextJPanel();\nct.setText(ReportBugTextGenerator.genText());\nshowContent(ct);\n}\npublic void showBrokerScreen() {\n// this is Creating a BrokerScreen Internal Frame in the Main Frame\nBrokerScreenHtmlJFrame brokerScreenHtmlJFrame = new BrokerScreenHtmlJFrame();\nbrokerScreenHtmlJFrame.setup(this.modelRoot, vl,\nthis.closeCurrentDialogue);\nbrokerScreenHtmlJFrame.setFrameIcon(null);\nshowContent(brokerScreenHtmlJFrame);\n}\n// Shows the Exit Dialog -- @author SonnyZ\npublic void showExitDialog() {\nConfirmExitJPanel bs = new ConfirmExitJPanel();\nbs.setup(this.modelRoot, vl, this.closeCurrentDialogue);\nthis.showContent(bs);\n}\npublic void showAbout() {\nshowContent(this.about);\n}\npublic void showHow2Play() {\nshowContent(this.how2play);\n}\npublic void showJavaProperties() {\nshowContent(javaProperties);\n}\npublic void showSelectWagons() {\nselectWagons.resetSelectedWagons();\nselectWagons.setEngineType(selectEngine.getEngineType());\nshowContent(selectWagons);\n}\npublic void showTerrainInfo(int terrainType) {\nthis.terrainInfo.setTerrainType(terrainType);\nshowContent(terrainInfo);\n}\npublic void showTerrainInfo(int x, int y) {\nFreerailsTile tile = (FreerailsTile) world.getTile(x, y);\nint terrainType = tile.getTerrainTypeID();\nshowTerrainInfo(terrainType);\n}\npublic void showStationInfo(int stationNumber) {\ntry {\nstationInfo.setStation(stationNumber);\nshowContent(stationInfo);\n} catch (NoSuchElementException e) {\nlogger.warning(\"Station \" + stationNumber + \" does not exist!\");\n}\n}\npublic void showTrainOrders(int trainId) {\ncloseContent();\nif (trainId != -1) {\ntrainDialogueJPanel.display(trainId);\nshowContent(trainDialogueJPanel);\n}\n}\npublic void showTrainList() {\nif (world.size(modelRoot.getPrincipal(), KEY.TRAINS) > 0) {\nfinal TrainListJPanel trainList = new TrainListJPanel();\ntrainList.setup(modelRoot, vl, closeCurrentDialogue);\ntrainList.setShowTrainDetailsActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent arg0) {\nint id = trainList.getSelectedTrainID();\nshowTrainOrders(id);\n}\n});\nshowContent(trainList);\n} else {\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"There are\"\n+ \" no trains to display!\");\n}\n}\npublic void showNetworthGraph() {\nfinal NetWorthGraphJPanel worthGraph = new NetWorthGraphJPanel();\nworthGraph.setup(modelRoot, vl, closeCurrentDialogue);\nshowContent(worthGraph);\n}\npublic void showLeaderBoard() {\nLeaderBoardJPanel leaderBoardJPanel = new LeaderBoardJPanel();\nleaderBoardJPanel.setup(modelRoot, vl, closeCurrentDialogue);\nshowContent(leaderBoardJPanel);\n}\npublic void showContent(JComponent component) {\ncloseContent();\nJComponent contentPanel;\nif (component instanceof JInternalFrame) {\ndialogueJInternalFrame = (JInternalFrame) component;\n} else {\nif (!(component instanceof View)) {\ncontentPanel = new javax.swing.JPanel();\ncontentPanel.setLayout(new java.awt.GridBagLayout());\nGridBagConstraints constraints = new GridBagConstraints();\nconstraints.gridx = 0;\nconstraints.gridy = 0;\nconstraints.weightx = 1.0;\nconstraints.weighty = 1.0;\nconstraints.insets = new Insets(7, 7, 7, 7);\ncontentPanel.add(component, constraints);\nconstraints = new GridBagConstraints();\nconstraints.gridx = 0;\nconstraints.gridy = 1;\nconstraints.insets = new Insets(7, 7, 7, 7);\ncontentPanel.add(closeButton, constraints);\n} else {\ncontentPanel = component;\n}\ndialogueJInternalFrame = new JInternalFrame();\ndialogueJInternalFrame.setFrameIcon(null);\ndialogueJInternalFrame.getContentPane().add(contentPanel);\ndialogueJInternalFrame.pack();\n}\n/*\n* Make sure the size of the dialogue does not exceed the size of the\n* frames content pane.\n*/\nint parentWidth = frame.getContentPane().getWidth();\nint parentHeight = frame.getContentPane().getHeight();\nDimension size = dialogueJInternalFrame.getSize();\nif (size.width > parentWidth) {\nsize.width = parentWidth;\n}\nif (size.height > parentHeight) {\nsize.height = parentHeight;\n}\ndialogueJInternalFrame.setSize(size);\ndialogueJInternalFrame.setLocation(\n(frame.getWidth() - dialogueJInternalFrame.getWidth()) / 2,\n(frame.getHeight() - dialogueJInternalFrame.getHeight()) / 2);\nframe.getLayeredPane().add(dialogueJInternalFrame,\nJLayeredPane.MODAL_LAYER);\ndialogueJInternalFrame.setVisible(true);\n}\npublic void closeContent() {\nif (null != dialogueJInternalFrame) {\ndialogueJInternalFrame.setVisible(false);\nframe.getLayeredPane().remove(dialogueJInternalFrame);\ndialogueJInternalFrame.dispose();\n}\nif (null != defaultFocusOwner) {\ndefaultFocusOwner.requestFocus();\n}\n}\npublic void setDefaultFocusOwner(Component defaultFocusOwner) {\nthis.defaultFocusOwner = defaultFocusOwner;\n}\npublic void showStationOrTerrainInfo(int x, int y) {\nFreerailsTile tile = (FreerailsTile) world.getTile(x, y);\nTrackRule trackRule = tile.getTrackPiece().getTrackRule();\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nif (trackRule.isStation()\n&& tile.getTrackPiece().getOwnerID() == world.getID(principal)) {\nfor (int i = 0; i < world.size(principal, KEY.STATIONS); i++) {\nStationModel station = (StationModel) world.get(principal,\nKEY.STATIONS, i);\nif (null != station && station.x == x && station.y == y) {\nthis.showStationInfo(i);\nreturn;\n}\n}\nthrow new IllegalStateException(\"Couldn't find station at \" + x\n+ \", \" + y);\n}\nthis.showTerrainInfo(x, y);\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal principal) {\n// do nothing\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal principal) {\n/*\n* Fix for: 910138 After building a train display train orders 910143\n* After building station show supply and demand\n*/\nboolean rightPrincipal = principal\n.equals(this.modelRoot.getPrincipal());\nif (KEY.TRAINS == key && rightPrincipal) {\nthis.showTrainOrders(index);\n} else if (KEY.STATIONS == key && rightPrincipal) {\nthis.showStationInfo(index);\n}\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal principal) {\n// do nothing\n}\n}"}
{"className":"jfreerails.client.view.ActiveView","javaDoc":"/**\n* Defines a standard method to initiate GUI components that need access to the\n* ModelRoot <b> and </b> the ActionRoot.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a standard method to initiate GUI components that need access to the\n* ModelRoot <b> and </b> the ActionRoot.\n*\n* @author Luke\n*\n*/\npublic interface ActiveView {\nvoid setup(ModelRoot modelRoot, ActionRoot ar, RenderersRoot vl,\nActionListener submitButtonCallBack);\n}"}
{"className":"jfreerails.client.view.OverviewMapJComponent","javaDoc":"/**\n* JPanel that displays the overview map and a rectangle showing the region of\n* the map currently displayed on the main view.\n*\n* @author Luke\n*/","code":"/**\n* JPanel that displays the overview map and a rectangle showing the region of\n* the map currently displayed on the main view.\n*\n* @author Luke\n*/\npublic class OverviewMapJComponent extends JPanel {\nprivate static final long serialVersionUID = 3258697585148376888L;\nprivate MapRenderer mapView = new BlankMapRenderer(0.4F);\nprivate final Rectangle mainMapVisRect;\npublic OverviewMapJComponent(Rectangle r) {\nthis.setPreferredSize(mapView.getMapSizeInPixels());\nmainMapVisRect = r;\n}\npublic void setup(MapRenderer mv) {\nmapView = mv;\nthis.setPreferredSize(mapView.getMapSizeInPixels());\nthis.setMinimumSize(this.getPreferredSize());\nthis.setSize(this.getPreferredSize());\nif (null != this.getParent()) {\nthis.getParent().validate();\n}\n}\n@Override\nprotected void paintComponent(java.awt.Graphics g) {\njava.awt.Graphics2D g2 = (java.awt.Graphics2D) g;\njava.awt.Rectangle r = this.getVisibleRect();\nmapView.paintRect(g2, r);\ng2.setColor(Color.WHITE);\ng2.drawRect(mainMapVisRect.x, mainMapVisRect.y, mainMapVisRect.width,\nmainMapVisRect.height);\n}\n@Override\npublic Dimension getPreferredSize() {\nreturn mapView.getMapSizeInPixels();\n}\n}"}
{"className":"jfreerails.client.view.BrokerScreenGenerator","javaDoc":"/**\n*\n* @author smackay\n* @author Luke\n*/","code":"/**\n*\n* @author smackay\n* @author Luke\n*/\npublic class BrokerScreenGenerator {\nprivate static final DecimalFormat DC = new DecimalFormat(\"#,###\");\nprivate FinancialDataGatherer dataGatherer;\nprivate GameCalendar cal;\npublic String playername;\npublic String year;\npublic Money cash;\npublic Money loansTotal;\npublic Money netWorth;\npublic Money pricePerShare;\npublic String publicShares;\npublic String treasuryStock;\npublic String othersRRsStockRows;\n/** Creates a new instance of BrokerScreenGenerator */\npublic BrokerScreenGenerator(ReadOnlyWorld w, FreerailsPrincipal principal) {\ndataGatherer = new FinancialDataGatherer(w, principal);\nint playerId = w.getID(principal);\nthis.playername = w.getPlayer(playerId).getName();\nthis.cal = (GameCalendar) w.get(ITEM.CALENDAR);\nGameTime time = w.currentTime();\nfinal int startyear = cal.getYear(time.getTicks());\nthis.year = String.valueOf(startyear);\nthis.cash = w.getCurrentBalance(principal);\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nw, principal);\naggregator.setCategory(BOND);\nthis.loansTotal = aggregator.calculateValue();\nthis.publicShares = DC.format(dataGatherer.sharesHeldByPublic());\nthis.netWorth = dataGatherer.netWorth();\nStockPrice[] stockPrices = (new StockPriceCalculator(w)).calculate();\nthis.pricePerShare = stockPrices[playerId].currentPrice;\nthis.treasuryStock = DC.format(dataGatherer.treasuryStock());\nStringBuffer otherRRsStakes = new StringBuffer();\nint[] stockInThisRRs = dataGatherer.getStockInThisRRs();\nfor (int i = 0; i < stockInThisRRs.length; i++) {\nif (i != playerId && stockInThisRRs[i] > 0) {\nString otherRRName = w.getPlayer(i).getName();\nString otherRRStake = DC.format(stockInThisRRs[i]);\notherRRsStakes.append(\"<tr> \");\notherRRsStakes.append(\"<td> </td>\");\notherRRsStakes.append(\"<td> </td>\");\notherRRsStakes.append(\"<td>\" + otherRRName + \"</td>\");\notherRRsStakes.append(\"<td>\" + otherRRStake + \"</td>\");\notherRRsStakes.append(\"</tr>\");\n}\n}\nothersRRsStockRows = otherRRsStakes.toString();\n}\n}"}
{"className":"jfreerails.client.view.NetWorthGraphJPanel","javaDoc":"/**\n* A JPanel that displays a graph of the net worth of each of the players\n* against time.\n*\n* @author Luke\n*\n*/","code":"/**\n* A JPanel that displays a graph of the net worth of each of the players\n* against time.\n*\n* @author Luke\n*\n*/\npublic class NetWorthGraphJPanel extends JPanel implements View {\nprivate static final long serialVersionUID = 3618703010813980982L;\nprivate static final Logger logger = Logger\n.getLogger(NetWorthGraphJPanel.class.getName());\nprivate JLabel title = null;\nprivate JLabel yAxisLabel1 = null;\nprivate JLabel yAxisLabel3 = null;\nprivate JLabel yAxisLabel4 = null;\nprivate JLabel yAxisLabel2 = null;\nprivate JLabel xAxisLabel3 = null;\nprivate JLabel xAxisLabel2 = null;\nprivate JLabel xAxisLabel1 = null;\nprivate final Font FONT;\nprivate ArrayList<CompanyDetails> companies = new ArrayList<CompanyDetails>();\nprivate long scaleMax;\nprivate Rectangle graphRect = new Rectangle(44, 50, 380, 245);\nActionListener submitButtonCallBack = null;\n/**\n* Stores the company details that are used to draw a line and title on the\n* graph.\n*\n* @author Luke\n*\n*/\nstatic class CompanyDetails {\n/** The company's net worth at the end of each year. */\nlong[] value = new long[100];\n/** The colour for the line on the graph. */\nfinal Color color;\n/** The company's name. */\nfinal String name;\nCompanyDetails(String n, Color c) {\ncolor = c;\nname = n;\nfor (int i = 0; i < 100; i++) {\nvalue[i] = Integer.MIN_VALUE;\n}\n}\n}\n/**\n* This method initializes\n*\n*/\npublic NetWorthGraphJPanel() {\nsuper();\nFONT = new java.awt.Font(\"Bookman Old Style\", java.awt.Font.BOLD, 10);\ninitialize();\n// companies.add(new CompanyDetails(\"Player 1\", Color.BLUE));\n// companies.add(new CompanyDetails(\"Player 2\", Color.GREEN));\n// companies.add(new CompanyDetails(\"Player 3\", Color.CYAN));\n// for(int i = 0; i < companies.size(); i++){\n// CompanyDetails cd = (CompanyDetails)companies.get(i);\n// cd.fillWithRnadomData();\n// }\n//\n// setAppropriateScale();\n}\n/**\n* This method initializes this\n*\n*/\nprivate void initialize() {\nyAxisLabel4 = new JLabel();\nyAxisLabel3 = new JLabel();\nyAxisLabel2 = new JLabel();\nxAxisLabel1 = new JLabel();\nxAxisLabel2 = new JLabel();\nxAxisLabel3 = new JLabel();\ntitle = new JLabel();\nyAxisLabel1 = new JLabel();\nthis.setLayout(null);\nthis.setBackground(java.awt.Color.white);\nthis.setSize(444, 315);\ntitle.setText(\"Net Worth\");\ntitle.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.PLAIN, 24));\ntitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\ntitle.setLocation(0, 0);\ntitle.setSize(444, 43);\nyAxisLabel1.setText(\"$25\");\nyAxisLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\nyAxisLabel3.setText(\"$999m\");\nyAxisLabel4.setText(\"$999M\");\nyAxisLabel4.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nyAxisLabel4.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\nyAxisLabel3.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nyAxisLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\nyAxisLabel2.setText(\"$50\");\nyAxisLabel2.setLocation(0, 167);\nyAxisLabel2.setSize(40, 16);\nyAxisLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);\nyAxisLabel2.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nyAxisLabel1.setLocation(0, 227);\nyAxisLabel1.setSize(40, 16);\nyAxisLabel3.setLocation(0, 107);\nyAxisLabel3.setSize(40, 16);\nyAxisLabel4.setLocation(0, 47);\nyAxisLabel4.setSize(40, 16);\nxAxisLabel3.setText(\"2000\");\nxAxisLabel3.setLocation(400, 300);\nxAxisLabel3.setSize(40, 17);\nxAxisLabel3.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nxAxisLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nxAxisLabel2.setText(\"1950\");\nxAxisLabel2.setLocation(210, 300);\nxAxisLabel2.setSize(40, 17);\nxAxisLabel2.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nxAxisLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nxAxisLabel1.setText(\"1900\");\nxAxisLabel1.setLocation(20, 300);\nxAxisLabel1.setSize(40, 17);\nxAxisLabel1.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nxAxisLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nthis.add(xAxisLabel3, null);\nthis.add(xAxisLabel2, null);\nthis.add(xAxisLabel1, null);\nyAxisLabel1.setFont(new java.awt.Font(\"Bookman Old Style\",\njava.awt.Font.BOLD, 10));\nthis.add(title, null);\nthis.add(yAxisLabel1, null);\nthis.add(yAxisLabel3, null);\nthis.add(yAxisLabel2, null);\nthis.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent e) {\nif (null == submitButtonCallBack) {\nSystem.err.println(\"mouseClicked\");\n} else {\nsubmitButtonCallBack.actionPerformed(new ActionEvent(this,\n0, null));\n}\n}\n});\nthis.add(yAxisLabel4, null);\n}\n@Override\nprotected void paintComponent(Graphics g) {\nsuper.paintComponent(g);\nGraphics2D g2 = (Graphics2D) g;\ng2.setStroke(new BasicStroke(2f, BasicStroke.CAP_SQUARE,\nBasicStroke.JOIN_BEVEL));\n// Draw guide lines.\ng2.setStroke(new BasicStroke(1f, BasicStroke.CAP_SQUARE,\nBasicStroke.JOIN_BEVEL));\ng.setColor(Color.GRAY);\nfor (int y = 295; y > 50; y -= 60) {\ng2.drawLine(graphRect.x, y, 420, y);\n}\ng2.setStroke(new BasicStroke(2f, BasicStroke.CAP_SQUARE,\nBasicStroke.JOIN_BEVEL));\n// Draw key\nfor (int i = 0; i < companies.size(); i++) {\nint yOffset = i * 20;\nCompanyDetails company = companies.get(i);\ng2.setColor(company.color);\ng2.drawLine(50, 70 + yOffset, 60, 70 + yOffset);\ng2.setColor(Color.BLACK);\ng2.setFont(FONT);\ng.drawString(company.name, 65, 72 + yOffset);\n}\n// Draw graphs lines\nfor (int i = 0; i < companies.size(); i++) {\nCompanyDetails company = companies.get(i);\ng2.setColor(company.color);\nfor (int year = 1; year < 100; year++) {\nif (company.value[year] != Integer.MIN_VALUE\n&& company.value[year - 1] != Integer.MIN_VALUE) {\nlong x1 = year * graphRect.width / 100 + graphRect.x;\nlong y1 = company.value[year] * graphRect.height / scaleMax;\ny1 = Math.max(1, y1);\ny1 = graphRect.y + graphRect.height - y1;\nlong x2 = (year - 1) * graphRect.width / 100 + graphRect.x;\nlong y2 = company.value[year - 1] * graphRect.height\n/ scaleMax;\ny2 = Math.max(1, y2);\ny2 = graphRect.y + graphRect.height - y2;\ng2.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n}\n}\n}\n// Draw axis\ng2.setColor(Color.BLACK);\ng2.drawLine(graphRect.x, graphRect.y, graphRect.x, graphRect.y\n+ graphRect.height);\ng2.drawLine(graphRect.x, graphRect.y + graphRect.height, graphRect.x\n+ graphRect.width, graphRect.y + graphRect.height);\n}\n/**\n* <p>\n* Sets the value of scaleMax subject to the following constraints.\n* </P>\n* <p>\n* (1) scaleMax >= max, where max is the max net worth value.\n* </p>\n* <p>\n* (2) (scaleMax % 4) == 0\n* </p>\n* <p>\n* (3) if max >= 1,000, then (scaleMax % 4,000) == 0\n* </p>\n* <p>\n* (4) if max >= 1,000,000, then (scaleMax % 4,000,000) == 0\n* </p>\n* <p>\n* (5) if max >= 1,000,000,000, then (scaleMax % 4,000,000,000) == 0\n* </p>\n*/\nprivate void setAppropriateScale() {\nlong max = 0;\nfor (int i = 0; i < companies.size(); i++) {\nCompanyDetails company = companies.get(i);\nfor (int year = 0; year < 100; year++) {\nlong value = company.value[year];\nif (value > max) {\nmax = value;\n}\n}\n}\nlong increment = 1;\nwhile (scaleMax < max) {\nscaleMax = increment;\nif (scaleMax < max) {\nscaleMax += increment;\nint loopCount = 0;\nwhile (scaleMax < max && loopCount < 3) {\nscaleMax += increment * 2;\nloopCount++;\n}\n}\nincrement = increment * 10;\n}\n/*\n* Make sure that if the scale is in k/m/b that each of the quarter\n* scales will be divisible by k/m/b.\n*/\nincrement = 1;\nfor (int i = 0; i < 3; i++) {\nincrement = increment * 1000;\nif (scaleMax >= 8 * increment && scaleMax < 12 * increment) {\nscaleMax = 12 * increment;\n} else if (scaleMax >= 4 * increment && scaleMax < 8 * increment) {\nscaleMax = 8 * increment;\n} else if (scaleMax >= 1 * increment && scaleMax < 4 * increment) {\nscaleMax = 4 * increment;\n}\n}\nif (scaleMax < 100) {\nscaleMax = 100;\n}\nlong quarterScale = scaleMax / 4;\nyAxisLabel1.setText(getYScaleString(quarterScale));\nyAxisLabel2.setText(getYScaleString(quarterScale * 2));\nyAxisLabel3.setText(getYScaleString(quarterScale * 3));\nyAxisLabel4.setText(getYScaleString(quarterScale * 4));\n}\nprivate String getYScaleString(long value) {\nString abv;\nif (value >= 1000000000) {\nvalue = value / 1000000000;\nabv = \"b\";\n} else if (value >= 1000000) {\nvalue = value / 1000000;\nabv = \"m\";\n} else if (value >= 1000) {\nvalue = value / 1000;\nabv = \"k\";\n} else {\nabv = \"\";\n}\nreturn \"$\" + String.valueOf(value) + abv;\n}\npublic void setup(ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nthis.submitButtonCallBack = closeAction;\nReadOnlyWorld world = modelRoot.getWorld();\ncompanies = new ArrayList<CompanyDetails>();\nGameCalendar calender = (GameCalendar) world.get(ITEM.CALENDAR);\nint startYear = calender.getYear(0);\nint endYear = startYear + 100;\nGameTime currentTime = world.currentTime();\nint currentYear = calender.getYear(currentTime.getTicks());\nxAxisLabel1.setText(String.valueOf(startYear));\nxAxisLabel2.setText(String.valueOf(startYear + 50));\nxAxisLabel3.setText(String.valueOf(endYear));\nfor (int i = 0; i < world.getNumberOfPlayers(); i++) {\nColor c = PlayerColors.getColor(i);\nPlayer player = world.getPlayer(i);\nString name = player.getName();\nlogger.fine(\"Adding player \" + name + \" to net worth graph.\");\nCompanyDetails cd = new CompanyDetails(name, c);\nGameTime[] times = new GameTime[101];\nfor (int year = 0; year < 101; year++) {\nint ticks = calender.getTicks(startYear + year - 1);\ntimes[year] = new GameTime(ticks);\n}\nTransactionAggregator aggregator = new NetWorthCalculator(world,\nplayer.getPrincipal());\naggregator.setTimes(times);\nMoney[] values = aggregator.calculateValues();\nint stopYear = currentYear - startYear + 1;\nfor (int year = 0; year < stopYear; year++) {\ncd.value[year] = values[year].getAmount();\n}\ncompanies.add(cd);\n}\nsetAppropriateScale();\n}\n} // @jve:decl-index=0:visual-constraint=\"10,10\""}
{"className":"jfreerails.client.view.ShowJavaProperties","javaDoc":"/**\n* This class returns the Java System Properties as an HTML table.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class returns the Java System Properties as an HTML table.\n*\n* @author Luke\n*\n*/\npublic class ShowJavaProperties {\npublic static final int TABLE_WIDTH = 500;\nprivate static final Logger logger = Logger\n.getLogger(ShowJavaProperties.class.getName());\npublic static void main(String[] args) {\nlogger.info(getPropertiesHtmlString());\n}\npublic static String getPropertiesHtmlString() {\nProperties p = System.getProperties();\nStringBuffer sb = new StringBuffer();\n/* We set the width of the table so that its text word-wraps. */\nsb.append(\"<html><h3>Java System Properties</h3><table width =\\\"\"\n+ TABLE_WIDTH + \"\\\" align = \\\"left\\\" valign = \\\"top\\\">\\n\");\nEnumeration keys = p.keys();\n//We use an ArrayList so that the keys can be sorted into alphabetical order\nArrayList<String> list = new ArrayList<String>();\nwhile (keys.hasMoreElements()) {\nString key = (String) keys.nextElement();\nlist.add(key);\n}\nCollections.sort(list);\nfor(String key : list){\nString value = p.getProperty(key);\n/*\n* Insert a line break after each \";\". This makes reading classpath\n* elements easier.\n*/\nvalue = value.replaceAll(\";\", \";<br>\");\nsb\n.append(\"<tr><td>\" + key + \" </td><td> \" + value\n+ \"</td></tr>\\n\");\n}\nsb.append(\"</table></html>\\n\");\nreturn sb.toString();\n}\n}"}
{"className":"jfreerails.client.view.SelectWagonsJPanel","javaDoc":"/**\n* This JPanel lets the user add wagons to a train.\n*\n* @author lindsal8\n*\n*/","code":"/**\n* This JPanel lets the user add wagons to a train.\n*\n* @author lindsal8\n*\n*/\npublic class SelectWagonsJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 3905239009449095220L;\nprivate final GraphicsConfiguration defaultConfiguration = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\nprivate final Image stationView;\nprivate final ArrayList<Integer> wagons = new ArrayList<Integer>();\nprivate int engineType = 0;\nprivate RenderersRoot rr;\npublic SelectWagonsJPanel() {\ninitComponents();\nupdateMaxWagonsText();\nURL url = SelectWagonsJPanel.class\n.getResource(\"/jfreerails/data/station.gif\");\nImage tempImage = (new javax.swing.ImageIcon(url)).getImage();\nstationView = defaultConfiguration.createCompatibleImage(tempImage\n.getWidth(null), tempImage.getHeight(null),\nTransparency.BITMASK);\nGraphics g = stationView.getGraphics();\ng.drawImage(tempImage, 0, 0, null);\n}\npublic void resetSelectedWagons() {\nthis.wagons.clear();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the FormEditor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njPanel1 = new javax.swing.JPanel();\njScrollPane1 = new javax.swing.JScrollPane();\nwagonTypesJList = new javax.swing.JList();\nokjButton = new javax.swing.JButton();\nclearjButton = new javax.swing.JButton();\njLabel1 = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\nsetBackground(new java.awt.Color(0, 255, 51));\nsetMinimumSize(new java.awt.Dimension(640, 400));\nsetPreferredSize(new java.awt.Dimension(620, 380));\njPanel1.setLayout(new java.awt.GridBagLayout());\njPanel1.setMinimumSize(new java.awt.Dimension(170, 300));\njPanel1.setPreferredSize(new java.awt.Dimension(170, 300));\nwagonTypesJList.addKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyTyped(java.awt.event.KeyEvent evt) {\nwagonTypesJListKeyTyped(evt);\n}\n});\nwagonTypesJList.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent evt) {\nwagonTypesJListMouseClicked(evt);\n}\n});\njScrollPane1.setViewportView(wagonTypesJList);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\njPanel1.add(jScrollPane1, gridBagConstraints);\nokjButton.setText(\"OK\");\nokjButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nokButtonAction(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\njPanel1.add(okjButton, gridBagConstraints);\nclearjButton.setText(\"Clear\");\nclearjButton.setActionCommand(\"clear\");\nclearjButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\njButton1ActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\njPanel1.add(clearjButton, gridBagConstraints);\njLabel1.setFont(new java.awt.Font(\"Dialog\", 0, 10));\njLabel1.setText(\"The maximum train length is 6 wagons\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);\njPanel1.add(jLabel1, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.insets = new java.awt.Insets(20, 400, 70, 10);\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;\nadd(jPanel1, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void okButtonAction(java.awt.event.ActionEvent evt) { // GEN-FIRST:event_okButtonAction\n// Add your handling code here:\n} // GEN-LAST:event_okButtonAction\nprivate void wagonTypesJListMouseClicked(java.awt.event.MouseEvent evt) { // GEN-FIRST:event_wagonTypesJListMouseClicked\n// Add your handling code here:\naddwagon();\n} // GEN-LAST:event_wagonTypesJListMouseClicked\nprivate void wagonTypesJListKeyTyped(java.awt.event.KeyEvent evt) { // GEN-FIRST:event_wagonTypesJListKeyTyped\n// Add your handling code here:\nif (KeyEvent.VK_ENTER == evt.getKeyCode()) {\naddwagon();\n} else {\n}\n} // GEN-LAST:event_wagonTypesJListKeyTyped\n// Adds the wagon selected in the list to the train consist.\nprivate void addwagon() {\nif (wagons.size() < TrainModel.MAX_NUMBER_OF_WAGONS) {\nint type = wagonTypesJList.getSelectedIndex();\nwagons.add(new Integer(type));\nupdateMaxWagonsText();\nthis.repaint();\n}\n}\nprivate void updateMaxWagonsText() {\nif (wagons.size() >= TrainModel.MAX_NUMBER_OF_WAGONS) {\njLabel1.setText(\"Max train length is \"\n+ TrainModel.MAX_NUMBER_OF_WAGONS + \" wagons\");\n} else {\njLabel1.setText(\"\");\n}\n}\nprivate void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { // GEN-FIRST:event_jButton1ActionPerformed\n// Add your handling code here:\nwagons.clear();\njLabel1.setText(\"\");\nthis.repaint();\n} // GEN-LAST:event_jButton1ActionPerformed\n@Override\npublic void paint(Graphics g) {\n// paint the background\ng.drawImage(this.stationView, 0, 0, null);\nint x = this.getWidth();\nint y = 330;\nfinal int SCALED_IMAGE_HEIGHT = 50;\n// paint the wagons\nfor (int i = this.wagons.size() - 1; i >= 0; i--) { // Count down so we\n// paint the wagon\n// at the end of the\n// train first.\nInteger type = wagons.get(i);\nImage image = rr.getWagonImages(type.intValue()).getSideOnImage();\nint scaledWidth = image.getWidth(null) * SCALED_IMAGE_HEIGHT\n/ image.getHeight(null);\nx -= scaledWidth;\ng.drawImage(image, x, y, scaledWidth, SCALED_IMAGE_HEIGHT, null);\n}\n// paint the engine\nif (-1 != this.engineType) { // If an engine is selected.\nImage image = rr.getEngineImages(engineType).getSideOnImage();\nint scaledWidth = (image.getWidth(null) * SCALED_IMAGE_HEIGHT)\n/ image.getHeight(null);\nx -= scaledWidth;\ng.drawImage(image, x, y, scaledWidth, SCALED_IMAGE_HEIGHT, null);\n}\nthis.paintChildren(g);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton clearjButton;\nprivate javax.swing.JLabel jLabel1;\nprivate javax.swing.JPanel jPanel1;\nprivate javax.swing.JScrollPane jScrollPane1;\nprivate javax.swing.JButton okjButton;\nprivate javax.swing.JList wagonTypesJList;\n// End of variables declaration//GEN-END:variables\nfinal private class WagonCellRenderer implements ListCellRenderer {\nprivate final Component[] labels;\nfinal RenderersRoot rr;\npublic WagonCellRenderer(World2ListModelAdapter w2lma, RenderersRoot s) {\nrr = s;\nlabels = new Component[w2lma.getSize()];\nfor (int i = 0; i < w2lma.getSize(); i++) {\nJLabel label = new JLabel();\nlabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\nImage image = rr.getWagonImages(i).getSideOnImage();\nint height = image.getHeight(null);\nint width = image.getWidth(null);\nint scale = height / 10;\nImageIcon icon = new ImageIcon(image.getScaledInstance(width\n/ scale, height / scale, Image.SCALE_FAST));\nlabel.setIcon(icon);\nlabels[i] = label;\n}\n}\npublic Component getListCellRendererComponent(JList list, Object value, /*\n* value\n* to\n* display\n*/\nint index, /* cell index */\nboolean isSelected, /* is the cell selected */\nboolean cellHasFocus) /* the list and the cell have the focus */{\nif (index >= 0 && index < labels.length) {\nCargoType cargoType = (CargoType) value;\nString text = \"<html><body>\"\n+ (isSelected ? \"<strong>\" : \"\")\n+ cargoType.getDisplayName()\n+ (isSelected ? \"</strong>\"\n: \"&nbsp;&nbsp;&nbsp;&nbsp;\"/*\n* padding to stop\n* word wrap due to\n* greater width of\n* strong font\n*/) + \"</body></html>\";\n((JLabel) labels[index]).setText(text);\nreturn labels[index];\n}\nreturn null;\n}\n}\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\nWorld2ListModelAdapter w2lma = new World2ListModelAdapter(\nmr.getWorld(), SKEY.CARGO_TYPES);\nthis.wagonTypesJList.setModel(w2lma);\nthis.rr = vl;\nWagonCellRenderer wagonCellRenderer = new WagonCellRenderer(w2lma,\nrr);\nthis.wagonTypesJList.setCellRenderer(wagonCellRenderer);\nthis.okjButton.addActionListener(closeAction);\n}\npublic int[] getWagons() {\nint[] wagonsArray = new int[wagons.size()];\nfor (int i = 0; i < wagons.size(); i++) {\nInteger type = wagons.get(i);\nwagonsArray[i] = type.intValue();\n}\nreturn wagonsArray;\n}\npublic void setEngineType(int engineType) {\nthis.engineType = engineType;\n}\n}"}
{"className":"jfreerails.client.view.HtmlJPanel","javaDoc":"/**\n* This JPanel displays a HTML document read from a URL.\n*\n* @author Luke\n*/","code":"/**\n* This JPanel displays a HTML document read from a URL.\n*\n* @author Luke\n*/\npublic class HtmlJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 4120848850266371126L;\nprivate static final Logger logger = Logger.getLogger(HtmlJPanel.class\n.getName());\nHtmlJPanel() {\ninitComponents();\n}\npublic HtmlJPanel(URL url) {\ninitComponents();\nsetHtml(loadText(url));\n}\npublic HtmlJPanel(URL url, HashMap context) {\ninitComponents();\nString template = loadText(url);\nString populatedTemplate = populateTokens(template, context);\nsetHtml(populatedTemplate);\n}\npublic HtmlJPanel(String html) {\ninitComponents();\nsetHtml(html);\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njScrollPane1 = new javax.swing.JScrollPane();\nhtmlJLabel = new javax.swing.JLabel();\ndone = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\nsetMinimumSize(new java.awt.Dimension(400, 300));\njScrollPane1\n.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\nhtmlJLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\nhtmlJLabel.setVerticalTextPosition(javax.swing.SwingConstants.TOP);\njScrollPane1.setViewportView(htmlJLabel);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(jScrollPane1, gridBagConstraints);\ndone.setText(\"Close\");\ndone.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndoneActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(done, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void doneActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_doneActionPerformed\n// TODO add your handling code here:\n}// GEN-LAST:event_doneActionPerformed\npublic void setup(ModelRoot m, RenderersRoot vl,\nAction closeAction) {\nthis.done.setAction(closeAction);\n}\n/** Load the help text from file. */\nString loadText(final URL htmlUrl) {\ntry {\nInputStream in = htmlUrl.openStream();\nBufferedReader br = new BufferedReader(new InputStreamReader(\nnew DataInputStream(in)));\nString line;\nString text = \"\";\nwhile ((line = br.readLine()) != null) {\ntext = text + line;\n}\nreturn text;\n} catch (Exception e) {\ne.printStackTrace();\nlogger.warning(htmlUrl.toString());\nreturn \"Couldn't read: \" + htmlUrl;\n}\n}\nvoid setHtml(String s) {\nhtmlJLabel.setText(s);\n}\nstatic String populateTokens(String template, Object context) {\nStringTokenizer tokenizer = new StringTokenizer(template, \"$\");\nString output = \"\";\nwhile (tokenizer.hasMoreTokens()) {\noutput += tokenizer.nextToken();\nif (tokenizer.hasMoreTokens()) {\nString token = tokenizer.nextToken();\nString value;\nif (context instanceof HashMap) {\nvalue = (String) ((HashMap) context).get(token);\n} else {\ntry {\nStringTokenizer t2 = new StringTokenizer(token, \".\");\nvalue = null;\nObject o = context;\nwhile (t2.hasMoreTokens()) {\nString subToken = t2.nextToken();\nField field = o.getClass().getField(subToken);\no = field.get(o);\n}\nvalue = o.toString();\n} catch (Exception e) {\ne.printStackTrace();\nthrow new NoSuchElementException(token);\n}\n}\noutput += value;\n}\n}\nreturn output;\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton done;\nprivate javax.swing.JLabel htmlJLabel;\nprivate javax.swing.JScrollPane jScrollPane1;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.StationBuildModel","javaDoc":"/**\n* This class provides the UI model for building a station. The mode of\n* operation is as follows:\n* <ol>\n* <li>Select a station to build by calling ActionPerformed() on the choose\n* Action.\n* <li>Set the position to build.\n* <li>call actionPerformed on the build Action\n* <li> alternatively, call actionPerformed on the cancel Action\n* </ol>\n*\n* @author rob\n*/","code":"/**\n* This class provides the UI model for building a station. The mode of\n* operation is as follows:\n* <ol>\n* <li>Select a station to build by calling ActionPerformed() on the choose\n* Action.\n* <li>Set the position to build.\n* <li>call actionPerformed on the build Action\n* <li> alternatively, call actionPerformed on the cancel Action\n* </ol>\n*\n* @author rob\n*/\npublic class StationBuildModel {\n/*\n* 100 010 001 = 0x111\n*/\nprivate static final int trackTemplate = TrackConfiguration\n.from9bitTemplate(0x111).get9bitTemplate();\n/**\n* Vector of StationBuildAction. Actions which represent stations which can\n* be built\n*/\nprivate final Vector<Action> stationChooseActions = new Vector<Action>();\n/**\n* Whether the station's position can should change when the mouse moves.\n*/\nprivate boolean positionFollowsMouse = true;\nprivate final StationBuildAction stationBuildAction = new StationBuildAction();\nprivate final StationCancelAction stationCancelAction = new StationCancelAction();\nprivate final StationBuilder stationBuilder;\nprivate final ModelRoot modelRoot;\nprivate final HashMap<Integer, Action> id2Action = new HashMap<Integer, Action>();\npublic StationBuildModel(StationBuilder sb, RenderersRoot rr, ModelRoot mr) {\nstationBuilder = sb;\nmodelRoot = mr;\nReadOnlyWorld world = modelRoot.getWorld();\nfor (int i = 0; i < world.size(SKEY.TRACK_RULES); i++) {\nfinal TrackRule trackRule = (TrackRule) world.get(\nSKEY.TRACK_RULES, i);\nif (trackRule.isStation()) {\nTrackPieceRenderer renderer = rr.getTrackPieceView(i);\nStationChooseAction action = new StationChooseAction(i);\nString trackType = trackRule.getTypeName();\nMoney price = trackRule.getFixedCost();\nString shortDescrpt = Utils.capitalizeEveryWord(trackType)\n+ \" $\" + price.toString();\naction.putValue(Action.SHORT_DESCRIPTION, shortDescrpt);\naction.putValue(Action.NAME, \"Build \" + trackType);\naction.putValue(Action.SMALL_ICON, new ImageIcon(renderer\n.getTrackPieceIcon(trackTemplate)));\nstationChooseActions.add(action);\nid2Action.put(new Integer(i), action);\n}\n}\n}\npublic Action getStationChooseAction(Integer ruleID) {\nreturn id2Action.get(ruleID);\n}\npublic Action[] getStationChooseActions() {\nreturn stationChooseActions.toArray(new Action[stationChooseActions.size()]);\n}\nprivate class StationChooseAction extends AbstractAction {\nprivate static final long serialVersionUID = 3257290240279458098L;\nprivate final int actionId;\npublic StationChooseAction(int actionId) {\nthis.actionId = actionId;\n}\npublic void actionPerformed(ActionEvent e) {\nstationBuilder.setStationType(actionId);\nTrackRule trackRule = (TrackRule) modelRoot.getWorld().get(\nSKEY.TRACK_RULES, actionId);\n// Show the relevant station radius when the station type's menu\n// item\n// gets focus.\nstationBuildAction.putValue(StationBuildAction.STATION_RADIUS_KEY,\nnew Integer(trackRule.getStationRadius()));\nstationBuildAction.setEnabled(true);\n}\n}\nprivate class StationCancelAction extends AbstractAction {\nprivate static final long serialVersionUID = 3256441421581203252L;\npublic void actionPerformed(ActionEvent e) {\nstationBuildAction.setEnabled(false);\n}\n}\n/**\n* This action builds the station.\n*/\npublic class StationBuildAction extends AbstractAction {\nprivate static final long serialVersionUID = 3905236827739926833L;\n/**\n* This key can be used to set the position where the station is to be\n* built as a Point object.\n*/\npublic final static String STATION_POSITION_KEY = \"STATION_POSITION_KEY\";\n/**\n* This key can be used to retrieve the radius of the currently selected\n* station as an Integer value. Don't bother writing to it!\n*/\npublic final static String STATION_RADIUS_KEY = \"STATION_RADIUS_KEY\";\nStationBuildAction() {\nsetEnabled(false);\n}\npublic void actionPerformed(ActionEvent e) {\nPoint value = (Point) stationBuildAction\n.getValue(StationBuildAction.STATION_POSITION_KEY);\nMoveStatus ms = stationBuilder.buildStation(new ImPoint(value.x,\nvalue.y));\nString message = null;\nif (ms.isOk()) {\nstationBuildAction.setEnabled(false);\n} else {\nmessage = ms.message;\n}\nmodelRoot.setProperty(ModelRoot.Property.CURSOR_MESSAGE, message);\n}\n}\npublic boolean canBuildStationHere() {\nPoint p = (Point) stationBuildAction\n.getValue(StationBuildAction.STATION_POSITION_KEY);\nreturn stationBuilder.tryBuildingStation(new ImPoint(p.x, p.y)).ok;\n}\npublic Action getStationCancelAction() {\nreturn stationCancelAction;\n}\npublic StationBuildAction getStationBuildAction() {\nreturn stationBuildAction;\n}\npublic boolean isPositionFollowsMouse() {\nreturn positionFollowsMouse;\n}\npublic void setPositionFollowsMouse(boolean positionFollowsMouse) {\nthis.positionFollowsMouse = positionFollowsMouse;\n}\n}"}
{"className":"jfreerails.client.view.World2ListModelAdapter","javaDoc":"/**\n* Converts the interface of a list on the world object to a ListModel interface\n* that can be used by JLists. Currently, change notification is <b>not</b>\n* implemented (null elements are skipped).\n*\n* @author Luke\n*\n*/","code":"/**\n* Converts the interface of a list on the world object to a ListModel interface\n* that can be used by JLists. Currently, change notification is <b>not</b>\n* implemented (null elements are skipped).\n*\n* @author Luke\n*\n*/\npublic class World2ListModelAdapter implements ListModel {\nprivate final ReadOnlyWorld w;\nprivate final NonNullElements elements;\npublic World2ListModelAdapter(ReadOnlyWorld world, SKEY key) {\nthis.w = world;\nif (null == key)\nthrow new NullPointerException();\nif (null == w)\nthrow new NullPointerException();\nelements = new NonNullElements(key, world);\n}\npublic World2ListModelAdapter(ReadOnlyWorld world, KEY key,\nFreerailsPrincipal p) {\nthis.w = world;\nif (null == key)\nthrow new NullPointerException();\nif (null == p)\nthrow new NullPointerException();\nif (null == w)\nthrow new NullPointerException();\n// Check that the principal exists.\nif (!world.isPlayer(p))\nthrow new IllegalArgumentException(p.getName());\nelements = new NonNullElements(key, world, p);\n}\npublic int getSize() {\nreturn elements.size();\n}\npublic Object getElementAt(int i) {\nelements.gotoRow(i);\nreturn elements.getElement();\n}\npublic void addListDataListener(ListDataListener arg0) {\n// TODO Auto-generated method stub\n}\npublic void removeListDataListener(ListDataListener arg0) {\n// TODO Auto-generated method stub\n}\n}"}
{"className":"jfreerails.client.view.DateJLabel","javaDoc":"/**\n* This JLabel shows the current date.\n*\n* @author Luke\n*\n*/","code":"/**\n* This JLabel shows the current date.\n*\n* @author Luke\n*\n*/\npublic class DateJLabel extends JLabel implements View {\nprivate static final long serialVersionUID = 3689348840578757942L;\nprivate ReadOnlyWorld w;\npublic DateJLabel() {\nthis.setText(\" \");\n}\n@Override\nprotected void paintComponent(Graphics g) {\nif (null != w) {\nGameTime time = w.currentTime();\nGameCalendar gameCalendar = (GameCalendar) w.get(ITEM.CALENDAR);\nString s = gameCalendar.getYearAndMonth(time.getTicks());\nsuper.setText(s);\n}\nsuper.paintComponent(g);\n}\npublic void setup(ModelRoot model, RenderersRoot vl,\nAction closeAction) {\nthis.w = model.getWorld();\n}\n}"}
{"className":"jfreerails.client.view.TrainOrdersListModel","javaDoc":"/**\n* AbstractListModel used by {@link TrainScheduleJPanel} to display the orders\n* making up a train schedule.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* AbstractListModel used by {@link TrainScheduleJPanel} to display the orders\n* making up a train schedule.\n*\n* @author Luke Lindsay\n*/\npublic class TrainOrdersListModel extends AbstractListModel {\nprivate static final long serialVersionUID = 3762537827703009847L;\nprivate final int trainNumber;\nprivate final ReadOnlyWorld w;\nprivate final FreerailsPrincipal principal;\npublic static final int DONT_GOTO = 0;\npublic static final int GOTO_NOW = 1;\npublic static final int GOTO_AFTER_PRIORITY_ORDERS = 2;\n/**\n* This class holds the values that are needed by the ListCellRender.\n* TrainOrdersListModel.getElementAt(int index) returns an instance of this\n* class.\n*/\npublic static class TrainOrdersListElement {\npublic final boolean isPriorityOrder;\npublic final int gotoStatus;\npublic final TrainOrdersModel order;\npublic final int trainNumber;\npublic TrainOrdersListElement(boolean isPriorityOrder, int gotoStatus,\nTrainOrdersModel order, int trainNumber) {\nthis.isPriorityOrder = isPriorityOrder;\nthis.gotoStatus = gotoStatus;\nthis.order = order;\nthis.trainNumber = trainNumber;\n}\n}\npublic TrainOrdersListModel(ReadOnlyWorld w, int trainNumber,\nFreerailsPrincipal p) {\nthis.trainNumber = trainNumber;\nthis.w = w;\nthis.principal = p;\nassert (null != getSchedule());\n}\npublic Object getElementAt(int index) {\nSchedule s = getSchedule();\nint gotoStatus;\nif (s.getNextScheduledOrder() == index) {\nif (s.hasPriorityOrders()) {\ngotoStatus = GOTO_AFTER_PRIORITY_ORDERS;\n} else {\ngotoStatus = GOTO_NOW;\n}\n} else {\nif (s.hasPriorityOrders() && 0 == index) {\n// These orders are the priority orders.\ngotoStatus = GOTO_NOW;\n} else {\ngotoStatus = DONT_GOTO;\n}\n}\nboolean isPriorityOrders = 0 == index && s.hasPriorityOrders();\nTrainOrdersModel order = getSchedule().getOrder(index);\nreturn new TrainOrdersListElement(isPriorityOrders, gotoStatus, order,\ntrainNumber);\n}\npublic int getSize() {\nSchedule s = getSchedule();\nint size = 0;\nif (s != null) {\nsize = s.getNumOrders();\n}\nreturn size;\n}\npublic void fireRefresh() {\nsuper.fireContentsChanged(this, 0, getSize());\n}\nprivate Schedule getSchedule() {\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\ntrainNumber);\nImmutableSchedule sched = null;\nif (train != null) {\nsched = (ImmutableSchedule) w.get(principal, KEY.TRAIN_SCHEDULES, train\n.getScheduleID());\n}\nreturn sched;\n}\n}"}
{"className":"jfreerails.client.view.BrokerJFrame","javaDoc":"/**\n* @author smackay\n* @author Luke\n*/","code":"/**\n* @author smackay\n* @author Luke\n*/\npublic class BrokerJFrame extends javax.swing.JInternalFrame {\nprivate static final long serialVersionUID = 4121409622587815475L;\nprivate static final Logger logger = Logger.getLogger(BrokerJFrame.class\n.getName());\n/** Creates new form BrokerJFrame */\nBrokerJFrame() {\ninitComponents();\n}\npublic BrokerJFrame(URL url) {\ninitComponents();\nsetHtml(loadText(url));\n}\npublic BrokerJFrame(URL url, HashMap context) {\ninitComponents();\nString template = loadText(url);\nString populatedTemplate = populateTokens(template, context);\nsetHtml(populatedTemplate);\n}\npublic BrokerJFrame(String html) {\ninitComponents();\nsetHtml(html);\n}\npublic void setup(ModelRoot m, RenderersRoot vl,\nAction closeAction) {\nthis.done.setAction(closeAction);\n}\n/** Load the help text from file. */\nString loadText(final URL htmlUrl) {\ntry {\nInputStream in = htmlUrl.openStream();\nBufferedReader br = new BufferedReader(new InputStreamReader(\nnew DataInputStream(in)));\nString line;\nString text = \"\";\nwhile ((line = br.readLine()) != null) {\ntext = text + line;\n}\nreturn text;\n} catch (Exception e) {\ne.printStackTrace();\nlogger.warning(htmlUrl.toString());\nreturn \"Couldn't read: \" + htmlUrl;\n}\n}\nvoid setHtml(String s) {\nhtmlJLabel.setText(s);\n}\npublic String populateTokens(String template, Object context) {\nStringTokenizer tokenizer = new StringTokenizer(template, \"$\");\nString output = \"\";\nwhile (tokenizer.hasMoreTokens()) {\noutput += tokenizer.nextToken();\nif (tokenizer.hasMoreTokens()) {\nString token = tokenizer.nextToken();\nString value;\nif (context instanceof HashMap) {\nvalue = (String) ((HashMap) context).get(token);\n} else {\ntry {\nField field = context.getClass().getField(token);\nvalue = field.get(context).toString();\n} catch (Exception e) {\ne.printStackTrace();\nthrow new NoSuchElementException(token);\n}\n}\noutput += value;\n}\n}\nreturn output;\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\njScrollPane1 = new javax.swing.JScrollPane();\njPanel1 = new javax.swing.JPanel();\nhtmlJLabel = new javax.swing.JLabel();\ndone = new javax.swing.JButton();\nbrokerMenu = new javax.swing.JMenuBar();\nbonds = new javax.swing.JMenu();\nissueBond = new javax.swing.JMenuItem();\nrepayBond = new javax.swing.JMenuItem();\nstocks = new javax.swing.JMenu();\ngetContentPane().setLayout(new java.awt.GridBagLayout());\njScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\njPanel1.setLayout(new java.awt.BorderLayout());\nhtmlJLabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\nhtmlJLabel.setText(\"sdfa\");\nhtmlJLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);\nhtmlJLabel.setVerticalTextPosition(javax.swing.SwingConstants.TOP);\njPanel1.add(htmlJLabel, java.awt.BorderLayout.CENTER);\njScrollPane1.setViewportView(jPanel1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngetContentPane().add(jScrollPane1, gridBagConstraints);\ndone.setText(\"Close\");\ndone.setVerifyInputWhenFocusTarget(false);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\ngetContentPane().add(done, gridBagConstraints);\nbonds.setText(\"Bonds\");\nissueBond.setText(\"Issue Bond\");\nbonds.add(issueBond);\nrepayBond.setText(\"Repay Bond\");\nbonds.add(repayBond);\nbrokerMenu.add(bonds);\nstocks.setText(\"Stocks\");\nbrokerMenu.add(stocks);\nsetJMenuBar(brokerMenu);\npack();\n}\n// </editor-fold>//GEN-END:initComponents\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JMenu bonds;\njavax.swing.JMenuBar brokerMenu;\njavax.swing.JButton done;\njavax.swing.JLabel htmlJLabel;\njavax.swing.JMenuItem issueBond;\njavax.swing.JPanel jPanel1;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JMenuItem repayBond;\njavax.swing.JMenu stocks;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.KeyCode2OneTileMoveVector","javaDoc":"/**\n* Maps keys to OneTileMoveVectors.\n*\n* @author Luke\n*\n*/","code":"/**\n* Maps keys to OneTileMoveVectors.\n*\n* @author Luke\n*\n*/\npublic class KeyCode2OneTileMoveVector {\nprivate static final HashMap<Integer, Step> keycode2vector = new HashMap<Integer, Step>();\nstatic {\n// Set up key mappings...\n// Num pad with num lock on\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD1), Step.SOUTH_WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD2), Step.SOUTH);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD3), Step.SOUTH_EAST);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD4), Step.WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD6), Step.EAST);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD7), Step.NORTH_WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD8), Step.NORTH);\nkeycode2vector.put(new Integer(KeyEvent.VK_NUMPAD9), Step.NORTH_EAST);\n// Num pad with num lock off\nkeycode2vector.put(new Integer(KeyEvent.VK_END), Step.SOUTH_WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_DOWN), Step.SOUTH);\nkeycode2vector.put(new Integer(KeyEvent.VK_PAGE_DOWN), Step.SOUTH_EAST);\nkeycode2vector.put(new Integer(KeyEvent.VK_LEFT), Step.WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_RIGHT), Step.EAST);\nkeycode2vector.put(new Integer(KeyEvent.VK_HOME), Step.NORTH_WEST);\nkeycode2vector.put(new Integer(KeyEvent.VK_UP), Step.NORTH);\nkeycode2vector.put(new Integer(KeyEvent.VK_PAGE_UP), Step.NORTH_EAST);\n}\n/** Returns the OneTileMoveVector that is mapped to the specified keycode. */\npublic static Step getInstanceMappedToKey(int keycode)\nthrows NoSuchElementException {\nInteger integer = new Integer(keycode);\nif (!keycode2vector.containsKey(integer)) {\nthrow new NoSuchElementException(String.valueOf(keycode));\n}\nreturn keycode2vector.get(integer);\n}\n}"}
{"className":"jfreerails.client.view.ServerControlModel","javaDoc":"/**\n* Exposes the ServerControlInterface to client UI implementations.\n*\n* @author rob\n* @author Luke\n* @author MystiqueAgent\n*/","code":"/**\n* Exposes the ServerControlInterface to client UI implementations.\n*\n* @author rob\n* @author Luke\n* @author MystiqueAgent\n*/\npublic class ServerControlModel implements ModelRootListener{\nprivate class LoadGameAction extends AbstractAction {\nprivate static final long serialVersionUID = 3616451215278682931L;\npublic LoadGameAction() {\nputValue(NAME, \"Load Game\");\nputValue(MNEMONIC_KEY, new Integer(76));\n}\npublic void actionPerformed(ActionEvent e) {\ndbc.showSelectSavedGame2Load();\n/*\nImStringList files = (ImStringList)modelRoot.getProperty(Property.SAVED_GAMES_LIST);\nObject[] saves = new Object[files.size()];\nfor (int i = 0; i < files.size(); i++) {\nsaves[i] = files.get(i);\n}\n// Display a JOptionPane that lists the existing saved games\ntry {\nObject showInputDialog = JOptionPane.showInputDialog(null,\n\"Saved Games:\", \"Select game to load\",\nJOptionPane.INFORMATION_MESSAGE, null, saves, saves[0]);\nString filename = showInputDialog.toString();\n// Load the game chosen\nMessage2Server message2 = new LoadGameMessage2Server(1,\nfilename);\nmodelRoot.sendCommand(message2);\n} catch (Exception exept) {\n// <Hack>\n// When no saved game is selected, or one that doesnt exist,\n// nothing changes\n// </.Hack>\n}\n*/\n}\n}\nprivate class NewGameAction extends AbstractAction {\nprivate static final long serialVersionUID = 3690758388631745337L;\npublic NewGameAction(String s) {\nif (s == null) {\nputValue(NAME, \"New Game...\");\n} else {\nputValue(NAME, s);\nputValue(ACTION_COMMAND_KEY, s);\n}\n}\npublic void actionPerformed(ActionEvent e) {\nString mapName = e.getActionCommand();\nif (mapName != null) {\nMessage2Server message2 = new NewGameMessage2Server(1, mapName);\nmodelRoot.sendCommand(message2);\n}\n}\n}\nprivate class SaveGameAction extends AbstractAction {\nprivate static final long serialVersionUID = 3905808578064562480L;\npublic SaveGameAction() {\nputValue(NAME, \"Save Game\");\nputValue(MNEMONIC_KEY, new Integer(83));\n}\npublic void actionPerformed(ActionEvent e) {\ndbc.showSaveGame();\n/*\ntry {\n// @SonnyZ\n// Show a JOptionPane that takes in a string from a text box\nString filename = JOptionPane.showInputDialog(null,\n\"Saved Game Name:\", \"Save Game\",\nJOptionPane.QUESTION_MESSAGE, null, null,\nmodelRoot.getPrincipal().getName()).toString();\n// Save the current game using the string\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Saved game \"\n+ filename);\nMessage2Server message2 = new SaveGameMessage2Server(1,\nfilename + \".sav\");\nmodelRoot.sendCommand(message2);\nloadGameAction.setEnabled(true);\n} catch (Exception except) {\n}\n*/\n}\n}\nprivate class SetTargetTicksPerSecondAction extends AbstractAction {\nprivate static final long serialVersionUID = 3256437014978048052L;\nfinal int speed;\n/**\n* Same as the constructor above but it enables also to associate a\n* <code>keyEvent</code> with the action.\n*\n* @param name\n* action name\n* @param speed\n* speed\n* @param keyEvent\n* associated key event. Use values from\n* <code>KeyEvent</class>.\n*\n* by MystiqueAgent\n*/\npublic SetTargetTicksPerSecondAction(String name, int speed,\nint keyEvent) {\nputValue(NAME, name);\nthis.speed = speed;\nputValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(keyEvent, 0));\n}\npublic void actionPerformed(ActionEvent e) {\nint speed2set = speed;\nif (speed == 0) { // pausing/unpausing\nspeed2set = -1 * getTargetTicksPerSecond();\n}\nmodelRoot.doMove(ChangeGameSpeedMove.getMove(modelRoot.getWorld(),\nnew GameSpeed(speed2set)));\n}\n}\nprivate final Action loadGameAction = new LoadGameAction();\nprivate ModelRootImpl modelRoot;\nprivate final Action newGameAction = new NewGameAction(null);\nprivate final Action saveGameAction = new SaveGameAction();\nprivate ActionAdapter selectMapActions;\nprivate final SetTargetTicksPerSecondAction[] speedActions = new SetTargetTicksPerSecondAction[] {\nnew SetTargetTicksPerSecondAction(\"Pause\", 0, KeyEvent.VK_P),\nnew SetTargetTicksPerSecondAction(\"Slow\", 10, KeyEvent.VK_1),\nnew SetTargetTicksPerSecondAction(\"Moderate\", 30, KeyEvent.VK_2),\nnew SetTargetTicksPerSecondAction(\"Fast\", 70, KeyEvent.VK_3),\n};\nprivate final ActionAdapter targetTicksPerSecondActions = new ActionAdapter(\nspeedActions, 0);\nprivate DialogueBoxController dbc;\npublic ServerControlModel(ModelRootImpl mr) {\nthis.modelRoot = mr;\nmr.addPropertyChangeListener(this);\nsetServerControlInterface();\n}\n/**\n* Returns human readable string description of <code>tickPerSecond</code>\n* number. Looks for <code>tickPerSecond</code> in\n* <code>targetTicksPerSecondActions</code>. If appropriate action is not\n* found returns first greater value or the greatest value.\n*\n* @param tickPerSecond\n* int\n* @return String human readable description\n*/\npublic String getGameSpeedDesc(int tickPerSecond) {\nSetTargetTicksPerSecondAction action = null;\nfor (int i = 0; i < speedActions.length; i++) {\naction = speedActions[i];\nif (action.speed >= tickPerSecond)\nbreak;\n}\nreturn (String) action.getValue(Action.NAME);\n}\n/**\n* @return an action to load a game.\n*/\npublic Action getLoadGameAction() {\nreturn loadGameAction;\n}\n/**\n* @return an ActionAdapter representing a list of actions representing\n* valid map names.\n*/\npublic ActionAdapter getMapNames() {\nreturn selectMapActions;\n}\n/**\n* When calling this action, set the action command string to the desired\n* map name, or call the appropriate selectMapAction.\n*\n* @return an action to start a new game\n*/\npublic Action getNewGameAction() {\nreturn newGameAction;\n}\n/**\n* @return an action to save a game TODO The action produces a file selector\n* dialog to save the game\n*/\npublic Action getSaveGameAction() {\nreturn saveGameAction;\n}\n/**\n* @return an action adapter to set the target ticks per second\n*/\npublic ActionAdapter getSetTargetTickPerSecondActions() {\nreturn targetTicksPerSecondActions;\n}\npublic int getTargetTicksPerSecond() {\nReadOnlyWorld world = modelRoot.getWorld();\nreturn ((GameSpeed) world.get(ITEM.GAME_SPEED)).getSpeed();\n}\npublic void propertyChange(Property p, Object oldValue, Object newValue) {\n// switch (p) {\n// case SAVED_GAMES_LIST:\n// updateLoadGameAction();\n// break;\n//\n// default:\n// break;\n// }\n}\npublic void setup(ModelRootImpl modelRoot, DialogueBoxController dbc) {\nthis.modelRoot = modelRoot;\nthis.dbc = dbc;\nmodelRoot.addPropertyChangeListener(this);\n}\npublic void setServerControlInterface() {\n// Check that there is a file to load..\nsaveGameAction.setEnabled(true);\nEnumeration<Action> e = targetTicksPerSecondActions.getActions();\ntargetTicksPerSecondActions.setPerformActionOnSetSelectedItem(false);\nwhile (e.hasMoreElements()) {\ne.nextElement().setEnabled(true);\n}\nString[] mapNames = NewGameMessage2Server.getMapNames();\nAction[] actions = new Action[mapNames.length];\nfor (int j = 0; j < actions.length; j++) {\nactions[j] = new NewGameAction(mapNames[j]);\nactions[j].setEnabled(true);\n}\nselectMapActions = new ActionAdapter(actions);\nnewGameAction.setEnabled(true);\n}\n}"}
{"className":"jfreerails.client.view.RHSJTabPane","javaDoc":"/**\n* The tabbed panel that sits in the lower right hand corner of the screen.\n*\n* @author rob\n*/","code":"/**\n* The tabbed panel that sits in the lower right hand corner of the screen.\n*\n* @author rob\n*/\npublic class RHSJTabPane extends JTabbedPane implements ModelRootListener {\nprivate static final long serialVersionUID = 3906926798502965297L;\nprivate final TerrainInfoJPanel terrainInfoPanel;\nprivate final StationInfoJPanel stationInfoPanel;\nprivate final TrainListJPanel trainListPanel;\nprivate final BuildTrackJPanel buildTrackPanel;\nprivate ReadOnlyWorld world;\nprivate int trainListIndex;\npublic RHSJTabPane() {\n/*\n* Dont accept keyboard focus since we want to leave it with the main\n* map view.\n*/\nsetFocusable(false);\nImageIcon trainListIcon;\nImageIcon buildTrackIcon;\n/* set up trainsJTabbedPane */\nsetTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\nterrainInfoPanel = new TerrainInfoJPanel();\ntrainListPanel = new TrainListJPanel(true);\nbuildTrackPanel = new BuildTrackJPanel();\ntrainListPanel.removeButtons();\nURL terrainInfoIconUrl = getClass().getResource(\n\"/jfreerails/client/graphics/icons/terrain_info.png\");\nImageIcon terrainInfoIcon = new ImageIcon(terrainInfoIconUrl);\nURL buildTrackIconUrl = getClass().getResource(\n\"/jfreerails/client/graphics/icons/track_new.png\");\nbuildTrackIcon = new ImageIcon(buildTrackIconUrl);\nURL trainListIconUrl = getClass().getResource(\n\"/jfreerails/client/graphics/icons/train_list.png\");\ntrainListIcon = new ImageIcon(trainListIconUrl);\n// Note titles set to null so only the icon appears at the top of the\n// top.\nJScrollPane terrainInfoJScrollPane = new JScrollPane(terrainInfoPanel);\nterrainInfoJScrollPane\n.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\naddTab(null, terrainInfoIcon, terrainInfoJScrollPane, \"Terrain Info\");\nstationInfoPanel = new StationInfoJPanel();\nstationInfoPanel.removeCloseButton();\n// Don't show the station info tab until it has been rewritten to take\n// up less space.\n// JScrollPane stationInfoJScrollPane = new\n// JScrollPane(stationInfoPanel);\n// stationInfoJScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n// addTab(null, stationInfoIcon, stationInfoJScrollPane, \"Station\n// Info\");\n// this.stationInfoIndex= this.getTabCount()-1;\ntrainListPanel.setTrainViewHeight(20);\naddTab(null, buildTrackIcon, buildTrackPanel, \"Build Track\");\naddTab(null, trainListIcon, trainListPanel, \"Train List\");\nthis.trainListIndex = this.getTabCount() - 1;\n/* These values were picked by trial and error! */\nthis.setMinimumSize(new Dimension(250, 200));\n}\npublic void setup(final ActionRoot actionRoot, RenderersRoot vl,\nfinal ModelRootImpl modelRoot) {\nworld = modelRoot.getWorld();\nterrainInfoPanel.setup(world, vl);\nstationInfoPanel.setup(modelRoot, vl, null);\nActionListener showTrain = new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nint id = trainListPanel.getSelectedTrainID();\nactionRoot.getDialogueBoxController().showTrainOrders(id);\n}\n};\ntrainListPanel.setShowTrainDetailsActionListener(showTrain);\ntrainListPanel.setup(modelRoot, vl, null);\nmodelRoot.addPropertyChangeListener(this);\nbuildTrackPanel.setup(modelRoot, actionRoot, vl, null);\n}\n/**\n* Updates the Terrain Info Panel if the specified PropertyChangeEvent was\n* triggered by the cursor moving.\n*/\npublic void propertyChange(ModelRoot.Property prop, Object before,\nObject after) {\nif (prop.equals(ModelRoot.Property.CURSOR_POSITION)) {\nImPoint p = (ImPoint) after;\nterrainInfoPanel.setTerrainType(((FreerailsTile) world.getTile(p.x,\np.y)).getTerrainTypeID());\n}\n}\npublic void setTrainTabEnabled(boolean enabled) {\nthis.setEnabledAt(this.trainListIndex, enabled);\n}\npublic void setStationTabEnabled(boolean enabled) {\n// this.setEnabledAt(this.stationInfoIndex, enabled);\n}\n}"}
{"className":"jfreerails.client.view.TrainListCellRenderer","javaDoc":"/**\n* This JPanel displays an engine and a number of wagons.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This JPanel displays an engine and a number of wagons.\n*\n* @author Luke Lindsay\n*/\npublic class TrainListCellRenderer extends JPanel implements View, ListCellRenderer,\nWorldListListener {\nprivate static final long serialVersionUID = 3546076964969591093L;\nprivate ReadOnlyWorld w;\nprivate RenderersRoot vl;\nprivate int trainNumber = -1;\nprivate int scheduleOrderNumber;\nprivate int scheduleID = -1;\nprivate int height = 100;\nprivate FreerailsPrincipal principal;\nprivate Image[] images = new Image[0];\n/**\n* Whether this JPanel should one of the trains orders from the schedule\n* instead of the trains current formation.\n*/\nprivate boolean showingOrder = false;\n/**\n* If true, the train is drawn in the center to the JPanel; if false, the\n* train is drawn left aligned.\n*/\nprivate boolean centerTrain = false;\nprivate int trainWidth = 0;\nprivate boolean selected = false;\nprivate final Color backgroundColor = (java.awt.Color) javax.swing.UIManager.getDefaults().get(\n\"List.background\");\nprivate final Color selectedColor = (java.awt.Color) javax.swing.UIManager.getDefaults().get(\n\"List.selectionBackground\");\nprivate final Color selectedColorNotFocused = Color.LIGHT_GRAY;\npublic TrainListCellRenderer() {\nthis.setOpaque(false);\n}\npublic TrainListCellRenderer(ModelRoot mr, RenderersRoot vl) {\nsetup(mr, vl, null);\nthis.setBackground(backgroundColor);\n}\npublic void setCenterTrain(boolean b) {\nthis.centerTrain = b;\n}\npublic void display(int newTrainNumber) {\nshowingOrder = false;\nthis.trainNumber = newTrainNumber;\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS, trainNumber);\ndisplay(train.getEngineType(), train.getConsist());\nresetPreferredSize();\n}\nprivate void display(int engine, ImInts wagons){\nimages = new Image[1 + wagons.size()];\n// images[0] = vl.getTrainImages().getSideOnEngineImage(\n// train.getEngineType(), height);\nString engineFilename = vl.getEngineImages(engine).sideOnFileName;\ntry {\nimages[0] = vl.getScaledImage(engineFilename, height);\n} catch (IOException e) {\ne.printStackTrace();\nthrow new IllegalArgumentException(engineFilename);\n}\nfor (int i = 0; i < wagons.size(); i++) {\n// images[i + 1] = vl.getTrainImages().getSideOnWagonImage(\n// order.consist.get(i), height);\nint wagonType = wagons.get(i);\nString wagonFilename = vl.getWagonImages(wagonType).sideOnFileName;\ntry {\nimages[i + 1] = vl.getScaledImage(wagonFilename, height);\n} catch (IOException e) {\ne.printStackTrace();\nthrow new IllegalArgumentException(wagonFilename);\n}\n}\n}\npublic void display(int newTrainNumber, int newScheduleOrderID) {\nshowingOrder = true;\nthis.trainNumber = newTrainNumber;\nthis.scheduleOrderNumber = newScheduleOrderID;\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS, trainNumber);\nthis.scheduleID = train.getScheduleID();\nImmutableSchedule s = (ImmutableSchedule) w.get(principal, KEY.TRAIN_SCHEDULES, scheduleID);\nTrainOrdersModel order = s.getOrder(newScheduleOrderID);\n// Set up the array of images.\nif (null != order.consist) {\ndisplay(train.getEngineType(), order.consist);\n} else {\nimages = new Image[0];\n}\nresetPreferredSize();\n}\nprivate void resetPreferredSize() {\nint width = 0;\nfor (int i = 0; i < images.length; i++) {\nwidth += images[i].getWidth(null);\n}\nthis.trainWidth = width;\nthis.setPreferredSize(new Dimension(width, height));\n}\npublic void setup(ModelRoot mr, RenderersRoot vl, Action closeAction) {\nthis.w = mr.getWorld();\nthis.vl = vl;\nthis.principal = mr.getPrincipal();\n}\npublic Component getListCellRendererComponent(JList list, Object value, int index,\nboolean isSelected, boolean cellHasFocus) {\nint trainID = NonNullElements.row2index(w, KEY.TRAINS, principal, index);\ndisplay(trainID);\nselected = isSelected;\nif (selected) {\nif (list.isFocusOwner()) {\nsetBackground(selectedColor);\n} else {\nsetBackground(selectedColorNotFocused);\n}\n} else {\nsetBackground(backgroundColor);\n}\nreturn this;\n}\n@Override\npublic int getHeight() {\nreturn height;\n}\npublic void setHeight(int i) {\nheight = i;\n}\n@Override\nprotected void paintComponent(Graphics g) {\nsuper.paintComponent(g);\nint x = 0;\nif (this.centerTrain) {\nx = (this.getWidth() - this.trainWidth) / 2;\n}\nfor (int i = 0; i < images.length; i++) {\ng.drawImage(images[i], x, 0, null);\nx += images[i].getWidth(null);\n}\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal p) {\nif (showingOrder) {\nif (KEY.TRAIN_SCHEDULES == key && this.scheduleID == index) {\nthis.display(this.trainNumber, this.scheduleOrderNumber);\n}\n} else {\nif (KEY.TRAINS == key && this.trainNumber == index) {\nthis.display(this.trainNumber);\n}\n}\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal p) {\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal p) {\n}\n}"}
{"className":"jfreerails.client.view.DisplayModesComboBoxModels","javaDoc":"/**\n* ComboBoxModel that provides access to the screen resolutions and bit depths\n* available.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* ComboBoxModel that provides access to the screen resolutions and bit depths\n* available.\n*\n* @author Luke Lindsay\n*/\npublic class DisplayModesComboBoxModels implements javax.swing.ComboBoxModel {\nprivate final GraphicsConfiguration defaultConfiguration = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\nprivate final ArrayList<MyDisplayMode> modes = new ArrayList<MyDisplayMode>();\nprivate MyDisplayMode selection;\npublic DisplayModesComboBoxModels() {\nDisplayMode currentMode = defaultConfiguration.getDevice()\n.getDisplayMode();\nselection = new MyDisplayMode(currentMode);\nDisplayMode[] displayModes = defaultConfiguration.getDevice()\n.getDisplayModes();\nfor (int i = 0; i < displayModes.length; i++) {\nMyDisplayMode mode = new MyDisplayMode(displayModes[i]);\nmodes.add(mode);\n}\n}\n/**\n* Permanently removes from the list in this object any display modes with\n* width, height, or bitdepth below the specified values.\n*/\npublic void removeDisplayModesBelow(int width, int height, int bitdepth) {\nIterator<MyDisplayMode> it = modes.iterator();\nwhile (it.hasNext()) {\nMyDisplayMode mode = it.next();\nDisplayMode displayMode = mode.displayMode;\nfinal boolean tooNarrow = displayMode.getWidth() < width;\nfinal boolean tooShort = displayMode.getHeight() < height;\n/*\n* Note, displayMode.getBitDepth() may return\n* DisplayMode.BIT_DEPTH_MULTI, which is -1.\n*/\nfinal boolean tooFewColours = (displayMode.getBitDepth() < bitdepth)\n&& (displayMode.getBitDepth() != DisplayMode.BIT_DEPTH_MULTI);\nif (tooNarrow || tooShort || tooFewColours) {\nit.remove();\n}\n}\n}\npublic Object getSelectedItem() {\nreturn selection;\n}\npublic void setSelectedItem(Object anItem) {\nselection = (MyDisplayMode) anItem;\n}\npublic void addListDataListener(javax.swing.event.ListDataListener l) {\n}\npublic MyDisplayMode getElementAt(int index) {\nreturn modes.get(index);\n}\npublic int getSize() {\nreturn modes.size();\n}\npublic void removeListDataListener(javax.swing.event.ListDataListener l) {\n}\n}"}
{"className":"jfreerails.client.view.NewsPaperJPanel","javaDoc":"/**\n* A JPanel that displays a newspaper headline.\n*\n* @author lindsal8\n*\n*/","code":"/**\n* A JPanel that displays a newspaper headline.\n*\n* @author lindsal8\n*\n*/\npublic class NewsPaperJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 3258410638366946868L;\nprivate final GraphicsConfiguration defaultConfiguration = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\nprivate ActionListener callBack;\nprivate final Image pieceOfNewspaper;\npublic NewsPaperJPanel() {\ninitComponents();\nImage tempImage = (new javax.swing.ImageIcon(getClass().getResource(\n\"/jfreerails/data/newspaper.png\"))).getImage();\npieceOfNewspaper = defaultConfiguration.createCompatibleImage(tempImage\n.getWidth(null), tempImage.getHeight(null),\nTransparency.BITMASK);\nGraphics g = pieceOfNewspaper.getGraphics();\ng.drawImage(tempImage, 0, 0, null);\nthis.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mousePressed(java.awt.event.MouseEvent evt) {\ncallBack.actionPerformed(new ActionEvent(this, 0, null));\n}\n});\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the FormEditor.\n*/\nprivate void initComponents() { // GEN-BEGIN:initComponents\nheadline = new javax.swing.JLabel();\njPanel1 = new javax.swing.JPanel();\nanyKeyToContinueJLabel = new javax.swing.JLabel();\nsetLayout(null);\nsetPreferredSize(new java.awt.Dimension(640, 400));\nsetMinimumSize(new java.awt.Dimension(640, 400));\nsetMaximumSize(new java.awt.Dimension(640, 400));\nsetOpaque(false);\naddKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nformKeyPressed(evt);\n}\n});\nheadline.setPreferredSize(new java.awt.Dimension(620, 110));\nheadline.setMinimumSize(new java.awt.Dimension(620, 110));\nheadline.setText(\"NEWSPAPER HEADLINE\");\nheadline.setForeground(java.awt.Color.black);\nheadline.setBackground(java.awt.Color.white);\nheadline.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nheadline.setFont(new java.awt.Font(\"Lucida Bright\", 1, 36));\nheadline.setMaximumSize(new java.awt.Dimension(620, 110));\nadd(headline);\nheadline.setBounds(10, 70, 620, 110);\njPanel1.setBorder(new javax.swing.border.BevelBorder(0));\nanyKeyToContinueJLabel.setText(\"Click to continue\");\nanyKeyToContinueJLabel.setForeground(java.awt.Color.black);\nanyKeyToContinueJLabel.setBackground(java.awt.Color.darkGray);\njPanel1.add(anyKeyToContinueJLabel);\nadd(jPanel1);\njPanel1.setBounds(230, 260, 190, 30);\n}\n// GEN-END:initComponents\nprivate void formKeyPressed(java.awt.event.KeyEvent evt) { // GEN-FIRST:event_formKeyPressed\n// Add your handling code here:\nthis.setVerifyInputWhenFocusTarget(false);\n}\n// GEN-LAST:event_formKeyPressed\n@Override\npublic void paint(Graphics g) {\ng.drawImage(this.pieceOfNewspaper, 0, 0, null);\nthis.paintChildren(g);\n}\npublic void setHeadline(String s) {\nthis.headline.setText(s);\n}\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\nthis.callBack = closeAction;\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JLabel headline;\nprivate javax.swing.JPanel jPanel1;\nprivate javax.swing.JLabel anyKeyToContinueJLabel;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.TrainDescriptionJPanel","javaDoc":"/**\n* This JPanel displays a side-on view of a train and a summary of the cargo\n* that it is carrying.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This JPanel displays a side-on view of a train and a summary of the cargo\n* that it is carrying.\n*\n* @author Luke Lindsay\n*/\npublic class TrainDescriptionJPanel extends javax.swing.JPanel implements View{\nprivate static final long serialVersionUID = 3977018444325664049L;\nprivate ReadOnlyWorld w;\nprivate FreerailsPrincipal principal;\nprivate int trainNumber = -1;\nprivate FreerailsSerializable lastTrain, lastCargoBundle;\npublic TrainDescriptionJPanel() {\ninitComponents();\n}\n@Override\nprotected void paintComponent(Graphics arg0) {\n//Check whether the train or its cargo have changed since the last call to this method.\nupdateIfNecessary();\nsuper.paintComponent(arg0);\n}\nprivate void updateIfNecessary() {\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\ntrainNumber);\nfor (int i = 0; i < train.getNumberOfWagons(); i++) {\n// this.sideOnTrainViewJPanel1.addWagon(train.getWagon(i));\n}\nint cargoBundleID = train.getCargoBundleID();\nFreerailsSerializable cb = w.get(\nprincipal, KEY.CARGO_BUNDLES, cargoBundleID);\nif(train != lastTrain || cb != lastCargoBundle)\ndisplayTrain(trainNumber);\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njLabel1 = new javax.swing.JLabel();\ntrainViewJPanel1 = new jfreerails.client.view.TrainListCellRenderer();\nsetLayout(new java.awt.GridBagLayout());\nsetBorder(new javax.swing.border.TitledBorder(\"Current Details\"));\nsetPreferredSize(new java.awt.Dimension(250, 97));\njLabel1.setFont(new java.awt.Font(\"Dialog\", 0, 12));\njLabel1\n.setText(\"<html><head></head><body>Trains X: 20 passengers, 15 tons of mfg goods, 12 sacks of mail, and 7 tons of livestock.</body></html>\");\njLabel1.setMinimumSize(new java.awt.Dimension(250, 17));\njLabel1.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);\njLabel1.setVerticalTextPosition(javax.swing.SwingConstants.TOP);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jLabel1, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\nadd(trainViewJPanel1, gridBagConstraints);\n}// GEN-END:initComponents\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\nthis.trainViewJPanel1.setup(mr, vl, closeAction);\ntrainViewJPanel1.setHeight(30);\ntrainViewJPanel1.setCenterTrain(true);\nthis.w = mr.getWorld();\nprincipal = mr.getPrincipal();\n}\npublic void displayTrain(int newTrainNumber) {\nNonNullElements it = new NonNullElements(KEY.TRAINS, w, principal);\nit.gotoIndex(newTrainNumber);\nthis.trainNumber = newTrainNumber;\ntrainViewJPanel1.display(newTrainNumber);\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\nnewTrainNumber);\nfor (int i = 0; i < train.getNumberOfWagons(); i++) {\n// this.sideOnTrainViewJPanel1.addWagon(train.getWagon(i));\n}\nint cargoBundleID = train.getCargoBundleID();\nImmutableCargoBundle cb = (ImmutableCargoBundle) w.get(\nprincipal, KEY.CARGO_BUNDLES, cargoBundleID);\nString s = \"Train #\" + it.getNaturalNumber() + \": \";\nint numberOfTypesInBundle = 0;\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\nint amount = cb.getAmount(i);\nif (0 != amount) {\nCargoType ct = (CargoType) w.get(SKEY.CARGO_TYPES, i);\nString cargoTypeName = ct.getDisplayName();\nif (0 != numberOfTypesInBundle) {\ns += \"; \";\n}\nnumberOfTypesInBundle++;\ns += cargoTypeName + \" (\" + amount + \")\";\n}\n}\nif (0 == numberOfTypesInBundle) {\ns += \"no cargo\";\n}\ns += \".\";\nthis.jLabel1.setText(s);\nthis.lastCargoBundle = cb;\nthis.lastTrain = train;\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JLabel jLabel1;\nprivate jfreerails.client.view.TrainListCellRenderer trainViewJPanel1;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.CashJLabel","javaDoc":"/**\n* This JLabel shows the amount of cash available.\n*\n* @author Luke\n*\n*/","code":"/**\n* This JLabel shows the amount of cash available.\n*\n* @author Luke\n*\n*/\npublic class CashJLabel extends JLabel implements View {\nprivate static final long serialVersionUID = 3257853181542412341L;\nprivate ReadOnlyWorld w;\nprivate FreerailsPrincipal principal;\npublic CashJLabel() {\nthis.setText(\" \");\n}\npublic void setup(ModelRoot model, RenderersRoot vl,\nAction closeAction) {\nthis.w = model.getWorld();\nprincipal = model.getPrincipal();\n}\n@Override\nprotected void paintComponent(Graphics g) {\nif (null != w) {\nMoney m = w.getCurrentBalance(principal);\nString s = m.toString();\nthis.setText(\"$\" + s);\n}\nsuper.paintComponent(g);\n}\n}"}
{"className":"jfreerails.client.view.StationPlacementCursor","javaDoc":"/**\n* This class implements a cursor which can be used to place a station on the\n* map. Mode of operation:\n* <ol>\n* <li>User selects a station to place, which sets the current cursor to the\n* station placement cursor.\n* <li>User highlights desired build location with the mouse, boundary of the\n* station radius is highlighted. If the station cannot be built, the boundary\n* highlights in red.\n* <li>User places station with the left mouse button.\n* <li>User may cancel placement by using the right mouse button\n* <li>Cursor fires the actionPerformed causing the station to be built.\n* </ol>\n* When the StationBuildAction is no longer enabled, the owner reverts to the\n* regular cursor type. TODO scroll the area when the mouse hovers at the edge\n* of the map.\n*\n* @author rob\n*/","code":"/**\n* This class implements a cursor which can be used to place a station on the\n* map. Mode of operation:\n* <ol>\n* <li>User selects a station to place, which sets the current cursor to the\n* station placement cursor.\n* <li>User highlights desired build location with the mouse, boundary of the\n* station radius is highlighted. If the station cannot be built, the boundary\n* highlights in red.\n* <li>User places station with the left mouse button.\n* <li>User may cancel placement by using the right mouse button\n* <li>Cursor fires the actionPerformed causing the station to be built.\n* </ol>\n* When the StationBuildAction is no longer enabled, the owner reverts to the\n* regular cursor type. TODO scroll the area when the mouse hovers at the edge\n* of the map.\n*\n* @author rob\n*/\npublic class StationPlacementCursor extends MouseInputAdapter {\npublic static void wireUp(ActionRoot actionRoot, StationRadiusRenderer srr,\nMapViewJComponent mapView) {\nStationPlacementCursor spc = new StationPlacementCursor(actionRoot,\nsrr, mapView);\nspc.init();\n}\nprivate final PropertyChangeListener buildActionListener = new PropertyChangeListener() {\npublic void propertyChange(PropertyChangeEvent e) {\nif (e.getPropertyName().equals(\nStationBuildModel.StationBuildAction.STATION_POSITION_KEY)) {\n/* update the renderer pos */\nPoint p = (Point) e.getNewValue();\nstationRadiusRenderer.setPosition(p.x, p.y);\nif (stationBuildModel.canBuildStationHere()) {\nstationRadiusRenderer\n.setBorderColor(StationRadiusRenderer.COLOR_OK);\n} else {\nstationRadiusRenderer\n.setBorderColor(StationRadiusRenderer.COLOR_CANNOT_BUILD);\n}\n} else if (e.getPropertyName().equals(\nStationBuildModel.StationBuildAction.STATION_RADIUS_KEY)) {\nInteger radius = (Integer) e.getNewValue();\nstationRadiusRenderer.setRadius(radius.intValue());\n}\nboolean enabled = stationBuildModel.getStationBuildAction()\n.isEnabled();\nif (buildEnabled != enabled) {\nif (enabled) {\nmapView.addMouseListener(StationPlacementCursor.this);\nmapView.addMouseMotionListener(StationPlacementCursor.this);\nstationRadiusRenderer.show();\n} else {\nstationRadiusRenderer.hide();\nmapView.removeMouseListener(StationPlacementCursor.this);\nmapView\n.removeMouseMotionListener(StationPlacementCursor.this);\n}\nbuildEnabled = enabled;\n}\n}\n};\nprivate boolean buildEnabled;\nprivate final MapViewJComponent mapView;\nprivate final float scale;\nprivate final StationBuildModel stationBuildModel;\nprivate final StationRadiusRenderer stationRadiusRenderer;\nprivate StationPlacementCursor(ActionRoot actionRoot,\nStationRadiusRenderer srr, MapViewJComponent mapView) {\nscale = mapView.getScale();\nthis.mapView = mapView;\nstationBuildModel = actionRoot.getStationBuildModel();\nstationRadiusRenderer = srr;\nbuildEnabled = stationBuildModel.getStationBuildAction().isEnabled();\n}\nprivate void init() {\nif (buildEnabled) {\nmapView.addMouseListener(this);\nmapView.addMouseMotionListener(this);\nstationRadiusRenderer.show();\n} else {\nstationRadiusRenderer.hide();\nmapView.removeMouseListener(this);\nmapView.removeMouseMotionListener(this);\n}\nstationBuildModel.getStationBuildAction().addPropertyChangeListener(\nbuildActionListener);\n}\n@Override\npublic void mouseClicked(MouseEvent e) {\nint button = e.getButton();\nif (button == MouseEvent.BUTTON1) {\n/* attempt to build */\nstationBuildModel.getStationBuildAction().actionPerformed(\nnew ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"\"));\n} else if (button == MouseEvent.BUTTON3) {\n/* cancel the build */\nstationBuildModel.getStationCancelAction().actionPerformed(\nnew ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"\"));\n}\n}\n@Override\npublic void mouseEntered(MouseEvent e) {\nstationRadiusRenderer.show();\n}\n@Override\npublic void mouseExited(MouseEvent e) {\nstationRadiusRenderer.hide();\n}\n@Override\npublic void mouseMoved(MouseEvent e) {\nif (stationBuildModel.isPositionFollowsMouse()) {\nPoint p = e.getPoint();\nPoint mapCoord = new Point((int) (p.x / scale), (int) (p.y / scale));\nstationBuildModel.getStationBuildAction().putValue(\nStationBuildModel.StationBuildAction.STATION_POSITION_KEY,\nmapCoord);\n}\n}\n}"}
{"className":"jfreerails.client.view.LoadGameJPanel","javaDoc":"/**\n*\n* @author Luke\n*/","code":"/**\n*\n* @author Luke\n*/\npublic class LoadGameJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = -6810248272441137826L;\nprivate ImStringList lastFiles;\n/** Creates new form LoadGameJPanel */\npublic LoadGameJPanel() {\ninitComponents();\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\njScrollPane1 = new javax.swing.JScrollPane();\njList1 = new javax.swing.JList();\njLabel1 = new javax.swing.JLabel();\nokButton = new javax.swing.JButton();\ncancelButton = new javax.swing.JButton();\nrefreshButton = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\naddComponentListener(new java.awt.event.ComponentAdapter() {\n@Override\npublic void componentShown(java.awt.event.ComponentEvent evt) {\nformComponentShown(evt);\n}\n});\njList1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\njList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(javax.swing.event.ListSelectionEvent evt) {\njList1ValueChanged(evt);\n}\n});\njScrollPane1.setViewportView(jList1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(jScrollPane1, gridBagConstraints);\njLabel1.setText(\"Please select a game to load.\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridwidth = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(jLabel1, gridBagConstraints);\nokButton.setText(\"OK\");\nokButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nokButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(okButton, gridBagConstraints);\ncancelButton.setText(\"Cancel\");\ncancelButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ncancelButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(cancelButton, gridBagConstraints);\nrefreshButton.setText(\"Refresh\");\nrefreshButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nrefreshButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(refreshButton, gridBagConstraints);\n}// </editor-fold>//GEN-END:initComponents\nprivate void refreshButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_refreshButtonActionPerformed\nMessage2Server refreshGames = new RefreshListOfGamesMessage2Server(2);\nmodelRoot.sendCommand(refreshGames);\n}//GEN-LAST:event_refreshButtonActionPerformed\nprivate void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown\n}//GEN-LAST:event_formComponentShown\nprivate void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed\nif(null != close)\nclose.actionPerformed(evt);\n}//GEN-LAST:event_cancelButtonActionPerformed\nprivate void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed\nString filename = (String)jList1.getSelectedValue();\nMessage2Server message2 = new LoadGameMessage2Server(1,\nfilename);\nmodelRoot.sendCommand(message2);\nif(null != close)\nclose.actionPerformed(evt);\n}//GEN-LAST:event_okButtonActionPerformed\nprivate void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1ValueChanged\nokButton.setEnabled(jList1.getSelectedIndex() != -1);\n}//GEN-LAST:event_jList1ValueChanged\npublic void setup(ModelRoot m, RenderersRoot vl, Action closeAction) {\nthis.close = closeAction;\nmodelRoot = m;\nupdateListOfFiles();\n}\nprivate void updateListOfFiles() {\nImStringList files = (ImStringList) modelRoot.getProperty(Property.SAVED_GAMES_LIST);\nObject[] saves = new Object[files.size()];\nfor (int i = 0; i < files.size(); i++) {\nsaves[i] = files.get(i);\n}\njList1.setListData(saves);\nokButton.setEnabled(jList1.getSelectedIndex() != -1);\nlastFiles = files;\n}\n@Override\nprotected void paintComponent(Graphics g) {\nImStringList files = (ImStringList) modelRoot.getProperty(Property.SAVED_GAMES_LIST);\nif(!lastFiles.equals(files)){\nupdateListOfFiles();\n}\nsuper.paintComponent(g);\n}\nModelRoot modelRoot;\nActionListener close;\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JButton cancelButton;\njavax.swing.JLabel jLabel1;\njavax.swing.JList jList1;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JButton okButton;\njavax.swing.JButton refreshButton;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.TrainScheduleJPanel","javaDoc":"/**\n* This JPanel displays a train's schedule and provides controls that let you\n* edit it.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This JPanel displays a train's schedule and provides controls that let you\n* edit it.\n*\n* @author Luke Lindsay\n*/\npublic class TrainScheduleJPanel extends javax.swing.JPanel implements View,\nWorldListListener {\nprivate static final long serialVersionUID = 3762248626113884214L;\nprivate static final Logger logger = Logger\n.getLogger(TrainScheduleJPanel.class.getName());\nprivate int trainNumber = -1;\nprivate int scheduleID = -1;\nprivate TrainOrdersListModel listModel;\nprivate ModelRoot modelRoot;\nprivate RenderersRoot vl;\npublic TrainScheduleJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ntrainOrderJPanel1 = new jfreerails.client.view.TrainOrderJPanel();\neditOrderJPopupMenu = new javax.swing.JPopupMenu();\ngotoStationJMenuItem = new javax.swing.JMenuItem();\nchangeStation = new javax.swing.JMenuItem();\nremoveStationJMenuItem = new javax.swing.JMenuItem();\njSeparator1 = new javax.swing.JSeparator();\naddWagonJMenu = new javax.swing.JMenu();\nremoveWagonsJMenu = new javax.swing.JMenu();\nremoveLastJMenuItem = new javax.swing.JMenuItem();\nremoveAllJMenuItem = new javax.swing.JMenuItem();\nchangeConsistJMenu = new javax.swing.JMenu();\nnoChangeJMenuItem = new javax.swing.JMenuItem();\nengineOnlyJMenuItem = new javax.swing.JMenuItem();\nautoConsistJMenuItem = new javax.swing.JMenuItem();\nwaitJMenu = new javax.swing.JMenu();\ndontWaitJMenuItem = new javax.swing.JMenuItem();\nwaitUntilFullJMenuItem = new javax.swing.JMenuItem();\njSeparator2 = new javax.swing.JSeparator();\npullUpJMenuItem = new javax.swing.JMenuItem();\npushDownJMenuItem = new javax.swing.JMenuItem();\nselectStationJPanel1 = new jfreerails.client.view.SelectStationJPanel();\nselectStationJPopupMenu = new javax.swing.JPopupMenu();\nthis.selectStationJPopupMenu.add(selectStationJPanel1);\naddStationJButton = new javax.swing.JButton();\npriorityOrdersJButton = new javax.swing.JButton();\njScrollPane1 = new javax.swing.JScrollPane();\norders = new javax.swing.JList();\ngotoStationJMenuItem.setText(\"Goto station\");\ngotoStationJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ngotoStationJMenuItemActionPerformed(evt);\n}\n});\neditOrderJPopupMenu.add(gotoStationJMenuItem);\nchangeStation.setText(\"Change Station\");\nchangeStation.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nchangeStationActionPerformed(evt);\n}\n});\neditOrderJPopupMenu.add(changeStation);\nremoveStationJMenuItem.setText(\"Remove station\");\nremoveStationJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nremoveStationJMenuItemActionPerformed(evt);\n}\n});\neditOrderJPopupMenu.add(removeStationJMenuItem);\neditOrderJPopupMenu.add(jSeparator1);\naddWagonJMenu.setText(\"Add Wagon\");\neditOrderJPopupMenu.add(addWagonJMenu);\nremoveWagonsJMenu.setText(\"Remove wagon(s)\");\nremoveLastJMenuItem.setText(\"Remove last\");\nremoveLastJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nremoveLastJMenuItemActionPerformed(evt);\n}\n});\nremoveWagonsJMenu.add(removeLastJMenuItem);\nremoveAllJMenuItem.setText(\"Remove all wagons\");\nremoveAllJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nremoveAllJMenuItemActionPerformed(evt);\n}\n});\nremoveWagonsJMenu.add(removeAllJMenuItem);\neditOrderJPopupMenu.add(removeWagonsJMenu);\nchangeConsistJMenu.setText(\"Change consist to..\");\nnoChangeJMenuItem.setText(\"'No change'\");\nnoChangeJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nnoChangeJMenuItemActionPerformed(evt);\n}\n});\nchangeConsistJMenu.add(noChangeJMenuItem);\nengineOnlyJMenuItem.setText(\"Engine only\");\nengineOnlyJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nengineOnlyJMenuItemActionPerformed(evt);\n}\n});\nchangeConsistJMenu.add(engineOnlyJMenuItem);\nautoConsistJMenuItem.setText(\"Choose wagons automatically\");\nautoConsistJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nautoConsistJMenuItemActionPerformed(evt);\n}\n});\nchangeConsistJMenu.add(autoConsistJMenuItem);\neditOrderJPopupMenu.add(changeConsistJMenu);\nwaitJMenu.setText(\"Wait at station\");\ndontWaitJMenuItem.setText(\"Don't wait\");\ndontWaitJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndontWaitJMenuItemActionPerformed(evt);\n}\n});\nwaitJMenu.add(dontWaitJMenuItem);\nwaitUntilFullJMenuItem.setText(\"Wait until full\");\nwaitUntilFullJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nwaitUntilFullJMenuItemActionPerformed(evt);\n}\n});\nwaitJMenu.add(waitUntilFullJMenuItem);\neditOrderJPopupMenu.add(waitJMenu);\neditOrderJPopupMenu.add(jSeparator2);\npullUpJMenuItem.setText(\"Pull up\");\npullUpJMenuItem.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\npullUpJMenuItemActionPerformed(evt);\n}\n});\neditOrderJPopupMenu.add(pullUpJMenuItem);\npushDownJMenuItem.setText(\"Push down\");\npushDownJMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\npushDownJMenuItemActionPerformed(evt);\n}\n});\neditOrderJPopupMenu.add(pushDownJMenuItem);\nsetLayout(new java.awt.GridBagLayout());\nsetBorder(new javax.swing.border.TitledBorder(\"Schedule\"));\naddStationJButton.setText(\"Add Station\");\naddStationJButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\naddStationJButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(addStationJButton, gridBagConstraints);\npriorityOrdersJButton.setText(\"Add Priority Orders\");\npriorityOrdersJButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\npriorityOrdersJButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(priorityOrdersJButton, gridBagConstraints);\njScrollPane1.setPreferredSize(new java.awt.Dimension(280, 160));\norders\n.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\norders.setCellRenderer(trainOrderJPanel1);\norders.addKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nordersKeyPressed(evt);\n}\n});\norders.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent evt) {\nordersMouseClicked(evt);\n}\n});\njScrollPane1.setViewportView(orders);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);\nadd(jScrollPane1, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void ordersKeyPressed(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_ordersKeyPressed\nswitch (evt.getKeyCode()) {\ncase KeyEvent.VK_O: {\n// Add priority orders\npriorityOrdersJButtonActionPerformed(null);\nbreak;\n}\ncase KeyEvent.VK_N: {\n// Add station\naddStationJButtonActionPerformed(null);\nbreak;\n}\ndefault: {\n// do nothing.\n}\n}\nint orderNumber = this.orders.getSelectedIndex();\nif (orderNumber == -1) {\n// No order is selected.\nreturn;\n}\nswitch (evt.getKeyCode()) {\ncase KeyEvent.VK_G: {\n// Goto station.\ngotoStationJMenuItemActionPerformed(null);\nbreak;\n}\ncase KeyEvent.VK_S: {\n// Change station\nshowSelectStation(this.getSchedule(), orderNumber);\nbreak;\n}\ncase KeyEvent.VK_A: {\n// Auto schedule\nsetAutoConsist();\nbreak;\n}\ncase KeyEvent.VK_C: {\n// Change add wagon\nbreak;\n}\ncase KeyEvent.VK_DELETE: {\n// Remove station\nremoveStationJMenuItemActionPerformed(null);\nbreak;\n}\ncase KeyEvent.VK_BACK_SPACE: {\n// Remove last wagon\nremoveLastWagon();\nbreak;\n}\ncase KeyEvent.VK_W: {\n// toggle wait until full\nMutableSchedule s = getSchedule();\nTrainOrdersModel order = s.getOrder(orderNumber);\nsetWaitUntilFull(!order.waitUntilFull);\nbreak;\n}\ndefault: {\n// do nothing.\n}\n}\nlistModel.fireRefresh();\n}// GEN-LAST:event_ordersKeyPressed\nprivate void autoConsistJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_autoConsistJMenuItemActionPerformed\nsetAutoConsist();\n}// GEN-LAST:event_autoConsistJMenuItemActionPerformed\nprivate void changeStationActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_changeStationActionPerformed\nint orderNumber = this.orders.getSelectedIndex();\nshowSelectStation(this.getSchedule(), orderNumber);\n}// GEN-LAST:event_changeStationActionPerformed\nprivate void removeAllJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_removeAllJMenuItemActionPerformed\nremoveAllWagons();\n}// GEN-LAST:event_removeAllJMenuItemActionPerformed\nprivate void removeLastJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_removeLastJMenuItemActionPerformed\nremoveLastWagon();\n}// GEN-LAST:event_removeLastJMenuItemActionPerformed\nprivate void waitUntilFullJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_waitUntilFullJMenuItemActionPerformed\nsetWaitUntilFull(true);\n}// GEN-LAST:event_waitUntilFullJMenuItemActionPerformed\nprivate void dontWaitJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_dontWaitJMenuItemActionPerformed\nsetWaitUntilFull(false);\n}// GEN-LAST:event_dontWaitJMenuItemActionPerformed\nprivate void engineOnlyJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_engineOnlyJMenuItemActionPerformed\nremoveAllWagons();\n}// GEN-LAST:event_engineOnlyJMenuItemActionPerformed\nprivate void noChangeJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_noChangeJMenuItemActionPerformed\nnoChange();\n}// GEN-LAST:event_noChangeJMenuItemActionPerformed\nprivate void priorityOrdersJButtonActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_priorityOrdersJButtonActionPerformed\nMutableSchedule s = getSchedule();\ntry {\ns.setPriorityOrders(new TrainOrdersModel(getFirstStationID(), null,\nfalse, false));// TODO fix bug\nshowSelectStation(s, Schedule.PRIORITY_ORDERS);\n} catch (NoSuchElementException e) {\nlogger\n.warning(\"No stations exist so can't add station to schedule!\");\n}\n}// GEN-LAST:event_priorityOrdersJButtonActionPerformed\nprivate void addStationJButtonActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_addStationJButtonActionPerformed\nMutableSchedule s = getSchedule();\ntry {\nint newOrderNumber = s.addOrder(new TrainOrdersModel(\ngetFirstStationID(), null, false, false)); // TODO fix bug\nshowSelectStation(s, newOrderNumber);\n} catch (NoSuchElementException e) {\nlogger\n.warning(\"No stations exist so can't add station to schedule!\");\n}\n}// GEN-LAST:event_addStationJButtonActionPerformed\nprivate void removeStationJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_removeStationJMenuItemActionPerformed\nMutableSchedule s = getSchedule();\nif(s.getNumOrders() ==0){\nlogger.warning(\"Can't remove orders since non exist!\");\nreturn;\n}\nint i = orders.getSelectedIndex();\nif(s.getNumOrders() <= i){\nlogger.warning(\"Order #\"+String.valueOf(i)+\" does not exist!\");\nreturn;\n}\ns.removeOrder(i);\nsendUpdateMove(s);\n}// GEN-LAST:event_removeStationJMenuItemActionPerformed\nprivate void gotoStationJMenuItemActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_gotoStationJMenuItemActionPerformed\nMutableSchedule s = getSchedule();\nint i = orders.getSelectedIndex();\ns.setOrderToGoto(i);\nsendUpdateMove(s);\n}// GEN-LAST:event_gotoStationJMenuItemActionPerformed\nprivate void pushDownJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_pushDownJMenuItemActionPerformed\nMutableSchedule s = getSchedule();\nint i = orders.getSelectedIndex();\ns.pushDown(i);\nsendUpdateMove(s);\norders.setSelectedIndex(i + 1);\n}// GEN-LAST:event_pushDownJMenuItemActionPerformed\nprivate void ordersMouseClicked(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_ordersMouseClicked\nint i = orders.getSelectedIndex();\nMutableSchedule s = getSchedule();\nif (i >= s.getNumOrders()) {\n// The selected index does not exist!\n// For some reason, the JList hasn't updated yet.\ni = -1;\n}\nif (-1 != i && java.awt.event.MouseEvent.BUTTON3 == evt.getButton()) {\n// If an element is select and the right button is pressed.\nTrainOrdersModel order = s.getOrder(i);\npullUpJMenuItem.setEnabled(s.canPullUp(i));\npushDownJMenuItem.setEnabled(s.canPushDown(i));\ngotoStationJMenuItem.setEnabled(s.canSetGotoStation(i));\nremoveWagonsJMenu.setEnabled(order.orderHasWagons());\nwaitJMenu.setEnabled(order.orderHasWagons());\naddWagonJMenu.setEnabled(order.hasLessThanMaximumNumberOfWagons());\nsetupWagonsPopup();\nthis.editOrderJPopupMenu.show(evt.getComponent(), evt.getX(), evt\n.getY());\n}\n}// GEN-LAST:event_ordersMouseClicked\nprivate void pullUpJMenuItemActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_pullUpJMenuItemActionPerformed\nMutableSchedule s = getSchedule();\nint i = orders.getSelectedIndex();\ns.pullUp(i);\nsendUpdateMove(s);\norders.setSelectedIndex(i - 1);\n}// GEN-LAST:event_pullUpJMenuItemActionPerformed\npublic void setup(ModelRoot mr, RenderersRoot vl, Action al) {\ntrainOrderJPanel1.setup(mr, vl, null);\nthis.modelRoot = mr;\nthis.vl = vl;\n// This actionListener is fired by the select station popup when a\n// station is selected.\nAction action = new AbstractAction() {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent evt) {\nsendUpdateMove(selectStationJPanel1.generateNewSchedule());\nselectStationJPopupMenu.setVisible(false);\nlistModel.fireRefresh();\norders.requestFocus();\n}\n};\nthis.selectStationJPanel1.setup(mr, vl, action);\n}\npublic void display(int newTrainNumber) {\nthis.trainNumber = newTrainNumber;\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nReadOnlyWorld w = modelRoot.getWorld();\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\nnewTrainNumber);\nthis.scheduleID = train.getScheduleID();\nlistModel = new TrainOrdersListModel(w, newTrainNumber, principal);\norders.setModel(listModel);\norders.setFixedCellWidth(250);\nlistModel.fireRefresh();\nenableButtons();\n}\nprivate void enableButtons() {\nMutableSchedule s = getSchedule();\naddStationJButton.setEnabled(s.canAddOrder());\n// Only one set of priority orders are allowed.\npriorityOrdersJButton.setEnabled(!s.hasPriorityOrders());\n}\nprivate MutableSchedule getSchedule() {\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nReadOnlyWorld w = modelRoot.getWorld();\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\ntrainNumber);\nImmutableSchedule immutableSchedule = (ImmutableSchedule) w.get(\nprincipal, KEY.TRAIN_SCHEDULES, train.getScheduleID());\nreturn new MutableSchedule(immutableSchedule);\n}\n/**\n* Since stations can be removed, we should not assume that station 0\n* exists: this method returns the id of the first station that exists.\n*\n*/\nprivate int getFirstStationID() {\nNonNullElements stations = new NonNullElements(KEY.STATIONS, modelRoot\n.getWorld(), modelRoot.getPrincipal());\nif (stations.next()) {\nreturn stations.getIndex();\n}\nthrow new NoSuchElementException();\n}\nprivate void setupWagonsPopup() {\naddWagonJMenu.removeAll(); // Remove existing menu items.\nNonNullElements cargoTypes = new NonNullElements(SKEY.CARGO_TYPES,\nmodelRoot.getWorld());\nwhile (cargoTypes.next()) {\nfinal CargoType wagonType = (CargoType) cargoTypes.getElement();\nJMenuItem wagonMenuItem = new JMenuItem();\nfinal int wagonTypeNumber = cargoTypes.getIndex();\nwagonMenuItem.setText(wagonType.getDisplayName());\nImage image = vl.getWagonImages(wagonTypeNumber).getSideOnImage();\nint height = image.getHeight(null);\nint width = image.getWidth(null);\nint scale = height / 10;\nImageIcon icon = new ImageIcon(image.getScaledInstance(width\n/ scale, height / scale, Image.SCALE_FAST));\nwagonMenuItem.setIcon(icon);\nwagonMenuItem\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(\njava.awt.event.ActionEvent evt) {\naddWagon(wagonTypeNumber);\n}\n});\naddWagonJMenu.add(wagonMenuItem);\n}\n}\nprivate void noChange() {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(), null, false,\nfalse);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void setWaitUntilFull(boolean b) {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\n// If auto-consist is set do nothing\nif (oldOrders.autoConsist)\nreturn;\n// If no-change is set do nothing\nif (oldOrders.consist == null)\nreturn;\nboolean autoConsist = false;\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(),\noldOrders.consist, b, autoConsist);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void setAutoConsist() {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(), null, false,\ntrue);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void addWagon(int wagonTypeNumber) {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\nint[] newConsist;\n// The consist will be null if old orders were 'no change'.\nif (null != oldOrders.consist) {\nint oldLength = oldOrders.consist.size();\nnewConsist = new int[oldLength + 1];\n// Copy existing wagons\nfor (int i = 0; i < oldLength; i++) {\nnewConsist[i] = oldOrders.consist.get(i);\n}\n// Then add specified wagon.\nnewConsist[oldLength] = wagonTypeNumber;\n} else {\nnewConsist = new int[] { wagonTypeNumber };\n}\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(), new ImInts(\nnewConsist), oldOrders.getWaitUntilFull(), false);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void removeAllWagons() {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(),\nnew ImInts(), false, false);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void removeLastWagon() {\nTrainOrdersModel oldOrders, newOrders;\nMutableSchedule s = getSchedule();\nint orderNumber = this.orders.getSelectedIndex();\noldOrders = s.getOrder(orderNumber);\nImInts oldConsist = oldOrders.consist;\nif( null == oldConsist){\n//consist can be null if there is no\n//scheduled change of wagons.\n//Fixes freerails bug 1687677 and freerails2 bug 2014234\nreturn;\n}\nint newLength = oldConsist.size() - 1;\nif (newLength < 0) {\n//No wagons to remove!\nreturn;\n}\nImInts newConsist = oldConsist.removeLast();\nnewOrders = new TrainOrdersModel(oldOrders.getStationID(), newConsist,\noldOrders.waitUntilFull, false);\ns.setOrder(orderNumber, newOrders);\nsendUpdateMove(s);\n}\nprivate void sendUpdateMove(MutableSchedule mutableSchedule) {\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nReadOnlyWorld w = modelRoot.getWorld();\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS,\nthis.trainNumber);\n// int scheduleID = train.getScheduleID();\nassert (scheduleID == train.getScheduleID());\nImmutableSchedule before = (ImmutableSchedule) w.get(\nprincipal, KEY.TRAIN_SCHEDULES, scheduleID);\nImmutableSchedule after = mutableSchedule.toImmutableSchedule();\nMove m = new ChangeTrainScheduleMove(scheduleID, before, after,\nprincipal);\nthis.modelRoot.doMove(m);\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal p) {\nif (KEY.TRAIN_SCHEDULES == key && this.scheduleID == index) {\nlistModel.fireRefresh();\nenableButtons();\n}\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal p) {\n// do nothing.\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal p) {\n// do nothing.\n}\n/**\n* Show the popup that lets the user select a station, called when a new\n* scheduled stop is added and when an existing scheduled stop is changed.\n*/\nprivate void showSelectStation(MutableSchedule schedule, int orderNumber) {\nselectStationJPanel1.display(schedule, orderNumber);\n// Show the select station popup in the middle of the window.\nContainer topLevelAncestor = this.getTopLevelAncestor();\nDimension d = topLevelAncestor.getSize();\nDimension d2 = selectStationJPopupMenu.getPreferredSize();\nint x = Math.max((d.width - d2.width) / 2, 0);\nint y = Math.max((d.height - d2.height) / 2, 0);\nselectStationJPopupMenu.show(topLevelAncestor, x, y);\nselectStationJPanel1.requestFocus();\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JButton addStationJButton;\njavax.swing.JMenu addWagonJMenu;\njavax.swing.JMenuItem autoConsistJMenuItem;\njavax.swing.JMenu changeConsistJMenu;\njavax.swing.JMenuItem changeStation;\njavax.swing.JMenuItem dontWaitJMenuItem;\njavax.swing.JPopupMenu editOrderJPopupMenu;\njavax.swing.JMenuItem engineOnlyJMenuItem;\njavax.swing.JMenuItem gotoStationJMenuItem;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JSeparator jSeparator1;\njavax.swing.JSeparator jSeparator2;\njavax.swing.JMenuItem noChangeJMenuItem;\njavax.swing.JList orders;\njavax.swing.JButton priorityOrdersJButton;\njavax.swing.JMenuItem pullUpJMenuItem;\njavax.swing.JMenuItem pushDownJMenuItem;\njavax.swing.JMenuItem removeAllJMenuItem;\njavax.swing.JMenuItem removeLastJMenuItem;\njavax.swing.JMenuItem removeStationJMenuItem;\njavax.swing.JMenu removeWagonsJMenu;\njfreerails.client.view.SelectStationJPanel selectStationJPanel1;\njavax.swing.JPopupMenu selectStationJPopupMenu;\njfreerails.client.view.TrainOrderJPanel trainOrderJPanel1;\njavax.swing.JMenu waitJMenu;\njavax.swing.JMenuItem waitUntilFullJMenuItem;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.View","javaDoc":"/**\n* Defines a standard method to initiate GUI components that need access to the\n* ModelRoot.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a standard method to initiate GUI components that need access to the\n* ModelRoot.\n*\n* @author Luke\n*\n*/\npublic interface View {\nvoid setup(ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction);\n}"}
{"className":"jfreerails.client.view.MainMapAndOverviewMapMediator","javaDoc":"/**\n* This class mediates between the main map view and the overview map view. It\n* does the following:<br>\n* (1) Updates the rectangle on the overview map when the visible rectangle of\n* the main map changes.<br>\n* (2) Updates the main map visible rectangle when the user clicks on the\n* overview map.<br>\n* (3) Updates the main map visible rectangle when the user drags the rectangle\n* on the overview map.<br>\n* (4) Changes the mouse cursor to indicate that the rectangle on the overview\n* map is draggable when the mouse moves into the rectangle.\n*\n* @author Luke Lindsay\n* @version 1.0\n*/","code":"/**\n* This class mediates between the main map view and the overview map view. It\n* does the following:<br>\n* (1) Updates the rectangle on the overview map when the visible rectangle of\n* the main map changes.<br>\n* (2) Updates the main map visible rectangle when the user clicks on the\n* overview map.<br>\n* (3) Updates the main map visible rectangle when the user drags the rectangle\n* on the overview map.<br>\n* (4) Changes the mouse cursor to indicate that the rectangle on the overview\n* map is draggable when the mouse moves into the rectangle.\n*\n* @author Luke Lindsay\n* @version 1.0\n*/\npublic class MainMapAndOverviewMapMediator extends MouseInputAdapter {\nprivate JComponent overviewMapJPanel;\nprivate JViewport viewport;\nprivate JComponent mainMap;\nprivate Rectangle currentVisRect;\nprivate Point lastMouseLocation = new Point();\nprivate boolean inside = false;\nprivate boolean draggingAndStartedInside = false;\npublic MainMapAndOverviewMapMediator() {\n}\npublic MainMapAndOverviewMapMediator(JComponent omv, JViewport v,\nJComponent mm, Rectangle rect) {\nsetup(omv, v, mm, rect);\n}\npublic void setup(JComponent omv, JViewport v, JComponent mm, Rectangle rect) {\ncurrentVisRect = rect;\noverviewMapJPanel = omv;\nviewport = v;\nmainMap = mm;\noverviewMapJPanel.addMouseMotionListener(this);\noverviewMapJPanel.addMouseListener(this);\nviewport.addChangeListener(new javax.swing.event.ChangeListener() {\npublic void stateChanged(ChangeEvent e) {\nupdateObservedRect();\n}\n});\noverviewMapJPanel\n.addComponentListener(new java.awt.event.ComponentAdapter() {\n@Override\npublic void componentResized(\njava.awt.event.ComponentEvent evt) {\nupdateObservedRect();\n}\n@Override\npublic void componentShown(java.awt.event.ComponentEvent evt) {\nupdateObservedRect();\n}\n});\n}\n@Override\npublic void mouseMoved(MouseEvent evt) {\nlastMouseLocation.x = evt.getX();\nlastMouseLocation.y = evt.getY();\nupdateInside(evt);\n}\n@Override\npublic void mousePressed(MouseEvent evt) {\nif (inside) {\ndraggingAndStartedInside = true;\n}\n}\n@Override\npublic void mouseReleased(MouseEvent evt) {\ndraggingAndStartedInside = false;\n}\n@Override\npublic void mouseDragged(MouseEvent evt) {\nif (draggingAndStartedInside) {\n/*\n* Rectangle r= overviewMapJPanel.mainMapVisibleRect;\n* r.x+=evt.getX()-lastMouseLocation.x;\n* r.y+=evt.getY()-lastMouseLocation.y;\n* lastMouseLocation.x=evt.getX(); lastMouseLocation.y=evt.getY();\n*\n* updateInside(evt); overviewMapJPanel.repaint();\n*/\nint deltaX = evt.getX() - lastMouseLocation.x;\nint deltaY = evt.getY() - lastMouseLocation.y;\nlastMouseLocation.x = evt.getX();\nlastMouseLocation.y = evt.getY();\n// float overviewScale=overviewMapJPanel.getScale();\n// float mainMapScale=mainMap.getScale();\nint overviewScale = overviewMapJPanel.getPreferredSize().width;\nint mainMapScale = mainMap.getWidth();\nint scaledDeltaX = (deltaX * mainMapScale / overviewScale);\nint scaledDeltaY = (deltaY * mainMapScale / overviewScale);\nRectangle r = mainMap.getVisibleRect();\nr.x += scaledDeltaX;\nr.y += scaledDeltaY;\nmainMap.scrollRectToVisible(r);\nupdateInside(evt);\n}\n}\n@Override\npublic void mouseClicked(MouseEvent evt) {\n/*\n* Rectangle r= overviewMapJPanel.mainMapVisibleRect;\n* r.x=evt.getX()-r.width/2; r.y=evt.getY()-r.width/2;\n*/\n// float overviewScale=overviewMapJPanel.getScale();\n// float mainMapScale=mainMap.getScale();\nint overviewScale = overviewMapJPanel.getPreferredSize().width;\nint mainMapScale = mainMap.getWidth();\nint x = (evt.getX() * mainMapScale / overviewScale);\nint y = (evt.getY() * mainMapScale / overviewScale);\nRectangle r = mainMap.getVisibleRect();\nr.x = x - r.width / 2;\nr.y = y - r.height / 2;\nmainMap.scrollRectToVisible(r);\nupdateInside(evt);\n}\nprivate void updateInside(MouseEvent evt) {\n// Rectangle r= overviewMapJPanel.mainMapVisibleRect;\nboolean b = currentVisRect.contains(evt.getX(), evt.getY());\nif (b != inside) {\ninside = b;\nif (inside) {\noverviewMapJPanel.setCursor(new Cursor(Cursor.MOVE_CURSOR));\n} else {\noverviewMapJPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n}\n}\n}\nprivate void updateObservedRect() {\nRectangle r = mainMap.getVisibleRect();\n// if (!r.equals(this.currentVisRect)) {\n// float overviewScale=overviewMapJPanel.getScale();\n// float mainMapScale=mainMap.getScale();\nint overviewScale = overviewMapJPanel.getPreferredSize().width;\nint mainMapScale = mainMap.getWidth();\nif (0 != (overviewScale * mainMapScale)) {\n// avoid division by zero.\ncurrentVisRect.x = (r.x * overviewScale / mainMapScale);\ncurrentVisRect.y = (r.y * overviewScale / mainMapScale);\ncurrentVisRect.width = (r.width * overviewScale / mainMapScale);\ncurrentVisRect.height = (r.height * overviewScale / mainMapScale);\noverviewMapJPanel.repaint();\n}\n// }\n}\n}"}
{"className":"jfreerails.client.view.IncomeStatementHtmlJPanel","javaDoc":"/**\n* A HtmlJPanel that displays the income statement.\n*\n* @author Luke\n*\n*/","code":"/**\n* A HtmlJPanel that displays the income statement.\n*\n* @author Luke\n*\n*/\npublic class IncomeStatementHtmlJPanel extends HtmlJPanel implements View {\nprivate static final long serialVersionUID = 3257846588885120057L;\nprivate String template;\nprivate int lastNumTransactions = 0;\nprivate ModelRoot modelRoot;\npublic IncomeStatementHtmlJPanel() {\nsuper();\nURL url = IncomeStatementHtmlJPanel.class\n.getResource(\"/jfreerails/client/view/income_statement.htm\");\ntemplate = loadText(url);\n}\n@Override\npublic void setup(ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nsuper.setup(modelRoot, vl, closeAction);\nthis.modelRoot = modelRoot;\nupdateHtml();\n}\nprivate void updateHtml() {\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal playerPrincipal = modelRoot.getPrincipal();\nIncomeStatementGenerator balanceSheetGenerator = new IncomeStatementGenerator(\nworld, playerPrincipal);\nString populatedTemplate = populateTokens(template,\nbalanceSheetGenerator);\nsetHtml(populatedTemplate);\n}\n@Override\nprotected void paintComponent(Graphics g) {\n/* Check to see if the text needs updating before painting. */\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal playerPrincipal = modelRoot.getPrincipal();\nint currentNumberOfTransactions = world\n.getNumberOfTransactions(playerPrincipal);\nif (currentNumberOfTransactions != lastNumTransactions) {\nupdateHtml();\n}\nsuper.paintComponent(g);\n}\n}"}
{"className":"jfreerails.client.view.TrainDialogueJPanel","javaDoc":"/**\n* JPanel that displays info on a train; it is composed of a\n* {@link TrainScheduleJPanel} and {@link TrainDescriptionJPanel}.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* JPanel that displays info on a train; it is composed of a\n* {@link TrainScheduleJPanel} and {@link TrainDescriptionJPanel}.\n*\n* @author Luke Lindsay\n*/\npublic class TrainDialogueJPanel extends javax.swing.JPanel implements View,\nWorldListListener {\nprivate static final long serialVersionUID = 3257005466801157938L;\nprivate static final Logger logger = Logger\n.getLogger(TrainDialogueJPanel.class.getName());\nprivate WorldIterator wi;\nprivate ReadOnlyWorld w;\nprivate FreerailsPrincipal principal;\npublic TrainDialogueJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nnewTrainScheduleJPanel1 = new jfreerails.client.view.TrainScheduleJPanel();\ntrainDetailsJPanel1 = new TrainDescriptionJPanel();\npreviousJButton = new javax.swing.JButton();\nnextJButton = new javax.swing.JButton();\ntrainListJButton = new javax.swing.JButton();\ncloseJButton = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(510, 400));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(newTrainScheduleJPanel1, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridwidth = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\nadd(trainDetailsJPanel1, gridBagConstraints);\npreviousJButton.setText(\"last\");\npreviousJButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\npreviousJButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\nadd(previousJButton, gridBagConstraints);\nnextJButton.setText(\"next\");\nnextJButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nnextJButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\nadd(nextJButton, gridBagConstraints);\ntrainListJButton.setText(\"Train list\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\nadd(trainListJButton, gridBagConstraints);\ncloseJButton.setText(\"Close\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 3;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\nadd(closeJButton, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void previousJButtonActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_previousJButtonActionPerformed\n// Add your handling code here:\nif (wi.previous()) {\ndisplay(wi.getIndex());\n} else {\nlogger.warning(\"Couldn't get previous\");\n}\n}// GEN-LAST:event_previousJButtonActionPerformed\nprivate void nextJButtonActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_nextJButtonActionPerformed\n// Add your handling code here:\nif (wi.next()) {\ndisplay(wi.getIndex());\n} else {\nlogger.warning(\"Couldn't get next\");\n}\n}// GEN-LAST:event_nextJButtonActionPerformed\npublic void setup(ModelRoot mr, RenderersRoot vl, Action al) {\nnewTrainScheduleJPanel1.setup(mr, vl, al);\ntrainDetailsJPanel1.setup(mr, vl, al);\nthis.setCancelButtonActionListener(al);\nthis.principal = mr.getPrincipal();\nthis.w = mr.getWorld();\n}\npublic void display(int trainNumber) {\nwi = new NonNullElements(KEY.TRAINS, w, principal);\nwi.gotoIndex(trainNumber);\nif (wi.getRowID() > 0) {\nthis.previousJButton.setEnabled(true);\n} else {\nthis.previousJButton.setEnabled(false);\n}\nif (wi.getRowID() < (wi.size() - 1)) {\nthis.nextJButton.setEnabled(true);\n} else {\nthis.nextJButton.setEnabled(false);\n}\nnewTrainScheduleJPanel1.display(trainNumber);\ntrainDetailsJPanel1.displayTrain(trainNumber);\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal p) {\nnewTrainScheduleJPanel1.listUpdated(key, index, p);\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal p) {\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal p) {\n}\nvoid setTrainDetailsButtonActionListener(ActionListener l) {\nActionListener[] oldListeners = trainListJButton.getActionListeners();\nfor (int i = 0; i < oldListeners.length; i++) {\ntrainListJButton.removeActionListener(oldListeners[i]);\n}\nthis.trainListJButton.addActionListener(l);\n}\n/**\n* Removes any existing ActionListener listeners from the cancel button,\n* then adds the specified one.\n*/\nvoid setCancelButtonActionListener(ActionListener l) {\nActionListener[] oldListeners = closeJButton.getActionListeners();\nfor (int i = 0; i < oldListeners.length; i++) {\ncloseJButton.removeActionListener(oldListeners[i]);\n}\nthis.closeJButton.addActionListener(l);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JButton closeJButton;\njfreerails.client.view.TrainScheduleJPanel newTrainScheduleJPanel1;\njavax.swing.JButton nextJButton;\njavax.swing.JButton previousJButton;\njfreerails.client.view.TrainDescriptionJPanel trainDetailsJPanel1;\njavax.swing.JButton trainListJButton;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.OverHeadTrainView","javaDoc":"/**\n* Draws the trains on the main map.\n*\n* @author Luke\n*/","code":"/**\n* Draws the trains on the main map.\n*\n* @author Luke\n*/\npublic class OverHeadTrainView implements Painter {\nprivate final TrainRenderer trainRenderer;\nprivate final ReadOnlyWorld w;\nprivate SoundManager soundManager = SoundManager.getSoundManager();\nprivate ModelRoot mr;\npublic OverHeadTrainView(ReadOnlyWorld world, RenderersRoot rr, ModelRoot mr) {\nthis.w = world;\ntrainRenderer = new TrainRenderer(rr);\nthis.mr = mr;\n}\npublic TrainRenderer getTrainRenderer() {\nreturn trainRenderer;\n}\npublic void paint(Graphics2D g) {\ng.setColor(Color.BLUE);\ng.setStroke(new BasicStroke(10));\nDouble time = (Double)mr.getProperty(Property.TIME);\nfor (int k = 0; k < w.getNumberOfPlayers(); k++) {\nFreerailsPrincipal principal = w.getPlayer(k).getPrincipal();\nint selectedTrain = -1;\nif (mr.getPrincipal().getWorldIndex() == principal.getWorldIndex()) {\n//These are our trains...\nObject property = mr.getProperty(Property.SELECTED_TRAIN);\nif (null != property) {\nselectedTrain = (Integer) property;\n}\n}\nfor (int i = 0; i < w.size(principal, KEY.TRAINS); i++) {\nTrainModel train = (TrainModel) w.get(principal, KEY.TRAINS, i);\n// TrainPositionOnMap pos = (TrainPositionOnMap) w.get(\n// principal, KEY.TRAIN_POSITIONS, i);\nTrainAccessor ta = new TrainAccessor(w, principal, i);\nTrainPositionOnMap pos = ta.findPosition(time);\nif (pos.isCrashSite()\n&& (pos.getFrameCt() <= TrainPositionOnMap.CRASH_FRAMES_COUNT)) {\ntrainRenderer.paintTrainCrash(g, pos);\nif (pos.getFrameCt() == 1) {\ntry {\nsoundManager.playSound(\n\"/jfreerails/client/sounds/traincrash.wav\",\n1);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n} else {\nTrainImages.Highlight highlight = i == selectedTrain ? TrainImages.Highlight.SELECTED: null;\ntrainRenderer.paintTrain(g, train, pos, highlight);\n}\n}\n}\n}\n}"}
{"className":"jfreerails.client.view.TrainOrderJPanel","javaDoc":"/**\n* ListCellRenderer that displays a train order.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* ListCellRenderer that displays a train order.\n*\n* @author Luke Lindsay\n*/\npublic class TrainOrderJPanel extends javax.swing.JPanel implements View,\nListCellRenderer {\nprivate static final long serialVersionUID = 4051047466990319413L;\nprivate jfreerails.world.top.ReadOnlyWorld w;\nprivate FreerailsPrincipal principal;\nprivate final ImageIcon gotoNow = new ImageIcon(TrainOrderJPanel.class\n.getResource(\"/jfreerails/client/graphics/selected_arrow.png\"));\nprivate final ImageIcon gotoAfterPriorityOrders = new ImageIcon(\nTrainOrderJPanel.class\n.getResource(\"/jfreerails/client/graphics/deselected_arrow.png\"));\nprivate final ImageIcon dontGoto = null;\nprivate final Color backgroundColor = (java.awt.Color) javax.swing.UIManager\n.getDefaults().get(\"List.background\");\nprivate final Color selectedColor = (java.awt.Color) javax.swing.UIManager\n.getDefaults().get(\"List.selectionBackground\");\nprivate final Color selectedColorNotFocused = Color.LIGHT_GRAY;\npublic TrainOrderJPanel() {\ninitComponents();\nthis.setBackground(backgroundColor);\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ngotoIcon = new javax.swing.JLabel();\nconsistChangeJPanel = new TrainListCellRenderer();\nnoChangeJLabel = new javax.swing.JLabel();\nstationNameJLabel = new javax.swing.JLabel();\nordersJLabel = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\ngotoIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource(\n\"/jfreerails/client/graphics/selected_arrow.png\")));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridheight = 2;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\nadd(gotoIcon, gridBagConstraints);\nconsistChangeJPanel.setLayout(new java.awt.GridBagLayout());\nnoChangeJLabel.setText(\"No Change\");\nconsistChangeJPanel.add(noChangeJLabel,\nnew java.awt.GridBagConstraints());\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.weightx = 1.0;\nadd(consistChangeJPanel, gridBagConstraints);\nstationNameJLabel.setText(\"Some Station\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 5);\nadd(stationNameJLabel, gridBagConstraints);\nordersJLabel.setText(\"wait until full / don't wait\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.ipadx = 6;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\ngridBagConstraints.insets = new java.awt.Insets(0, 6, 0, 5);\nadd(ordersJLabel, gridBagConstraints);\n}// GEN-END:initComponents\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\nthis.w = mr.getWorld();\nTrainListCellRenderer trainViewJPanel = (TrainListCellRenderer) consistChangeJPanel;\ntrainViewJPanel.setHeight(15);\ntrainViewJPanel.setup(mr, vl, null);\nthis.principal = mr.getPrincipal();\n}\npublic java.awt.Component getListCellRendererComponent(JList list,\nObject value, int index, boolean isSelected, boolean cellHasFocus) {\nTrainOrdersListModel.TrainOrdersListElement trainOrders = (TrainOrdersListModel.TrainOrdersListElement) value;\n// Set station name\nint stationNumber = trainOrders.order.stationId;\nStationModel station = (StationModel) w.get(principal,\nKEY.STATIONS, stationNumber);\nString stationName = station.getStationName();\nthis.stationNameJLabel.setText(stationName);\n// Set wait until full\nString waitUntilFull = trainOrders.order.waitUntilFull ? \"Wait until full\"\n: \"\";\nthis.ordersJLabel.setText(waitUntilFull);\n// Set selected\nif (isSelected) {\nif (list.isFocusOwner()) {\nsetBackground(selectedColor);\n} else {\nsetBackground(selectedColorNotFocused);\n}\n} else {\nsetBackground(backgroundColor);\n}\n// Set goto status.\nswitch (trainOrders.gotoStatus) {\ncase TrainOrdersListModel.DONT_GOTO:\nthis.gotoIcon.setIcon(this.dontGoto);\nbreak;\ncase TrainOrdersListModel.GOTO_AFTER_PRIORITY_ORDERS:\nthis.gotoIcon.setIcon(this.gotoAfterPriorityOrders);\nbreak;\ncase TrainOrdersListModel.GOTO_NOW:\nthis.gotoIcon.setIcon(this.gotoNow);\nbreak;\ndefault:\nthrow new IllegalArgumentException(String\n.valueOf(trainOrders.gotoStatus));\n}\nthis.gotoIcon.setPreferredSize(new Dimension(20, 20));\n// Set consist\nTrainListCellRenderer trainViewJPanel = (TrainListCellRenderer) consistChangeJPanel;\ntrainViewJPanel.display(trainOrders.trainNumber, index);\n// Show priority orders.\nif (trainOrders.isPriorityOrder) {\n// Write the station name in upper case\nString s = this.stationNameJLabel.getText();\nthis.stationNameJLabel.setText(s + \" (Priority Orders)\");\n}\n// Check for 'No change'\nif (null == trainOrders.order.consist) {\nif (trainOrders.order.autoConsist) {\nthis.noChangeJLabel.setText(\"Select wagons automatically\");\n} else {\nthis.noChangeJLabel.setText(\"No Change\");\n}\n} else {\nthis.noChangeJLabel.setText(null);\n}\n// Set the section title\n// this.sectionTitleJLabel.setText(\"trainOrders.sectionTitle\");\nreturn this;\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JPanel consistChangeJPanel;\njavax.swing.JLabel gotoIcon;\njavax.swing.JLabel noChangeJLabel;\njavax.swing.JLabel ordersJLabel;\njavax.swing.JLabel stationNameJLabel;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.DetailMapRenderer","javaDoc":"/**\n* Draws the main map, that is the terrain, track, trains, station names etc.\n*\n* @author Luke\n*/","code":"/**\n* Draws the main map, that is the terrain, track, trains, station names etc.\n*\n* @author Luke\n*/\npublic class DetailMapRenderer implements MapRenderer {\nprivate static final boolean OSXWorkaround = (System\n.getProperty(\"OSXWorkaround\") != null);\nprivate final MapLayerRenderer background;\nprivate final Dimension mapSizeInPixels;\nprivate final OverHeadTrainView trainsview;\nprivate final StationRadiusRenderer stationRadius;\nprivate final BuildTrackRenderer buildTrackRenderer;\nprivate final BuildTrackController buildTrackController;\nprivate final Painter stationBoxes;\npublic DetailMapRenderer(ReadOnlyWorld world, RenderersRoot rr,\nModelRoot modelRoot) {\ntrainsview = new OverHeadTrainView(world, rr, modelRoot);\nMapBackgroundRender render = new MapBackgroundRender(world, rr,\nmodelRoot);\nif (OSXWorkaround) {\n// Don't buffer the mapviews background.\nbackground = render;\n} else {\nbackground = new SquareTileBackgroundRenderer(render);\n}\nDimension mapSize = new Dimension(world.getMapWidth(), world\n.getMapHeight());\nmapSizeInPixels = new Dimension(mapSize.width * Constants.TILE_SIZE,\nmapSize.height * Constants.TILE_SIZE);\nstationRadius = new StationRadiusRenderer(modelRoot);\nbuildTrackRenderer = new BuildTrackRenderer(rr, modelRoot);\nbuildTrackController = new BuildTrackController(world, modelRoot);\nstationBoxes = new StationBoxRenderer(world, rr, modelRoot);\n}\npublic StationRadiusRenderer getStationRadius() {\nreturn stationRadius;\n}\npublic BuildTrackController getBuildTrackController() {\nreturn buildTrackController;\n}\npublic float getScale() {\nreturn Constants.TILE_SIZE;\n}\npublic Dimension getMapSizeInPixels() {\nreturn mapSizeInPixels;\n}\npublic TrainRenderer getTrainRenderer() {\nreturn this.trainsview.getTrainRenderer();\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\nbackground.paintTile(g, tileX, tileY);\ntrainsview.paint((Graphics2D) g);\nstationRadius.paint((Graphics2D) g);\nstationBoxes.paint((Graphics2D) g);\nbuildTrackRenderer.paint((Graphics2D) g);\n}\npublic void refreshTile(int x, int y) {\nbackground.refreshTile(x, y);\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nbackground.paintRect(g, visibleRect);\ntrainsview.paint((Graphics2D) g);\nstationRadius.paint((Graphics2D) g);\nstationBoxes.paint((Graphics2D) g);\nbuildTrackRenderer.paint((Graphics2D) g);\n}\npublic void refreshAll() {\nbackground.refreshAll();\n}\n}"}
{"className":"jfreerails.client.view.IncomeStatementGenerator","javaDoc":"/**\n* Generates the income statement- note, its fields are read using reflection so\n* don't change their names.\n*\n* @author Luke\n*\n*/","code":"/**\n* Generates the income statement- note, its fields are read using reflection so\n* don't change their names.\n*\n* @author Luke\n*\n*/\npublic class IncomeStatementGenerator {\nGameTime from;\nGameTime to;\nfinal ReadOnlyWorld w;\nfinal FreerailsPrincipal principal;\nprivate int startyear = 0;\nprivate GameCalendar cal;\npublic Money mailTotal;\npublic Money passengersTotal;\npublic Money fastFreightTotal;\npublic Money slowFreightTotal;\npublic Money bulkFreightTotal;\npublic Money interestTotal;\npublic Money trainMaintenanceTotal;\npublic Money trackMaintenanceTotal;\npublic Money stationMaintenanceTotal;\npublic Money profitTotal;\npublic Money mailYtd;\npublic Money passengersYtd;\npublic Money fastFreightYtd;\npublic Money slowFreightYtd;\npublic Money bulkFreightYtd;\npublic Money interestYtd;\npublic Money trainMaintenanceYtd;\npublic Money trackMaintenanceYtd;\npublic Money stationMaintenanceYtd;\npublic Money profitYtd;\npublic String year;\nIncomeStatementGenerator(ReadOnlyWorld w, FreerailsPrincipal principal) {\nthis.w = w;\nthis.principal = principal;\ncal = (GameCalendar) w.get(ITEM.CALENDAR);\n// Income from cargo delivery\nmailTotal = calRevenue(Categories.Mail);\npassengersTotal = calRevenue(Categories.Passengers);\nfastFreightTotal = calRevenue(Categories.Fast_Freight);\nslowFreightTotal = calRevenue(Categories.Slow_Freight);\nbulkFreightTotal = calRevenue(Categories.Bulk_Freight);\n// Expenses.\ninterestTotal = calTotal(INTEREST_CHARGE);\ntrainMaintenanceTotal = calTotal(TRAIN_MAINTENANCE);\ntrackMaintenanceTotal = calTotal(TRACK_MAINTENANCE);\nstationMaintenanceTotal = calTotal(STATION_MAINTENANCE);\n/*\n* Note, expenses are stored as negative values so we just add\n* everything up.\n*/\nlong profit = mailTotal.getAmount() + passengersTotal.getAmount()\n+ fastFreightTotal.getAmount() + slowFreightTotal.getAmount()\n+ bulkFreightTotal.getAmount() + interestTotal.getAmount()\n+ trainMaintenanceTotal.getAmount()\n+ trackMaintenanceTotal.getAmount()\n+ stationMaintenanceTotal.getAmount();\nprofitTotal = new Money(profit);\nGameTime time = w.currentTime();\nstartyear = cal.getYear(time.getTicks());\nyear = String.valueOf(startyear);\n// Income from cargo delivery\nmailYtd = calRevenue(Categories.Mail);\npassengersYtd = calRevenue(Categories.Passengers);\nfastFreightYtd = calRevenue(Categories.Fast_Freight);\nslowFreightYtd = calRevenue(Categories.Slow_Freight);\nbulkFreightYtd = calRevenue(Categories.Bulk_Freight);\n// Expenses.\ninterestYtd = calTotal(INTEREST_CHARGE);\ntrainMaintenanceYtd = calTotal(TRAIN_MAINTENANCE);\ntrackMaintenanceYtd = calTotal(TRACK_MAINTENANCE);\nstationMaintenanceYtd = calTotal(STATION_MAINTENANCE);\n/*\n* Note, expenses are stored as negative values so we just add\n* everything up.\n*/\nprofit = mailYtd.getAmount() + passengersYtd.getAmount()\n+ fastFreightYtd.getAmount() + slowFreightYtd.getAmount()\n+ bulkFreightYtd.getAmount() + interestYtd.getAmount()\n+ trainMaintenanceYtd.getAmount()\n+ trackMaintenanceYtd.getAmount()\n+ stationMaintenanceYtd.getAmount();\nprofitYtd = new Money(profit);\n}\n/** Calculates the total revenue from the specified cargo type. */\nMoney calRevenue(Categories cargoCategory) {\nlong amount = 0;\nfor (int i = 0; i < w.getNumberOfTransactions(this.principal); i++) {\nTransaction t = w.getTransaction(principal, i);\nGameTime time = w.getTransactionTimeStamp(principal, i);\nif (t instanceof DeliverCargoReceipt\n&& cal.getYear(time.getTicks()) >= this.startyear) {\nDeliverCargoReceipt dcr = (DeliverCargoReceipt) t;\nint cargoType = dcr.getCb().getCargoType();\nCargoType ct = (CargoType) w.get(SKEY.CARGO_TYPES, cargoType);\nif (ct.getCategory().equals(cargoCategory)) {\namount += dcr.deltaCash().getAmount();\n}\n}\n}\nreturn new Money(amount);\n}\nMoney calTrainRevenue(int trainId) {\nlong amount = 0;\nfor (int i = 0; i < w.getNumberOfTransactions(this.principal); i++) {\nTransaction t = w.getTransaction(principal, i);\nGameTime time = w.getTransactionTimeStamp(principal, i);\nif (t instanceof DeliverCargoReceipt\n&& cal.getYear(time.getTicks()) >= this.startyear) {\nDeliverCargoReceipt dcr = (DeliverCargoReceipt) t;\nif (dcr.getTrainId() == trainId) {\namount += dcr.deltaCash().getAmount();\n}\n}\n}\nreturn new Money(amount);\n}\nprivate Money calTotal(Transaction.Category transactionCategory) {\nlong amount = 0;\nfor (int i = 0; i < w.getNumberOfTransactions(this.principal); i++) {\nTransaction t = w.getTransaction(principal, i);\nGameTime time = w.getTransactionTimeStamp(principal, i);\nif (t.getCategory() == transactionCategory\n&& cal.getYear(time.getTicks()) >= this.startyear) {\namount += t.deltaCash().getAmount();\n}\n}\nreturn new Money(amount);\n}\n}"}
{"className":"jfreerails.client.view.BuildTrackJPanel","javaDoc":"/**\n* A JPanel that presents toggle buttons that let the player select the build\n* mode (build track, upgrade track, build station, bulldoze, and info mode) and\n* select the track/bridge/station type to use.\n*\n* @author Luke\n*/","code":"/**\n* A JPanel that presents toggle buttons that let the player select the build\n* mode (build track, upgrade track, build station, bulldoze, and info mode) and\n* select the track/bridge/station type to use.\n*\n* @author Luke\n*/\npublic class BuildTrackJPanel extends javax.swing.JPanel implements ActiveView {\nprivate static final long serialVersionUID = 3618701915647850036L;\nprivate final ImageManager imageManager = new ImageManagerImpl(\n\"/jfreerails/client/graphics/\");\nprivate HashMap<TrackRule.TrackCategories, Integer> selectionSet;\nprivate ModelRoot modelRoot;\nprivate TrackMoveProducer trackMoveProducer;\nprivate StationBuildModel stationBuildModel;\n/** Creates new form BuildTrackJPanel */\npublic BuildTrackJPanel() {\ninitComponents();\n}\npublic void setup(ModelRoot mr, ActionRoot ar, RenderersRoot vl,\nActionListener al) {\nmodelRoot = mr;\nstationBuildModel = ar.getStationBuildModel();\ntrackMoveProducer = ar.getTrackMoveProducer();\nif (null == trackMoveProducer)\nthrow new NullPointerException();\nselectionSet = new HashMap<TrackRule.TrackCategories, Integer>();\ntrackButtonGroup = new javax.swing.ButtonGroup();\nbridgeButtonGroup = new javax.swing.ButtonGroup();\nstationButtonGroup = new javax.swing.ButtonGroup();\ntunnelButtonGroup = new javax.swing.ButtonGroup();\n// Remove any existing buttons.\nbridgesJPanel.removeAll();\nstationsJPanel.removeAll();\ntrackJPanel.removeAll();\ntunnelsJPanel.removeAll();\n// Add the new set of buttons.\nReadOnlyWorld world = mr.getWorld();\nfor (int i = 0; i < world.size(SKEY.TRACK_RULES); i++) {\nJToggleButton toggleButton = new JToggleButton();\nfinal Integer ruleID = new Integer(i);\nTrackRule rule = (TrackRule) world.get(SKEY.TRACK_RULES, i);\nTrackRule.TrackCategories category = rule.getCategory();\nMoney price = null;\nswitch (category) {\ncase track:\ntrackButtonGroup.add(toggleButton);\ntoggleButton.setIcon(getIcon(rule.getTypeName()));\ntoggleButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(\njava.awt.event.ActionEvent evt) {\nselectionSet\n.put(TrackRule.TrackCategories.track,\nruleID);\nsetBuildTrackStrategy();\n}\n});\nprice = rule.getPrice();\ntrackJPanel.add(toggleButton);\nbreak;\ncase bridge:\nbridgeButtonGroup.add(toggleButton);\ntoggleButton.setIcon(getIcon(rule.getTypeName()));\ntoggleButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(\njava.awt.event.ActionEvent evt) {\nselectionSet.put(\nTrackRule.TrackCategories.bridge,\nruleID);\nsetBuildTrackStrategy();\n}\n});\nbridgesJPanel.add(toggleButton);\nprice = rule.getFixedCost();\nbreak;\ncase tunnel:\ntunnelButtonGroup.add(toggleButton);\ntoggleButton.setIcon(getIcon(rule.getTypeName()));\ntoggleButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(\njava.awt.event.ActionEvent evt) {\nselectionSet.put(\nTrackRule.TrackCategories.tunnel,\nruleID);\nsetBuildTrackStrategy();\n}\n});\nprice = rule.getPrice();\ntunnelsJPanel.add(toggleButton);\nbreak;\ncase station:\nstationButtonGroup.add(toggleButton);\ntoggleButton.setAction(stationBuildModel\n.getStationChooseAction(ruleID));\ntoggleButton.setIcon(getIcon(rule.getTypeName()));\ntoggleButton\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(\njava.awt.event.ActionEvent evt) {\nselectionSet.put(\nTrackRule.TrackCategories.station,\nruleID);\n}\n});\nstationsJPanel.add(toggleButton);\nprice = rule.getFixedCost();\nbreak;\n}\ntoggleButton.setPreferredSize(new java.awt.Dimension(36, 36));\nString tooltip = Utils.capitalizeEveryWord(rule.getTypeName())\n+ \" $\" + price.toString();\ntoggleButton.setToolTipText(tooltip);\nif (!selectionSet.containsKey(category)) {\nselectionSet.put(category, new Integer(i));\ntoggleButton.setSelected(true);\n}\n}\naddNoTunnelsButton();\naddNoBridgesButton();\n// Default to add track.\naddTrackActionPerformed(null);\nbuildModeButtonGroup.setSelected(addTrack.getModel(), true);\nsetBuildTrackStrategy();\n// Make the buttons non-focusable\nsetFocusableFalse(bridgeButtonGroup);\nsetFocusableFalse(trackButtonGroup);\nsetFocusableFalse(tunnelButtonGroup);\nsetFocusableFalse(stationButtonGroup);\nsetFocusableFalse(buildModeButtonGroup);\n// Add button click\n// buildTrackJPanel.addKeyListener(new KeyListener(){\n// public void keyPressed(KeyEvent e){\n// System.out.println(e.getKeyCode());\n// viewMode.doClick();\n// }\n// public void keyReleased(KeyEvent e){\n//\n// }\n// public void keyTyped(KeyEvent e){\n//\n// }\n// });\n}\n/** Calls setFocusable(false) for each button in the button group. */\nprivate void setFocusableFalse(ButtonGroup bg) {\nfor (Enumeration<AbstractButton> buttons = bg.getElements(); buttons\n.hasMoreElements();) {\nbuttons.nextElement().setFocusable(false);\n}\n}\nprivate void addNoTunnelsButton() {\nJToggleButton toggleButton = new JToggleButton();\ntunnelButtonGroup.add(toggleButton);\ntoggleButton.setIcon(getIcon(\"no_tunnels\"));\ntoggleButton.setPreferredSize(new java.awt.Dimension(36, 36));\ntoggleButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectionSet.put(TrackRule.TrackCategories.tunnel, null);\nsetBuildTrackStrategy();\n}\n});\ntoggleButton.setToolTipText(\"Don't build tunnels\");\ntunnelsJPanel.add(toggleButton);\n}\nprivate void addNoBridgesButton() {\nJToggleButton toggleButton = new JToggleButton();\nbridgeButtonGroup.add(toggleButton);\ntoggleButton.setIcon(getIcon(\"no_bridges\"));\ntoggleButton.setPreferredSize(new java.awt.Dimension(36, 36));\ntoggleButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectionSet.put(TrackRule.TrackCategories.bridge, null);\nsetBuildTrackStrategy();\n}\n});\ntoggleButton.setToolTipText(\"Don't build bridges\");\nbridgesJPanel.add(toggleButton);\n}\nprivate ImageIcon getIcon(String typeName) {\ntry {\nString relativeFileName = \"icons\" + File.separator + typeName\n+ \".png\";\nrelativeFileName = relativeFileName.replace(' ', '_');\nImage im = imageManager.getImage(relativeFileName);\nreturn new ImageIcon(im);\n} catch (IOException e) {\ne.printStackTrace();\nthrow new IllegalStateException(e);\n}\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nbuildModeButtonGroup = new javax.swing.ButtonGroup();\ntrackButtonGroup = new javax.swing.ButtonGroup();\nbridgeButtonGroup = new javax.swing.ButtonGroup();\nstationButtonGroup = new javax.swing.ButtonGroup();\ntunnelButtonGroup = new javax.swing.ButtonGroup();\nbuildModeJPanel = new javax.swing.JPanel();\naddTrack = new javax.swing.JToggleButton();\nupgradeTrack = new javax.swing.JToggleButton();\naddStation = new javax.swing.JToggleButton();\nbulldoze = new javax.swing.JToggleButton();\nviewMode = new javax.swing.JToggleButton();\ntrackJPanel = new javax.swing.JPanel();\nviewMode1 = new javax.swing.JToggleButton();\nbridgesJPanel = new javax.swing.JPanel();\nviewMode2 = new javax.swing.JToggleButton();\ntunnelsJPanel = new javax.swing.JPanel();\nviewMode3 = new javax.swing.JToggleButton();\nstationsJPanel = new javax.swing.JPanel();\nviewMode4 = new javax.swing.JToggleButton();\nspacer = new javax.swing.JPanel();\nsetLayout(new java.awt.GridBagLayout());\nsetFocusable(false);\naddKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nformKeyPressed(evt);\n}\n@Override\npublic void keyTyped(java.awt.event.KeyEvent evt) {\nformKeyTyped(evt);\n}\n});\nbuildModeJPanel.setLayout(new java.awt.FlowLayout(\njava.awt.FlowLayout.LEFT, 4, 2));\nbuildModeButtonGroup.add(addTrack);\naddTrack.setIcon(getIcon(\"build track\"));\naddTrack.setSelected(true);\naddTrack.setToolTipText(\"Build Track\");\naddTrack.setFocusable(false);\naddTrack.setPreferredSize(new java.awt.Dimension(36, 36));\naddTrack.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\naddTrackActionPerformed(evt);\n}\n});\nbuildModeJPanel.add(addTrack);\nbuildModeButtonGroup.add(upgradeTrack);\nupgradeTrack.setIcon(getIcon(\"upgrade track\"));\nupgradeTrack.setToolTipText(\"Upgrade Track\");\nupgradeTrack.setFocusable(false);\nupgradeTrack.setPreferredSize(new java.awt.Dimension(36, 36));\nupgradeTrack.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nupgradeTrackActionPerformed(evt);\n}\n});\nbuildModeJPanel.add(upgradeTrack);\nbuildModeButtonGroup.add(addStation);\naddStation.setIcon(getIcon(\"build stations\"));\naddStation.setToolTipText(\"Build Station\");\naddStation.setFocusable(false);\naddStation.setPreferredSize(new java.awt.Dimension(36, 36));\naddStation.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\naddStationActionPerformed(evt);\n}\n});\nbuildModeJPanel.add(addStation);\nbuildModeButtonGroup.add(bulldoze);\nbulldoze.setIcon(getIcon(\"bulldozer\"));\nbulldoze.setToolTipText(\"Remove Track\");\nbulldoze.setFocusable(false);\nbulldoze.setPreferredSize(new java.awt.Dimension(36, 36));\nbulldoze.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nbulldozeActionPerformed(evt);\n}\n});\nbuildModeJPanel.add(bulldoze);\nbuildModeButtonGroup.add(viewMode);\nviewMode.setIcon(getIcon(\"eye\"));\nviewMode.setToolTipText(\"Don't build anything\");\nviewMode.setFocusable(false);\nviewMode.setPreferredSize(new java.awt.Dimension(36, 36));\nviewMode.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nviewModeActionPerformed(evt);\n}\n});\nbuildModeJPanel.add(viewMode);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\nadd(buildModeJPanel, gridBagConstraints);\ntrackJPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT,\n4, 2));\nbuildModeButtonGroup.add(viewMode1);\nviewMode1.setIcon(getIcon(\"turn_off\"));\nviewMode1.setPreferredSize(new java.awt.Dimension(36, 36));\ntrackJPanel.add(viewMode1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\nadd(trackJPanel, gridBagConstraints);\nbridgesJPanel.setLayout(new java.awt.FlowLayout(\njava.awt.FlowLayout.LEFT, 4, 2));\nbuildModeButtonGroup.add(viewMode2);\nviewMode2.setIcon(getIcon(\"turn_off\"));\nviewMode2.setPreferredSize(new java.awt.Dimension(36, 36));\nbridgesJPanel.add(viewMode2);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\nadd(bridgesJPanel, gridBagConstraints);\ntunnelsJPanel.setLayout(new java.awt.FlowLayout(\njava.awt.FlowLayout.LEFT, 4, 2));\nbuildModeButtonGroup.add(viewMode3);\nviewMode3.setIcon(getIcon(\"turn_off\"));\nviewMode3.setPreferredSize(new java.awt.Dimension(36, 36));\ntunnelsJPanel.add(viewMode3);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\nadd(tunnelsJPanel, gridBagConstraints);\nstationsJPanel.setLayout(new java.awt.FlowLayout(\njava.awt.FlowLayout.LEFT, 4, 2));\nbuildModeButtonGroup.add(viewMode4);\nviewMode4.setIcon(getIcon(\"turn_off\"));\nviewMode4.setPreferredSize(new java.awt.Dimension(36, 36));\nstationsJPanel.add(viewMode4);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\nadd(stationsJPanel, gridBagConstraints);\nspacer.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 0,\n0));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 5;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(spacer, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void formKeyTyped(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_formKeyTyped\nviewMode.doClick();\n}// GEN-LAST:event_formKeyTyped\nprivate void formKeyPressed(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_formKeyPressed\nviewMode.doClick();\n}// GEN-LAST:event_formKeyPressed\nprivate void viewModeActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_viewModeActionPerformed\nsetVisible(false, false, false, false);\ncancelStationPlacement();\nsetTrackBuilderMode(IGNORE_TRACK);\n}// GEN-LAST:event_viewModeActionPerformed\nprivate void bulldozeActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_bulldozeActionPerformed\nsetVisible(false, false, false, false);\ncancelStationPlacement();\nsetTrackBuilderMode(REMOVE_TRACK);\n}// GEN-LAST:event_bulldozeActionPerformed\nprivate void addStationActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_addStationActionPerformed\nsetVisible(false, false, false, true);\nsetTrackBuilderMode(BUILD_STATION);\n}// GEN-LAST:event_addStationActionPerformed\nprivate void upgradeTrackActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_upgradeTrackActionPerformed\nsetVisible(true, true, false, false);\ncancelStationPlacement();\nsetTrackBuilderMode(UPGRADE_TRACK);\n}// GEN-LAST:event_upgradeTrackActionPerformed\nprivate void addTrackActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_addTrackActionPerformed\nsetVisible(true, true, true, false);\ncancelStationPlacement();\nsetTrackBuilderMode(BUILD_TRACK);\n}// GEN-LAST:event_addTrackActionPerformed\nprivate void setVisible(boolean track, boolean bridges, boolean tunnels,\nboolean stations) {\ntrackJPanel.setVisible(bridges);\nbridgesJPanel.setVisible(bridges);\ntunnelsJPanel.setVisible(tunnels);\nstationsJPanel.setVisible(stations);\n}\nprivate void setBuildTrackStrategy() {\nArrayList<Integer> ruleIDs = new ArrayList<Integer>();\nruleIDs.add(selectionSet.get(TrackRule.TrackCategories.track));\nruleIDs.add(selectionSet.get(TrackRule.TrackCategories.bridge));\nruleIDs.add(selectionSet.get(TrackRule.TrackCategories.tunnel));\nBuildTrackStrategy bts = BuildTrackStrategy.getMultipleRuleInstance(\nruleIDs, modelRoot.getWorld());\nmodelRoot.setProperty(ModelRoot.Property.BUILD_TRACK_STRATEGY, bts);\n}\nprivate void cancelStationPlacement() {\n// Cancel build station mode..\nstationBuildModel.getStationCancelAction().actionPerformed(\nnew ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"\"));\n}\nprivate void setTrackBuilderMode(TrackMoveProducer.BuildMode mode) {\ntrackMoveProducer.setTrackBuilderMode(mode);\nmodelRoot.setProperty(ModelRoot.Property.TRACK_BUILDER_MODE, mode);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JToggleButton addStation;\nprivate javax.swing.JToggleButton addTrack;\nprivate javax.swing.ButtonGroup bridgeButtonGroup;\nprivate javax.swing.JPanel bridgesJPanel;\nprivate javax.swing.ButtonGroup buildModeButtonGroup;\nprivate javax.swing.JPanel buildModeJPanel;\nprivate javax.swing.JToggleButton bulldoze;\nprivate javax.swing.JPanel spacer;\nprivate javax.swing.ButtonGroup stationButtonGroup;\nprivate javax.swing.JPanel stationsJPanel;\nprivate javax.swing.ButtonGroup trackButtonGroup;\nprivate javax.swing.JPanel trackJPanel;\nprivate javax.swing.ButtonGroup tunnelButtonGroup;\nprivate javax.swing.JPanel tunnelsJPanel;\nprivate javax.swing.JToggleButton upgradeTrack;\nprivate javax.swing.JToggleButton viewMode;\nprivate javax.swing.JToggleButton viewMode1;\nprivate javax.swing.JToggleButton viewMode2;\nprivate javax.swing.JToggleButton viewMode3;\nprivate javax.swing.JToggleButton viewMode4;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.StationInfoJPanel","javaDoc":"/**\n* This JPanel displays the supply and demand at a station.\n*\n* @author Luke\n*/","code":"/**\n* This JPanel displays the supply and demand at a station.\n*\n* @author Luke\n*/\npublic class StationInfoJPanel extends JPanel implements View,\nWorldListListener {\nprivate static final long serialVersionUID = 4050759377680150585L;\nprivate ReadOnlyWorld w;\nprivate ModelRoot modelRoot;\nprivate WorldIterator wi;\n/**\n* The index of the cargoBundle associated with this station.\n*/\nprivate int cargoBundleIndex;\npublic StationInfoJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njLabel1 = new javax.swing.JLabel();\nnextStation = new javax.swing.JButton();\npreviousStation = new javax.swing.JButton();\nclose = new javax.swing.JButton();\nsetLayout(new java.awt.GridBagLayout());\nsetMinimumSize(new java.awt.Dimension(250, 177));\njLabel1.setFont(new java.awt.Font(\"Dialog\", 0, 10));\njLabel1\n.setText(\"<html>\\n<h4 align=\\\"center\\\">Supply and Demand at stationName</h4>\\n<table width=\\\"100%\\\" border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"2\\\">\\n <tr>\\n <td>&nbsp;</td>\\n <td>Will pay<br>for</td>\\n <td>Supplies<br>(cars per year)</td>\\n <td>Waiting for pickup<br>(car loads)</td>\\n </tr>\\n <tr>\\n <td>Mail</td>\\n <td>Yes</td>\\n <td>&nbsp;</td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr>\\n <td>Passengers</td>\\n <td>No</td>\\n <td>3</td>\\n <td>2.5</td>\\n </tr>\\n \\n</table>\\n\\n</html>\");\njLabel1.setVerticalAlignment(javax.swing.SwingConstants.TOP);\njLabel1.setAlignmentY(0.0F);\njLabel1.setVerticalTextPosition(javax.swing.SwingConstants.TOP);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridwidth = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(8, 8, 4, 8);\nadd(jLabel1, gridBagConstraints);\nnextStation.setText(\"next ->\");\nnextStation.setMargin(new java.awt.Insets(0, 0, 0, 0));\nnextStation.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nnextStationActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\nadd(nextStation, gridBagConstraints);\npreviousStation.setText(\"<- previous\");\npreviousStation.setMargin(new java.awt.Insets(0, 0, 0, 0));\npreviousStation.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\npreviousStationActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\nadd(previousStation, gridBagConstraints);\nclose.setText(\"close\");\nclose.setMargin(new java.awt.Insets(0, 0, 0, 0));\nclose.setMaximumSize(new java.awt.Dimension(65, 22));\nclose.setMinimumSize(new java.awt.Dimension(65, 22));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\nadd(close, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void previousStationActionPerformed(java.awt.event.ActionEvent evt) {\n// GEN-FIRST:event_previousStationActionPerformed\n// Add your handling code here:\nif (wi.previous()) {\nImPoint p = new ImPoint(((StationModel) wi.getElement())\n.getStationX(), ((StationModel) wi.getElement())\n.getStationY());\nthis.modelRoot.setProperty(ModelRoot.Property.CURSOR_POSITION, p);\ndisplay();\n} else {\nthrow new IllegalStateException();\n}\n} // GEN-LAST:event_previousStationActionPerformed\nprivate void nextStationActionPerformed(java.awt.event.ActionEvent evt) {\n// GEN-FIRST:event_nextStationActionPerformed\n// Add your handling code here:\nif (wi.next()) {\nImPoint p = new ImPoint(((StationModel) wi.getElement())\n.getStationX(), ((StationModel) wi.getElement())\n.getStationY());\nthis.modelRoot.setProperty(ModelRoot.Property.CURSOR_POSITION, p);\ndisplay();\n} else {\nthrow new IllegalStateException();\n}\n} // GEN-LAST:event_nextStationActionPerformed\npublic void setup(ModelRoot mr, RenderersRoot vl, Action al) {\nthis.wi = new NonNullElements(KEY.STATIONS, mr.getWorld(), mr\n.getPrincipal());\naddComponentListener(componentListener);\nthis.w = mr.getWorld();\nthis.modelRoot = mr;\nthis.close.addActionListener(al);\n}\npublic void setStation(int stationNumber) {\nthis.wi.gotoIndex(stationNumber);\ndisplay();\n}\nprivate void display() {\nif (wi.getRowID() > 0) {\nthis.previousStation.setEnabled(true);\n} else {\nthis.previousStation.setEnabled(false);\n}\nif (wi.getRowID() < (wi.size() - 1)) {\nthis.nextStation.setEnabled(true);\n} else {\nthis.nextStation.setEnabled(false);\n}\nint stationNumber = wi.getIndex();\nString label;\nif (stationNumber != WorldIterator.BEFORE_FIRST) {\nStationModel station = (StationModel) w.get(modelRoot.getPrincipal(),\nKEY.STATIONS, stationNumber);\nFreerailsTile tile = (FreerailsTile) w\n.getTile(station.x, station.y);\nString stationTypeName = tile.getTrackPiece().getTrackRule().getTypeName();\ncargoBundleIndex = station.getCargoBundleID();\nImmutableCargoBundle cargoWaiting = (ImmutableCargoBundle) w.get(\nmodelRoot\n.getPrincipal(), KEY.CARGO_BUNDLES, station.getCargoBundleID());\nString title = \"<h2 align=\\\"center\\\">\" + station.getStationName()\n+ \" (\" + stationTypeName + \")</h2>\";\nString table = \"<table width=\\\"100%\\\" border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"3\\\"><tr><td>&nbsp;</td>\\n <td>Will pay for</td>\\n <td>Supplies / cars per year</td><td>Waiting for pickup / car loads</td> </tr>\";\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\n// get the values\nCargoType cargoType = (CargoType) w.get(SKEY.CARGO_TYPES, i);\nString demanded = (station.getDemand().isCargoDemanded(i) ? \"Yes\"\n: \"No\");\nint amountSupplied = station.getSupply().getSupply(i);\nString supply = (amountSupplied > 0) ? String\n.valueOf(amountSupplied\n/ WagonType.UNITS_OF_CARGO_PER_WAGON)\n: \"&nbsp;\";\nint amountWaiting = cargoWaiting.getAmount(i);\nString waiting = (amountWaiting > 0) ? String\n.valueOf(amountWaiting\n/ WagonType.UNITS_OF_CARGO_PER_WAGON)\n: \"&nbsp;\";\n// build the html\ntable += \"<tr>\";\ntable += \"<td>\" + cargoType.getDisplayName() + \"</td>\";\ntable += \"<td>\" + demanded + \"</td>\";\ntable += \"<td>\" + supply + \"</td>\";\ntable += \"<td>\" + waiting + \"</td>\";\ntable += \"</tr>\";\n}\ntable += \"</table>\";\nlabel = \"<html>\" + title + table + \"</html>\";\n} else {\ncargoBundleIndex = WorldIterator.BEFORE_FIRST;\nlabel = \"<html><h2 align=\\\"center\\\">No Station \"\n+ \"Selected</h2></html>\";\n}\njLabel1.setText(label);\nthis.repaint();\n}\nprivate final ComponentAdapter componentListener = new ComponentAdapter() {\n@Override\npublic void componentHidden(ComponentEvent e) {\n}\n@Override\npublic void componentShown(ComponentEvent e) {\nint i = wi.getIndex();\nwi.reset();\nif (i != WorldIterator.BEFORE_FIRST) {\nwi.gotoIndex(i);\n}\ndisplay();\n}\n};\nprivate FreerailsSerializable lastCargoBundle = null;\n@Override\nprotected void paintComponent(Graphics g) {\n/* We need to update if the cargo bundle has changed. */\nFreerailsPrincipal playerPrincipal = this.modelRoot.getPrincipal();\n/*\n* Avoid a array out of bounds exception when there are no stations and\n* the stations tab is visible.\n*/\nif (w.boundsContain(playerPrincipal, KEY.CARGO_BUNDLES,\ncargoBundleIndex)) {\nFreerailsSerializable currentCargoBundle = w.get(playerPrincipal,\nKEY.CARGO_BUNDLES, this.cargoBundleIndex);\nif (lastCargoBundle != currentCargoBundle) {\nthis.display();\nlastCargoBundle = currentCargoBundle;\n}\n}\nsuper.paintComponent(g);\n}\nprivate void reactToUpdate(KEY key, int changedIndex, boolean isAddition) {\nif (!isVisible()) {\nreturn;\n}\nint currentIndex = wi.getIndex();\nif (key == KEY.CARGO_BUNDLES) {\nif (changedIndex == cargoBundleIndex) {\n/* update our cargo bundle */\ndisplay();\nreturn;\n}\n} else if (key == KEY.STATIONS) {\nwi.reset();\nif (currentIndex != WorldIterator.BEFORE_FIRST) {\nif (currentIndex < wi.size()) {\nwi.gotoIndex(currentIndex);\n} else {\ncurrentIndex = WorldIterator.BEFORE_FIRST;\n}\n}\nif (isAddition && wi.getIndex() == WorldIterator.BEFORE_FIRST) {\nif (wi.next()) {\ndisplay();\n}\n}\nif (currentIndex == changedIndex\n|| currentIndex == WorldIterator.BEFORE_FIRST) {\ndisplay();\n}\n}\nreturn;\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal principal) {\nif (modelRoot.getPrincipal().equals(principal))\nreactToUpdate(key, index, false);\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal principal) {\nif (modelRoot.getPrincipal().equals(principal))\nreactToUpdate(key, index, true);\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal principal) {\nif (modelRoot.getPrincipal().equals(principal))\nreactToUpdate(key, index, false);\n}\nvoid removeCloseButton() {\nthis.remove(close);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton close;\nprivate javax.swing.JLabel jLabel1;\nprivate javax.swing.JButton nextStation;\nprivate javax.swing.JButton previousStation;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.CargoWaitingAndDemandedJPanel","javaDoc":"/**\n* A JPanel that displays the cargo waiting and demanded at a station - used on\n* the select station popup window.\n*\n* @author Luke\n*/","code":"/**\n* A JPanel that displays the cargo waiting and demanded at a station - used on\n* the select station popup window.\n*\n* @author Luke\n*/\npublic class CargoWaitingAndDemandedJPanel extends javax.swing.JPanel implements\nView {\nprivate static final long serialVersionUID = 3760559784860071476L;\nprivate ReadOnlyWorld world;\nprivate FreerailsPrincipal principal;\npublic CargoWaitingAndDemandedJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njScrollPane1 = new javax.swing.JScrollPane();\njPanel1 = new javax.swing.JPanel();\nstationName = new javax.swing.JLabel();\nwaiting = new javax.swing.JLabel();\nwaitingJTable = new javax.swing.JTable();\ndemands = new javax.swing.JLabel();\ndemandsJList = new javax.swing.JList();\nspacer = new javax.swing.JPanel();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(100, 200));\njScrollPane1.setBorder(null);\njScrollPane1\n.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\njPanel1.setLayout(new java.awt.GridBagLayout());\nstationName.setText(\"Station Name\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.insets = new java.awt.Insets(6, 6, 6, 6);\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;\njPanel1.add(stationName, gridBagConstraints);\nwaiting.setText(\"Waiting\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\njPanel1.add(waiting, gridBagConstraints);\nwaitingJTable.setBackground(javax.swing.UIManager.getDefaults()\n.getColor(\"Button.background\"));\nwaitingJTable.setFont(new java.awt.Font(\"Dialog\", 0, 10));\nwaitingJTable.setModel(new javax.swing.table.DefaultTableModel(\nnew Object[][] { { \"Mail\", \"4\" }, { \"Passengers\", null } },\nnew String[] { \"Title 1\", \"Title 2\" }));\nwaitingJTable\n.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);\nwaitingJTable.setFocusable(false);\nwaitingJTable.setRequestFocusEnabled(false);\nwaitingJTable.setRowSelectionAllowed(false);\nwaitingJTable.setShowHorizontalLines(false);\nwaitingJTable.setShowVerticalLines(false);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\njPanel1.add(waitingJTable, gridBagConstraints);\ndemands.setText(\"Demands\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 3;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\njPanel1.add(demands, gridBagConstraints);\ndemandsJList.setBackground(javax.swing.UIManager.getDefaults()\n.getColor(\"Button.background\"));\ndemandsJList.setFont(new java.awt.Font(\"Dialog\", 0, 10));\ndemandsJList.setFocusable(false);\ndemandsJList.setRequestFocusEnabled(false);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\njPanel1.add(demandsJList, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 5;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\njPanel1.add(spacer, gridBagConstraints);\njScrollPane1.setViewportView(jPanel1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\n}// GEN-END:initComponents\npublic void setup(ModelRoot model, RenderersRoot vl,\nAction closeAction) {\nthis.world = model.getWorld();\nthis.principal = model.getPrincipal();\n}\npublic void display(int newStationID) {\nStationModel station = (StationModel) world.get(principal,\nKEY.STATIONS, newStationID);\nthis.stationName.setText(station.getStationName());\nfinal ImmutableCargoBundle cargoWaiting = (ImmutableCargoBundle) world\n.get(principal, KEY.CARGO_BUNDLES, station.getCargoBundleID());\n// count the number of cargo types waiting and demanded.\nfinal ArrayList<String> typeWaiting = new ArrayList<String>();\nfinal ArrayList<Integer> quantityWaiting = new ArrayList<Integer>();\nfinal Vector<String> typeDemanded = new Vector<String>();\nfor (int i = 0; i < world.size(SKEY.CARGO_TYPES); i++) {\nCargoType cargoType = (CargoType) world.get(SKEY.CARGO_TYPES, i);\nint amountWaiting = cargoWaiting.getAmount(i);\nif (0 != amountWaiting) {\ntypeWaiting.add(cargoType.getDisplayName());\nint carloads = amountWaiting\n/ WagonType.UNITS_OF_CARGO_PER_WAGON;\nquantityWaiting.add(new Integer(carloads));\n}\nif (station.getDemand().isCargoDemanded(i)) {\ntypeDemanded.add(cargoType.getDisplayName());\n}\n}\n/*\n* The table shows the cargo waiting at the station. First column is\n* cargo type; second column is quantity in carloads.\n*/\nTableModel tableModel = new AbstractTableModel() {\nprivate static final long serialVersionUID = 3760559784860071476L;\npublic int getRowCount() {\nreturn typeWaiting.size();\n}\npublic int getColumnCount() {\nreturn 2;\n}\npublic Object getValueAt(int row, int column) {\nif (0 == column) {\nreturn typeWaiting.get(row);\n}\nreturn quantityWaiting.get(row);\n}\n};\nthis.waitingJTable.setModel(tableModel);\n/* The list shows the cargo demanded by the station. */\nthis.demandsJList.setListData(typeDemanded);\nthis.invalidate();\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JLabel demands;\nprivate javax.swing.JList demandsJList;\nprivate javax.swing.JPanel jPanel1;\nprivate javax.swing.JScrollPane jScrollPane1;\nprivate javax.swing.JPanel spacer;\nprivate javax.swing.JLabel stationName;\nprivate javax.swing.JLabel waiting;\nprivate javax.swing.JTable waitingJTable;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.NearestStationFinder","javaDoc":"/**\n* Provides methods that find the nearest station in a given direction, used by\n* the select station popup window.\n*\n* @author Luke\n*\n*/","code":"/**\n* Provides methods that find the nearest station in a given direction, used by\n* the select station popup window.\n*\n* @author Luke\n*\n*/\npublic class NearestStationFinder {\npublic static final int NOT_FOUND = Integer.MIN_VALUE;\nprivate final ReadOnlyWorld world;\nprivate final FreerailsPrincipal principal;\nprivate final int MAX_DISTANCE_TO_SELECT_SQUARED = 20 * 20;\npublic NearestStationFinder(ReadOnlyWorld w, FreerailsPrincipal player) {\nworld = w;\nthis.principal = player;\n}\npublic int findNearestStation(int x, int y) {\n// Find nearest station.\nint distanceToClosestSquared = Integer.MAX_VALUE;\nNonNullElements it = new NonNullElements(KEY.STATIONS, world, principal);\nint nearestStation = NOT_FOUND;\nwhile (it.next()) {\nStationModel station = (StationModel) it.getElement();\nint deltaX = x - station.x;\nint deltaY = y - station.y;\nint distanceSquared = deltaX * deltaX + deltaY * deltaY;\nif (distanceSquared < distanceToClosestSquared\n&& MAX_DISTANCE_TO_SELECT_SQUARED > distanceSquared) {\ndistanceToClosestSquared = distanceSquared;\nnearestStation = it.getIndex();\n}\n}\nreturn nearestStation;\n}\npublic int findNearestStationInDirection(int startStation, Step direction) {\nint distanceToClosestSquared = Integer.MAX_VALUE;\nNonNullElements it = new NonNullElements(KEY.STATIONS, world, principal);\nStationModel currentStation = (StationModel) world.get(principal,\nKEY.STATIONS, startStation);\nint nearestStation = NOT_FOUND;\nwhile (it.next()) {\nStationModel station = (StationModel) it.getElement();\nint deltaX = station.x - currentStation.x;\nint deltaY = station.y - currentStation.y;\nint distanceSquared = deltaX * deltaX + deltaY * deltaY;\nboolean closer = distanceSquared < distanceToClosestSquared;\nboolean notTheSameStation = startStation != it.getIndex();\nboolean inRightDirection = isInRightDirection(direction, deltaX,\ndeltaY);\nif (closer && inRightDirection && notTheSameStation) {\ndistanceToClosestSquared = distanceSquared;\nnearestStation = it.getIndex();\n}\n}\nreturn nearestStation;\n}\n/**\n* Returns true if the angle between direction and the vector (deltaX,\n* deltaY) is less than 45 degrees.\n*/\nprivate boolean isInRightDirection(Step direction, int deltaX, int deltaY) {\nboolean isDiagonal = direction.deltaX * direction.deltaY != 0;\nboolean sameXDirection = (direction.deltaX * deltaX) > 0;\nboolean sameYDirection = (direction.deltaY * deltaY > 0);\nboolean deltaXisLongerThanDeltaY = deltaX * deltaX < deltaY * deltaY;\nif (isDiagonal) {\nreturn sameXDirection && sameYDirection;\n}\nif (0 == direction.deltaX) {\nreturn deltaXisLongerThanDeltaY && sameYDirection;\n}\nreturn !deltaXisLongerThanDeltaY && sameXDirection;\n}\n}"}
{"className":"jfreerails.client.view.FreerailsCursor","javaDoc":"/**\n* Paints the cursor on the map, note the cursor's position is stored on the\n* ModelRoot under the key CURSOR_POSITION.\n*\n* @author Luke\n*/","code":"/**\n* Paints the cursor on the map, note the cursor's position is stored on the\n* ModelRoot under the key CURSOR_POSITION.\n*\n* @author Luke\n*/\nfinal public class FreerailsCursor {\nprivate final Image buildTrack, upgradeTrack, removeTrack, infoMode;\nprivate final ModelRoot modelRoot;\n/** The location of the cursor last time paintCursor(.) was called. */\nprivate ImPoint lastCursorPosition = new ImPoint();\n/** The time in ms the cursor arrived at its current position. */\nprivate long timeArrived = 0;\n/**\n* Creates a new FreerailsCursor.\n*\n* @throws IOException\n*/\npublic FreerailsCursor(ModelRoot mr, RenderersRoot rr) throws IOException {\nthis.modelRoot = mr;\nmodelRoot.setProperty(ModelRoot.Property.CURSOR_MESSAGE, null);\nbuildTrack = rr.getImage(\"cursor/buildtrack.png\");\nupgradeTrack = rr.getImage(\"cursor/upgradetrack.png\");\nremoveTrack = rr.getImage(\"cursor/removetrack.png\");\ninfoMode = rr.getImage(\"cursor/infomode.png\");\n}\n/**\n* Paints the cursor. The method calculates position to paint it based on\n* the tile size and the cursor's map position.\n*\n* @param g\n* The graphics object to paint the cursor on.\n* @param tileSize\n* The dimensions of a tile.\n*/\npublic void paintCursor(Graphics g, Dimension tileSize) {\nGraphics2D g2 = (Graphics2D) g;\nTrackMoveProducer.BuildMode buildMode = (TrackMoveProducer.BuildMode) modelRoot\n.getProperty(ModelRoot.Property.TRACK_BUILDER_MODE);\nImPoint cursorMapPosition = (ImPoint) modelRoot\n.getProperty(ModelRoot.Property.CURSOR_POSITION);\n/* Has the cursor moved since we last painted it? */\nif (!cursorMapPosition.equals(lastCursorPosition)) {\nlastCursorPosition = cursorMapPosition;\ntimeArrived = System.currentTimeMillis();\n}\nint x = cursorMapPosition.x * tileSize.width;\nint y = cursorMapPosition.y * tileSize.height;\nImage cursor = null;\nswitch (buildMode) {\ncase BUILD_TRACK:\ncursor = buildTrack;\nbreak;\ncase REMOVE_TRACK:\ncursor = removeTrack;\nbreak;\ncase UPGRADE_TRACK:\ncursor = upgradeTrack;\nbreak;\ncase IGNORE_TRACK:\ncursor = infoMode;\nbreak;\ncase BUILD_STATION:\ncursor = buildTrack;\nbreak;\n}\nBoolean b = (Boolean) modelRoot\n.getProperty(ModelRoot.Property.IGNORE_KEY_EVENTS);\nlong time = System.currentTimeMillis() - timeArrived;\nboolean show = ((time / 500) % 2) == 0;\nif (show && !b.booleanValue()) {\ng.drawImage(cursor, x, y, null);\n}\n// Second, draw a message below the cursor if appropriate.\nString message = (String) modelRoot\n.getProperty(ModelRoot.Property.CURSOR_MESSAGE);\nif (null != message && !message.equals(\"\")) {\nint fontSize = 12;\nFont font = new Font(\"Arial\", 0, fontSize);\nFontRenderContext frc = g2.getFontRenderContext();\nTextLayout layout = new TextLayout(message, font, frc);\n// We want the message to be centered below the cursor.\nfloat visibleAdvance = layout.getVisibleAdvance();\nfloat textX = (x + (tileSize.width / 2) - (visibleAdvance / 2));\nfloat textY = y + tileSize.height + fontSize + 5;\ng.setColor(java.awt.Color.white);\nlayout.draw(g2, textX, textY);\n}\n// Draw a big white dot at the target point.\nImPoint targetPoint = (ImPoint) modelRoot\n.getProperty(ModelRoot.Property.THINKING_POINT);\nif (null != targetPoint) {\ntime = System.currentTimeMillis();\nint dotSize;\nif ((time % 500) > 250) {\ndotSize = BuildTrackRenderer.BIG_DOT_WIDTH;\n} else {\ndotSize = BuildTrackRenderer.SMALL_DOT_WIDTH;\n}\ng.setColor(Color.WHITE);\nx = targetPoint.x * tileSize.width + (tileSize.width - dotSize) / 2;\ny = targetPoint.y * tileSize.width + (tileSize.height - dotSize)\n/ 2;\ng.fillOval(x, y, dotSize, dotSize);\n}\n}\n}"}
{"className":"jfreerails.client.view.LeaderBoardJPanel","javaDoc":"/**\n* A JPanel that displays the details of the players ordered by net worth.\n*\n* @author Luke\n*/","code":"/**\n* A JPanel that displays the details of the players ordered by net worth.\n*\n* @author Luke\n*/\npublic class LeaderBoardJPanel extends JPanel implements View {\nprivate static final long serialVersionUID = 3258131375298066229L;\nprivate JList playersList = null;\nprivate ActionListener submitButtonCallBack = null;\nprivate Vector<PlayerDetails> values;\n/**\n* This method initializes\n*/\npublic LeaderBoardJPanel() {\nsuper();\nvalues = new Vector<PlayerDetails>();\nRandom rand = new Random();\nfor (int i = 0; i < 5; i++) {\nPlayerDetails p = new PlayerDetails();\np.networth = new Money(rand.nextInt(100));\nvalues.add(p);\n}\ninitialize();\n}\n/**\n* This method initializes this\n*/\nprivate void initialize() {\nthis.add(getPlayersList(), null);\njava.awt.event.MouseAdapter mouseAdapter = new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent e) {\nif (null == submitButtonCallBack) {\nSystem.err.println(\"mouseClicked\");\n} else {\nsubmitButtonCallBack.actionPerformed(new ActionEvent(\nthis, 0, null));\n}\n}\n};\nthis.addMouseListener(mouseAdapter);\nthis.playersList.addMouseListener(mouseAdapter);\nthis.setSize(getPreferredSize());\n}\n/**\n* This method initializes jList\n*\n* @return javax.swing.JList\n*/\nprivate JList getPlayersList() {\nif (playersList == null) {\nplayersList = new JList();\nplayersList\n.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\nplayersList.setRequestFocusEnabled(false);\nplayersList.setEnabled(true);\nCollections.sort(values);\nplayersList.setListData(values);\n}\nreturn playersList;\n}\npublic void setup(ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nReadOnlyWorld w = modelRoot.getWorld();\nvalues.clear();\nthis.submitButtonCallBack = closeAction;\nfor (int player = 0; player < w.getNumberOfPlayers(); player++) {\nPlayerDetails details = new PlayerDetails();\nFreerailsPrincipal principal = w.getPlayer(player).getPrincipal();\ndetails.name = principal.getName();\nNonNullElements stations = new NonNullElements(KEY.STATIONS, w,\nprincipal);\ndetails.stations = stations.size();\nTransactionAggregator networth = new NetWorthCalculator(\nw, principal);\ndetails.networth = networth.calculateValue();\nvalues.add(details);\n}\nCollections.sort(values);\nplayersList.setListData(values);\nsetSize(getPreferredSize());\n}\n/**\n* Stores the details a player that are shown on the leaderboard.\n*\n* @author Luke\n*/\nstatic class PlayerDetails implements Comparable<PlayerDetails> {\nString name = \"player\";\nMoney networth = new Money(0);\nint stations = 0;\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(name);\nsb.append(\", \");\nsb.append(networth.toString());\nsb.append(\" net worth, \");\nsb.append(stations);\nsb.append(\" stations.\");\nreturn sb.toString();\n}\npublic int compareTo(PlayerDetails test) {\nlong l = test.networth.getAmount() - networth.getAmount();\nreturn (int) l;\n}\n}\n} // @jve:decl-index=0:visual-constraint=\"67,32\""}
{"className":"jfreerails.client.view.SelectEngineJPanel","javaDoc":"/**\n* This JPanel lets the user select an engine from a list.\n*\n* @author lindsal8\n*\n*/","code":"/**\n* This JPanel lets the user select an engine from a list.\n*\n* @author lindsal8\n*\n*/\npublic class SelectEngineJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 4122537730158179638L;\npublic SelectEngineJPanel() {\ninitComponents();\njList1ValueChanged(null); // Disable the ok button if no engine type\n// is selected.\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the FormEditor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nokjButton = new javax.swing.JButton();\ncanceljButton = new javax.swing.JButton();\njScrollPane1 = new javax.swing.JScrollPane();\njList1 = new javax.swing.JList();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(400, 350));\nokjButton.setText(\"OK\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(10, 10, 9, 10);\nadd(okjButton, gridBagConstraints);\ncanceljButton.setText(\"Cancel\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);\nadd(canceljButton, gridBagConstraints);\njList1\n.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\njList1\n.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(\njavax.swing.event.ListSelectionEvent evt) {\njList1ValueChanged(evt);\n}\n});\njScrollPane1.setViewportView(jList1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridwidth = 3;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) { // GEN-FIRST:event_jList1ValueChanged\n// We need to disable the OK button if no engine type is selected.\nif (-1 == jList1.getSelectedIndex()) {\nokjButton.setEnabled(false);\n} else {\nokjButton.setEnabled(true);\n}\n} // GEN-LAST:event_jList1ValueChanged\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JButton canceljButton;\nprivate javax.swing.JList jList1;\nprivate javax.swing.JScrollPane jScrollPane1;\nprivate javax.swing.JButton okjButton;\n// End of variables declaration//GEN-END:variables\nfinal private class TrainCellRenderer implements ListCellRenderer {\nfinal JLabel label;\nfinal RenderersRoot rr;\npublic TrainCellRenderer(RenderersRoot vl) {\nrr = vl;\nlabel = new JLabel();\n}\npublic Component getListCellRendererComponent(JList list, Object value,\n/* value to display */\nint index, /* cell index */\nboolean isSelected, /* is the cell selected */\nboolean cellHasFocus) /* the list and the cell have the focus */{\nEngineType engine = (EngineType) value;\nlabel.setFont(new java.awt.Font(\"Dialog\", 0, 12));\nString text = \"<html><body>\" + (isSelected ? \"<strong>\" : \"\")\n+ engine.getEngineTypeName() + \"<br>\"\n+ engine.getMaxSpeed() + \" m.p.h. \"\n+ engine.getPowerAtDrawbar() + \" hp $\"\n+ engine.getPrice().toString()\n+ (isSelected ? \"</strong>\" : \"\") + \"</body></html>\";\nlabel.setText(text);\nImage image = rr.getEngineImages(index).getSideOnImage();\nint height = image.getHeight(null);\nint width = image.getWidth(null);\nint scale = height / 50;\nImageIcon icon = new ImageIcon(image.getScaledInstance(width\n/ scale, height / scale, Image.SCALE_FAST));\nlabel.setIcon(icon);\nreturn label;\n}\n}\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\njList1.setModel(new World2ListModelAdapter(mr.getWorld(),\nSKEY.ENGINE_TYPES));\njList1.setCellRenderer(new TrainCellRenderer(vl));\nokjButton.addActionListener(closeAction);\n}\n/**\n* Removes any existing ActionListener listeners from the cancel button,\n* then adds the specified one.\n*/\nvoid setCancelButtonActionListener(ActionListener l) {\nActionListener[] oldListeners = canceljButton.getActionListeners();\nfor (int i = 0; i < oldListeners.length; i++) {\ncanceljButton.removeActionListener(oldListeners[i]);\n}\nthis.canceljButton.addActionListener(l);\n}\n/**\n* Returns the number of the currently selected engine type.\n*\n*/\npublic int getEngineType() {\nreturn jList1.getSelectedIndex();\n}\n}"}
{"className":"jfreerails.client.view.BalanceSheetHtmlJPanel","javaDoc":"/**\n* A HtmlJPanel that displays the balance sheet.\n*\n* @author Luke\n*\n*/","code":"/**\n* A HtmlJPanel that displays the balance sheet.\n*\n* @author Luke\n*\n*/\npublic class BalanceSheetHtmlJPanel extends HtmlJPanel implements View {\nprivate static final long serialVersionUID = 3257009873370886964L;\nprivate String template;\nprivate int lastNumTransactions = 0;\nprivate ModelRoot modelRoot;\npublic BalanceSheetHtmlJPanel() {\nsuper();\nURL url = BalanceSheetHtmlJPanel.class\n.getResource(\"/jfreerails/client/view/balance_sheet.htm\");\ntemplate = loadText(url);\n}\n@Override\npublic void setup(ModelRoot modelRoot, RenderersRoot vl, Action closeAction) {\nsuper.setup(modelRoot, vl, closeAction);\nthis.modelRoot = modelRoot;\nupdateHtml();\n}\nprivate void updateHtml() {\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal playerPrincipal = modelRoot.getPrincipal();\nBalanceSheetGenerator balanceSheetGenerator = new BalanceSheetGenerator(\nworld, playerPrincipal);\nString populatedTemplate = populateTokens(template,\nbalanceSheetGenerator);\nsetHtml(populatedTemplate);\n}\n@Override\nprotected void paintComponent(Graphics g) {\n/* Check to see if the text needs updating before painting. */\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal playerPrincipal = modelRoot.getPrincipal();\nint currentNumberOfTransactions = world\n.getNumberOfTransactions(playerPrincipal);\nif (currentNumberOfTransactions != lastNumTransactions) {\nupdateHtml();\n}\nsuper.paintComponent(g);\n}\n}"}
{"className":"jfreerails.client.view.TerrainInfoJPanel","javaDoc":"/**\n* This JPanel shows information on a terrain type.\n*\n* @author Luke\n*/","code":"/**\n* This JPanel shows information on a terrain type.\n*\n* @author Luke\n*/\npublic class TerrainInfoJPanel extends javax.swing.JPanel {\nprivate static final long serialVersionUID = 3258131375164045363L;\nprivate RenderersRoot rr;\nprivate ReadOnlyWorld w;\npublic TerrainInfoJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nterrainImage = new javax.swing.JLabel();\nterrainName = new javax.swing.JLabel();\nterrainDescription = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\nterrainImage.setIcon(new javax.swing.ImageIcon(getClass().getResource(\n\"/jfreerails/client/graphics/terrain/City_0.png\")));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.insets = new java.awt.Insets(8, 8, 4, 4);\nadd(terrainImage, gridBagConstraints);\nterrainName.setFont(new java.awt.Font(\"Dialog\", 1, 14));\nterrainName.setText(\"City\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 8);\nadd(terrainName, gridBagConstraints);\nterrainDescription.setFont(new java.awt.Font(\"Dialog\", 0, 12));\nterrainDescription\n.setText(\"<html>\\n<p>Right-of-Way costs X per mile. </p>\\n<table width=\\\"75%\\\" >\\n <tr> \\n <td><strong>Supplies:</strong></td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr> \\n <td>Mail </td>\\n <td>2</td>\\n </tr>\\n <tr> \\n <td>Passengers</td>\\n <td>2</td>\\n </tr>\\n <tr> \\n <td> <strong>Demands</strong></td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr> \\n <td>Mail</td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr> \\n <td>Passengers</td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr> \\n <td><strong>Converts</strong></td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr> \\n <td>Livestock to Food</td>\\n <td>&nbsp;</td>\\n </tr>\\n <tr>\\n <td>Steel to Goods</td>\\n <td>&nbsp;</td>\\n </tr>\\n</table>\\n</html>\");\nterrainDescription.setVerticalAlignment(javax.swing.SwingConstants.TOP);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 8, 4, 8);\nadd(terrainDescription, gridBagConstraints);\n}// GEN-END:initComponents\npublic void setup(ReadOnlyWorld w, RenderersRoot vl) {\nthis.w = w;\nthis.rr = vl;\n}\npublic void setTerrainType(int typeNumber) {\nTerrainType type = (TerrainType) w.get(SKEY.TERRAIN_TYPES, typeNumber);\nString row = \"<p>Right-of-Way costs $\" + type.getRightOfWay()\n+ \" per mile. </p>\";\nString tableString = \"\";\nint cargosProduced = type.getProduction().size();\nint cargosConsumed = type.getConsumption().size();\nint cargosConverted = type.getConversion().size();\nif ((cargosProduced + cargosConsumed + cargosConverted) > 0) {\n// if the terrain type produces, consumes, or converts anything.\ntableString = \"<table width=\\\"75%\\\" >\";\nif (cargosProduced != 0) {\ntableString += \"<tr> <td><strong>Supplies</strong></td> <td>&nbsp;</td> </tr>\";\nfor (int i = 0; i < cargosProduced; i++) {\nProduction p = type.getProduction().get(i);\nCargoType c = (CargoType) w.get(SKEY.CARGO_TYPES, p\n.getCargoType());\nString supply = String.valueOf(p.getRate()\n/ WagonType.UNITS_OF_CARGO_PER_WAGON);\ntableString += \"<tr> <td>\" + c.getDisplayName()\n+ \" </td><td>\" + supply + \"</td></tr>\";\n}\n}\nif (cargosConsumed != 0) {\ntableString += \"<tr> <td><strong>Demands</strong></td> <td>&nbsp;</td> </tr>\";\nfor (int i = 0; i < cargosConsumed; i++) {\nConsumption p = type.getConsumption().get(i);\nCargoType c = (CargoType) w.get(SKEY.CARGO_TYPES, p\n.getCargoType());\ntableString += \"<tr> <td>\" + c.getDisplayName()\n+ \" </td><td>&nbsp;</td></tr>\";\n}\n}\nif (cargosConverted != 0) {\ntableString += \"<tr> <td><strong>Converts</strong></td> <td>&nbsp;</td> </tr>\";\nfor (int i = 0; i < cargosConverted; i++) {\nConversion p = type.getConversion().get(i);\nCargoType input = (CargoType) w.get(SKEY.CARGO_TYPES, p\n.getInput());\nCargoType output = (CargoType) w.get(SKEY.CARGO_TYPES, p\n.getOutput());\ntableString += \"<tr> <td colspan=\\\"2\\\">\"\n+ input.getDisplayName() + \" to \"\n+ output.getDisplayName() + \"</td></tr>\";\n}\n}\ntableString += \"</table> \";\n}\nString labelString = \"<html>\" + row + tableString + \"</html>\";\nterrainDescription.setText(labelString);\nterrainName.setText(type.getDisplayName());\nImage tileIcon = rr.getTileViewWithNumber(typeNumber)\n.getDefaultIcon();\nterrainImage.setIcon(new ImageIcon(tileIcon));\nrepaint();\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JLabel terrainDescription;\nprivate javax.swing.JLabel terrainImage;\nprivate javax.swing.JLabel terrainName;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.SelectStationJPanel","javaDoc":"/**\n* This JPanel lets the user select a station from a map and add it to a train\n* schedule.\n*\n* @author Luke\n*/","code":"/**\n* This JPanel lets the user select a station from a map and add it to a train\n* schedule.\n*\n* @author Luke\n*/\npublic class SelectStationJPanel extends javax.swing.JPanel implements View {\nprivate static final long serialVersionUID = 3258411750662877488L;\nprivate ReadOnlyWorld world;\nprivate ActionListener submitButtonCallBack;\nprivate int selectedStationID = 0;\nprivate int selectedOrderNumber = 1;\nprivate MutableSchedule schedule;\nprivate Rectangle mapRect = new Rectangle();\nprivate Rectangle visibleMapTiles = new Rectangle();\nprivate double scale = 1;\nprivate boolean needsUpdating = true;\nprivate FreerailsPrincipal principal;\npublic SelectStationJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ncargoWaitingAndDemandedJPanel1 = new jfreerails.client.view.CargoWaitingAndDemandedJPanel();\njLabel1 = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(500, 350));\naddComponentListener(new java.awt.event.ComponentAdapter() {\n@Override\npublic void componentResized(java.awt.event.ComponentEvent evt) {\nformComponentResized(evt);\n}\n@Override\npublic void componentShown(java.awt.event.ComponentEvent evt) {\nformComponentShown(evt);\n}\n});\naddKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nformKeyPressed(evt);\n}\n});\naddMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent evt) {\nformMouseClicked(evt);\n}\n});\naddMouseMotionListener(new java.awt.event.MouseMotionAdapter() {\n@Override\npublic void mouseMoved(java.awt.event.MouseEvent evt) {\nformMouseMoved(evt);\n}\n});\ncargoWaitingAndDemandedJPanel1\n.setBorder(new javax.swing.border.LineBorder(\nnew java.awt.Color(0, 0, 0)));\ncargoWaitingAndDemandedJPanel1.setPreferredSize(new java.awt.Dimension(\n165, 300));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;\ngridBagConstraints.weighty = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(cargoWaitingAndDemandedJPanel1, gridBagConstraints);\njLabel1.setText(\"Train #1 Stop 1\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;\ngridBagConstraints.weightx = 1.0;\nadd(jLabel1, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void formComponentShown(java.awt.event.ComponentEvent evt) {// GEN-FIRST:event_formComponentShown\nsetZoom();\n}// GEN-LAST:event_formComponentShown\nprivate void formMouseClicked(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseClicked\nformMouseMoved(evt);\nneedsUpdating = true;\nthis.submitButtonCallBack.actionPerformed(null);\n}// GEN-LAST:event_formMouseClicked\nprivate void formKeyPressed(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_formKeyPressed\ntry {\nStep v = KeyCode2OneTileMoveVector.getInstanceMappedToKey(evt\n.getKeyCode());\n// now find nearest station in direction of the vector.\nNearestStationFinder stationFinder = new NearestStationFinder(\nthis.world, this.principal);\nint station = stationFinder.findNearestStationInDirection(\nthis.selectedStationID, v);\nif (selectedStationID != station\n&& station != NearestStationFinder.NOT_FOUND) {\nselectedStationID = station;\ncargoWaitingAndDemandedJPanel1.display(selectedStationID);\nthis.validate();\nthis.repaint();\n}\n} catch (NoSuchElementException e) {\nif (evt.getKeyCode() == KeyEvent.VK_ENTER) {\nneedsUpdating = true;\nsubmitButtonCallBack.actionPerformed(null);\n}\n// The key pressed isn't mapped to a OneTileMoveVector so do\n// nothing.\n}\n}// GEN-LAST:event_formKeyPressed\nprivate void formComponentResized(java.awt.event.ComponentEvent evt) {// GEN-FIRST:event_formComponentResized\nsetZoom();\n}// GEN-LAST:event_formComponentResized\nprivate void formMouseMoved(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseMoved\n// Add your handling code here:\ndouble x = evt.getX();\nx = x / scale + visibleMapTiles.x;\ndouble y = evt.getY();\ny = y / scale + visibleMapTiles.y;\nNearestStationFinder stationFinder = new NearestStationFinder(\nthis.world, this.principal);\nint station = stationFinder.findNearestStation((int) x, (int) y);\nif (selectedStationID != station\n&& station != NearestStationFinder.NOT_FOUND) {\nselectedStationID = station;\ncargoWaitingAndDemandedJPanel1.display(selectedStationID);\nthis.validate();\nthis.repaint();\n}\n}// GEN-LAST:event_formMouseMoved\npublic void display(MutableSchedule newSchedule, int orderNumber) {\nthis.schedule = newSchedule;\nthis.selectedOrderNumber = orderNumber;\nTrainOrdersModel order = newSchedule.getOrder(selectedOrderNumber);\nthis.selectedStationID = order.getStationID();\n// Set the text on the title JLabel.\nthis.jLabel1.setText(\"Stop \" + String.valueOf(selectedOrderNumber + 1));\n// Set the station info panel to show the current selected station.\ncargoWaitingAndDemandedJPanel1.display(selectedStationID);\n}\n/**\n* Sets the zoom based on the size of the component and the positions of the\n* stations.\n*/\nprivate void setZoom() {\nmapRect = this.getBounds();\nRectangle r = cargoWaitingAndDemandedJPanel1.getBounds();\nmapRect.width -= r.width;\nint topLeftX = Integer.MAX_VALUE;\nint topLeftY = Integer.MAX_VALUE;\nint bottomRightX = Integer.MIN_VALUE;\nint bottomRightY = Integer.MIN_VALUE;\nNonNullElements it = new NonNullElements(KEY.STATIONS, world,\nthis.principal);\nwhile (it.next()) {\nStationModel station = (StationModel) it.getElement();\nif (station.x < topLeftX)\ntopLeftX = station.x;\nif (station.y < topLeftY)\ntopLeftY = station.y;\nif (station.x > bottomRightX)\nbottomRightX = station.x;\nif (station.y > bottomRightY)\nbottomRightY = station.y;\n}\n// Add some padding.\ntopLeftX -= 10;\ntopLeftY -= 10;\nbottomRightX += 10;\nbottomRightY += 10;\nint width = bottomRightX - topLeftX;\nint height = bottomRightY - topLeftY;\nvisibleMapTiles = new Rectangle(topLeftX, topLeftY, width, height);\nboolean heightConstraintBinds = (visibleMapTiles.getHeight() / visibleMapTiles\n.getWidth()) > (mapRect.getHeight() / mapRect.getWidth());\nif (heightConstraintBinds) {\nscale = mapRect.getHeight() / visibleMapTiles.getHeight();\n} else {\nscale = mapRect.getWidth() / visibleMapTiles.getWidth();\n}\nneedsUpdating = false;\n}\n@Override\nprotected void paintComponent(Graphics g) {\nif (needsUpdating) {\nthis.setZoom();\n}\nsuper.paintComponent(g);\nGraphics2D g2 = (Graphics2D) g;\nNonNullElements it = new NonNullElements(KEY.STATIONS, world,\nthis.principal);\n// Draw track\ng2.setColor(Color.BLACK);\nfor (int x = Math.max(0, visibleMapTiles.x); x < Math.min(\nvisibleMapTiles.width + visibleMapTiles.x, world.getMapWidth()); x++) {\nfor (int y = Math.max(0, visibleMapTiles.y); y < Math.min(\nvisibleMapTiles.height + visibleMapTiles.y, world\n.getMapHeight()); y++) {\nFreerailsTile tt = (FreerailsTile) world.getTile(x, y);\nif (!tt.getTrackPiece().equals(NullTrackPiece.getInstance())) {\ndouble xDouble = x - visibleMapTiles.x;\nxDouble = xDouble * scale;\ndouble yDouble = y - visibleMapTiles.y;\nyDouble = yDouble * scale;\ng.drawRect((int) xDouble, (int) yDouble, 1, 1);\n}\n}\n}\n// Draw stations\nwhile (it.next()) {\n/*\n* (1) The selected station is drawn green. (2) Non-selected\n* stations which are on the schedule are drawn blue. (3) Other\n* stations are drawn white. (4) If, for instance, station X is the\n* first stop on the schedule, \"1\" is drawn above the station. (5)\n* If, for instance, station X is the first and third stop on the\n* schedule, \"1, 3\" is drawn above the station. (6) The stop numbers\n* drawn above the stations are drawn using the same colour as used\n* to draw the station.\n*/\nStationModel station = (StationModel) it.getElement();\ndouble x = station.x - visibleMapTiles.x;\nx = x * scale;\ndouble y = station.y - visibleMapTiles.y;\ny = y * scale;\nint xInt = (int) x;\nint yInt = (int) y;\nString stopNumbersString = \"\";\nboolean stationIsOnSchedule = false;\nfor (int orderNumber = 0; orderNumber < schedule.getNumOrders(); orderNumber++) {\nint stationID = orderNumber == this.selectedOrderNumber ? this.selectedStationID\n: schedule.getOrder(orderNumber).getStationID();\nif (it.getIndex() == stationID) {\nif (stationIsOnSchedule) {\nstopNumbersString = stopNumbersString + \", \"\n+ String.valueOf(orderNumber + 1);\n} else {\nstopNumbersString = String.valueOf(orderNumber + 1);\n}\nstationIsOnSchedule = true;\n}\n}\nif (stationIsOnSchedule) {\nif (it.getIndex() == selectedStationID) {\ng2.setColor(Color.GREEN);\n} else {\ng2.setColor(Color.BLUE);\n}\ng2.drawString(stopNumbersString, xInt, yInt - 4);\n} else {\ng2.setColor(Color.WHITE);\n}\ng2.fillRect(xInt, yInt, 10, 10);\n}\n}\npublic void setup(ModelRoot mr, RenderersRoot vl,\nAction closeAction) {\ncargoWaitingAndDemandedJPanel1.setup(mr, vl, null);\nthis.world = mr.getWorld();\nthis.submitButtonCallBack = closeAction;\nprincipal = mr.getPrincipal();\n}\npublic MutableSchedule generateNewSchedule() {\nTrainOrdersModel oldOrders, newOrders;\noldOrders = schedule.getOrder(selectedOrderNumber);\nnewOrders = new TrainOrdersModel(selectedStationID, oldOrders\n.getConsist(), oldOrders.getWaitUntilFull(), oldOrders\n.isAutoConsist());\nschedule.setOrder(selectedOrderNumber, newOrders);\nreturn schedule;\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate jfreerails.client.view.CargoWaitingAndDemandedJPanel cargoWaitingAndDemandedJPanel1;\nprivate javax.swing.JLabel jLabel1;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.view.MapViewJComponentConcrete","javaDoc":"/**\n* Displays the map, the cursor, and user messages (which are stored on the\n* ModelRoot under the keys QUICK_MESSAGE and PERMANENT_MESSAGE).\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Displays the map, the cursor, and user messages (which are stored on the\n* ModelRoot under the keys QUICK_MESSAGE and PERMANENT_MESSAGE).\n*\n* @author Luke Lindsay\n*\n*/\nfinal public class MapViewJComponentConcrete extends MapViewJComponent\nimplements ModelRootListener {\nprivate static final long serialVersionUID = 3834868087706236208L;\nprivate static final Font USER_MESSAGE_FONT = new Font(\"Arial\", 0, 12);\nprivate static final Font LARGE_MESSAGE_FONT = new Font(\"Arial\", 0, 24);\n/**\n* The length of the array is the number of lines. This is necessary since\n* Graphics.drawString(..) doesn't know about newline characters\n*/\nprivate String[] userMessage = new String[0];\n/**\n* Message that will appear in the middle of the screen in\n* <code>LARGE_MESSAGE_FONT</code>.\n*/\nprivate String message = null;\n/** Time at which to stop displaying the current user message. */\nprivate long displayMessageUntil = 0;\nprivate FreerailsCursor mapCursor;\n/**\n* Affects scroll direction and scroll speed relative to the cursor.\n* Examples:\n* <p>\n* 1 := grab map, move 1:1\n* <p>\n* -2 := invert mouse, scroll twice as fast\n*/\nprivate final int LINEAR_ACCEL = -1;\n/**\n* Affects the granularity of the map scrolling (the map is scrolled in\n* tileSize/GRANULARITY intervals). Multiply this value with LINEAR_ACCEL to\n* be independent of acceleration.\n*/\nprivate final int GRANULARITY = 2 * LINEAR_ACCEL;\n/**\n* A {@link Robot} to compensate mouse cursor movement.\n*/\nprivate static Robot robot;\nstatic {\ntry {\nrobot = new Robot();\n} catch (java.awt.AWTException e) {\n}\n}\n/**\n* Implements a MouseListener for FreerailsCursor-movement (left mouse\n* button) and a MouseMotionListener for map-scrolling (right mouse button).\n* <p>\n* Possible enhancements: setCursor(blankCursor),\n* g.draw(cursorimage,lastMouseLocation.x,lastMouseLocation.y,null)\n*/\nfinal private class MapViewJComponentMouseAdapter extends MouseInputAdapter {\n/**\n* Screen location of the mouse cursor, when the second mouse button was\n* pressed.\n*/\nprivate Point screenLocation = new Point();\nprivate Point lastMouseLocation = new Point();\n/**\n* A variable to sum up relative mouse movement.\n*/\nprivate Point sigmadelta = new Point();\n/**\n* Where to scroll - Reflects granularity, scroll direction and\n* acceleration, respects bounds.\n*/\nprivate Point tiledelta = new Point();\n@Override\npublic void mousePressed(MouseEvent evt) {\n/*\n* Note, moving the cursor using the mouse is now handled in\n* UserInputOnMapController\n*/\nif (SwingUtilities.isRightMouseButton(evt)) {\nMapViewJComponentConcrete.this\n.setCursor(Cursor\n.getPredefinedCursor((LINEAR_ACCEL > 0) ? Cursor.HAND_CURSOR\n: Cursor.MOVE_CURSOR));\nlastMouseLocation.x = evt.getX();\nlastMouseLocation.y = evt.getY();\nscreenLocation.x = evt.getX();\nscreenLocation.y = evt.getY();\nsigmadelta.x = 0;\nsigmadelta.y = 0;\njavax.swing.SwingUtilities.convertPointToScreen(screenLocation,\nMapViewJComponentConcrete.this);\n}\n}\n@Override\npublic void mouseReleased(MouseEvent evt) {\nMapViewJComponentConcrete.this.setCursor(Cursor\n.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n}\n@Override\npublic void mouseDragged(MouseEvent evt) {\nif (SwingUtilities.isRightMouseButton(evt)) {\nsigmadelta.x += evt.getX() - lastMouseLocation.x;\nsigmadelta.y += evt.getY() - lastMouseLocation.y;\nint tileSize = (int) getScale();\ntiledelta.x = (sigmadelta.x * GRANULARITY) / tileSize;\ntiledelta.y = (sigmadelta.y * GRANULARITY) / tileSize;\ntiledelta.x = ((tiledelta.x * tileSize) / GRANULARITY)\n* LINEAR_ACCEL;\ntiledelta.y = ((tiledelta.y * tileSize) / GRANULARITY)\n* LINEAR_ACCEL;\nRectangle vr = MapViewJComponentConcrete.this.getVisibleRect();\nRectangle bounds = MapViewJComponentConcrete.this.getBounds();\nint temp; // respect bounds\nif ((temp = vr.x - tiledelta.x) < 0) {\nsigmadelta.x += temp / LINEAR_ACCEL;\ntiledelta.x += temp;\n} else if ((temp = (bounds.width) - (vr.x + vr.width)\n+ tiledelta.x) < 0) {\nsigmadelta.x -= temp / LINEAR_ACCEL;\ntiledelta.x -= temp;\n}\nif ((temp = vr.y - tiledelta.y) < 0) {\nsigmadelta.y += temp / LINEAR_ACCEL;\ntiledelta.y += temp;\n} else if ((temp = (bounds.height) - (vr.y + vr.height)\n+ tiledelta.y) < 0) {\nsigmadelta.y -= temp / LINEAR_ACCEL;\ntiledelta.y -= temp;\n}\nif (tiledelta.x != 0 || tiledelta.y != 0) {\nvr.x -= tiledelta.x;\nvr.y -= tiledelta.y;\nMapViewJComponentConcrete.this.scrollRectToVisible(vr);\nsigmadelta.x -= tiledelta.x / LINEAR_ACCEL;\nsigmadelta.y -= tiledelta.y / LINEAR_ACCEL;\nlastMouseLocation.x -= tiledelta.x;\nlastMouseLocation.y -= tiledelta.y;\n}\nMapViewJComponentConcrete.robot.mouseMove(screenLocation.x,\nscreenLocation.y);\n}\n}\n}\n@Override\nprotected void paintComponent(java.awt.Graphics g) {\nsuper.paintComponent(g);\nif (null != mapCursor && this.isFocusOwner()) {\nmapCursor.paintCursor(g, new java.awt.Dimension(30, 30));\n}\nif (System.currentTimeMillis() < this.displayMessageUntil) {\nRectangle visRect = this.getVisibleRect();\ng.setColor(Color.WHITE);\ng.setFont(USER_MESSAGE_FONT);\nfor (int i = 0; i < userMessage.length; i++) {\ng.drawString(this.userMessage[i], 50 + visRect.x, 50\n+ visRect.y + i * 20);\n}\n}\nif (message != null) {\nRectangle visRect = this.getVisibleRect();\ng.setColor(Color.lightGray);\ng.setFont(LARGE_MESSAGE_FONT);\nint msgWidth = g.getFontMetrics(LARGE_MESSAGE_FONT).stringWidth(\nmessage);\nint msgHeight = g.getFontMetrics(LARGE_MESSAGE_FONT).getHeight();\ng.drawString(message,\n(int) (visRect.x + (visRect.getWidth() - msgWidth) / 2),\n(int) (visRect.y + (visRect.getHeight() - msgHeight) / 2));\n}\n}\npublic MapViewJComponentConcrete() {\nsuper();\nMapViewJComponentMouseAdapter mva = new MapViewJComponentMouseAdapter();\nthis.addMouseListener(mva);\nthis.addMouseMotionListener(mva);\n}\npublic void setup(MapRenderer mv, ModelRootImpl mr, RenderersRoot rr)\nthrows IOException {\nsuper.setMapView(mv);\nthis.setBorder(null);\nthis.mapCursor = new FreerailsCursor(mr, rr);\nmr.addPropertyChangeListener(this);\n}\npublic void setup(MapRenderer mv) {\nsuper.setMapView(mv);\n}\nprivate void react2cursorMove(ImPoint newPoint, ImPoint oldPoint) {\nfloat scale = getMapView().getScale();\nDimension tileSize = new Dimension((int) scale, (int) scale);\nRectangle vr = this.getVisibleRect();\nRectangle rectangleSurroundingCursor = new Rectangle(0, 0, 1, 1);\nrectangleSurroundingCursor.setLocation((newPoint.x - 1)\n* tileSize.width, (newPoint.y - 1) * tileSize.height);\nrectangleSurroundingCursor.setSize(tileSize.width * 3,\ntileSize.height * 3);\nif (!(vr.contains(rectangleSurroundingCursor))) {\nint x = newPoint.x * tileSize.width - vr.width / 2;\nint y = newPoint.y * tileSize.height - vr.height / 2;\nthis.scrollRectToVisible(new Rectangle(x, y, vr.width, vr.height));\n}\nthis.repaint((newPoint.x - 1) * tileSize.width, (newPoint.y - 1)\n* tileSize.height, tileSize.width * 3, tileSize.height * 3);\nthis.repaint((oldPoint.x - 1) * tileSize.width, (oldPoint.y - 1)\n* tileSize.height, tileSize.width * 3, tileSize.height * 3);\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\nthrow new UnsupportedOperationException();\n}\npublic void refreshTile(int x, int y) {\nthrow new UnsupportedOperationException();\n}\npublic void refreshAll() {\nthis.getMapView().refreshAll();\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nthrow new UnsupportedOperationException();\n}\npublic FreerailsCursor getMapCursor() {\nreturn mapCursor;\n}\nprivate void println(String s) {\nStringTokenizer st = new StringTokenizer(s, \"\\n\");\nthis.userMessage = new String[st.countTokens()];\nint i = 0;\nwhile (st.hasMoreTokens()) {\nuserMessage[i] = st.nextToken();\ni++;\n}\n// Display the message for 5 seconds.\ndisplayMessageUntil = System.currentTimeMillis() + 1000 * 5;\n}\n/**\n* Checks what triggered the specified PropertyChangeEvent and reacts as\n* follows.\n* <p>\n* (1) If it was ModelRoot.CURSOR_POSITION, scrolls the map if necessary.\n* </p>\n* <p>\n* (2) If it was ModelRoot.QUICK_MESSAGE, display or hide the message as\n* appropriate.\n* </p>\n* <p>\n* (3) If it was ModelRoot.PERMANENT_MESSAGE, display or hide the message as\n* appropriate.\n* </p>\n*/\npublic void propertyChange(ModelRoot.Property p, Object before, Object after) {\nif (p.equals(ModelRoot.Property.CURSOR_POSITION)) {\nImPoint newPoint = (ImPoint) after;\nImPoint oldPoint = (ImPoint) before;\nif (null == oldPoint) {\noldPoint = new ImPoint();\n}\nreact2cursorMove(newPoint, oldPoint);\n} else if (p.equals(ModelRoot.Property.QUICK_MESSAGE)) {\nString newMessage = (String) after;\nif (null != newMessage) {\nprintln(newMessage);\n} else {\n// Its null, so stop displaying whatever we where displaying.\ndisplayMessageUntil = Long.MIN_VALUE;\n}\n} else if (p.equals(ModelRoot.Property.PERMANENT_MESSAGE)) {\nmessage = (String) after;\n}\n}\n}"}
{"className":"jfreerails.client.view.PlayerColors","javaDoc":"/**\n* Stores a list of colours to use to represent different players.\n*\n* @author Luke\n*\n*/","code":"/**\n* Stores a list of colours to use to represent different players.\n*\n* @author Luke\n*\n*/\npublic class PlayerColors {\nprivate static final Color[] colors = new Color[] { Color.BLUE,\nColor.GREEN, Color.CYAN, Color.MAGENTA, Color.ORANGE, Color.YELLOW };// Save\n// red\n// for\n// when\n// we\n// need\n// to\n// grab\n// the\n// player's\n// attention!\npublic static Color getColor(int playerNumber) {\nreturn colors[playerNumber % colors.length];\n}\n}"}
{"className":"jfreerails.client.view.MapViewJComponent","javaDoc":"/**\n* JPanel that displays the map and provides methods to handle scrolling.\n*\n* @author Luke Lindsay 01 November 2001\n*/","code":"/**\n* JPanel that displays the map and provides methods to handle scrolling.\n*\n* @author Luke Lindsay 01 November 2001\n*/\npublic abstract class MapViewJComponent extends JPanel implements Scrollable,\nMapRenderer {\nprivate MapRenderer mapView = new BlankMapRenderer(10);\npublic MapViewJComponent() {\nthis.setAutoscrolls(true);\n}\npublic float getScale() {\nreturn getMapView().getScale();\n}\n@Override\nprotected void paintComponent(java.awt.Graphics g) {\njava.awt.Graphics2D g2 = (java.awt.Graphics2D) g;\njava.awt.Rectangle r = this.getVisibleRect();\ngetMapView().paintRect(g2, r);\n}\npublic int getScrollableUnitIncrement(java.awt.Rectangle rectangle,\nint orientation, int direction) {\nreturn (int) getMapView().getScale();\n}\npublic boolean getScrollableTracksViewportWidth() {\nreturn false;\n}\npublic int getScrollableBlockIncrement(java.awt.Rectangle rectangle,\nint orientation, int direction) {\nif (javax.swing.SwingConstants.VERTICAL == orientation) {\nint best = (int) (((rectangle.height / getMapView().getScale()) - 2) * getMapView()\n.getScale());\nif (best > 0) {\nreturn best;\n}\nreturn rectangle.height;\n}\nfloat f = ((rectangle.width / getMapView().getScale()) - 2)\n* getMapView().getScale();\nint best = (int) (f);\nif (best > 0) {\nreturn best;\n}\nreturn rectangle.width;\n}\n/**\n* Gets the scrollableTracksViewportHeight attribute of the\n* MapViewJComponent object.\n*\n* @return The scrollableTracksViewportHeight value\n*/\npublic boolean getScrollableTracksViewportHeight() {\nreturn false;\n}\n/**\n* Gets the preferredScrollableViewportSize attribute of the\n* MapViewJComponent object.\n*\n* @return The preferredScrollableViewportSize value\n*/\npublic java.awt.Dimension getPreferredScrollableViewportSize() {\nreturn this.getPreferredSize();\n}\npublic void centerOnTile(Point tile) {\nfloat scale = getMapView().getScale();\nRectangle visRect = new Rectangle(this.getVisibleRect());\nvisRect.x = (int) (tile.x * scale - (visRect.width / 2));\nvisRect.y = (int) (tile.y * scale - (visRect.height / 2));\nthis.scrollRectToVisible(visRect);\n}\npublic Dimension getMapSizeInPixels() {\nreturn getMapView().getMapSizeInPixels();\n}\n@Override\npublic Dimension getPreferredSize() {\nreturn getMapSizeInPixels();\n}\nvoid setMapView(MapRenderer mapView) {\nthis.mapView = mapView;\n}\npublic MapRenderer getMapView() {\nreturn mapView;\n}\n}"}
{"className":"jfreerails.client.view.ActionRoot","javaDoc":"/**\n* Provides access to Actions change the game state and the GUI.\n*\n* @author Luke\n*\n*/","code":"/**\n* Provides access to Actions change the game state and the GUI.\n*\n* @author Luke\n*\n*/\npublic class ActionRoot {\nprivate class BuildTrainDialogAction extends AbstractAction {\nprivate static final long serialVersionUID = 3257853173002416948L;\npublic BuildTrainDialogAction() {\nsuper(\"Build Train\");\nputValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_F7, 0));\nputValue(SHORT_DESCRIPTION, \"Build a new train\");\n}\npublic void actionPerformed(ActionEvent e) {\nif (dialogueBoxController != null) {\ndialogueBoxController.showSelectEngine();\n}\n}\n}\nprivate final BuildTrainDialogAction buildTrainDialogAction = new BuildTrainDialogAction();\nprivate DialogueBoxController dialogueBoxController = null;\nprivate final ServerControlModel serverControls;\nprivate StationBuildModel stationBuildModel;\nprivate TrackMoveProducer trackMoveProducer;\npublic ActionRoot(ModelRootImpl mr) {\nthis.serverControls = new ServerControlModel(mr);\n}\npublic Action getBuildTrainDialogAction() {\nreturn buildTrainDialogAction;\n}\npublic DialogueBoxController getDialogueBoxController() {\nreturn dialogueBoxController;\n}\npublic ServerControlModel getServerControls() {\nreturn serverControls;\n}\npublic StationBuildModel getStationBuildModel() {\nreturn stationBuildModel;\n}\npublic TrackMoveProducer getTrackMoveProducer() {\nreturn trackMoveProducer;\n}\npublic void setDialogueBoxController(\nDialogueBoxController dialogueBoxController) {\nthis.dialogueBoxController = dialogueBoxController;\n}\n/**\n* Call this method when a new game is started or a game is loaded.\n*/\npublic void setup(ModelRootImpl modelRoot, RenderersRoot vl) {\nserverControls.setup(modelRoot, dialogueBoxController);\nif (!modelRoot.hasBeenSetup)\nthrow new IllegalStateException();\nReadOnlyWorld world = modelRoot.getWorld();\nif (world.size(SKEY.TRACK_RULES) > 0) {\ntrackMoveProducer = new TrackMoveProducer(modelRoot);\nstationBuildModel = new StationBuildModel(new StationBuilder(\nmodelRoot), vl, modelRoot);\n}\n}\n}"}
{"className":"jfreerails.client.view.BrokerScreenHtmlJFrame","javaDoc":"/**\n*\n* @author smackay\n* @author Luke\n*/","code":"/**\n*\n* @author smackay\n* @author Luke\n*/\npublic class BrokerScreenHtmlJFrame extends BrokerJFrame implements View {\nprivate static final long serialVersionUID = 3257003246252800050L;\nprivate String template;\nprivate int lastNumTransactions = 0;\nprivate ModelRoot modelRoot;\npublic static BrokerScreenGenerator brokerScreenGenerator;\nprivate FinancialDataGatherer financialDataGatherer;\nprivate Action[] buyStock, sellStock;\n/** Creates a new instance of BrokerScreenHtmlJPanel */\npublic BrokerScreenHtmlJFrame() {\nsuper();\nURL url = BrokerScreenHtmlJFrame.class\n.getResource(\"/jfreerails/client/view/Broker_Screen.html\");\ntemplate = loadText(url);\nthis.setSize(550, 300);\n}\nprivate final Action issueBondAction = new AbstractAction(\"Issue bond\") {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nif (financialDataGatherer.canIssueBond()) {\nMove bondTransaction = new AddTransactionMove(modelRoot\n.getPrincipal(),\nBondTransaction.issueBond(financialDataGatherer\n.nextBondInterestRate()));\nmodelRoot.doMove(bondTransaction);\n}\n}\n};\nprivate final Action repayBondAction = new AbstractAction(\"Repay bond\") {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nMove bondTransaction = new AddTransactionMove(modelRoot\n.getPrincipal(), BondTransaction.repayBond(5));\nmodelRoot.doMove(bondTransaction);\n}\n};\n@Override\npublic void setup(final ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nsuper.setup(modelRoot, vl, closeAction);\nfinancialDataGatherer = new FinancialDataGatherer(modelRoot.getWorld(),\nmodelRoot.getPrincipal());\nthis.modelRoot = modelRoot;\nsetupStockMenu();\nupdateHtml();\n// Sets up the BrokerScreen and Adds ActionListeners to the Menu\nissueBond.setAction(issueBondAction);\nrepayBond.setAction(repayBondAction);\n}\nprivate void setupStockMenu(){\nstocks.removeAll();\nReadOnlyWorld world = modelRoot.getWorld();\nint thisPlayerId = world.getID(modelRoot.getPrincipal());\nint numberOfPlayers = world.getNumberOfPlayers();\nbuyStock = new Action[numberOfPlayers];\nsellStock = new Action[numberOfPlayers];\nfor(int playerId = 0 ; playerId < numberOfPlayers; playerId++){\nfinal boolean isThisPlayer = playerId == thisPlayerId;\nfinal int otherPlayerId = playerId;\nPlayer otherPlayer = world.getPlayer(playerId);\nString playerLabel = isThisPlayer ? \"Treasury stock\" : otherPlayer.getName();\nString buyLabel = \"Buy 10,000 shares of \" + playerLabel;\nString sellLabel = \"Sell 10,000 shares of \" + playerLabel;\nbuyStock[playerId] = new AbstractAction(buyLabel) {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nStockPrice stockPrice = new StockPriceCalculator(modelRoot.getWorld()).calculate()[otherPlayerId];\nMoney sharePrice = isThisPlayer ? stockPrice.treasuryBuyPrice : stockPrice.buyPrice;\nStockTransaction t = StockTransaction\n.buyOrSellStock(otherPlayerId, StockTransaction.STOCK_BUNDLE_SIZE, sharePrice);\nMove move = new AddTransactionMove(modelRoot.getPrincipal(), t);\nmodelRoot.doMove(move);\nupdateHtml();\n}\n};\nsellStock[playerId] = new AbstractAction(sellLabel) {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\nStockPrice stockPrice = new StockPriceCalculator(modelRoot.getWorld()).calculate()[otherPlayerId];\nMoney sharePrice = isThisPlayer ? stockPrice.treasurySellPrice : stockPrice.sellPrice;\nStockTransaction t = StockTransaction\n.buyOrSellStock(otherPlayerId, -StockTransaction.STOCK_BUNDLE_SIZE, sharePrice);\nMove move = new AddTransactionMove(modelRoot.getPrincipal(), t);\nmodelRoot.doMove(move);\nupdateHtml();\n}\n};\nstocks.add(buyStock[playerId]);\nstocks.add(sellStock[playerId]);\n}\nenableAndDisableActions();\n}\nprivate void enableAndDisableActions(){\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal p = modelRoot.getPrincipal();\nFinancialDataGatherer thisDataGatherer = new FinancialDataGatherer(\nworld, p);\nStockPrice[] stockPrices = new StockPriceCalculator(world).calculate();\nlong highestAffordablePrice = world.getCurrentBalance(p).getAmount() / StockTransaction.STOCK_BUNDLE_SIZE;\n//Enable and disable stock actions.\nfor(int playerId = 0; playerId < world.getNumberOfPlayers(); playerId++){\nPlayer temp = modelRoot.getWorld().getPlayer(playerId);\nFreerailsPrincipal otherPrincipal = temp.getPrincipal();\nFinancialDataGatherer otherDataGatherer = new FinancialDataGatherer(world, otherPrincipal);\n//If this RR has stock in other RR, then enable sell stock\nboolean hasStockInRR = thisDataGatherer.getStockInRRs()[playerId] > 0;\nsellStock[playerId].setEnabled(hasStockInRR);\n//If the public own some stock, then enable buy stock.\nboolean isStockAvailable = otherDataGatherer.sharesHeldByPublic() > 0;\nbuyStock[playerId].setEnabled(isStockAvailable);\n//Don't let player buy 100% of treasury stock.\nif(otherPrincipal.equals(p)){\nint treasuryStock = otherDataGatherer.treasuryStock();\nint totalStock = otherDataGatherer.totalShares();\nif(StockTransaction.STOCK_BUNDLE_SIZE + treasuryStock >= totalStock){\nbuyStock[playerId].setEnabled(false);\n}\n}\n//Don't let the player buy stock if they cannot afford it.\nif(stockPrices[playerId].currentPrice.getAmount() > highestAffordablePrice){\nbuyStock[playerId].setEnabled(false);\n}\n}\n//Enable and disable bond actions.\nint outstandingBonds = thisDataGatherer.getBonds();\nrepayBondAction.setEnabled(outstandingBonds > 0);\nissueBondAction.setEnabled(outstandingBonds < 4);\n}\nprivate void updateHtml() {\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal p = modelRoot.getPrincipal();\nbrokerScreenGenerator = new BrokerScreenGenerator(world, p);\n// this is where the Menu get Enable and Disable by if you own any stock\n// or if the TotalShares are 0\nStringBuffer populatedTemplate = new StringBuffer();\npopulatedTemplate.append(\"<html>\");\npopulatedTemplate\n.append(populateTokens(template, brokerScreenGenerator));\nfor (int i = 0; i < world.getNumberOfPlayers(); i++) {\nif (!(world.getPlayer(i).getPrincipal().equals(p))) {\nBrokerScreenGenerator temp = new BrokerScreenGenerator(world,\nworld.getPlayer(i).getPrincipal());\npopulatedTemplate.append(populateTokens(template, temp));\n}\n}\npopulatedTemplate.append(\"</html>\");\nString html = populatedTemplate.toString();\nsetHtml(html);\nenableAndDisableActions();\n}\n@Override\nprotected void paintComponent(Graphics g) {\n/* Check to see if the text needs updating before painting. */\nReadOnlyWorld world = modelRoot.getWorld();\nFreerailsPrincipal playerPrincipal = modelRoot.getPrincipal();\nint currentNumberOfTransactions = world\n.getNumberOfTransactions(playerPrincipal);\nif (currentNumberOfTransactions != lastNumTransactions) {\nupdateHtml();\n}\nsuper.paintComponent(g);\n}\n}"}
{"className":"jfreerails.client.view.TrainSummaryJPanel","javaDoc":"/**\n*\n* @author cphillips\n*/","code":"/**\n*\n* @author cphillips\n*/\npublic class TrainSummaryJPanel extends javax.swing.JPanel implements\nListCellRenderer, View {\nprivate static final long serialVersionUID = 4121133628006020919L;\nprivate jfreerails.world.top.ReadOnlyWorld w;\nprivate FreerailsPrincipal principal;\nprivate final Color backgroundColor = (java.awt.Color) javax.swing.UIManager\n.getDefaults().get(\"List.background\");\nprivate final Color selectedColor = (java.awt.Color) javax.swing.UIManager\n.getDefaults().get(\"List.selectionBackground\");\nprivate final Color selectedColorNotFocused = Color.LIGHT_GRAY;\nprivate TrainListCellRenderer trainListCellRenderer1;\n/** Creates new form TrainSummaryJPanel */\npublic TrainSummaryJPanel() {\ninitComponents();\n}\npublic void setup(ModelRoot modelRoot, RenderersRoot vl,\nAction closeAction) {\nthis.principal = modelRoot.getPrincipal();\nthis.w = modelRoot.getWorld();\ntrainListCellRenderer1 = new TrainListCellRenderer(modelRoot, vl);\ntrainListCellRenderer1.setHeight(15);\n}\nprivate String findStationName(int trainNum) {\nTrainOrdersModel orders = null;\nTrainOrdersListModel ordersList = new TrainOrdersListModel(w, trainNum,\nprincipal);\nfor (int i = 0; i < ordersList.getSize(); ++i) {\nTrainOrdersListElement element = (TrainOrdersListElement) ordersList\n.getElementAt(i);\nif (element.gotoStatus == TrainOrdersListModel.GOTO_NOW) {\norders = element.order;\nbreak;\n}\n}\nStationModel station = (StationModel) w.get(principal, KEY.STATIONS, orders\n.getStationID());\nreturn station.getStationName();\n}\nprivate String findTrainIncome(int trainNum) {\nIncomeStatementGenerator income = new IncomeStatementGenerator(w,\nprincipal);\nMoney m = income.calTrainRevenue(trainNum);\nreturn \"$\" + m.toString();\n}\npublic java.awt.Component getListCellRendererComponent(\njavax.swing.JList list, Object value, int index,\nboolean isSelected, boolean cellHasFocus) {\nint trainID = NonNullElements\n.row2index(w, KEY.TRAINS, principal, index);\ntrainNumLabel.setText(\"#\" + (trainID + 1));\nheadingLabel.setText(findStationName(trainID));\ntrainMaintenanceCostLabel.setText(findMaintenanceCost());\ntrainIncomeLabel.setText(findTrainIncome(trainID));\njava.awt.GridBagConstraints gridBagConstraints;\ntrainListCellRenderer1.setOpaque(true);\ntrainListCellRenderer1.setCenterTrain(false);\ntrainListCellRenderer1.display(trainID);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);\nadd(trainListCellRenderer1, gridBagConstraints);\nif (isSelected) {\nif (list.isFocusOwner()) {\nsetBackground(selectedColor);\ntrainListCellRenderer1.setBackground(selectedColor);\n} else {\nsetBackground(selectedColorNotFocused);\ntrainListCellRenderer1.setBackground(selectedColorNotFocused);\n}\n} else {\nsetBackground(backgroundColor);\ntrainListCellRenderer1.setBackground(backgroundColor);\n}\n// Set selected\nreturn this;\n}\nprivate String findMaintenanceCost() {\nGameTime time = w.currentTime();\nGameCalendar gameCalendar = (GameCalendar) w.get(ITEM.CALENDAR);\ndouble month = gameCalendar.getMonth(time.getTicks());\nlong cost = (long) (month / 12 * 5000);\nMoney m = new Money(cost);\nreturn \"$\" + m.toString();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ntrainNumLabel = new javax.swing.JLabel();\nheadingLabel = new javax.swing.JLabel();\ntrainMaintenanceCostLabel = new javax.swing.JLabel();\ntrainIncomeLabel = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(500, 50));\ntrainNumLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\ntrainNumLabel.setText(\"jLabel1\");\ntrainNumLabel\n.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);\ntrainNumLabel.setPreferredSize(new java.awt.Dimension(100, 25));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 10);\nadd(trainNumLabel, gridBagConstraints);\nheadingLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nheadingLabel.setText(\"jLabel2\");\nheadingLabel\n.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\nheadingLabel.setPreferredSize(new java.awt.Dimension(100, 25));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 10);\nadd(headingLabel, gridBagConstraints);\ntrainMaintenanceCostLabel\n.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\ntrainMaintenanceCostLabel.setText(\"jLabel3\");\ntrainMaintenanceCostLabel.setMaximumSize(getMaximumSize());\ntrainMaintenanceCostLabel.setPreferredSize(new java.awt.Dimension(100,\n25));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 2;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHEAST;\ngridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 10);\nadd(trainMaintenanceCostLabel, gridBagConstraints);\ntrainIncomeLabel\n.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\ntrainIncomeLabel.setText(\"jLabel1\");\ntrainIncomeLabel.setPreferredSize(new java.awt.Dimension(100, 25));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);\nadd(trainIncomeLabel, gridBagConstraints);\n}// GEN-END:initComponents\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JLabel headingLabel;\nprivate javax.swing.JLabel trainIncomeLabel;\nprivate javax.swing.JLabel trainMaintenanceCostLabel;\nprivate javax.swing.JLabel trainNumLabel;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.common.ActionAdapter","javaDoc":"/**\n* Provides a mapping from a set of ButtonModels or a ComboBoxModel to a set of\n* Actions. To use with a set of buttons, call elements() to obtain the set of\n* ButtonModels to apply to the buttons, and add each button in the enumeration\n* to a ButtonGroup. Listeners should listen for changes to the model and not to\n* any events from UI components, although UI components may call setAction() in\n* order to receive property change updates and to set icons etc.\n*\n* @author Rob\n*/","code":"/**\n* Provides a mapping from a set of ButtonModels or a ComboBoxModel to a set of\n* Actions. To use with a set of buttons, call elements() to obtain the set of\n* ButtonModels to apply to the buttons, and add each button in the enumeration\n* to a ButtonGroup. Listeners should listen for changes to the model and not to\n* any events from UI components, although UI components may call setAction() in\n* order to receive property change updates and to set icons etc.\n*\n* @author Rob\n*/\npublic class ActionAdapter extends DefaultComboBoxModel {\nprivate static final long serialVersionUID = 3546920294666351415L;\n/**\n* The set of actions which each button / menu item correspond to.\n*/\nprivate final Action[] actions;\nprivate boolean initialised = false;\nprivate boolean performActionOnSetSelectedItem = true;\n/**\n* The set of MappedButtonModels corresponding to the actions.\n*/\nprivate final Vector<MappedButtonModel> buttonModels;\n/**\n* An array of the actions to be used. The ComboBoxModel objects are taken\n* from the NAME property of the Action. The ButtonModel icons are obtained\n* from the SMALL_ICON property.\n*/\npublic ActionAdapter(Action[] actions) {\nsuper();\nthis.actions = actions;\nbuttonModels = new Vector<MappedButtonModel>();\nfor (int i = 0; i < actions.length; i++) {\nbuttonModels.add(new MappedButtonModel(actions[i]));\naddElement(actions[i].getValue(Action.NAME));\n}\ninitialised = true;\n}\n/**\n* @param actions\n* An array of the actions to be used. The ComboBoxModel objects\n* are taken from the NAME property of the Action. The\n* ButtonModel icons are obtained from the SMALL_ICON property.\n* @param selected\n* Index of the default selected action.\n*/\npublic ActionAdapter(Action[] actions, int selected) {\nthis(actions);\nfor (int i = 0; i < buttonModels.size(); i++) {\nMappedButtonModel bm = buttonModels.get(i);\nbm.setSelected(i == selected);\n}\n}\n/**\n* @return an enumeration of Action\n*/\npublic Enumeration<Action> getActions() {\nreturn new Enumeration<Action>() {\nprivate int i = 0;\npublic boolean hasMoreElements() {\nreturn (i < actions.length);\n}\npublic Action nextElement() {\nreturn actions[i++];\n}\n};\n}\n/**\n* @return an enumeration of MappedButtonModel\n*/\npublic Enumeration<MappedButtonModel> getButtonModels() {\nreturn buttonModels.elements();\n}\n/**\n* @param item\n* The NAME of the Action selected\n*/\n@Override\npublic void setSelectedItem(Object item) {\n// only set the item if not already selected\nif ((item != null) && item.equals(getSelectedItem())) {\nreturn;\n}\nsuper.setSelectedItem(item);\n// stop addElement from triggering actions\nif (!initialised) {\nreturn;\n}\nfor (int i = 0; i < buttonModels.size(); i++) {\nMappedButtonModel bm = buttonModels.get(i);\nif (bm.actionName.equals(item)) {\nbm.setSelected(true);\n}\n}\nif (performActionOnSetSelectedItem) {\nfor (int i = 0; i < actions.length; i++) {\nif (actions[i].getValue(Action.NAME).equals(item)) {\nactions[i].actionPerformed(new ActionEvent(this,\nActionEvent.ACTION_PERFORMED, (String) actions[i]\n.getValue(Action.ACTION_COMMAND_KEY)));\n}\n}\n}\n}\npublic class MappedButtonModel extends JToggleButton.ToggleButtonModel\nimplements PropertyChangeListener {\nprivate static final long serialVersionUID = 3834589889856353845L;\n/**\n* The NAME of the Action to which this ButtonModel is mapped.\n*/\npublic final String actionName;\npublic MappedButtonModel(Action action) {\nactionName = (String) action.getValue(Action.NAME);\naction.addPropertyChangeListener(this);\nsetEnabled(action.isEnabled());\n}\n@Override\npublic void setSelected(boolean b) {\nif (isSelected() != b) {\nsuper.setSelected(b);\nif (b) {\nActionAdapter.this.setSelectedItem(actionName);\n}\n}\n}\npublic void propertyChange(PropertyChangeEvent e) {\nsetEnabled(((Action) e.getSource()).isEnabled());\n}\n}\npublic void setPerformActionOnSetSelectedItem(\nboolean performActionOnSetSelectedItem) {\nthis.performActionOnSetSelectedItem = performActionOnSetSelectedItem;\n}\n}"}
{"className":"jfreerails.client.common.ImageManagerImpl","javaDoc":"/**\n* Implementation of ImageManager that returns images that are compatible with\n* the current graphics configuration and whose transparency is set to\n* TRANSLUCENT, the scaled images it returns are rendered with renderingHints\n* set for quality.\n*\n* @author Luke\n*\n*/","code":"/**\n* Implementation of ImageManager that returns images that are compatible with\n* the current graphics configuration and whose transparency is set to\n* TRANSLUCENT, the scaled images it returns are rendered with renderingHints\n* set for quality.\n*\n* @author Luke\n*\n*/\npublic class ImageManagerImpl implements ImageManager {\n/**\n* Matches anying but a string beginning with a \"/\"*. The reason for this\n* check is that relative filenames such as \"/cursor/removetrack.png\" work\n* from with files but not from within jars, which lets bugs slip in.\n*/\nprivate static final String A_REGEX = \"^[^///].*\";\nprivate static final Logger logger = Logger\n.getLogger(ImageManagerImpl.class.getName());\nprivate static final Pattern pattern = Pattern.compile(A_REGEX);\npublic static boolean isValid(String s) {\nMatcher m = pattern.matcher(s);\nreturn m.matches();\n}\nprivate final GraphicsConfiguration defaultConfiguration = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\nprivate final HashMap<String, Image> imageHashMap = new HashMap<String, Image>();\nprivate String pathToReadFrom;\nprivate String pathToWriteTo;\nprivate final RenderingHints renderingHints;\nprivate final HashMap<String, Image> scaledImagesHashMap = new HashMap<String, Image>();\npublic ImageManagerImpl(String readpath) {\nthis(readpath, null);\n}\npublic ImageManagerImpl(String readpath, String writePath) {\npathToReadFrom = readpath;\npathToWriteTo = writePath;\n// Attempt to increase quality..\nrenderingHints = new RenderingHints(\nRenderingHints.KEY_ALPHA_INTERPOLATION,\nRenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\nrenderingHints.put(RenderingHints.KEY_ANTIALIASING,\nRenderingHints.VALUE_ANTIALIAS_ON);\nrenderingHints.put(RenderingHints.KEY_INTERPOLATION,\nRenderingHints.VALUE_INTERPOLATION_BICUBIC);\n}\npublic boolean contains(String relativeFilename) {\nrelativeFilename = relativeFilename.replace(' ', '_');\nif (imageHashMap.containsKey(relativeFilename)) {\nreturn true;\n}\nFile f = new File(pathToWriteTo + File.separator + relativeFilename);\nif (f.isFile()) {\nreturn true;\n}\nreturn false;\n}\npublic Image getImage(String relativeFilename) throws IOException {\nrelativeFilename = relativeFilename.replace(' ', '_');\nif (!isValid(relativeFilename))\nthrow new IllegalArgumentException(relativeFilename\n+ \" must match \" + A_REGEX);\nif (imageHashMap.containsKey(relativeFilename)) {\nreturn imageHashMap.get(relativeFilename);\n}\n// File f = new File(pathToReadFrom+File.separator+relativeFilename);\nString read = pathToReadFrom + relativeFilename;\nread = read.replace(File.separatorChar, '/');\nURL url = ImageManagerImpl.class.getResource(read);\nif (null == url) {\nthrow new IOException(\"Couldn't find: \" + read);\n}\nImage tempImage = ImageIO.read(url);\nif (null == tempImage) {\nthrow new IOException(\"Couldn't find: \" + read);\n}\nImage compatibleImage = defaultConfiguration.createCompatibleImage(\ntempImage.getWidth(null), tempImage.getHeight(null),\nTransparency.TRANSLUCENT);\nGraphics g = compatibleImage.getGraphics();\ng.drawImage(tempImage, 0, 0, null);\nimageHashMap.put(relativeFilename, compatibleImage);\nreturn compatibleImage;\n}\n/**\n* Returns the specified image scaled so that its height is equal to the\n* specified height.\n*/\npublic Image getScaledImage(String relativeFilename, int height)\nthrows IOException {\nrelativeFilename = relativeFilename.replace(' ', '_');\nif (!isValid(relativeFilename))\nthrow new IllegalArgumentException(relativeFilename\n+ \" must match \" + A_REGEX);\nString hashKey = relativeFilename + height;\nif (this.scaledImagesHashMap.containsKey(hashKey)) {\nreturn scaledImagesHashMap.get(hashKey);\n}\nImage i = getImage(relativeFilename);\nif (i.getHeight(null) == height) {\nreturn i;\n}\nint width = (i.getWidth(null) * height) / i.getHeight(null);\nImage compatibleImage = newBlankImage(height, width);\nGraphics2D g = (Graphics2D) compatibleImage.getGraphics();\ng.setRenderingHints(this.renderingHints);\ng.drawImage(i, 0, 0, width, height, null);\nscaledImagesHashMap.put(hashKey, compatibleImage);\nreturn compatibleImage;\n}\npublic Image newBlankImage(int height, int width) {\nImage compatibleImage = defaultConfiguration.createCompatibleImage(\nwidth, height, Transparency.TRANSLUCENT);\nreturn compatibleImage;\n}\npublic void setImage(String relativeFilename, Image i) {\nrelativeFilename = relativeFilename.replace(' ', '_');\nif (i == null) {\nthrow new NullPointerException(relativeFilename);\n}\nimageHashMap.put(relativeFilename, i);\n}\npublic void setPathToReadFrom(String s) {\npathToReadFrom = s;\n}\npublic void setPathToWriteTo(String s) {\npathToWriteTo = s;\n}\npublic void writeAllImages() throws IOException {\nfor (String s : imageHashMap.keySet()) {\nwriteImage(s);\n}\n}\npublic void writeImage(String relativeFilename) throws IOException {\nif (null == pathToWriteTo)\nthrow new NullPointerException(\"null == pathToWriteTo\");\nrelativeFilename = relativeFilename.replace(' ', '_');\nFile f = new File(pathToWriteTo + File.separator + relativeFilename);\nif (imageHashMap.containsKey(relativeFilename)) {\nRenderedImage i = (RenderedImage) imageHashMap\n.get(relativeFilename);\nString pathName = f.getPath();\nFile path = new File(pathName);\npath.mkdirs();\nImageIO.write(i, \"png\", f);\nlogger.info(\"Writing \" + f);\n} else {\nthrow new NoSuchElementException(relativeFilename);\n}\n}\n}"}
{"className":"jfreerails.client.common.ModelRootImpl","javaDoc":"/**\n* Provides access to the World object and other data that is shared by GUI\n* components (for instance the cursor's position).\n*\n* @author Luke\n* @author Rob\n*/","code":"/**\n* Provides access to the World object and other data that is shared by GUI\n* components (for instance the cursor's position).\n*\n* @author Luke\n* @author Rob\n*/\npublic final class ModelRootImpl implements ModelRoot, ServerCommandReceiver {\npublic boolean hasBeenSetup = false;\nprivate MoveChainFork moveFork = new MoveChainFork();\nprivate UntriedMoveReceiver moveReceiver = new UntriedMoveReceiver() {\npublic void processMove(Move Move) {\n}\npublic void processPreMove(PreMove pm) {\n}\npublic MoveStatus tryDoMove(Move move) {\nreturn MoveStatus.moveFailed(\"No move receiver set on model root!\");\n}\n};\nprivate FreerailsPrincipal playerPrincipal;\nprivate final HashMap<Property, Object> properties = new HashMap<Property, Object>();\nprivate ServerCommandReceiver serverCommandReceiver;\nprivate ReadOnlyWorld world;\nprivate final ArrayList<ModelRootListener> listeners = new ArrayList<ModelRootListener>();\npublic ModelRootImpl() {\nproperties.put(Property.CURSOR_POSITION, new ImPoint());\nproperties.put(Property.SHOW_STATION_NAMES, Boolean.TRUE);\nproperties.put(Property.SHOW_CARGO_AT_STATIONS, Boolean.TRUE);\nproperties.put(Property.SHOW_STATION_BORDERS, Boolean.TRUE);\nproperties.put(Property.CURSOR_MODE, Value.BUILD_TRACK_CURSOR_MODE);\nproperties.put(Property.PREVIOUS_CURSOR_MODE,\nValue.BUILD_TRACK_CURSOR_MODE);\nproperties.put(Property.SERVER, \"server details not set!\");\nproperties.put(Property.PLAY_SOUNDS, Boolean.TRUE);\nproperties.put(Property.IGNORE_KEY_EVENTS, Boolean.FALSE);\nproperties.put(Property.TIME, new Double(0));\nproperties.put(Property.TRACK_BUILDER_MODE,\nTrackMoveProducer.BuildMode.BUILD_TRACK);\nproperties.put(Property.SAVED_GAMES_LIST, new ImStringList());\naddPropertyChangeListener(SoundManager.getSoundManager());\n}\npublic void addCompleteMoveReceiver(MoveReceiver l) {\nthis.moveFork.addCompleteMoveReceiver(l);\n}\npublic void addListListener(WorldListListener listener) {\nthis.moveFork.addListListener(listener);\n}\npublic void addMapListener(WorldMapListener l) {\nthis.moveFork.addMapListener(l);\n}\npublic void addPropertyChangeListener(ModelRootListener l) {\nlisteners.add(l);\n}\npublic void addSplitMoveReceiver(MoveReceiver l) {\nthis.moveFork.addSplitMoveReceiver(l);\n}\npublic MoveStatus doMove(Move m) {\nMoveStatus ms = this.moveReceiver.tryDoMove(m);\nthis.moveReceiver.processMove(m);\nreturn ms;\n}\npublic MoveStatus doPreMove(PreMove pm) {\nMove m = pm.generateMove(world);\nMoveStatus ms = moveReceiver.tryDoMove(m);\nmoveReceiver.processPreMove(pm);\nreturn ms;\n}\npublic FreerailsPrincipal getPrincipal() {\nif (null == playerPrincipal) {\nthrow new NullPointerException();\n}\nreturn playerPrincipal;\n}\npublic Object getProperty(Property p) {\nreturn properties.get(p);\n}\npublic ReadOnlyWorld getWorld() {\nreturn world;\n}\npublic void sendCommand(Message2Server c) {\nif (null != serverCommandReceiver) {\nserverCommandReceiver.sendCommand(c);\n} else {\nSystem.err.println(c.toString());\n}\n}\npublic void setMoveFork(MoveChainFork moveFork) {\nthis.moveFork = moveFork;\n}\npublic void setMoveReceiver(UntriedMoveReceiver moveReceiver) {\nthis.moveReceiver = moveReceiver;\n}\npublic void setProperty(Property p, Object newValue) {\nObject oldValue = properties.get(p);\nproperties.put(p, newValue);\nfor (ModelRootListener listener : listeners) {\nlistener.propertyChange(p, oldValue, newValue);\n}\n}\npublic void setServerCommandReceiver(\nServerCommandReceiver serverCommandReceiver) {\nthis.serverCommandReceiver = serverCommandReceiver;\n}\n/**\n* Updates the ModelRoot with those properties which are dependent upon the\n* world model. Call this when the world model is changed (e.g. new map is\n* loaded)\n*/\npublic void setup(ReadOnlyWorld world, FreerailsPrincipal p) {\nthis.world = world;\nassert p != null;\nassert world.isPlayer(p);\nplayerPrincipal = p;\nif (null == world) {\nthrow new NullPointerException();\n}\nBuildTrackStrategy bts = BuildTrackStrategy.getDefault(world);\nsetProperty(ModelRoot.Property.BUILD_TRACK_STRATEGY, bts);\nhasBeenSetup = true;\n}\npublic MoveStatus tryDoMove(Move m) {\nreturn this.moveReceiver.tryDoMove(m);\n}\npublic boolean is(ModelRoot.Property p, Object value) {\nreturn getProperty(p).equals(value);\n}\n}"}
{"className":"jfreerails.client.common.BinaryNumberFormatter","javaDoc":"/**\n* Used to generate filenames for track and terrain images.\n*\n* @author Luke\n*/","code":"/**\n* Used to generate filenames for track and terrain images.\n*\n* @author Luke\n*/\npublic class BinaryNumberFormatter {\npublic static String format(int i, int bits) {\nint maxValue = 1 << (bits);\nif (i < 0) {\nthrow new IllegalArgumentException(\n\"i must be greater than 0. It was \" + i);\n}\nif (i >= maxValue) {\nthrow new IllegalArgumentException(\"i must be less than \"\n+ maxValue + \". It was \" + i);\n}\nString s = Integer.toString(i + maxValue, 2);\nString number = s.substring(1);\nreturn number;\n}\npublic static String formatWithLowBitOnLeft(int i, int bits) {\nStringBuffer buff = new StringBuffer(format(i, bits));\nbuff.reverse();\nreturn buff.toString();\n}\n}"}
{"className":"jfreerails.client.common.MyGlassPanel","javaDoc":"/**\n* A transparent JPanel that catches key presses and mouse clicks.\n*\n* @author lindsal8\n*\n*/","code":"/**\n* A transparent JPanel that catches key presses and mouse clicks.\n*\n* @author lindsal8\n*\n*/\npublic class MyGlassPanel extends javax.swing.JPanel {\nprivate static final long serialVersionUID = 3976735856986239795L;\npublic MyGlassPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the FormEditor.\n*/\nprivate void initComponents() { // GEN-BEGIN:initComponents\ncontentPanel = new javax.swing.JPanel();\nsetLayout(new java.awt.GridBagLayout());\njava.awt.GridBagConstraints gridBagConstraints1;\nsetOpaque(false);\naddKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nformKeyPressed(evt);\n}\n});\naddMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mousePressed(java.awt.event.MouseEvent evt) {\nformMousePressed(evt);\n}\n});\naddMouseMotionListener(new java.awt.event.MouseMotionAdapter() {\n@Override\npublic void mouseMoved(java.awt.event.MouseEvent evt) {\nformMouseMoved(evt);\n}\n});\ncontentPanel.setPreferredSize(new java.awt.Dimension(60, 40));\ncontentPanel.setMinimumSize(new java.awt.Dimension(60, 40));\ncontentPanel.setBackground(java.awt.Color.red);\ncontentPanel.setMaximumSize(new java.awt.Dimension(60, 40));\ngridBagConstraints1 = new java.awt.GridBagConstraints();\ngridBagConstraints1.gridx = 2;\ngridBagConstraints1.gridy = 1;\nadd(contentPanel, gridBagConstraints1);\n}\n// GEN-END:initComponents\nprivate void formMouseMoved(java.awt.event.MouseEvent evt) { // GEN-FIRST:event_formMouseMoved\n// Add your handling code here:\n}\n// GEN-LAST:event_formMouseMoved\nprivate void formMousePressed(java.awt.event.MouseEvent evt) { // GEN-FIRST:event_formMousePressed\n// Add your handling code here:\n}\n// GEN-LAST:event_formMousePressed\nprivate void formKeyPressed(java.awt.event.KeyEvent evt) { // GEN-FIRST:event_formKeyPressed\n// Add your handling code here:\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\nprivate javax.swing.JComponent contentPanel;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.client.common.Painter","javaDoc":"/**\n* Paints a layer of the map view.\n*\n* @author Luke\n*/","code":"/**\n* Paints a layer of the map view.\n*\n* @author Luke\n*/\npublic interface Painter {\nvoid paint(Graphics2D g);\n}"}
{"className":"jfreerails.client.common.ModelRootListener","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic interface ModelRootListener {\nvoid propertyChange(ModelRoot.Property p, Object oldValue, Object newValue);\n}"}
{"className":"jfreerails.client.common.SoundManager","javaDoc":"/**\n* This class is responsible for loading and playing sounds. Samples are read\n* into a byte arrays so that they don't need to be loaded from disk each time\n* they are played.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class is responsible for loading and playing sounds. Samples are read\n* into a byte arrays so that they don't need to be loaded from disk each time\n* they are played.\n*\n* @author Luke\n*\n*/\npublic class SoundManager implements ModelRootListener, LineListener {\n/**\n* Stores the audio data and properties of a sample.\n*\n*/\nprivate static class Sample {\nbyte[] audio;\nAudioFormat format;\nDataLine.Info info;\nint size;\n}\nprivate static final Logger logger = Logger.getLogger(SoundManager.class\n.getName());\nprivate static final SoundManager soundManager = new SoundManager();\npublic static SoundManager getSoundManager() {\nreturn soundManager;\n}\npublic static void main(String[] args) {\nSoundManager soundPlayer = getSoundManager();\nfor (int i = 0; i < 100; i++) {\nsoundPlayer.playSound(\"/jfreerails/client/sounds/cash.wav\", 10);\ntry {\nThread.sleep(40);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n}\nprivate int maxLines;\nprivate Mixer mixer;\nprivate boolean playSounds = true;\nprivate HashMap<String, Sample> samples = new HashMap<String, Sample>();\nprivate final LinkedList<Clip> voices = new LinkedList<Clip>();\nprivate SoundManager() {\nAudioFormat format2 = new AudioFormat(8000f, 16, 1, true, false);\nDataLine.Info info2 = new DataLine.Info(Clip.class, format2);\nfor (Mixer.Info mo : AudioSystem.getMixerInfo()) {\nmixer = AudioSystem.getMixer(mo);\nmaxLines = mixer.getMaxLines(info2);\nif (maxLines == AudioSystem.NOT_SPECIFIED){\nmaxLines = 100;\n}\nif (maxLines >= 32)\nbreak; // Java Sound Audio Engine, version 1.0 satisfies this.\n}\nlogger.fine(\"Sound Mixer: \" + mixer.getMixerInfo() + \"(\" + maxLines\n+ \" voices).\");\n}\npublic void addClip(String s) throws IOException,\nUnsupportedAudioFileException, LineUnavailableException {\nif (samples.containsKey(s)) {\nreturn;\n}\nURL url = getClass().getResource(s);\nAudioInputStream audioInputStream = AudioSystem\n.getAudioInputStream(loadStream(url.openStream()));\nSample sample = new Sample();\nsample.format = audioInputStream.getFormat();\nsample.size = (int) (sample.format.getFrameSize() * audioInputStream\n.getFrameLength());\nsample.audio = new byte[sample.size];\nsample.info = new DataLine.Info(Clip.class, sample.format, sample.size);\naudioInputStream.read(sample.audio, 0, sample.size);\nsamples.put(s, sample);\n}\nprivate ByteArrayInputStream loadStream(InputStream inputstream)\nthrows IOException {\nByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();\nbyte[] data = new byte[1024];\nfor (int i = inputstream.read(data); i != -1; i = inputstream\n.read(data)) {\nbytearrayoutputstream.write(data, 0, i);\n}\ninputstream.close();\nbytearrayoutputstream.close();\ndata = bytearrayoutputstream.toByteArray();\nreturn new ByteArrayInputStream(data);\n}\npublic void playSound(String s, int loops) {\nif (playSounds) {\ntry {\nif (!samples.containsKey(s)) {\naddClip(s);\n}\nSample sample = samples.get(s);\nClip clip;\nif (voices.size() < maxLines) {\nclip = (Clip) mixer.getLine(sample.info);\n} else {\nclip = voices.removeFirst();\nclip.stop();\nclip.flush();\nclip.close();\n}\nclip.addLineListener(this);\nclip.open(sample.format, sample.audio, 0, sample.size);\nclip.loop(loops);\nvoices.add(clip);\n} catch (LineUnavailableException e) {\nlogger.warning(e.getMessage());\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}\npublic void propertyChange(ModelRoot.Property p, Object before, Object after) {\nif (p.equals(ModelRoot.Property.PLAY_SOUNDS)) {\nBoolean b = (Boolean) after;\nplaySounds = b.booleanValue();\n}\n}\npublic void update(LineEvent event) {\n// TODO free up resources when we have finished playing a clip.\n}\n}"}
{"className":"jfreerails.client.common.ImageManager","javaDoc":"/**\n* This interface defines methods for loading and saving images, and producing\n* scaled images whose quality may be controlled.\n*\n* @author Luke\n*\n*/","code":"/**\n* This interface defines methods for loading and saving images, and producing\n* scaled images whose quality may be controlled.\n*\n* @author Luke\n*\n*/\npublic interface ImageManager {\nImage newBlankImage(int height, int width);\nvoid setPathToReadFrom(String s);\nvoid setPathToWriteTo(String s);\nImage getImage(String relativeFilename) throws IOException;\nboolean contains(String relativeFilename);\nvoid setImage(String relativeFilename, Image i);\nvoid writeImage(String relativeFilename) throws IOException;\nvoid writeAllImages() throws IOException;\nImage getScaledImage(String relativeFilename, int height)\nthrows IOException;\n}"}
{"className":"jfreerails.client.common.RepaintManagerForActiveRendering","javaDoc":"/**\n* This RepaintManager is intended to be used when we are using active rendering\n* to paint a top level component. Repaint requests for components whose\n* TopLevelAncestor is the component being actively rendered in the game loop\n* are ignored; repaint requests for components whose TopLevelAncestor is\n* <strong>not</strong> the component being actively rendered in the game loop\n* are processed normally. This behaviour is needed because when menus extend\n* outside the bounds of their parent window, they have a different top level\n* component to the parent window, so are not painted when paintComponents is\n* called from the game loop.\n*\n* @author Luke\n*\n*/","code":"/**\n* This RepaintManager is intended to be used when we are using active rendering\n* to paint a top level component. Repaint requests for components whose\n* TopLevelAncestor is the component being actively rendered in the game loop\n* are ignored; repaint requests for components whose TopLevelAncestor is\n* <strong>not</strong> the component being actively rendered in the game loop\n* are processed normally. This behaviour is needed because when menus extend\n* outside the bounds of their parent window, they have a different top level\n* component to the parent window, so are not painted when paintComponents is\n* called from the game loop.\n*\n* @author Luke\n*\n*/\npublic final class RepaintManagerForActiveRendering extends RepaintManager {\n/** The JFrame(s) that are being actively rendered in the game loop(s). */\nprivate static final HashSet<JFrame> activelyRenderedComponents = new HashSet<JFrame>();\nprivate static final RepaintManagerForActiveRendering instance = new RepaintManagerForActiveRendering();\nprivate static long numRepaintRequests = 0;\npublic static void setAsCurrentManager() {\nRepaintManager.setCurrentManager(instance);\n}\nprivate RepaintManagerForActiveRendering() {\n}\n@Override\npublic synchronized void addDirtyRegion(JComponent c, int x, int y, int w,\nint h) {\nif (hasDifferentAncestor(c)) {\nsuper.addDirtyRegion(c, x, y, w, h);\n} else {\nnumRepaintRequests++;\n}\n}\npublic static synchronized void addJFrame(JFrame f) {\nactivelyRenderedComponents.add(f);\n}\n@Override\npublic synchronized void addInvalidComponent(JComponent invalidComponent) {\nif (hasDifferentAncestor(invalidComponent)) {\nsuper.addInvalidComponent(invalidComponent);\n} else {\nnumRepaintRequests++;\n}\n}\n@Override\npublic void markCompletelyClean(JComponent aComponent) {\nif (hasDifferentAncestor(aComponent)) {\nsuper.markCompletelyClean(aComponent);\n} else {\nnumRepaintRequests++;\n}\n}\n@Override\npublic void markCompletelyDirty(JComponent aComponent) {\nif (hasDifferentAncestor(aComponent)) {\nsuper.markCompletelyDirty(aComponent);\n} else {\nnumRepaintRequests++;\n}\n}\nprivate boolean hasDifferentAncestor(JComponent aComponent) {\nContainer topLevelAncestor = aComponent.getTopLevelAncestor();\nif (null == topLevelAncestor\n|| activelyRenderedComponents.contains(topLevelAncestor)) {\nreturn false;\n}\nreturn true;\n}\npublic static long getNumRepaintRequests() {\nreturn numRepaintRequests;\n}\n}"}
{"className":"jfreerails.client.renderer.TileRendererList","javaDoc":"/**\n* A list of TileRenderers.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* A list of TileRenderers.\n*\n* @author Luke Lindsay 09 October 2001\n*/\npublic interface TileRendererList {\nTileRenderer getTileViewWithNumber(int i);\n/**\n* Checks whether this tile view list has tile views for all the terrain\n* types in the specified list.\n*/\nboolean validate(ReadOnlyWorld world);\n}"}
{"className":"jfreerails.client.renderer.BuildTrackController","javaDoc":"/**\n* This class provides methods to change the proposed track and save it to the\n* real world.\n*\n* TODO jfreerails.client.renderer is not the most logical place for this class.\n*\n* @author MystiqueAgent\n* @author Luke\n*\n*/","code":"/**\n* This class provides methods to change the proposed track and save it to the\n* real world.\n*\n* TODO jfreerails.client.renderer is not the most logical place for this class.\n*\n* @author MystiqueAgent\n* @author Luke\n*\n*/\npublic class BuildTrackController implements GameModel {\nprivate static final Logger LOGGER = Logger\n.getLogger(BuildTrackController.class.getName());\nprivate boolean buildNewTrack = true;\nprivate List<ImPoint> builtTrack = new ArrayList<ImPoint>();\nprivate boolean isBuildTrackSuccessful = false;\nprivate final ModelRoot modelRoot;\nprivate Step[] path;\nprivate TrackPathFinder path4newTrackFinder;\nprivate PathOnTrackFinder pathOnExistingTrackFinder;\nprivate FreerailsPrincipal principal;\nprivate ReadOnlyWorld realWorld;\nprivate SoundManager soundManager = SoundManager.getSoundManager();\nprivate ImPoint startPoint;\nprivate ImPoint targetPoint;\nprivate boolean visible = false;\nprivate WorldDiffs worldDiffs;\n/**\n* BuildTrackRenderer\n*\n* @param readOnlyWorld\n* ReadOnlyWorld\n*/\npublic BuildTrackController(ReadOnlyWorld readOnlyWorld, ModelRoot modelRoot) {\nworldDiffs = new WorldDiffs(readOnlyWorld);\nrealWorld = readOnlyWorld;\npath4newTrackFinder = new TrackPathFinder(readOnlyWorld, modelRoot\n.getPrincipal());\npathOnExistingTrackFinder = new PathOnTrackFinder(readOnlyWorld);\nthis.modelRoot = modelRoot;\nprincipal = modelRoot.getPrincipal();\nsetWorldDiffs(worldDiffs);\n}\n/** Utility method that gets the BuildTrackStrategy from the model root. */\nprivate BuildTrackStrategy getBts() {\nBuildTrackStrategy btss = (BuildTrackStrategy) modelRoot\n.getProperty(ModelRoot.Property.BUILD_TRACK_STRATEGY);\nif (null == btss)\nthrow new NullPointerException();\nreturn btss;\n}\n/** Utility method that gets the cursor position from the model root. */\nprivate ImPoint getCursorPosition() {\nImPoint point = (ImPoint) modelRoot\n.getProperty(ModelRoot.Property.CURSOR_POSITION);\n// Check for null & make a defensive copy\npoint = null == point ? new ImPoint() : point;\nif (!modelRoot.getWorld().boundsContain(point.x, point.y)) {\nthrow new IllegalStateException(String.valueOf(point));\n}\nreturn point;\n}\n/** Hides and cancels any proposed track. */\npublic void hide() {\nthis.setVisible(false);\nsetTargetPoint(null);\nreset();\n}\n/**\n* returns <code>true</code> if the track is being build - it is iff the\n* build track is shown\n*\n* @return boolean\n*/\npublic boolean isBuilding() {\nreturn visible;\n}\n/** Returns true if all the track pieces can be successfully built. */\npublic boolean isBuildTrackSuccessful() {\nreturn isBuildTrackSuccessful;\n}\n/** Moves cursor which causes track to be built on the worldDiff object. */\nprivate void moveCursorMoreTiles(List<ImPoint> track) {\nmoveCursorMoreTiles(track, null);\n}\n/**\n* uses <code>trackBuilder</code> if not null -- otherwise uses own\n* <code>buildTrack</code> method - that is applied on\n* <code>worldDifferences</code>\n*\n* @param track\n* List\n* @param trackBuilder\n* TrackMoveProducer\n*/\nprivate MoveStatus moveCursorMoreTiles(List<ImPoint> track,\nTrackMoveProducer trackBuilder) {\nImPoint oldPosition = getCursorPosition();\nif(!Step.checkValidity(oldPosition, track.get(0))){\nthrow new IllegalStateException(oldPosition.toString()+ \" and \"+track.get(0).toString());\n}\nMoveStatus ms = null;\nint piecesOfNewTrack = 0;\nif (null != trackBuilder) {\ntrackBuilder.setBuildTrackStrategy(getBts());\n}\nfor (Iterator<ImPoint> iter = track.iterator(); iter.hasNext();) {\nImPoint point = iter.next();\nLOGGER.fine(\"point\" + point);\nLOGGER.fine(\"oldPosition\" + oldPosition);\nif (oldPosition.equals(point)) {\nLOGGER.fine(\"(oldPosition.equals(point))\" + point);\ncontinue;\n}\nStep vector = Step.getInstance(point.x - oldPosition.x, point.y\n- oldPosition.y);\n// If there is already track between the two tiles, do nothing\nFreerailsTile tile = (FreerailsTile) realWorld.getTile(\noldPosition.x, oldPosition.y);\nif (tile.getTrackPiece().getTrackConfiguration().contains(vector)) {\noldPosition = point;\ncontinue;\n}\npiecesOfNewTrack++;\nif (trackBuilder != null) {\nms = trackBuilder.buildTrack(oldPosition, vector);\n} else {\nms = planBuildingTrack(oldPosition, vector);\n}\nif (ms.ok) {\nsetCursorMessage(\"\");\n} else {\nsetCursorMessage(ms.message);\nreset();\nreturn ms;\n}\noldPosition = point;\n}\n/* Check whether there is already track at every point. */\nif (piecesOfNewTrack == 0) {\nMoveStatus moveFailed = MoveStatus.moveFailed(\"Track already here\");\nsetCursorMessage(moveFailed.message);\nreturn moveFailed;\n}\nisBuildTrackSuccessful = true;\n// If track has actually been built, play the build track sound.\nif (trackBuilder != null && ms.isOk()) {\nif (trackBuilder.getTrackBuilderMode() == BUILD_TRACK) {\nthis.soundManager.playSound(\n\"/jfreerails/client/sounds/buildtrack.wav\", 0);\n}\n}\nreturn ms;\n}\n/**\n* Attempts to building track from the specified point in the specified\n* direction on the worldDiff object.\n*/\nprivate MoveStatus planBuildingTrack(ImPoint point, Step vector) {\nFreerailsTile tileA = (FreerailsTile) worldDiffs.getTile(point.x,\npoint.y);\nBuildTrackStrategy bts = getBts();\nint trackTypeAID = bts.getRule(tileA.getTerrainTypeID());\nTrackRule trackRuleA = (TrackRule) worldDiffs.get(SKEY.TRACK_RULES,\ntrackTypeAID);\nFreerailsTile tileB = (FreerailsTile) worldDiffs.getTile(point.x\n+ vector.deltaX, point.y + vector.deltaY);\nint trackTypeBID = bts.getRule(tileB.getTerrainTypeID());\nTrackRule trackRuleB = (TrackRule) worldDiffs.get(SKEY.TRACK_RULES,\ntrackTypeBID);\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(point, vector, trackRuleA, trackRuleB,\nworldDiffs, principal);\nreturn move.doMove(worldDiffs, principal);\n}\n/** Cancels any proposed track and resets the path finder. */\nprivate void reset() {\nworldDiffs.reset();\npath4newTrackFinder.abandonSearch();\nthis.builtTrack.clear();\nthis.isBuildTrackSuccessful = false;\n}\nint searchStatus() {\nif (buildNewTrack) {\nreturn path4newTrackFinder.getStatus();\n}\nreturn pathOnExistingTrackFinder.getStatus();\n}\n/** Utility method that sets the CURSOR_MESSAGE property on the model root. */\nprivate void setCursorMessage(String s) {\nmodelRoot.setProperty(ModelRoot.Property.CURSOR_MESSAGE, s);\n}\n/** Sets the proposed track: from the current cursor position to the specified point.*/\npublic void setProposedTrack(ImPoint to,\nTrackMoveProducer trackBuilder) {\nImPoint from = getCursorPosition();\nassert (trackBuilder.getTrackBuilderMode() != IGNORE_TRACK);\nassert (trackBuilder.getTrackBuilderMode() != BUILD_STATION);\nbuildNewTrack = trackBuilder.getTrackBuilderMode() == BUILD_TRACK;\n/*\n* If we have just found the route between the two points, don't waste\n* time doing it again.\n*/\nif (null != targetPoint && null != startPoint\n&& targetPoint.equals(to)\n&& startPoint.equals(from)\n&& searchStatus() != IncrementalPathFinder.SEARCH_NOT_STARTED) {\nreturn;\n}\nworldDiffs.reset();\nbuiltTrack.clear();\nisBuildTrackSuccessful = false;\nif (from.equals(to)) {\nhide();\nreturn;\n}\n/* Check both points are on the map. */\nif (!realWorld.boundsContain(from.x, from.y)\n|| !realWorld.boundsContain(to.x, to.y)) {\nhide();\nreturn;\n}\nsetTargetPoint(to);\nstartPoint = from;\ntry {\nBuildTrackStrategy bts = getBts();\nif (buildNewTrack) {\npath4newTrackFinder.setupSearch(from, to, bts);\n} else {\npathOnExistingTrackFinder.setupSearch(from, to);\n}\n} catch (PathNotFoundException e) {\nsetCursorMessage(e.getMessage());\nreturn;\n}\nupdateSearch();\n}\n/**\n* @param newTargetPoint\n* The m_targetPoint to set.\n*/\nprivate void setTargetPoint(ImPoint newTargetPoint) {\nthis.targetPoint = newTargetPoint;\nImPoint p = null == newTargetPoint ? null : newTargetPoint;\nmodelRoot.setProperty(ModelRoot.Property.THINKING_POINT, p);\n}\nprivate void setVisible(boolean show) {\nif (show == visible) {\nreturn;\n}\nif (show) {\nsetWorldDiffs(worldDiffs);\n} else {\nsetWorldDiffs(null);\n}\nthis.visible = show;\n}\nprivate void setWorldDiffs(WorldDiffs worldDiffs) {\nmodelRoot.setProperty(ModelRoot.Property.PROPOSED_TRACK, worldDiffs);\n}\npublic void show() {\nthis.setVisible(true);\n}\npublic void update() {\n// update search for path if necessary.\nif (searchStatus() == IncrementalPathFinder.SEARCH_PAUSED) {\nupdateSearch();\n}\n}\npublic void updateUntilComplete() {\nwhile (searchStatus() != IncrementalPathFinder.PATH_FOUND) {\nupdateSearch();\n}\n}\n/**\n* Updates the search, if the search is completed, the proposed track is\n* shown.\n*/\nprivate void updateSearch() {\ntry {\nif (buildNewTrack) {\npath4newTrackFinder.search(100);\n} else {\npathOnExistingTrackFinder.search(100);\n}\n} catch (PathNotFoundException e) {\nsetCursorMessage(e.getMessage());\nreturn;\n}\nif (searchStatus() == IncrementalPathFinder.PATH_FOUND) {\nif (buildNewTrack) {\nbuiltTrack = path4newTrackFinder.pathAsPoints();\nmoveCursorMoreTiles(builtTrack);\n} else {\nboolean okSoFar = true;\npath = pathOnExistingTrackFinder.pathAsVectors();\nTrackMoveProducer.BuildMode mode = getBuildMode();\nint locationX = startPoint.x;\nint locationY = startPoint.y;\nFreerailsPrincipal fp = modelRoot.getPrincipal();\nfor (Step v : path) {\nMove move;\nattemptMove: {\nswitch (mode) {\ncase REMOVE_TRACK:\ntry {\nmove = ChangeTrackPieceCompositeMove\n.generateRemoveTrackMove(new ImPoint(\nlocationX, locationY), v,\nworldDiffs, fp);\nbreak;\n} catch (Exception e1) {\ne1.printStackTrace();\nbreak attemptMove;\n}\ncase UPGRADE_TRACK:\nint owner = ChangeTrackPieceCompositeMove.getOwner(\nfp, worldDiffs);\nFreerailsTile tile = (FreerailsTile) worldDiffs\n.getTile(locationX, locationY);\nint tt = tile.getTerrainTypeID();\nint trackRuleID = getBts().getRule(tt);\n/*\n* Skip tiles that already have the right track\n* type.\n*/\nif (trackRuleID == tile.getTrackPiece().getTrackTypeID()) {\nbreak attemptMove;\n}\nTrackRule trackRule = (TrackRule) worldDiffs.get(\nSKEY.TRACK_RULES, trackRuleID);\nTrackPiece after = new TrackPieceImpl(tile\n.getTrackPiece().getTrackConfiguration(), trackRule, owner,\ntrackRuleID);\n/*\n* We don't want to 'upgrade' a station to track.\n* See bug 874416.\n*/\nif (tile.getTrackPiece().getTrackRule().isStation()) {\nbreak attemptMove;\n}\nmove = UpgradeTrackMove.generateMove(tile\n.getTrackPiece(), after, new ImPoint(\nlocationX, locationY));\nbreak;\ndefault:\nthrow new IllegalStateException(mode.toString());\n}// end of switch statement\nMoveStatus ms = move.doMove(worldDiffs, fp);\nokSoFar = ms.ok && okSoFar;\n}// end of attemptMove\nlocationX += v.deltaX;\nlocationY += v.deltaY;\n}// end for loop\nstartPoint = new ImPoint(locationX, locationY);\nisBuildTrackSuccessful = okSoFar;\nif (okSoFar) {\nsetCursorMessage(\"\");\n}\n}\nshow();\n}\n}\nprivate TrackMoveProducer.BuildMode getBuildMode() {\nTrackMoveProducer.BuildMode mode;\nmode = (TrackMoveProducer.BuildMode) modelRoot\n.getProperty(ModelRoot.Property.TRACK_BUILDER_MODE);\nreturn mode;\n}\n/**\n* Saves track into real world\n*/\npublic ImPoint updateWorld(TrackMoveProducer trackBuilder) {\nImPoint actPoint = getCursorPosition();\nif (buildNewTrack) {\nif (builtTrack.size() > 0) {\nMoveStatus ms = moveCursorMoreTiles(builtTrack, trackBuilder);\n/* Note, reset() will have been called if ms.ok == false */\nif (ms.ok) {\nactPoint = builtTrack.get(builtTrack.size() - 1);\nbuiltTrack = new ArrayList<ImPoint>();\n}\n}\n} else {\ntrackBuilder.setBuildTrackStrategy(getBts());\nMoveStatus ms = trackBuilder.buildTrack(actPoint, path);\n//MoveStatus ms = trackBuilder.buildTrack(startPoint, path);\nif (ms.ok) {\nactPoint = targetPoint;\nsetCursorMessage(\"\");\nif (REMOVE_TRACK == getBuildMode()) {\nsoundManager.playSound(\n\"/jfreerails/client/sounds/removetrack.wav\", 0);\n} else {\nsoundManager.playSound(\n\"/jfreerails/client/sounds/buildtrack.wav\", 0);\n}\n} else {\nsetCursorMessage(ms.message);\nreset();\n}\n}\nhide();\nreturn actPoint;\n}\n}"}
{"className":"jfreerails.client.renderer.TrackPieceRendererList","javaDoc":"/**\n* A list of TrackPieceRenderers.\n*\n* @author Luke\n*/","code":"/**\n* A list of TrackPieceRenderers.\n*\n* @author Luke\n*/\nfinal public class TrackPieceRendererList {\nprivate static final Logger logger = Logger\n.getLogger(TrackPieceRendererList.class.getName());\nprivate final TrackPieceRenderer[] trackPieceViewArray;\npublic TrackPieceRenderer getTrackPieceView(int i) {\nif (NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER == i) {\nreturn NullTrackPieceRenderer.instance;\n}\nreturn trackPieceViewArray[i];\n}\npublic TrackPieceRendererList(ReadOnlyWorld w, ImageManager imageManager,\nFreerailsProgressMonitor pm) throws IOException {\n// Setup progress monitor..\npm.nextStep(w.size(SKEY.TRACK_RULES));\nint progress = 0;\npm.setValue(progress);\nint numberOfTrackTypes = w.size(SKEY.TRACK_RULES);\ntrackPieceViewArray = new TrackPieceRenderer[numberOfTrackTypes];\nfor (int i = 0; i < numberOfTrackTypes; i++) {\ntrackPieceViewArray[i] = new TrackPieceRendererImpl(w,\nimageManager, i);\npm.setValue(++progress);\n}\n}\npublic boolean validate(ReadOnlyWorld w) {\nboolean okSoFar = true;\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nIterator<TrackConfiguration> legalConfigurationsIterator = trackRule\n.getLegalConfigurationsIterator();\nTrackPieceRenderer trackPieceView = this.getTrackPieceView(i);\nif (null == trackPieceView) {\nlogger\n.warning(\"No track piece view for the following track type: \"\n+ trackRule.getTypeName());\nreturn false;\n}\nwhile (legalConfigurationsIterator.hasNext()) {\nTrackConfiguration trackConfig = legalConfigurationsIterator\n.next();\nint trackGraphicsNo = trackConfig.getTrackGraphicsID();\nImage img = trackPieceView.getTrackPieceIcon(trackGraphicsNo);\nif (null == img) {\nlogger\n.warning(\"No track piece image for the following track type: \"\n+ trackRule.getTypeName()\n+ \", with configuration: \"\n+ trackGraphicsNo);\nokSoFar = false;\n}\n}\n}\nreturn okSoFar;\n}\n}"}
{"className":"jfreerails.client.renderer.ZoomedOutMapRenderer","javaDoc":"/**\n* This class draws the overview map.\n*\n* @author Luke Lindsay\n* @author Robert Tuck\n*/","code":"/**\n* This class draws the overview map.\n*\n* @author Luke Lindsay\n* @author Robert Tuck\n*/\nfinal public class ZoomedOutMapRenderer implements MapRenderer {\nprivate final int imageWidth;\nprivate final int imageHeight;\nprivate final int mapWidth;\nprivate final int mapHeight;\nprivate final int mapX;\nprivate final int mapY;\nprivate final ReadOnlyWorld w;\nprivate BufferedImage one2oneImage;\nprivate BufferedImage mapImage;\nprivate final AffineTransform affineTransform;\n// private Graphics2D mapGraphics;\nprivate final GraphicsConfiguration defaultConfiguration = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\nprivate boolean isDirty = true;\npublic static ZoomedOutMapRenderer getInstance(ReadOnlyWorld world,\nDimension maxSize) {\n// Work with doubles to avoid rounding errors.\ndouble worldWidth = world.getMapWidth();\ndouble worldHeight = world.getMapHeight();\ndouble scale;\nif (worldWidth / worldHeight > maxSize.getWidth() / maxSize.getHeight()) {\nscale = maxSize.getWidth() / worldWidth;\n} else {\nscale = maxSize.getHeight() / worldHeight;\n}\ndouble height = scale * worldHeight;\ndouble width = scale * worldWidth;\nreturn new ZoomedOutMapRenderer(world, (int) width, (int) height, 0, 0,\nworld.getMapWidth(), world.getMapHeight());\n}\nprivate ZoomedOutMapRenderer(ReadOnlyWorld world, int width, int height,\nint mapX, int mapY, int mapWidth, int mapHeight) {\nw = world;\nthis.mapWidth = mapWidth;\nthis.mapHeight = mapHeight;\nimageHeight = height;\nimageWidth = width;\ndouble scalingFactor = ((double) imageHeight) / mapHeight;\naffineTransform = AffineTransform.getScaleInstance(scalingFactor,\nscalingFactor);\nthis.mapX = mapX;\nthis.mapY = mapY;\nrefresh();\n}\npublic float getScale() {\nreturn (float) imageHeight / (float) mapHeight;\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nrenderOffScreenImage();\ng.drawImage(mapImage, 0, 0, null);\n}\nprivate void renderOffScreenImage() {\nif (isDirty) {\nGraphics2D mapGraphics = mapImage.createGraphics();\nmapGraphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,\nRenderingHints.VALUE_INTERPOLATION_BILINEAR);\nmapGraphics.setClip(0, 0, imageWidth, imageHeight);\nmapGraphics.clearRect(0, 0, imageWidth, imageHeight);\nmapGraphics.drawImage(one2oneImage, affineTransform, null);\nisDirty = false;\n}\n}\nprivate void refreshTile(Point tile) {\nFreerailsTile tt = (FreerailsTile) w.getTile(tile.x, tile.y);\nif (tt.getTrackPiece().equals(NullTrackPiece.getInstance())) {\nint typeNumber = tt.getTerrainTypeID();\nTerrainType terrainType = (TerrainType) w.get(SKEY.TERRAIN_TYPES,\ntypeNumber);\none2oneImage.setRGB(tile.x, tile.y, terrainType.getRGB());\n} else {\n/* black with alpha of 1 */\none2oneImage.setRGB(tile.x, tile.y, 0xff000000);\n}\nisDirty = true;\n// int scaledX = (tile.x - mapX) * imageWidth / mapWidth;\n// int scaledY = (tile.y - mapY) * imageHeight / mapHeight;\n// int minx = scaledX < 2 ? 0 : scaledX - 2;\n// int miny = scaledY < 2 ? 0 : scaledY - 2;\n// int maxx = scaledX > imageWidth - 4 ? imageWidth : scaledX + 4;\n// int maxy = scaledY > imageHeight - 4 ? imageHeight : scaledY + 4;\n// mapGraphics.setClip(minx, miny, maxx - minx, maxy - miny);\n// mapGraphics.clearRect(minx, miny, maxx - minx, maxy - miny);\n// mapGraphics.drawImage(one2oneImage, affineTransform, null);\n}\n/**\n* Redraw the whole map onto a new buffer.\n*/\nprivate void refresh() {\nisDirty = true;\n/* free up memory used by the old image */\nif (mapImage != null) {\nmapImage.flush();\n}\nif (one2oneImage != null) {\none2oneImage.flush();\n}\n// if (mapGraphics != null) {\n// mapGraphics.dispose();\n// }\n/* generate a 1:1 map of the terrain layer */\none2oneImage = defaultConfiguration.createCompatibleImage(mapWidth,\nmapHeight, Transparency.TRANSLUCENT);\nmapImage = defaultConfiguration.createCompatibleImage(imageWidth,\nimageHeight, Transparency.OPAQUE);\nPoint tile = new Point();\nfor (tile.x = mapX; tile.x < mapWidth + mapX; tile.x++) {\nfor (tile.y = mapY; tile.y < mapHeight + mapY; tile.y++) {\nFreerailsTile tt = (FreerailsTile) w.getTile(tile.x, tile.y);\nif (tt.getTrackPiece().equals(NullTrackPiece.getInstance())) {\nint typeNumber = tt.getTerrainTypeID();\nTerrainType terrainType = (TerrainType) w.get(\nSKEY.TERRAIN_TYPES, typeNumber);\none2oneImage.setRGB(tile.x - mapX, tile.y - mapY,\nterrainType.getRGB());\n} else {\n/* black with alpha of 1 */\none2oneImage.setRGB(tile.x - mapX, tile.y - mapY,\n0xff000000);\n}\n}\n}\nrenderOffScreenImage();\n}\n/*\n* @see NewMapView#getMapSizeInPixels()\n*/\npublic Dimension getMapSizeInPixels() {\nreturn new Dimension(imageWidth, imageHeight);\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\ng.drawImage(mapImage, 0, 0, null);\n}\npublic void refreshTile(int x, int y) {\nrefreshTile(new Point(x, y));\n}\npublic void refreshAll() {\nrefresh();\n}\n}"}
{"className":"jfreerails.client.renderer.BufferedTiledBackgroundRenderer","javaDoc":"/**\n* This abstract class stores a buffer of the background of the current visible\n* rectangle of the map. Code that is independent of how tiles are represented,\n* e.g. whether they are square or isometric, should go here.\n*\n* @author Luke Lindsay 06 October 2001\n* @version 1.0\n*\n*/","code":"/**\n* This abstract class stores a buffer of the background of the current visible\n* rectangle of the map. Code that is independent of how tiles are represented,\n* e.g. whether they are square or isometric, should go here.\n*\n* @author Luke Lindsay 06 October 2001\n* @version 1.0\n*\n*/\npublic abstract class BufferedTiledBackgroundRenderer implements\nMapLayerRenderer {\n/**\n* This is used to create images that are compatible with the default\n* graphics configuration. Such images can be drawn to the screen quickly\n* since no conversion is needed.\n*/\nprivate final GraphicsConfiguration defaultConfig = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice()\n.getDefaultConfiguration();\n/**\n* Used to draw on the backbuffer.\n*/\nGraphics bg;\n/**\n* Used to draw on the backbuffer. It is translated so that to its users, it\n* appears they are drawing on the actual map, not a buffered region of the\n* map.\n*\n* translatedBg equals bg.translate(-bufferRect.x , -bufferRect.y);\n*/\nprivate Graphics translatedBg;\n/**\n* The bounds and location of the map region that is stored in the offscreen\n* Image backgroundBuffer.\n*/\nfinal Rectangle bufferRect = new Rectangle();\n/**\n* An offscreen image storing the background of a region of the map.\n*/\nVolatileImage backgroundBuffer;\n/**\n* Updates the backbuffer as necessary, then draws it on to the Graphics\n* object passed.\n*\n* @param outputGraphics\n* Once it has been updated, the backbuffer is drawn onto this\n* Graphics object.\n* @param newVisibleRectangle\n* The region of the map that the backbuffer must be updated to\n* display.\n*/\npublic void paintRect(Graphics outputGraphics,\nRectangle newVisibleRectangle) {\ndo {\n/*\n* If this is the first call to the paint method or the component\n* has just been resized, we need to create a new backgroundBuffer.\n*/\nif ((backgroundBuffer == null)\n|| (newVisibleRectangle.height != bufferRect.height)\n|| (newVisibleRectangle.width != bufferRect.width)) {\nsetbackgroundBuffer(newVisibleRectangle.width,\nnewVisibleRectangle.height);\n}\n// Test if image is lost and restore it.\nint valCode = backgroundBuffer.validate(defaultConfig);\nif (valCode == VolatileImage.IMAGE_INCOMPATIBLE) {\nsetbackgroundBuffer(newVisibleRectangle.width,\nnewVisibleRectangle.height);\n} else if (valCode == VolatileImage.IMAGE_RESTORED) {\nresetGraphics();\nthis.refreshBackground();\n}\n/*\n* Has the VisibleRectangle moved since the last paint?\n*/\nif ((bufferRect.x != newVisibleRectangle.x)\n|| (bufferRect.y != newVisibleRectangle.y)) {\nint dx = bufferRect.x - newVisibleRectangle.x;\nint dy = bufferRect.y - newVisibleRectangle.y;\nscrollbackgroundBuffer(dx, dy);\nbufferRect.setBounds(newVisibleRectangle);\n}\nif ((bufferRect.width != newVisibleRectangle.width)\n&& (bufferRect.height != newVisibleRectangle.height)) {\npaintBufferRectangle(newVisibleRectangle.x - bufferRect.x,\nnewVisibleRectangle.y - bufferRect.y,\nnewVisibleRectangle.width,\nnewVisibleRectangle.height);\n}\noutputGraphics.drawImage(backgroundBuffer,\nnewVisibleRectangle.x, newVisibleRectangle.y, null);\nbufferRect.setBounds(newVisibleRectangle);\n} while (backgroundBuffer.contentsLost());\n}\nprivate void refreshBackground() {\npaintBufferRectangle(0, 0, bufferRect.width, bufferRect.height);\n}\npublic void refreshAll() {\nrefreshBackground();\n}\nprivate void setbackgroundBuffer(int w, int h) {\n// Releases VRAM used by backgroundBuffer.\nif (backgroundBuffer != null) {\nbackgroundBuffer.flush();\n}\n// Create new backgroundBuffer.\nbackgroundBuffer = defaultConfig.createCompatibleVolatileImage(w, h);\nbufferRect.height = backgroundBuffer.getHeight(null);\nbufferRect.width = backgroundBuffer.getWidth(null);\nresetGraphics();\nbg.clearRect(0, 0, w, h);\nrefreshBackground();\n}\n/** When the VolatileImage is created or restored, we need to (re)create the\nGraphics objects.\n*/\nprivate void resetGraphics() {\nif (bg != null) {\nbg.dispose();\n}\nbg = backgroundBuffer.getGraphics();\nif (translatedBg != null) {\ntranslatedBg.dispose();\n}\ntranslatedBg = bg.create();\ntranslatedBg.translate(-bufferRect.x, -bufferRect.y);\n}\nprotected abstract void paintBufferRectangle(int x, int y, int width,\nint height);\nprivate void scrollbackgroundBuffer(int dx, int dy) {\nint copyWidth = bufferRect.width;\nint copyHeight = bufferRect.height;\nint copySourceX = 0;\nint copySourceY = 0;\nif (dx > 0) {\ncopyWidth -= dx;\n} else {\ncopyWidth += dx;\ncopySourceX = -dx;\n}\nif (dy > 0) {\ncopyHeight -= dy;\n} else {\ncopyHeight += dy;\ncopySourceY = -dy;\n}\nbg.copyArea(copySourceX, copySourceY, copyWidth, copyHeight, dx, dy);\nbufferRect.x -= dx;\nbufferRect.y -= dy;\n// paint exposed areas\nif (dx != 0) {\nif (dx > 0) {\nbg.setClip(0, 0, dx, bufferRect.height);\nbg.clearRect(0, 0, dx, bufferRect.height);\npaintBufferRectangle(0, 0, dx, bufferRect.height);\n} else {\nbg.setClip(bufferRect.width + dx, 0, -dx, bufferRect.height);\nbg.clearRect(bufferRect.width + dx, 0, -dx, bufferRect.height);\npaintBufferRectangle(bufferRect.width + dx, 0, -dx,\nbufferRect.height);\n}\n}\nif (dy != 0) {\nif (dy > 0) {\nbg.setClip(0, 0, bufferRect.width, dy);\nbg.clearRect(0, 0, bufferRect.width, dy);\npaintBufferRectangle(0, 0, bufferRect.width, dy);\n} else {\nbg.setClip(0, bufferRect.height + dy, bufferRect.width, -dy);\nbg.clearRect(0, bufferRect.height + dy, bufferRect.width, -dy);\npaintBufferRectangle(0, bufferRect.height + dy,\nbufferRect.width, -dy);\n}\n}\nbg.setClip(0, 0, bufferRect.width, bufferRect.height);\n}\n}"}
{"className":"jfreerails.client.renderer.StationBoxRenderer","javaDoc":"/**\n* Renders box showing the cargo waiting at a station.\n*\n* @author Luke\n*/","code":"/**\n* Renders box showing the cargo waiting at a station.\n*\n* @author Luke\n*/\npublic class StationBoxRenderer implements Painter {\nprivate static final int WAGON_IMAGE_HEIGHT = 10;\nprivate static final int SPACING = 3;\nprivate static final int MAX_WIDTH = 80;\nprivate final ReadOnlyWorld w;\nprivate final Color bgColor;\nprivate final int wagonImageWidth;\nprivate final ModelRoot modelRoot;\nprivate final Image[] cargoImages;\nprivate static final int MAX_HEIGHT = 5 * (WAGON_IMAGE_HEIGHT + SPACING);\npublic StationBoxRenderer(ReadOnlyWorld world, RenderersRoot vl,\nModelRoot modelRoot) {\nthis.w = world;\nthis.bgColor = new Color(0, 0, 200, 60);\nthis.modelRoot = modelRoot;\n// How wide will the wagon images be if we scale them so their height is\n// WAGON_IMAGE_HEIGHT?\nImage wagonImage = vl.getWagonImages(0).getSideOnImage();\nwagonImageWidth = wagonImage.getWidth(null) * WAGON_IMAGE_HEIGHT\n/ wagonImage.getHeight(null);\nint nrOfCargoTypes = w.size(SKEY.CARGO_TYPES);\ncargoImages = new Image[nrOfCargoTypes];\nfor (int i = 0; i < nrOfCargoTypes; i++) {\nString wagonFilename = vl.getWagonImages(i).sideOnFileName;\ntry {\nwagonImage = vl.getScaledImage(wagonFilename,\nWAGON_IMAGE_HEIGHT);\n} catch (IOException e) {\nthrow new IllegalArgumentException(wagonFilename);\n}\ncargoImages[i] = wagonImage;\n}\n}\npublic void paint(Graphics2D g) {\nBoolean showCargoWaiting = (Boolean) modelRoot\n.getProperty(ModelRoot.Property.SHOW_CARGO_AT_STATIONS);\nif (showCargoWaiting.booleanValue()) {\n/* We only show the station boxes for the current player. */\nFreerailsPrincipal principal = modelRoot.getPrincipal();\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w, principal);\nwhile (wi.next()) { // loop over non null stations\nStationModel station = (StationModel) wi.getElement();\nint positionX = (station.getStationX() * Constants.TILE_SIZE)\n+ Constants.TILE_SIZE / 2;\nint positionY = (station.getStationY() * Constants.TILE_SIZE)\n+ Constants.TILE_SIZE * 2;\nRectangle r = new Rectangle(positionX, positionY, MAX_WIDTH,\nMAX_HEIGHT);\ng.setColor(bgColor);\ng.fillRect(positionX, positionY, MAX_WIDTH, MAX_HEIGHT);\ng.setColor(Color.WHITE);\ng.setStroke(new BasicStroke(1f));\ng.drawRect(positionX, positionY, MAX_WIDTH, MAX_HEIGHT);\nImmutableCargoBundle cb = (ImmutableCargoBundle) w.get(\nprincipal, KEY.CARGO_BUNDLES, station\n.getCargoBundleID());\nint[][] carsLoads = calculateCarLoads(cb);\nfor (int category = 0; category < CargoType\n.getNumberOfCategories(); category++) {\nint alternateWidth = (MAX_WIDTH - 2 * SPACING)\n/ (carsLoads[category].length + 1);\nint xOffsetPerWagon = Math.min(wagonImageWidth,\nalternateWidth);\nfor (int car = 0; car < carsLoads[category].length; car++) {\nint x = positionX + (car * xOffsetPerWagon)\n+ SPACING;\nint y = positionY\n+ (category * (WAGON_IMAGE_HEIGHT + SPACING));\nint cargoType = carsLoads[category][car];\ng.drawImage(cargoImages[cargoType], x, y, null);\n}\n}\n}\n}\n}\n/**\n* The length of the returned array is the number of complete carloads of\n* the specified cargo category in the specified bundle. The values in the\n* array are the type of the cargo. E.g. if the bundle contained 2 carloads\n* of cargo type 3 and 1 of type 7, {3, 3, 7} would be returned.\n*/\nprivate int[][] calculateCarLoads(ImmutableCargoBundle cb) {\nint categories = CargoType.getNumberOfCategories();\nint numCargoTypes = w.size(SKEY.CARGO_TYPES);\nint[] numberOfCarLoads = new int[categories];\nint[][] cars = new int[categories][numCargoTypes];\nfor (int i = 0; i < numCargoTypes; i++) {\nCargoType ct = (CargoType) w.get(SKEY.CARGO_TYPES, i);\nint carsOfThisCargo = cb.getAmount(i)\n/ WagonType.UNITS_OF_CARGO_PER_WAGON;\nnumberOfCarLoads[ct.getCategory().getNumber()] += carsOfThisCargo;\ncars[ct.getCategory().getNumber()][i] += carsOfThisCargo;\n}\nint[][] returnMatrix = new int[categories][];\nfor (int category = 0; category < categories; category++) {\nint[] returnValue = new int[numberOfCarLoads[category]];\nint arrayIndex = 0;\nfor (int cargoType = 0; cargoType < numCargoTypes; cargoType++) {\nfor (int j = 0; j < cars[category][cargoType]; j++) {\nreturnValue[arrayIndex] = cargoType;\narrayIndex++;\n}\n}\nreturnMatrix[category] = returnValue;\n}\nreturn returnMatrix;\n}\n}"}
{"className":"jfreerails.client.renderer.SquareTileBackgroundRenderer","javaDoc":"/**\n* This class stores a buffer containing the terrain and track layers of current\n* visible rectangle of the map. It is responsible of painting these layers and\n* updating the buffer when the map scrolls or tiles are updated.\n*\n* @author Luke Lindsay 01 November 2001\n* @version 1.0\n*/","code":"/**\n* This class stores a buffer containing the terrain and track layers of current\n* visible rectangle of the map. It is responsible of painting these layers and\n* updating the buffer when the map scrolls or tiles are updated.\n*\n* @author Luke Lindsay 01 November 2001\n* @version 1.0\n*/\nfinal public class SquareTileBackgroundRenderer extends BufferedTiledBackgroundRenderer {\nprivate final MapLayerRenderer mapView;\n@Override\nprotected void paintBufferRectangle(int x, int y, int width, int height) {\n// Fix for bug [ 1303162 ]\n// If the buffer hasn't been set yet, don't try and refresh it!\nif (null != super.backgroundBuffer) {\nGraphics gg = bg.create();\ngg.setClip(x, y, width, height);\ngg.translate(-bufferRect.x, -bufferRect.y);\nmapView.paintRect(gg, bufferRect);\n}\n}\npublic SquareTileBackgroundRenderer(MapLayerRenderer mv) {\nif (null == mv) {\nthrow new NullPointerException();\n}\nthis.mapView = mv;\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\nmapView.paintTile(g, tileX, tileY);\n}\npublic void refreshTile(int x, int y) {\n// The backgroundBuffer gets created on the first call to\n// backgroundBuffer.paintRect(..)\n// so we need a check here to avoid a null pointer exception.\nif (null != super.backgroundBuffer) {\nGraphics gg = bg.create();\ngg.translate(-bufferRect.x, -bufferRect.y);\nmapView.paintTile(gg, x, y);\n}\n}\n}"}
{"className":"jfreerails.client.renderer.BuildTrackRenderer","javaDoc":"/**\n* This class draws the track being build.\n*\n* @author MystiqueAgent\n* @author Luke\n*\n*/","code":"/**\n* This class draws the track being build.\n*\n* @author MystiqueAgent\n* @author Luke\n*\n*/\npublic class BuildTrackRenderer implements Painter {\npublic static final int BIG_DOT_WIDTH = 12;\npublic static final int SMALL_DOT_WIDTH = 6;\nprivate final ModelRoot modelRoot;\nprivate final Dimension tileSize = new Dimension(30, 30);\nprivate RenderersRoot rr;\npublic BuildTrackRenderer(RenderersRoot trackPieceViewList,\nModelRoot modelRoot) {\nthis.modelRoot = modelRoot;\nthis.rr = trackPieceViewList;\n}\nprivate WorldDiffs getWorldDiffs() {\nif (modelRoot == null) {\nreturn null;\n}\nreturn (WorldDiffs) modelRoot\n.getProperty(ModelRoot.Property.PROPOSED_TRACK);\n}\n/**\n* Paints the proposed track and dots to distinguish the proposed track from\n* any existing track.\n*/\npublic void paint(Graphics2D g) {\nWorldDiffs worldDiffs = getWorldDiffs();\nif (null != worldDiffs) {\nfor (Iterator<ImPoint> iter = worldDiffs.getMapDiffs(); iter\n.hasNext();) {\nImPoint point = iter.next();\nFreerailsTile fp = (FreerailsTile)worldDiffs.getTile(point.x,\npoint.y);\nTrackPiece tp = fp.getTrackPiece();\nint graphicsNumber = tp.getTrackGraphicID();\nint ruleNumber = tp.getTrackTypeID();\njfreerails.client.renderer.TrackPieceRenderer trackPieceView = rr\n.getTrackPieceView(ruleNumber);\ntrackPieceView.drawTrackPieceIcon(graphicsNumber, g, point.x,\npoint.y, tileSize);\n}\nReadOnlyWorld realWorld = modelRoot.getWorld();\n/*\n* Draw small dots for each tile whose track has changed. The dots\n* are white if track has been added or upgraded and red if it has\n* been removed.\n*/\nfor (Iterator<ImPoint> iter = worldDiffs.getMapDiffs(); iter\n.hasNext();) {\nImPoint p = iter.next();\nint x = p.x * tileSize.width\n+ (tileSize.width - SMALL_DOT_WIDTH) / 2;\nint y = p.y * tileSize.width\n+ (tileSize.height - SMALL_DOT_WIDTH) / 2;\nFreerailsTile before = (FreerailsTile) realWorld.getTile(p.x,\np.y);\nFreerailsTile after = (FreerailsTile) worldDiffs.getTile(p.x,\np.y);\nboolean trackRemoved = !after.getTrackPiece().getTrackConfiguration().contains(\nbefore.getTrackPiece().getTrackConfiguration());\nColor dotColor = trackRemoved ? Color.RED : Color.WHITE;\ng.setColor(dotColor);\ng.fillOval(x, y, SMALL_DOT_WIDTH, SMALL_DOT_WIDTH);\n}\n}\n}\n}"}
{"className":"jfreerails.client.renderer.ForestStyleTileRenderer","javaDoc":"/**\n* Looks to see whether the tiles to the left and right of the same type when\n* deciding which tile icon to use.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Looks to see whether the tiles to the left and right of the same type when\n* deciding which tile icon to use.\n*\n* @author Luke Lindsay\n*/\nfinal public class ForestStyleTileRenderer extends\njfreerails.client.renderer.AbstractTileRenderer {\nprivate static final int[] X_LOOK_AT = { -1, 1 };\nprivate static final int[] Y_LOOK_AT = { 0, 0 };\npublic ForestStyleTileRenderer(ImageManager imageManager, int[] rgbValues,\nTerrainType tileModel) throws IOException {\nsuper(tileModel, rgbValues);\nthis.setTileIcons(new Image[4]);\nfor (int i = 0; i < this.getTileIcons().length; i++) {\nString fileName = generateRelativeFileName(i);\nthis.getTileIcons()[i] = imageManager.getImage(fileName);\n}\n}\n@Override\npublic int selectTileIcon(int x, int y, ReadOnlyWorld w) {\nint iconNumber = 0;\nfor (int i = 0; i < 2; i++) {\niconNumber = iconNumber\n| checkTile(x + X_LOOK_AT[i], y + Y_LOOK_AT[i], w);\niconNumber = iconNumber << 1;\n}\niconNumber = iconNumber >> 1;\nreturn iconNumber;\n}\n@Override\npublic void dumpImages(ImageManager imageManager) {\nfor (int i = 0; i < this.getTileIcons().length; i++) {\nString fileName = generateRelativeFileName(i);\nimageManager.setImage(fileName, this.getTileIcons()[i]);\n}\n}\n@Override\nprotected String generateFileNameNumber(int i) {\nreturn BinaryNumberFormatter.format(i, 2);\n}\n}"}
{"className":"jfreerails.client.renderer.MapRenderer","javaDoc":"/**\n* Lets the GUI component that is displaying the map known the scale at which\n* the map is being rendered.\n*\n* @author Luke\n*/","code":"/**\n* Lets the GUI component that is displaying the map known the scale at which\n* the map is being rendered.\n*\n* @author Luke\n*/\npublic interface MapRenderer extends MapLayerRenderer {\nfloat getScale();\nDimension getMapSizeInPixels();\n}"}
{"className":"jfreerails.client.renderer.AbstractTileRenderer","javaDoc":"/**\n* This class encapsulates the visible properties of a tile.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This class encapsulates the visible properties of a tile.\n*\n* @author Luke Lindsay\n*/\npublic abstract class AbstractTileRenderer implements TileRenderer {\nprivate final int[] typeNumbers;\nprivate Image[] tileIcons;\nprivate final TerrainType tileModel;\nAbstractTileRenderer(TerrainType t, int[] rgbValues) {\ntileModel = t;\nthis.typeNumbers = rgbValues;\nif (null == t) {\nthrow new NullPointerException();\n}\nif (null == rgbValues) {\nthrow new NullPointerException();\n}\n}\npublic void renderTile(java.awt.Graphics g, int screenX, int screenY,\nint mapX, int mapY, ReadOnlyWorld w) {\nImage icon = this.getIcon(mapX, mapY, w);\nif (null != icon) {\ng.drawImage(icon, screenX, screenY, null);\n}\n}\npublic Image getDefaultIcon() {\nreturn getTileIcons()[0];\n}\nString getTerrainType() {\nreturn tileModel.getTerrainTypeName();\n}\n/**\n* Returns an icon for the tile at x,y, which may depend on the terrain\n* types of of the surrounding tiles.\n*/\nImage getIcon(int x, int y, ReadOnlyWorld w) {\nint tile = selectTileIcon(x, y, w);\nif (getTileIcons()[tile] != null) {\nreturn getTileIcons()[tile];\n}\nthrow new NullPointerException(\"Error in TileView.getIcon: icon no. \"\n+ tile + \"==null\");\n}\nint selectTileIcon(int x, int y, ReadOnlyWorld w) {\nreturn 0;\n}\nint checkTile(int x, int y, ReadOnlyWorld w) {\nint match = 0;\nif (((x < w.getMapWidth()) && (x >= 0)) && (y < w.getMapHeight())\n&& (y >= 0)) {\nfor (int i = 0; i < typeNumbers.length; i++) {\nTerrainTile tt = (TerrainTile) w.getTile(x, y);\nif (tt.getTerrainTypeID() == typeNumbers[i]) {\nmatch = 1;\n// A match\n}\n}\n} else {\nmatch = 1; // A match\n/*\n* If the tile we are checking is off the map, let it be a match.\n* This stops coast appearing where the ocean meets the map edge.\n*/\n}\nreturn match;\n}\nabstract public void dumpImages(ImageManager imageManager);\nString generateRelativeFileName(int i) {\nreturn \"terrain\" + File.separator + this.getTerrainType() + \"_\"\n+ generateFileNameNumber(i) + \".png\";\n}\nprotected abstract String generateFileNameNumber(int i);\nvoid setTileIcons(Image[] tileIcons) {\nthis.tileIcons = tileIcons;\n}\nImage[] getTileIcons() {\nreturn tileIcons;\n}\n}"}
{"className":"jfreerails.client.renderer.CityNamesRenderer","javaDoc":"/**\n* Paints the city names on the map.\n*\n* @author Scott\n*/","code":"/**\n* Paints the city names on the map.\n*\n* @author Scott\n*/\npublic class CityNamesRenderer implements Painter {\nprivate final ReadOnlyWorld w;\npublic CityNamesRenderer(ReadOnlyWorld world) {\nthis.w = world;\n}\npublic void paint(Graphics2D g) {\ng.setColor(Color.WHITE);\ng.setFont(new Font(\"Arial\", 0, 20));\n// draw city names onto map\nfor (int i = 0; i < w.size(SKEY.CITIES); i++) {\nCityModel tempCity = (CityModel) w.get(SKEY.CITIES, i);\ng.drawString(tempCity.getCityName(), tempCity.getCityX() * 30,\ntempCity.getCityY() * 30 + 10);\n}\n}\n}"}
{"className":"jfreerails.client.renderer.NullTrackPieceRenderer","javaDoc":"/**\n* This class implements the TrackPieceView interface, but intentionally does\n* nothing. Its methods are called when drawing tiles with no track.\n*\n* @author Luke\n*/","code":"/**\n* This class implements the TrackPieceView interface, but intentionally does\n* nothing. Its methods are called when drawing tiles with no track.\n*\n* @author Luke\n*/\nfinal public class NullTrackPieceRenderer implements TrackPieceRenderer {\npublic static final NullTrackPieceRenderer instance = new NullTrackPieceRenderer();\nprivate NullTrackPieceRenderer() {\n}\n/*\n* @see TrackPieceView#getTrackPieceIcon(int)\n*/\npublic Image getTrackPieceIcon(int trackTemplate) {\nreturn null;\n}\n/*\n* @see TrackPieceView#drawTrackPieceIcon(int, Graphics, int, int,\n* Dimension)\n*/\npublic void drawTrackPieceIcon(int trackTemplate, Graphics g, int x, int y,\nDimension tileSize) {\n// Draw nothing since there no track here.\n}\npublic void dumpImages(ImageManager imageManager) {\n// TODO Auto-generated method stub\n}\n}"}
{"className":"jfreerails.client.renderer.TileRenderer","javaDoc":"/**\n* Draws an icon to represent a tile.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Draws an icon to represent a tile.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface TileRenderer {\nImage getDefaultIcon();\nvoid renderTile(java.awt.Graphics g, int renderX, int renderY, int mapX,\nint mapY, ReadOnlyWorld w);\n/** Adds the images this TileRenderer uses to the specified ImageManager. */\nvoid dumpImages(ImageManager imageManager);\n}"}
{"className":"jfreerails.client.renderer.RiverStyleTileRenderer","javaDoc":"/**\n* Selects a tile icon to use based on the type of the tiles to the North, East,\n* South and West.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Selects a tile icon to use based on the type of the tiles to the North, East,\n* South and West.\n*\n* @author Luke Lindsay\n*/\nfinal public class RiverStyleTileRenderer extends\njfreerails.client.renderer.AbstractTileRenderer {\nprivate static final int[] Y_LOOK_AT = { 0, 1, 0, -1 };\nprivate static final int[] X_LOOK_AT = { -1, 0, 1, 0 };\npublic RiverStyleTileRenderer(ImageManager imageManager, int[] rgbValues,\nTerrainType tileModel) throws IOException {\nsuper(tileModel, rgbValues);\nthis.setTileIcons(new Image[16]);\nfor (int i = 0; i < this.getTileIcons().length; i++) {\nString fileName = generateRelativeFileName(i);\nthis.getTileIcons()[i] = imageManager.getImage(fileName);\n}\n}\n@Override\npublic int selectTileIcon(int x, int y, ReadOnlyWorld w) {\nint iconNumber = 0;\nfor (int i = 0; i < 4; i++) {\niconNumber = iconNumber << 1;\niconNumber = iconNumber\n| checkTile(x + X_LOOK_AT[i], y + Y_LOOK_AT[i], w);\n}\nreturn iconNumber;\n}\n@Override\npublic void dumpImages(ImageManager imageManager) {\nfor (int i = 0; i < this.getTileIcons().length; i++) {\nimageManager.setImage(generateRelativeFileName(i), this\n.getTileIcons()[i]);\n}\n}\n@Override\nprotected String generateFileNameNumber(int i) {\nreturn BinaryNumberFormatter.formatWithLowBitOnLeft(i, 4);\n}\n}"}
{"className":"jfreerails.client.renderer.StationNamesRenderer","javaDoc":"/**\n*\n* Class to render the station names and spheres of influence on the game map.\n* Names are retrieved from the KEY.STATIONS object. Date: 14th April 2003 28\n* May 2004 updated to also show station sphere of influence.\n*\n* @author Scott Bennett\n* @author Luke Lindsay\n*\n*/","code":"/**\n*\n* Class to render the station names and spheres of influence on the game map.\n* Names are retrieved from the KEY.STATIONS object. Date: 14th April 2003 28\n* May 2004 updated to also show station sphere of influence.\n*\n* @author Scott Bennett\n* @author Luke Lindsay\n*\n*/\npublic class StationNamesRenderer implements Painter {\nprivate final ReadOnlyWorld w;\nprivate final ModelRoot modelRoot;\nprivate final int fontSize;\nprivate final Color bgColor;\nprivate final Color textColor;\nfinal static float[] dash1 = { 5.0f };\nfinal static BasicStroke dashed = new BasicStroke(1.0f,\nBasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f);\nprivate final Font font;\npublic StationNamesRenderer(ReadOnlyWorld world, ModelRoot modelRoot) {\nthis.w = world;\nthis.modelRoot = modelRoot;\nthis.fontSize = 10;\nthis.bgColor = Color.BLACK;\nthis.textColor = Color.WHITE;\nfont = new Font(\"Arial\", 0, fontSize);\n}\npublic void paint(Graphics2D g) {\nint rectWidth;\nint rectHeight;\nint rectX;\nint rectY;\nfloat visibleAdvance;\nfloat textX;\nfloat textY;\nStationModel tempStation;\nString stationName;\nint positionX;\nint positionY;\nBoolean showStationNames = (Boolean) modelRoot\n.getProperty(ModelRoot.Property.SHOW_STATION_NAMES);\nBoolean showStationBorders = (Boolean) modelRoot\n.getProperty(ModelRoot.Property.SHOW_STATION_BORDERS);\nFontRenderContext frc = g.getFontRenderContext();\nTextLayout layout;\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\n// draw station names onto map\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w, principal);\nwhile (wi.next()) { // loop over non null stations\ntempStation = (StationModel) wi.getElement();\nint x = tempStation.getStationX();\nint y = tempStation.getStationY();\n// First draw station sphere of influence\nif (showStationBorders.booleanValue()) {\nFreerailsTile tile = (FreerailsTile) w.getTile(x, y);\nint radius = tile.getTrackPiece().getTrackRule().getStationRadius();\nint diameterInPixels = (radius * 2 + 1) * 30;\nint radiusX = (x - radius) * 30;\nint radiusY = (y - radius) * 30;\ng.setColor(Color.WHITE);\ng.setStroke(dashed);\ng.draw(new RoundRectangle2D.Double(radiusX, radiusY,\ndiameterInPixels, diameterInPixels, 10, 10));\n}\n// Then draw the station name.\nif (showStationNames.booleanValue()) {\nstationName = tempStation.getStationName();\npositionX = (x * 30) + 15;\npositionY = (y * 30) + 30;\nlayout = new TextLayout(stationName, font, frc);\nvisibleAdvance = layout.getVisibleAdvance();\nrectWidth = (int) (visibleAdvance * 1.2);\nrectHeight = (int) (fontSize * 1.5);\nrectX = (positionX - (rectWidth / 2));\nrectY = positionY;\ng.setColor(bgColor);\ng.fillRect(rectX, rectY, rectWidth, rectHeight);\ntextX = (positionX - (visibleAdvance / 2));\ntextY = positionY + fontSize + 1;\ng.setColor(textColor);\nlayout.draw(g, textX, textY);\ng.setStroke(new BasicStroke(1.0f));\n// draw a border 1 pixel inside the edges of the rectangle\ng.draw(new Rectangle(rectX + 1, rectY + 1, rectWidth - 3,\nrectHeight - 3));\n}\n}\n}\n// end FOR loop\n}\n// paint method\n}"}
{"className":"jfreerails.client.renderer.TrainRenderer","javaDoc":"/**\n* This class draws a train from an overhead view.\n*\n* Also has a method that determines if a mouse click was on a train.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/","code":"/**\n* This class draws a train from an overhead view.\n*\n* Also has a method that determines if a mouse click was on a train.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/\npublic class TrainRenderer {\nprivate final RenderersRoot rr;\npublic TrainRenderer(RenderersRoot trainImages) {\nthis.rr = trainImages;\n}\n/**\n* Calculates the positions of the engine and each wagon on the map.\n* Intended to be used for rendering trains, for rendering highlights\n* around trains, and for determining if a mouse click was on a train.\n*\n* @param train\n* @param s\n* @return List of positions, one entry for the engine and one for each\n* wagon.\n*/\npublic List<Entry<Point, Step>> calcPositions(TrainModel train, TrainPositionOnMap s) {\nList<Entry<Point, Step>> positions = new ArrayList<>(train.getLength() + 1);\nFreerailsPathIterator it = s.path();\nPathWalker pw = new PathWalkerImpl(it);\n// Engine + wagons\nfor (int i = 0; i < train.getNumberOfWagons() + 1; i++) {\nIntLine wagon = new IntLine();\nIntLine line = new IntLine();\npw.stepForward(16);\nboolean firstIteration = true;\nwhile (pw.hasNext()) {\npw.nextSegment(line);\nif (firstIteration) {\nwagon.x1 = line.x1;\nwagon.y1 = line.y1;\nfirstIteration = false;\n}\n}\nwagon.x2 = line.x2;\nwagon.y2 = line.y2;\nStep v = Step\n.getNearestVector(wagon.x2 - wagon.x1, wagon.y2 - wagon.y1);\nPoint wagonCenter = new Point((wagon.x2 + wagon.x1) / 2,\n(wagon.y2 + wagon.y1) / 2);\npositions.add(new AbstractMap.SimpleImmutableEntry<>(wagonCenter, v));\n// The gap between wagons\npw.stepForward(8);\nwhile (pw.hasNext()) {\npw.nextSegment(line);\n}\n}\nreturn positions;\n}\npublic void paintTrain(Graphics g, TrainModel train, List<Entry<Point, Step>> positions) {\nfor (int i = 0; i < positions.size(); i++) {\nTrainImages trainImages;\nif (i == 0) {\ntrainImages = rr.getEngineImages(train.getEngineType());\n} else {\nint type = train.getWagon(i - 1);\ntrainImages = rr.getWagonImages(type);\n}\nEntry<Point, Step> entry = positions.get(i);\nImage image = trainImages.getOverheadImage(entry.getValue().getID());\nPoint p = entry.getKey();\ng.drawImage(image, p.x - 15, p.y - 15, null);\n}\n}\npublic void paintTrainHighlight(Graphics g, TrainModel train, List<Entry<Point, Step>> positions, TrainImages.Highlight highlight) {\nfor (int i = 0; i < positions.size(); i++) {\nTrainImages trainImages;\nif (i == 0) {\ntrainImages = rr.getEngineImages(train.getEngineType());\n} else {\nint type = train.getWagon(i - 1);\ntrainImages = rr.getWagonImages(type);\n}\nEntry<Point, Step> entry = positions.get(i);\nImage image = trainImages.getOverheadHighlightImage(entry.getValue().getID(), highlight);\nPoint p = entry.getKey();\ng.drawImage(image, p.x - 15, p.y - 15, null);\n}\n}\npublic boolean isHit(Point mousePosition, TrainModel train, List<Entry<Point, Step>> positions) {\nfor (int i = 0; i < positions.size(); i++) {\nEntry<Point, Step> entry = positions.get(i);\nPoint p = entry.getKey();\nint xDist = mousePosition.x - p.x;\nint yDist = mousePosition.y - p.y;\nint sumSquares = xDist * xDist + yDist * yDist;\nif( sumSquares > 15 * 15){\ncontinue;\n}\nTrainImages trainImages;\nif (i == 0) {\ntrainImages = rr.getEngineImages(train.getEngineType());\n} else {\nint type = train.getWagon(i - 1);\ntrainImages = rr.getWagonImages(type);\n}\nBufferedImage image = (BufferedImage) trainImages.getOverheadImage(entry.getValue().getID());\nint x = xDist + 15;\nint y = yDist + 15;\nColor c = new Color(image.getRGB(x, y), true);\nint alpha = c.getAlpha();\nif(alpha > 128){\nreturn true;\n}\n}\nreturn false;\n}\npublic void paintTrain(Graphics g, TrainModel train, TrainPositionOnMap s, TrainImages.Highlight highlight) {\n// If the train has been removed, it will be null!\nif (train == null) {\nreturn;\n}\n/*\n* XXX HACK !! really our position ought to be defined at all times, but\n* this is a workaround until we can fix movement\n*/\nif (s == null) {\nreturn;\n}\nList<Entry<Point, Step>> positions = calcPositions(train, s);\nif(null != highlight){\npaintTrainHighlight(g, train, positions, highlight);\n}\npaintTrain(g, train, positions);\n}\n// @SonnyZ\n// This code renders the explosion that occurs when 2 trains crash on the\n// map\npublic void paintTrainCrash(Graphics g, TrainPositionOnMap s) {\n// check to see if there is a train\n// if (s == null) {\n// return;\n// }\n// // Get the image for that frame of the explosion\n// Image explosionImage = rr\n// .getExplosionImage(s.getFrameCt() - 1);\n// // draw the image\n// for (int i = 0; i < s.getLength() - 1; i++) {\n// Point wagonCenter = new Point(s.getX(i), s.getY(i));\n// g.drawImage(explosionImage, wagonCenter.x - 15, wagonCenter.y - 15, null);\n//\n// }\n// // increment the frame count\n// s.incrementFramCt();\n}\n}"}
{"className":"jfreerails.client.renderer.ChequeredTileRenderer","javaDoc":"/**\n* Paints 2 variations of a tile icon a chequered pattern.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Paints 2 variations of a tile icon a chequered pattern.\n*\n* @author Luke Lindsay\n*/\nfinal public class ChequeredTileRenderer extends AbstractTileRenderer {\n@Override\npublic int selectTileIcon(int x, int y, ReadOnlyWorld w) {\nreturn (x + y) % 2;\n}\npublic ChequeredTileRenderer(ImageManager imageManager, int[] rgbValues,\nTerrainType tileModel) throws IOException {\nsuper(tileModel, rgbValues);\nthis.setTileIcons(new Image[2]);\nthis.getTileIcons()[0] = imageManager\n.getImage(generateRelativeFileName(0));\nthis.getTileIcons()[1] = imageManager\n.getImage(generateRelativeFileName(1));\n}\n@Override\npublic void dumpImages(ImageManager imageManager) {\nfor (int i = 0; i < this.getTileIcons().length; i++) {\nString fileName = generateRelativeFileName(i);\nimageManager.setImage(fileName, this.getTileIcons()[i]);\n}\n}\n@Override\nprotected String generateFileNameNumber(int i) {\nreturn String.valueOf(i);\n}\n}"}
{"className":"jfreerails.client.renderer.TrackPieceRendererImpl","javaDoc":"/**\n* This class renders a track piece.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* This class renders a track piece.\n*\n* @author Luke Lindsay 09 October 2001\n*/\nfinal public class TrackPieceRendererImpl implements TrackPieceRenderer {\nprivate final Image[] trackPieceIcons = new Image[512];\nprivate final String typeName;\npublic void drawTrackPieceIcon(int trackTemplate, java.awt.Graphics g,\nint x, int y, java.awt.Dimension tileSize) {\nif ((trackTemplate > 511) || (trackTemplate < 0)) {\nthrow new java.lang.IllegalArgumentException(\"trackTemplate = \"\n+ trackTemplate + \", it should be in the range 0-511\");\n}\nif (trackPieceIcons[trackTemplate] != null) {\nint drawX = x * tileSize.width - tileSize.width / 2;\nint drawY = y * tileSize.height - tileSize.height / 2;\ng.drawImage(trackPieceIcons[trackTemplate], drawX, drawY, null);\n}\n}\npublic TrackPieceRendererImpl(ReadOnlyWorld w, ImageManager imageManager,\nint typeNumber) throws IOException {\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, typeNumber);\nthis.typeName = trackRule.getTypeName();\nfor (int i = 0; i < 512; i++) {\nif (trackRule.testTrackPieceLegality(i)) {\nString fileName = generateFilename(i, getTrackTypeName());\ntrackPieceIcons[i] = imageManager.getImage(fileName);\n}\n}\n}\npublic Image getTrackPieceIcon(int trackTemplate) {\nif ((trackTemplate > 511) || (trackTemplate < 0)) {\nthrow new java.lang.IllegalArgumentException(\"trackTemplate = \"\n+ trackTemplate + \", it should be in the range 0-511\");\n}\nreturn trackPieceIcons[trackTemplate];\n}\npublic void dumpImages(ImageManager imageManager) {\nfor (int i = 0; i < 512; i++) {\nif (trackPieceIcons[i] != null) {\nString fileName = generateFilename(i, getTrackTypeName());\nimageManager.setImage(fileName, trackPieceIcons[i]);\n}\n}\n}\npublic static String generateFilename(int i, String trackTypeName) {\nString relativeFileNameBase = \"track\" + File.separator + trackTypeName;\nint newTemplate = TrackConfiguration.from9bitTemplate(i)\n.get8bitTemplate();\nString fileName = relativeFileNameBase + \"_\"\n+ BinaryNumberFormatter.formatWithLowBitOnLeft(newTemplate, 8)\n+ \".png\";\nreturn fileName;\n}\nprivate String getTrackTypeName() {\nreturn typeName;\n}\n}"}
{"className":"jfreerails.client.renderer.TileRendererListImpl","javaDoc":"/**\n* A list of TileRenderers stored in an array and created from an ArrayList.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* A list of TileRenderers stored in an array and created from an ArrayList.\n*\n* @author Luke Lindsay 09 October 2001\n*/\nfinal public class TileRendererListImpl implements TileRendererList {\nprivate final TileRenderer[] tiles;\npublic TileRenderer getTileViewWithNumber(int i) {\nreturn tiles[i];\n}\npublic TileRendererListImpl(ArrayList<TileRenderer> t) {\ntiles = new TileRenderer[t.size()];\nfor (int i = 0; i < t.size(); i++) {\ntiles[i] = t.get(i);\n}\n}\npublic boolean validate(ReadOnlyWorld w) {\n// There should a TileRenderer for each terrain type.\nreturn w.size(SKEY.TERRAIN_TYPES) == tiles.length;\n}\n}"}
{"className":"jfreerails.client.renderer.TrackPieceRenderer","javaDoc":"/**\n* Draws an icon to represent a track piece.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* Draws an icon to represent a track piece.\n*\n* @author Luke Lindsay 09 October 2001\n*/\npublic interface TrackPieceRenderer {\nImage getTrackPieceIcon(int trackTemplate);\nvoid drawTrackPieceIcon(int trackTemplate, java.awt.Graphics g, int x,\nint y, java.awt.Dimension tileSize);\n/** Adds the images this TileRenderer uses to the specified ImageManager. */\nvoid dumpImages(ImageManager imageManager);\n}"}
{"className":"jfreerails.client.renderer.MapBackgroundRender","javaDoc":"/**\n* This class encapsulates the objects that make-up and paint the background of\n* the map view. At present it is composed of two layers: the terrain layer and\n* the track layer.\n*\n* @author Luke Lindsay 21 September 2001\n* @version 1\n*/","code":"/**\n* This class encapsulates the objects that make-up and paint the background of\n* the map view. At present it is composed of two layers: the terrain layer and\n* the track layer.\n*\n* @author Luke Lindsay 21 September 2001\n* @version 1\n*/\nfinal public class MapBackgroundRender implements MapLayerRenderer {\nprivate static final Logger logger = Logger\n.getLogger(MapBackgroundRender.class.getName());\n/**\n* The terrain layer.\n*/\nprivate final TerrainLayer terrainLayer;\n/**\n* The track layer.\n*/\nprivate final TrackLayer trackLayer;\nprivate final Dimension tileSize = new Dimension(30, 30);\nprivate final Dimension mapSize;\nprivate final Painter cityNames;\nprivate final Painter stationNames;\n/*\n* Used to avoid having to create a new rectangle for each call to the paint\n* methods.\n*/\nprivate Rectangle clipRectangle = new Rectangle();\n/**\n* This inner class represents a view of the track on the map.\n*\n* @author Luke Lindsay 21 September 2001\n*/\nfinal public class TrackLayer implements MapLayerRenderer {\nprivate final ReadOnlyWorld w;\nprivate final RenderersRoot rr;\n/**\n* Paints a rectangle of tiles onto the supplied graphics context.\n*\n* @param g\n* The graphics context on which the tiles get painted.\n* @param tilesToPaint\n* The rectangle, measured in tiles, to paint.\n*/\npublic void paintRectangleOfTiles(Graphics g, Rectangle tilesToPaint) {\n/*\n* Track can overlap the adjacent terrain tiles by half a tile. This\n* means that we need to paint the track from the tiles bordering\n* the specified rectangle of tiles (tilesToPaint). To prevent\n* unnecessary painting, we set the clip to expose only the rectangle\n* of tilesToPaint.\n*/\nGraphics tempG = g;\nPoint tile = new Point();\nfor (tile.x = tilesToPaint.x - 1; tile.x < (tilesToPaint.x\n+ tilesToPaint.width + 1); tile.x++) {\nfor (tile.y = tilesToPaint.y - 1; tile.y < (tilesToPaint.y\n+ tilesToPaint.height + 1); tile.y++) {\nif ((tile.x >= 0) && (tile.x < mapSize.width)\n&& (tile.y >= 0) && (tile.y < mapSize.height)) {\nFreerailsTile ft = (FreerailsTile)w.getTile(tile.x, tile.y);\nTrackPiece tp = ft.getTrackPiece();\nint graphicsNumber = tp.getTrackGraphicID();\nint ruleNumber = tp.getTrackTypeID();\nif (ruleNumber != NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\nTrackPieceRenderer trackPieceView = rr.getTrackPieceView(ruleNumber);\ntrackPieceView.drawTrackPieceIcon(graphicsNumber,\ntempG, tile.x, tile.y, tileSize);\n}\n}\n}\n}\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\n/*\n* Since track tiles overlap the adjacent terrain tiles, we create a\n* temporary Graphics object that only lets us draw on the selected\n* tile.\n*/\npaintRectangleOfTiles(g, new Rectangle(tileX, tileY, 1, 1));\n}\nprivate void paintRectangleOfTiles(Graphics g, int x, int y, int width,\nint height) {\npaintRectangleOfTiles(g, new Rectangle(x, y, width, height));\n}\npublic void refreshTile(int x, int y) {\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nthrow new UnsupportedOperationException(\n\"Method not yet implemented.\");\n}\npublic TrackLayer(ReadOnlyWorld world,\nRenderersRoot trackPieceViewList) {\nthis.rr = trackPieceViewList;\nthis.w = world;\n}\npublic void refreshAll() {\n}\n}\n/**\n* This inner class represents the terrain of the map.\n*\n* @author Luke Lindsay 21 September 2001\n*/\nfinal public class TerrainLayer implements MapLayerRenderer {\nprivate final TileRendererList tiles;\nprivate final ReadOnlyWorld w;\npublic void paintTile(Graphics g, Point tile) {\nint screenX = tileSize.width * tile.x;\nint screenY = tileSize.height * tile.y;\nif ((tile.x >= 0) && (tile.x < mapSize.width) && (tile.y >= 0)\n&& (tile.y < mapSize.height)) {\nTerrainTile tt = (TerrainTile) w.getTile(tile.x, tile.y);\nint typeNumber = tt.getTerrainTypeID();\nTileRenderer tr = tiles.getTileViewWithNumber(typeNumber);\nif (null == tr) {\nlogger.warning(\"No tile renderer for \" + typeNumber);\n} else {\ntr.renderTile(g, screenX, screenY, tile.x, tile.y, w);\n}\n}\n}\n/**\n* Paints a rectangle of tiles on the supplied graphics context.\n*\n* @param g\n* The graphics context.\n* @param tilesToPaint\n* The rectangle, measured in tiles, to paint.\n*/\npublic void paintRectangleOfTiles(Graphics g, Rectangle tilesToPaint) {\nPoint tile = new Point();\nfor (tile.x = tilesToPaint.x; tile.x < (tilesToPaint.x + tilesToPaint.width); tile.x++) {\nfor (tile.y = tilesToPaint.y; tile.y < (tilesToPaint.y + tilesToPaint.height); tile.y++) {\nterrainLayer.paintTile(g, tile);\n}\n}\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nthrow new UnsupportedOperationException(\n\"Method not yet implemented.\");\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\npaintTile(g, new Point(tileX, tileY));\n}\nprivate void paintRectangleOfTiles(Graphics g, int x, int y, int width,\nint height) {\npaintRectangleOfTiles(g, new Rectangle(x, y, width, height));\n}\npublic void refreshTile(int x, int y) {\n}\npublic TerrainLayer(ReadOnlyWorld world, TileRendererList tiles) {\nthis.w = world;\nthis.tiles = tiles;\n}\npublic void refreshAll() {\n}\n}\npublic MapBackgroundRender(ReadOnlyWorld w, RenderersRoot rr,\nModelRoot modelRoot) {\ntrackLayer = new TrackLayer(w, rr);\nterrainLayer = new TerrainLayer(w, rr);\nmapSize = new Dimension(w.getMapWidth(), w.getMapHeight());\ncityNames = new CityNamesRenderer(w);\nstationNames = new StationNamesRenderer(w, modelRoot);\n}\npublic void paintTile(Graphics g, int x, int y) {\nterrainLayer.paintTile(g, x, y);\ntrackLayer.paintTile(g, x, y);\ncityNames.paint((Graphics2D) g);\nstationNames.paint((Graphics2D) g);\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\nint tileWidth = 30;\nint tileHeight = 30;\nclipRectangle = g.getClipBounds(clipRectangle);\nint x = clipRectangle.x / tileWidth;\nint y = clipRectangle.y / tileHeight;\nint width = (clipRectangle.width / tileWidth) + 2;\nint height = (clipRectangle.height) / tileHeight + 2;\npaintRectangleOfTiles(g, x, y, width, height);\ncityNames.paint((Graphics2D) g);\nstationNames.paint((Graphics2D) g);\n}\nprivate void paintRectangleOfTiles(Graphics g, int x, int y, int width,\nint height) {\nterrainLayer.paintRectangleOfTiles(g, x, y, width, height);\ntrackLayer.paintRectangleOfTiles(g, x, y, width, height);\ncityNames.paint((Graphics2D) g);\nstationNames.paint((Graphics2D) g);\n}\npublic void refreshTile(int x, int y) {\n// Do nothing\n}\npublic void refreshAll() {\n// Do nothing\n}\n}"}
{"className":"jfreerails.client.renderer.RenderersRoot","javaDoc":"/**\n* Provides access to the objects that render terrain, track, and trains.\n*\n* @author Luke\n*/","code":"/**\n* Provides access to the objects that render terrain, track, and trains.\n*\n* @author Luke\n*/\npublic interface RenderersRoot extends TileRendererList {\nTrackPieceRenderer getTrackPieceView(int i);\nTrainImages getWagonImages(int type);\nTrainImages getEngineImages(int type);\n//OldTrainImages getTrainImages();\nboolean validate(ReadOnlyWorld world);\nImage getImage(String relativeFilename) throws IOException;\nImage getScaledImage(String relativeFilename, int height) throws IOException;\n}"}
{"className":"jfreerails.client.renderer.SpecialTileRenderer","javaDoc":"/**\n* A special tile's icon gets drawn over the icon of a normal tile.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* A special tile's icon gets drawn over the icon of a normal tile.\n*\n* @author Luke Lindsay\n*/\nfinal public class SpecialTileRenderer extends AbstractTileRenderer {\nprivate static final Logger logger = Logger\n.getLogger(SpecialTileRenderer.class.getName());\nfinal private TileRenderer parentTileView;\n@Override\npublic void renderTile(java.awt.Graphics g, int renderX, int renderY,\nint mapX, int mapY, ReadOnlyWorld w) {\nif (parentTileView != null) {\nparentTileView.renderTile(g, renderX, renderY, mapX, mapY, w);\n} else {\nlogger.warning(\"parent tileView==null\");\n}\nImage icon = this.getIcon(mapX, mapX, w);\nif (null != icon) {\ng.drawImage(icon, renderX, renderY, null);\n} else {\nlogger.warning(\"special tileView icon==null\");\n}\n}\n@Override\npublic int selectTileIcon(int x, int y, ReadOnlyWorld w) {\nreturn 0;\n}\npublic SpecialTileRenderer(ImageManager imageManager, int[] rgbValues,\nTerrainType tileModel, TileRenderer parentTileView)\nthrows IOException {\nsuper(tileModel, rgbValues);\nthis.setTileIcons(new Image[1]);\nthis.getTileIcons()[0] = imageManager.getImage(generateFilename());\nthis.parentTileView = parentTileView;\n}\n@Override\npublic void dumpImages(ImageManager imageManager) {\nimageManager.setImage(generateFilename(), this.getTileIcons()[0]);\n}\nprivate String generateFilename() {\nreturn \"terrain\" + File.separator + this.getTerrainType() + \".png\";\n}\n@Override\nprotected String generateFileNameNumber(int i) {\nthrow new UnsupportedOperationException();\n}\n}"}
{"className":"jfreerails.client.renderer.TrainImages","javaDoc":"/**\n* Stores side-on and over-head images of a particular wagon or engine type.\n*\n* @author Luke\n*\n*\n*/","code":"/**\n* Stores side-on and over-head images of a particular wagon or engine type.\n*\n* @author Luke\n*\n*\n*/\npublic class TrainImages {\npublic enum Highlight{SELECTED, FOCUSED};\nprivate final Image sideOnImage;\nprivate final Image[] overheadImages = new Image[8];\nprivate final Image[] overheadSelectedImages = new Image[8];\nprivate final Image[] overheadFocusedImages = new Image[8];\npublic final String sideOnFileName;\npublic Image getSideOnImage() {\nreturn sideOnImage;\n}\npublic Image getOverheadImage(int direction) {\nreturn overheadImages[direction];\n}\n/**\n* @param direction\n* @return the image to render under the wagon/engine image\n* when the train is selects/focused.\n*/\npublic Image getOverheadHighlightImage(int direction, Highlight h) {\nif(h == Highlight.FOCUSED)\nreturn overheadFocusedImages[direction];\nif(h == Highlight.SELECTED)\nreturn overheadSelectedImages[direction];\nreturn null;\n}\npublic static String generateOverheadFilename(String name, int i) {\nStep[] vectors = Step.getList();\nreturn \"trains\" + File.separator + \"overhead\" + File.separator + name\n+ \"_\" + vectors[i].toAbrvString() + \".png\";\n}\npublic static String generateSideOnFilename(String name) {\nreturn \"trains\" + File.separator + \"sideon\" + File.separator + name\n+ \".png\";\n}\npublic TrainImages(ImageManager imageManager, String name) throws IOException {\nsideOnFileName = TrainImages.generateSideOnFilename(name);\nsideOnImage = imageManager.getImage(sideOnFileName);\nfor (int direction = 0; direction < 8; direction++) {\noverheadImages[direction] = imageManager\n.getImage(generateOverheadFilename(name, direction));\noverheadSelectedImages[direction] = imageManager\n.getImage(generateOverheadFilename(\"highlights\" + File.separator + \"selected\", direction));\noverheadFocusedImages[direction] = imageManager\n.getImage(generateOverheadFilename(\"highlights\" + File.separator + \"focused\", direction));\n}\n}\n}"}
{"className":"jfreerails.client.renderer.StandardTileRenderer","javaDoc":"/**\n* Paints a tile for which there only one tile icon.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Paints a tile for which there only one tile icon.\n*\n* @author Luke Lindsay\n*/\nfinal public class StandardTileRenderer extends\njfreerails.client.renderer.AbstractTileRenderer {\npublic StandardTileRenderer(ImageManager imageManager, int[] rgbValues,\nTerrainType tileModel) throws IOException {\nsuper(tileModel, rgbValues);\nthis.setTileIcons(new Image[1]);\nthis.getTileIcons()[0] = imageManager.getImage(generateFilename());\n}\n@Override\npublic void dumpImages(ImageManager imageManager) {\nimageManager.setImage(generateFilename(), this.getTileIcons()[0]);\n}\nprivate String generateFilename() {\nreturn generateFilename(this.getTerrainType());\n}\npublic static String generateFilename(String typeName) {\nreturn \"terrain\" + File.separator + typeName + \".png\";\n}\n@Override\nprotected String generateFileNameNumber(int i) {\nthrow new UnsupportedOperationException();\n}\n}"}
{"className":"jfreerails.client.renderer.BlankMapRenderer","javaDoc":"/**\n* Used for testing the Map view components without setting up any map data.\n*\n* @author Luke\n*/","code":"/**\n* Used for testing the Map view components without setting up any map data.\n*\n* @author Luke\n*/\npublic class BlankMapRenderer implements MapRenderer {\nprivate final float scale;\npublic BlankMapRenderer(float s) {\nscale = s;\n}\npublic float getScale() {\nreturn scale;\n}\npublic Dimension getMapSizeInPixels() {\nint height = (int) (400 * scale);\nint width = (int) (400 * scale);\nreturn new Dimension(height, width);\n}\npublic void paintTile(Graphics g, int tileX, int tileY) {\npaintRect(g, null);\n}\npublic void refreshTile(int x, int y) {\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\ng.setColor(Color.darkGray);\ng.fillRect(0, 0, (int) (scale * 400), (int) (scale * 400));\ng.setColor(Color.blue);\nint x = (int) (100 * scale);\nint y = (int) (100 * scale);\nint height = (int) (200 * scale);\nint width = (int) (200 * scale);\ng.fillRect(x, y, height, width);\n}\npublic void refreshAll() {\n// do nothing\n}\n}"}
{"className":"jfreerails.client.renderer.StationRadiusRenderer","javaDoc":"/**\n* This class draws the radius of a station on the map.\n*\n* @author Luke\n*/","code":"/**\n* This class draws the radius of a station on the map.\n*\n* @author Luke\n*/\npublic class StationRadiusRenderer implements Painter {\n/**\n* Border colour to use when placement is OK.\n*/\npublic static final Color COLOR_OK = Color.WHITE;\n/**\n* Border colour to use when placement is not allowed.\n*/\npublic static final Color COLOR_CANNOT_BUILD = Color.RED;\n/**\n* Colour of the highlighted border.\n*/\nprivate Color borderColor = COLOR_OK;\nprivate static final int tileSize = 30;\nprivate int radius = 2;\nprivate int x;\nprivate int y;\nprivate final ModelRoot modelRoot;\npublic StationRadiusRenderer(ModelRoot mr) {\nthis.modelRoot = mr;\n}\npublic void setBorderColor(Color c) {\nborderColor = c;\n}\npublic void setPosition(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\npublic void setRadius(int radius) {\nthis.radius = radius;\n}\npublic void show() {\nif (!modelRoot\n.is(Property.CURSOR_MODE, Value.PLACE_STATION_CURSOR_MODE)) {\nmodelRoot.setProperty(Property.PREVIOUS_CURSOR_MODE, modelRoot\n.getProperty(Property.CURSOR_MODE));\nmodelRoot.setProperty(Property.CURSOR_MODE,\nValue.PLACE_STATION_CURSOR_MODE);\nmodelRoot.setProperty(Property.IGNORE_KEY_EVENTS, Boolean.TRUE);\n}\n}\npublic void hide() {\nModelRoot.Value lastCursorMode = (ModelRoot.Value) modelRoot\n.getProperty(ModelRoot.Property.PREVIOUS_CURSOR_MODE);\nassert !lastCursorMode\n.equals(ModelRoot.Value.PLACE_STATION_CURSOR_MODE);\nmodelRoot.setProperty(ModelRoot.Property.CURSOR_MODE, lastCursorMode);\nmodelRoot.setProperty(Property.IGNORE_KEY_EVENTS, Boolean.FALSE);\n}\npublic void paint(Graphics2D g) {\nif (modelRoot.getProperty(ModelRoot.Property.CURSOR_MODE).equals(\nValue.PLACE_STATION_CURSOR_MODE)) {\ng.setStroke(new BasicStroke(2f));\ng.setColor(borderColor);\ng.drawRect(tileSize * (x - radius), tileSize * (y - radius),\ntileSize * (2 * radius + 1), tileSize * (2 * radius + 1));\n}\n}\n}"}
{"className":"jfreerails.client.renderer.MapLayerRenderer","javaDoc":"/**\n* Paints a layer of the map which might be buffered.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Paints a layer of the map which might be buffered.\n*\n* @author Luke Lindsay\n*/\npublic interface MapLayerRenderer {\nvoid paintTile(Graphics g, int tileX, int tileY);\nvoid refreshTile(int x, int y);\nvoid refreshAll();\nvoid paintRect(Graphics g, Rectangle visibleRect);\n}"}
{"className":"jfreerails.server.CityTilePositioner","javaDoc":"/**\n* This class initialises cities and controls their growth. It makes changes to\n* directly to the world object, so if the game has already started, use\n* WorldDifferences and MapDiffMove to pass changes to the clients.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class initialises cities and controls their growth. It makes changes to\n* directly to the world object, so if the game has already started, use\n* WorldDifferences and MapDiffMove to pass changes to the clients.\n*\n* @author Luke\n*\n*/\npublic class CityTilePositioner {\nRandom random = new Random();\nArrayList<TerrainType> urbanTerrainTypes = new ArrayList<TerrainType>();\nArrayList<TerrainType> industryTerrainTypes = new ArrayList<TerrainType>();\nArrayList<TerrainType> resourceTerrainTypes = new ArrayList<TerrainType>();\nWorld w;\npublic CityTilePositioner(World w) {\nthis.w = w;\n// get the different types of Urban/Industry/Resource terrain\nfor (int i = 0; i < w.size(SKEY.TERRAIN_TYPES); i++) {\nTerrainType type = (TerrainType) w.get(SKEY.TERRAIN_TYPES, i);\nswitch (type.getCategory().ordinal()) {\ncase 0:\nurbanTerrainTypes.add(type);\nbreak;\ncase 6:\nindustryTerrainTypes.add(type);\nbreak;\ncase 7:\nresourceTerrainTypes.add(type);\nbreak;\n}\n}\n}\nvoid initCities() {\nfinal int numCities = w.size(SKEY.CITIES);\nCityEconomicModel[] cities = new CityEconomicModel[numCities];\nfor (int cityId = 0; cityId < numCities; cityId++) {\nCityEconomicModel city = new CityEconomicModel();\ncity.loadFromMap(w, cityId);\nfinal int urbanTiles = 2 + random.nextInt(3);\nfor (int i = 0; i < urbanTiles; i++) {\naddUrbanTile(city);\n}\nfinal int industryTiles = random.nextInt(3);\nfor (int i = 0; i < industryTiles; i++) {\naddIndustryTile(city);\n}\nfinal int resourceTiles = random.nextInt(3);\nfor (int i = 0; i < resourceTiles; i++) {\naddResourceTile(city);\n}\ncity.write2map(w);\ncities[cityId] = city;\n}\n}\nprivate void addResourceTile(CityEconomicModel city) {\nint tileTypeNo = random.nextInt(resourceTerrainTypes.size());\nTerrainType type = resourceTerrainTypes.get(tileTypeNo);\ncity.addTile(type);\n}\nprivate void addIndustryTile(CityEconomicModel city) {\nint size = city.industriesNotAtCity.size();\nif (size > 0) {\nint tileTypeNo = random.nextInt(size);\nTerrainType type = city.industriesNotAtCity.get(tileTypeNo);\ncity.addTile(type);\n}\n}\nprivate void addUrbanTile(CityEconomicModel city) {\nint tileTypeNo = random.nextInt(urbanTerrainTypes.size());\nTerrainType type = urbanTerrainTypes.get(tileTypeNo);\ncity.addTile(type);\n}\nvoid growCities() {\nfinal int numCities = w.size(SKEY.CITIES);\n/*\n* At some stage this will be refined to take into account how much\n* cargo has been picked up and delivered and what city tiles are\n* already present.\n*/\nfor (int cityId = 0; cityId < numCities; cityId++) {\nCityEconomicModel city = new CityEconomicModel();\ncity.loadFromMap(w, cityId);\n// Only increase cities with stations and less than 16 tiles\nif (city.size() < 16 && city.stations > 0) {\nswitch (random.nextInt(10)) {\ncase 0:\ncase 1:\naddResourceTile(city); // 20% chance\nbreak;\ncase 2:\ncase 3:\ncase 4:\ncase 5:\naddUrbanTile(city); // 40% chance\nbreak;\ncase 6:\naddIndustryTile(city); // 10% chance\nbreak;\ndefault:\n// do nothing, 30% chance\nbreak;\n}\ncity.write2map(w);\n}\n}\n}\n}"}
{"className":"jfreerails.server.CitySAXParser","javaDoc":"/**\n*\n* Class to parse an xml file that contains city names and co-ords. Upon reading\n* in the data, its stored in KEY.CITIES.\n*\n* @author Scott Bennett Date: 31st March 2003\n*/","code":"/**\n*\n* Class to parse an xml file that contains city names and co-ords. Upon reading\n* in the data, its stored in KEY.CITIES.\n*\n* @author Scott Bennett Date: 31st March 2003\n*/\npublic class CitySAXParser extends DefaultHandler {\nprivate final Vector<CityModel> cities;\nprivate final World world;\npublic CitySAXParser(World w) throws SAXException {\nworld = w;\ncities = new Vector<CityModel>();\n}\n@Override\npublic void endDocument() throws SAXException {\nfor (int i = 0; i < cities.size(); i++) {\nCityModel tempCity = cities.elementAt(i);\nworld.add(SKEY.CITIES, new CityModel(tempCity.getCityName(),\ntempCity.getCityX(), tempCity.getCityY()));\n}\n}\n@Override\npublic void startElement(String namespaceURI, String sName, String qName,\nAttributes attrs) throws SAXException {\nString cityName = null;\nint x = 0;\nint y = 0;\nif (attrs != null) {\nfor (int i = 0; i < attrs.getLength(); i++) {\nString aName = attrs.getLocalName(i); // Attr name\nif (aName.equals(\"\")) {\naName = attrs.getQName(i);\n}\n// put values in CityModel obj\nif (aName.equals(\"name\")) {\ncityName = attrs.getValue(i);\n}\nif (aName.equals(\"x\")) {\nx = Integer.parseInt(attrs.getValue(i));\n}\nif (aName.equals(\"y\")) {\ny = Integer.parseInt(attrs.getValue(i));\nCityModel city = new CityModel(cityName, x, y);\ncities.addElement(city);\n}\n}\n// end for loop\n}\n// end if\n}\n// end startElement method\n}"}
{"className":"jfreerails.server.MapFixtureFactory2","javaDoc":"/**\n* Stores a static world object and provides copies to clients.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Stores a static world object and provides copies to clients.\n*\n* @author Luke Lindsay\n*\n*/\npublic class MapFixtureFactory2 {\nprivate static World w;\n/**\n* Returns a world object with a map of size 50*50, 4 players, and track,\n* terrain and cargo types as specified in the xml files used by the actual\n* game.\n*/\nsynchronized public static World getCopy() {\nif (null == w) {\nw = generateWorld();\n}\nreturn w.defensiveCopy();\n}\nprivate static World generateWorld() {\nWorld world = new WorldImpl(50, 50);\nTileSetFactory tileFactory = new TileSetFactoryImpl();\nWagonAndEngineTypesFactory wetf = new WagonAndEngineTypesFactory();\nwetf.addTypesToWorld(world);\ntileFactory.addTerrainTileTypesList(world);\nURL track_xml_url = OldWorldImpl.class\n.getResource(\"/jfreerails/data/track_tiles.xml\");\nTrack_TilesHandlerImpl trackSetFactory = new Track_TilesHandlerImpl(\ntrack_xml_url);\ntrackSetFactory.addTrackRules(world);\n// Add 4 players\nfor (int i = 0; i < 4; i++) {\nString name = \"player\" + i;\nPlayer p = new Player(name, i);\nAddPlayerMove move = AddPlayerMove.generateMove(world, p);\nMoveStatus ms = move.doMove(world, Player.AUTHORITATIVE);\nassert(ms.ok);\n}\nworld.set(ITEM.CALENDAR, new GameCalendar(1200, 1840));\nworld.setTime(new GameTime(0));\nworld.set(ITEM.GAME_SPEED, new GameSpeed(10));\nworld.set(ITEM.GAME_RULES, GameRules.DEFAULT_RULES);\nint clearTypeID = 0;\n// Fill the world with clear terrain.\nfor (int i = 0; i < world.size(SKEY.TERRAIN_TYPES); i++) {\nTerrainType tt = (TerrainType) world.get(SKEY.TERRAIN_TYPES, i);\nif (\"Clear\".equals(tt.getTerrainTypeName())) {\nclearTypeID = i;\nbreak;\n}\n}\nFreerailsTile tile = FreerailsTile.getInstance(clearTypeID);\nfor (int x = 0; x < world.getMapWidth(); x++) {\nfor (int y = 0; y < world.getMapHeight(); y++) {\nworld.setTile(x, y, tile);\n}\n}\nreturn world;\n}\n}"}
{"className":"jfreerails.server.ServerAutomaton","javaDoc":"/**\n* This interface is implemented by objects which are responsible for updating\n* the game world. They are serialized when the game is saved. They are internal\n* clients of the ServerGameEngine and need to be initialised with a connection\n* to the game when deserialized.\n*\n* @author rob\n*/","code":"/**\n* This interface is implemented by objects which are responsible for updating\n* the game world. They are serialized when the game is saved. They are internal\n* clients of the ServerGameEngine and need to be initialised with a connection\n* to the game when deserialized.\n*\n* @author rob\n*/\npublic interface ServerAutomaton extends Serializable {\n/**\n* Initializes the automaton with a connection to the MoveExecutor.\n*/\npublic void initAutomaton(MoveReceiver mr);\n}"}
{"className":"jfreerails.server.SavFileFilter","javaDoc":"/**\n* A SavedGamesManager reads and writes gzipped saved games to the working\n* directory.\n*\n* @author Luke\n*\n*/","code":"/**\n* A SavedGamesManager reads and writes gzipped saved games to the working\n* directory.\n*\n* @author Luke\n*\n*/\nclass SavFileFilter implements FilenameFilter {\npublic boolean accept(File dir, String name) {\nreturn (name.endsWith(\".sav\"));\n}\n}"}
{"className":"jfreerails.server.SavedGamesManagerImpl","javaDoc":null,"code":"public class SavedGamesManagerImpl implements SavedGamesManager {\nprivate static final Logger logger = Logger\n.getLogger(SavedGamesManagerImpl.class.getName());\npublic String[] getSaveGameNames() {\njava.io.File dir = new File(\"./\");\nFilenameFilter filter = new SavFileFilter();\nString[] files = dir.list(filter);\nreturn files;\n}\npublic String[] getNewMapNames() {\nreturn NewGameMessage2Server.getMapNames();\n}\npublic void saveGame(Serializable w, String s) throws IOException {\nlong startTime = System.currentTimeMillis();\nlogger.info(\"Saving game.. \" + s);\nFileOutputStream out = new FileOutputStream(s);\nGZIPOutputStream zipout = new GZIPOutputStream(out);\nObjectOutputStream objectOut = new ObjectOutputStream(zipout);\nobjectOut.writeObject(ServerControlInterface.VERSION);\nobjectOut.writeObject(w);\nobjectOut.flush();\nobjectOut.close();\nout.close();\nlong finishTime = System.currentTimeMillis();\nlong deltaTime = finishTime - startTime;\nlogger.info(\"done, \" + deltaTime + \"ms\");\n}\npublic Serializable loadGame(String name) throws IOException {\nlong startTime = System.currentTimeMillis();\nlogger.info(\"Loading game.. \" + name);\nFileInputStream in = new FileInputStream(name);\nGZIPInputStream zipin = new GZIPInputStream(in);\nObjectInputStream objectIn = new ObjectInputStream(zipin);\nString version_string;\ntry {\nversion_string = (String) objectIn.readObject();\nif (!ServerControlInterface.VERSION.equals(version_string)) {\nthrow new IOException(version_string);\n}\nSerializable game = (Serializable) objectIn.readObject();\n/**\n* load player private data\n*/\n// for (int i = 0; i < world.getNumberOfPlayers(); i++) {\n// Player player = world.getPlayer(i);\n// player.loadSession(objectIn);\n// }\nlong finishTime = System.currentTimeMillis();\nlong deltaTime = finishTime - startTime;\nlogger.info(\"done, \" + deltaTime + \"ms\");\nreturn game;\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\nthrow new IOException(e.getMessage());\n} catch (InvalidClassException e) {\n// e.printStackTrace();\nthrow new IOException(e.getMessage());\n}\n}\npublic Serializable newMap(String name) throws IOException {\nreturn OldWorldImpl.createWorldFromMapFile(name,\nFreerailsProgressMonitor.NULL_INSTANCE);\n}\n}"}
{"className":"jfreerails.server.TrainPathFinder","javaDoc":"/**\n* This class provides methods that generate a path to a target as a series of\n* PositionOnTrack objects encoded as ints, it also deals with stops at\n* stations.\n*\n* @author Luke Lindsay 28-Nov-2002\n*/","code":"/**\n* This class provides methods that generate a path to a target as a series of\n* PositionOnTrack objects encoded as ints, it also deals with stops at\n* stations.\n*\n* @author Luke Lindsay 28-Nov-2002\n*/\npublic class TrainPathFinder implements FreerailsIntIterator, ServerAutomaton {\nprivate static final long serialVersionUID = 3256446893302559280L;\nprivate final SimpleAStarPathFinder pathFinder = new SimpleAStarPathFinder();\nprivate final FreerailsPrincipal principal;\nprivate final TrainStopsHandler stopsHandler;\nprivate final FlatTrackExplorer trackExplorer;\nprivate final int trainId;\nprivate transient MoveReceiver mr = null;\nReadOnlyWorld w;\npublic TrainPathFinder(FlatTrackExplorer tx, ReadOnlyWorld w,\nint trainNumber, MoveReceiver newMr, FreerailsPrincipal p) {\nthis.trackExplorer = tx;\nthis.trainId = trainNumber;\nprincipal = p;\nstopsHandler = new TrainStopsHandler(trainId, principal, new WorldDiffs(w));\nthis.mr = newMr;\nthis.w = w;\n}\npublic boolean hasNextInt() {\nboolean moving = stopsHandler.isTrainMoving();\nif (moving) {\nreturn trackExplorer.hasNextEdge();\n}\nmr.processMove(stopsHandler.getMoves());\nreturn false;\n}\npublic void initAutomaton(MoveReceiver newMr) {\nthis.mr = newMr;\n}\nboolean isTrainMoving() {\nboolean moving = stopsHandler.isTrainMoving();\nmr.processMove(stopsHandler.getMoves());\nreturn moving;\n}\n/**\n* @return a PositionOnTrack packed into an int\n*/\npublic int nextInt() {\nPositionOnTrack tempP = new PositionOnTrack(trackExplorer.getPosition());\nint x = tempP.getX();\nint y = tempP.getY();\nImPoint targetPoint = stopsHandler.arrivesAtPoint(x, y);\nint currentPosition = tempP.getOpposite().toInt();\nReadOnlyWorld world = trackExplorer.getWorld();\nPositionOnTrack[] t = FlatTrackExplorer.getPossiblePositions(world,\ntargetPoint);\nint[] targets = new int[t.length];\nfor (int i = 0; i < t.length; i++) {\nint target = t[i].getOpposite().toInt();\nif (target == currentPosition) {\nstopsHandler.updateTarget();\n}\ntargets[i] = target;\n}\nFlatTrackExplorer tempExplorer = new FlatTrackExplorer(world, tempP);\nint next = pathFinder.findstep(currentPosition, targets, tempExplorer);\nif (next == IncrementalPathFinder.PATH_NOT_FOUND) {\ntrackExplorer.nextEdge();\ntrackExplorer.moveForward();\nreturn trackExplorer.getVertexConnectedByEdge();\n}\ntempP.setValuesFromInt(next);\ntempP = tempP.getOpposite();\nint nextPosition = tempP.toInt();\ntrackExplorer.setPosition(nextPosition);\nmr.processMove(stopsHandler.getMoves());\nreturn nextPosition;\n}\n}"}
{"className":"jfreerails.server.TileSetFactoryImpl","javaDoc":"/**\n* This class adds cargo and terrain types defined in an XML file to a World\n* object.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class adds cargo and terrain types defined in an XML file to a World\n* object.\n*\n* @author Luke\n*\n*/\npublic class TileSetFactoryImpl implements TileSetFactory {\npublic void addTerrainTileTypesList(World w) {\ntry {\njava.net.URL url = RunTypesParser.class\n.getResource(\"/jfreerails/data/cargo_and_terrain.xml\");\nCargoAndTerrainParser.parse(url, new CargoAndTerrainHandlerImpl(w));\n} catch (Exception e) {\ne.printStackTrace();\nthrow new IllegalStateException();\n}\n}\n}"}
{"className":"jfreerails.server.TrainMaintenanceMoveGenerator","javaDoc":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of trains, then calculates the cost of maintenance.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of trains, then calculates the cost of maintenance.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrainMaintenanceMoveGenerator {\nprivate final MoveReceiver moveReceiver;\npublic TrainMaintenanceMoveGenerator(MoveReceiver mr) {\nthis.moveReceiver = mr;\n}\nprivate static AddTransactionMove generateMove(World w,\nFreerailsPrincipal principal) {\nNonNullElements trains = new NonNullElements(KEY.TRAINS, w, principal);\nint numberOfTrains = trains.size();\nlong amount = numberOfTrains * 5000;\nTransaction t = new Bill(new Money(amount),\nTransaction.Category.TRAIN_MAINTENANCE);\nreturn new AddTransactionMove(principal, t);\n}\npublic void update(World w) {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\nMove m = generateMove(w, principal);\nmoveReceiver.processMove(m);\n}\n}\n}"}
{"className":"jfreerails.server.ServerGameModelImpl","javaDoc":"/**\n* A ServerGameModel that contains the automations used in the actual game.\n*\n* @author Luke\n*\n*/","code":"/**\n* A ServerGameModel that contains the automations used in the actual game.\n*\n* @author Luke\n*\n*/\npublic class ServerGameModelImpl implements ServerGameModel {\nprivate static final long serialVersionUID = 3978144352788820021L;\npublic World world;\nprivate transient CalcSupplyAtStations calcSupplyAtStations;\nprivate TrainUpdater tb;\nprivate String[] passwords;\n/**\n* List of the ServerAutomaton objects connected to this game.\n*/\nprivate final Vector<ServerAutomaton> serverAutomata;\n/**\n* Number of ticks since the last time we did an infrequent update.\n*/\nprivate int ticksSinceUpdate = 0;\nprivate transient long nextModelUpdateDue;\nprivate transient MoveReceiver moveExecuter;\npublic ServerGameModelImpl() {\nthis(null, new Vector<ServerAutomaton>());\n}\npublic ServerGameModelImpl( World w,\nVector<ServerAutomaton> serverAutomata) {\nthis.world = w;\nthis.serverAutomata = serverAutomata;\nnextModelUpdateDue = System.currentTimeMillis();\n}\n/** This is called on the last tick of each year. */\nprivate void yearEnd() {\nTrackMaintenanceMoveGenerator tmmg = new TrackMaintenanceMoveGenerator(\nmoveExecuter);\ntmmg.update(world);\nTrainMaintenanceMoveGenerator trainMaintenanceMoveGenerator = new TrainMaintenanceMoveGenerator(\nmoveExecuter);\ntrainMaintenanceMoveGenerator.update(world);\nInterestChargeMoveGenerator interestChargeMoveGenerator = new InterestChargeMoveGenerator(\nmoveExecuter);\ninterestChargeMoveGenerator.update(world);\n// Grow cities.\nWorldDiffs wd = new WorldDiffs(world);\nCityTilePositioner ctp = new CityTilePositioner(wd);\nctp.growCities();\nWorldDiffMove move = new WorldDiffMove(world, wd, WorldDiffMove.Cause.YearEnd);\nmoveExecuter.processMove(move);\n}\n/** This is called at the start of each new month. */\nprivate void monthEnd() {\ncalcSupplyAtStations.doProcessing();\nCargoAtStationsGenerator cargoAtStationsGenerator = new CargoAtStationsGenerator();\ncargoAtStationsGenerator.update(world, moveExecuter);\n}\nprivate void updateGameTime() {\nmoveExecuter.processMove(TimeTickMove.getMove(world));\n}\n/**\n*\n*/\npublic synchronized void update() {\nlong frameStartTime = System.currentTimeMillis();\nwhile (nextModelUpdateDue <= frameStartTime) {\n/*\n* First do the things that need doing whether or not the game is\n* paused.\n*/\ntb.buildTrains(world);\nint gameSpeed = ((GameSpeed) world.get(ITEM.GAME_SPEED)).getSpeed();\nif (gameSpeed > 0) {\n/*\n* Update the time first, since other updates might need to know\n* the current time.\n*/\nupdateGameTime();\n// now do the other updates\ntb.moveTrains(world);\n// Check whether we are about to start a new year..\nGameTime time = world.currentTime();\nGameCalendar calendar = (GameCalendar) world.get(ITEM.CALENDAR);\nint yearNextTick = calendar.getYear(time.getTicks() + 1);\nint yearThisTick = calendar.getYear(time.getTicks());\nif (yearThisTick != yearNextTick) {\nyearEnd();\n}\n// And a new month..\nint monthThisTick = calendar.getMonth(time.getTicks());\nint monthNextTick = calendar.getMonth(time.getTicks() + 1);\nif (monthNextTick != monthThisTick) {\nmonthEnd();\n}\n/* calculate \"ideal world\" time for next tick */\nnextModelUpdateDue = nextModelUpdateDue + (1000 / gameSpeed);\n// int delay = (int)(nextModelUpdateDue - frameStartTime);\n//\n// /* wake up any waiting client threads - we could be\n// * more aggressive, and only notify them if delay > 0? */\n// this.notifyAll();\n//\n// try {\n// if (delay > 0) {\n// this.wait(delay);\n// } else {\n// this.wait(1);\n// }\n// } catch (InterruptedException e) {\n// // do nothing\n// }\nticksSinceUpdate++;\n} else {\n// try {\n// //When the game is frozen we don't want to be spinning in a\n// //loop.\n// Thread.sleep(200);\n// } catch (InterruptedException e) {\n// // do nothing\n// }\nnextModelUpdateDue = System.currentTimeMillis();\n}\n}\n}\npublic void write(ObjectOutputStream objectOut) throws IOException {\nobjectOut.writeObject(world);\nobjectOut.writeObject(serverAutomata);\n/**\n* save player private data\n*/\nfor (int i = 0; i < world.getNumberOfPlayers(); i++) {\nPlayer player = world.getPlayer(i);\nplayer.saveSession(objectOut);\n}\n}\npublic void init(MoveReceiver newMoveExecuter) {\nthis.moveExecuter = newMoveExecuter;\ntb = new TrainUpdater(newMoveExecuter);\ncalcSupplyAtStations = new CalcSupplyAtStations(world, newMoveExecuter);\nfor (int i = 0; i < serverAutomata.size(); i++) {\nserverAutomata.get(i).initAutomaton(newMoveExecuter);\n}\ntb.initAutomaton(newMoveExecuter);\nnextModelUpdateDue = System.currentTimeMillis();\n}\npublic World getWorld() {\nreturn world;\n}\npublic void setWorld(World w, String[] passwords) {\nthis.world = w;\nthis.serverAutomata.clear();\nthis.passwords = passwords.clone();\n}\npublic String[] getPasswords() {\nreturn passwords.clone();\n}\n}"}
{"className":"jfreerails.server.TrackMaintenanceMoveGenerator","javaDoc":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of units of each track type, then calculates the cost of maintenance.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of units of each track type, then calculates the cost of maintenance.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrackMaintenanceMoveGenerator {\nprivate final MoveReceiver moveReceiver;\npublic TrackMaintenanceMoveGenerator(MoveReceiver mr) {\nthis.moveReceiver = mr;\n}\npublic static AddTransactionMove generateMove(World w,\nFreerailsPrincipal principal, Transaction.Category category) {\nif (TRACK_MAINTENANCE != category && STATION_MAINTENANCE != category) {\nthrow new IllegalArgumentException(String.valueOf(category));\n}\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nw, principal);\naggregator.setCategory(TRACK);\nlong amount = 0;\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nlong maintenanceCost = trackRule.getMaintenanceCost().getAmount();\n// Is the track type the category we are interested in?\nboolean rightType = TRACK_MAINTENANCE == category ? !trackRule\n.isStation() : trackRule.isStation();\nif (rightType) {\naggregator.setType(i);\namount += maintenanceCost * aggregator.calculateQuantity()\n/ TrackConfiguration.LENGTH_OF_STRAIGHT_TRACK_PIECE;\n}\n}\nTransaction t = new Bill(new Money(amount), category);\nreturn new AddTransactionMove(principal, t);\n}\npublic void update(World w) {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\nMove m = generateMove(w, principal, TRACK_MAINTENANCE);\nmoveReceiver.processMove(m);\nm = generateMove(w, principal, STATION_MAINTENANCE);\nmoveReceiver.processMove(m);\n}\n}\n}"}
{"className":"jfreerails.server.InterestChargeMoveGenerator","javaDoc":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of outstanding bonds, then calculates the interest due.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class iterates over the entries in the BankAccount and counts the number\n* of outstanding bonds, then calculates the interest due.\n*\n* @author Luke Lindsay\n*\n*/\npublic class InterestChargeMoveGenerator {\nprivate final MoveReceiver moveReceiver;\npublic InterestChargeMoveGenerator(MoveReceiver mr) {\nthis.moveReceiver = mr;\n}\nprivate static AddTransactionMove generateMove(World w,\nFreerailsPrincipal principal) {\nlong interestDue = 0;\nfor (int i = 0; i < w.getNumberOfTransactions(principal); i++) {\nTransaction t = w.getTransaction(principal, i);\nif (t instanceof BondTransaction) {\nBondTransaction bt = (BondTransaction) t;\nint interestRate = bt.getType();\nlong bondAmount = BondTransaction.BOND_VALUE_ISSUE.getAmount();\ninterestDue += (interestRate * bondAmount / 100)\n* bt.getQuantity();\n}\n}\nTransaction t = new Bill(new Money(interestDue),\nTransaction.Category.INTEREST_CHARGE);\nreturn new AddTransactionMove(principal, t);\n}\npublic void update(World w) {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\nMove m = generateMove(w, principal);\nmoveReceiver.processMove(m);\n}\n}\n}"}
{"className":"jfreerails.server.MapFactory","javaDoc":"/**\n* This class has a static method that converts an image file into a map.\n*\n* @author Luke\n* @author Scott Bennett (Updated 23rd Jan 2004)\n*\n* Implemented Terrain Randomisation to randomly position the terrain types for\n* each tile on the map.\n*/","code":"/**\n* This class has a static method that converts an image file into a map.\n*\n* @author Luke\n* @author Scott Bennett (Updated 23rd Jan 2004)\n*\n* Implemented Terrain Randomisation to randomly position the terrain types for\n* each tile on the map.\n*/\npublic class MapFactory {\n/*\n* create a vector to keep track of what terrain types to 'clump'\n*/\nprivate static final Vector<Integer> countryTypes = new Vector<Integer>();\nprivate static final Vector<Integer> non_countryTypes = new Vector<Integer>();\nprivate static WorldImpl world;\npublic static void setupMap(URL map_url, WorldImpl w,\nFreerailsProgressMonitor pm) {\n// Setup progress monitor..\npm.setValue(0);\nworld = w;\nImage mapImage = (new ImageIcon(map_url)).getImage();\nRectangle mapRect = new java.awt.Rectangle(0, 0, mapImage\n.getWidth(null), mapImage.getHeight(null));\nBufferedImage mapBufferedImage = new BufferedImage(mapRect.width,\nmapRect.height, BufferedImage.TYPE_INT_ARGB);\nGraphics g = mapBufferedImage.getGraphics();\ng.drawImage(mapImage, 0, 0, null);\nw.setupMap(mapRect.width, mapRect.height);\npm.nextStep(mapRect.width);\nHashMap<Integer, Integer> rgb2TerrainType = new HashMap<Integer, Integer>();\nfor (int i = 0; i < w.size(SKEY.TERRAIN_TYPES); i++) {\nTerrainType tilemodel = (TerrainType) w.get(SKEY.TERRAIN_TYPES, i);\nrgb2TerrainType.put(tilemodel.getRGB(), i);\n}\nTerrainType terrainTypeTile;\nfor (int c = 0; c < w.size(SKEY.TERRAIN_TYPES); c++) {\nterrainTypeTile = (TerrainType) w.get(SKEY.TERRAIN_TYPES, c);\nif (terrainTypeTile.getCategory().equals(\nTerrainType.Category.Country)) {\nif ((!terrainTypeTile.getTerrainTypeName().equals(\"Clear\"))) {\ncountryTypes.add(new Integer(c));\n}\n}\nif (terrainTypeTile.getCategory()\n.equals(TerrainType.Category.Ocean)\n|| terrainTypeTile.getCategory().equals(\nTerrainType.Category.River)\n|| terrainTypeTile.getCategory().equals(\nTerrainType.Category.Hill)) {\nnon_countryTypes.add(new Integer(c));\n}\n}\nTerrainRandomiser terrainRandomiser = new TerrainRandomiser(\ncountryTypes, non_countryTypes);\n/*\n* create vector to keep track of terrain randomisation 'clumping'\n*/\nVector<RandomTerrainValue> locations = new Vector<RandomTerrainValue>();\nfor (int x = 0; x < mapRect.width; x++) {\npm.setValue(x);\nfor (int y = 0; y < mapRect.height; y++) {\nint rgb = mapBufferedImage.getRGB(x, y);\nFreerailsTile tile;\nInteger type = rgb2TerrainType.get(rgb);\nif (null == type) {\nthrow new NullPointerException(\n\"There is no terrain type mapped to rgb value \"\n+ rgb + \" at location \" + x + \", \" + y);\n}\ntile = FreerailsTile.getInstance(terrainRandomiser\n.getNewType(type.intValue()));\nif (countryTypes.contains(tile.getTerrainTypeID())) {\nlocations.add(new RandomTerrainValue(x, y, tile\n.getTerrainTypeID()));\n}\nw.setTile(x, y, tile);\n}\n}\nfor (int i = 0; i < locations.size(); i++) {\nRandomTerrainValue rtv = locations.elementAt(i);\nFreerailsTile tile = FreerailsTile.getInstance(rtv.getType());\nint x = rtv.getX();\nint y = rtv.getY();\nint val = 3;\ndouble prob = 0.75;\nif (w.boundsContain(x - val, y - val)\n&& w.boundsContain(x + val, y + val)) {\nfor (int m = x - val; m < x + val; m++) {\nfor (int n = y - val; n < y + val; n++) {\nif (Math.random() > prob) {\nsetTile(m, n, tile);\n}\n}\n}\n}\n}\n}\nprivate static void setTile(int x, int y, FreerailsTile tile) {\nif (!non_countryTypes.contains(new Integer(((FreerailsTile) world\n.getTile(x, y)).getTerrainTypeID()))) {\nworld.setTile(x, y, tile);\n}\n}\n}"}
{"className":"jfreerails.server.RandomTerrainValue","javaDoc":"/**\n* Stores a location and terrain type.\n*\n* @author Scott?\n*/","code":"/**\n* Stores a location and terrain type.\n*\n* @author Scott?\n*/\npublic class RandomTerrainValue {\nprivate final int x;\nprivate final int y;\nprivate final int terrainType;\npublic RandomTerrainValue(int x, int y, int tt) {\nthis.x = x;\nthis.y = y;\nthis.terrainType = tt;\n}\npublic int getX() {\nreturn x;\n}\npublic int getY() {\nreturn y;\n}\npublic int getType() {\nreturn terrainType;\n}\n}"}
{"className":"jfreerails.server.TerrainRandomiser","javaDoc":"/**\n* Class to randomly select a terrain type for a terrain tile.\n*\n* TerrainRandomiser.java\n*\n* @author Scott Bennett Created on 23rd Jan 2004 The\n* Terrain Types are: 0) City (Urban) 1) Refinery (Industry) 2) Village\n* (Urban) 3) Factory (Industry) 4) Clear (Country) 5) Farm (Country) 6)\n* Desert (Country) 7) Ocean (Ocean) 8) Harbour (Ocean) 9) Stock-Yard\n* (Industry) 10) Food_Proc._Plant (Industry) 11) Cattle_Ranch\n* (Resource) 12) Grain_Elevator (Resource) 13) Oil_Well (Resource) 14)\n* Lumber_Mill (Resource) 15) Sugar_Plant. (Resource) 16) River (River)\n* 17) Landing (River) 18) Terminal (Special) 19) Jungle (Country) 20)\n* Hills (Hill) 21) Foothills (Hill) 22) Mountain (Hill)\n*/","code":"/**\n* Class to randomly select a terrain type for a terrain tile.\n*\n* TerrainRandomiser.java\n*\n* @author Scott Bennett Created on 23rd Jan 2004 The\n* Terrain Types are: 0) City (Urban) 1) Refinery (Industry) 2) Village\n* (Urban) 3) Factory (Industry) 4) Clear (Country) 5) Farm (Country) 6)\n* Desert (Country) 7) Ocean (Ocean) 8) Harbour (Ocean) 9) Stock-Yard\n* (Industry) 10) Food_Proc._Plant (Industry) 11) Cattle_Ranch\n* (Resource) 12) Grain_Elevator (Resource) 13) Oil_Well (Resource) 14)\n* Lumber_Mill (Resource) 15) Sugar_Plant. (Resource) 16) River (River)\n* 17) Landing (River) 18) Terminal (Special) 19) Jungle (Country) 20)\n* Hills (Hill) 21) Foothills (Hill) 22) Mountain (Hill)\n*/\npublic class TerrainRandomiser {\nprivate final Vector<Integer> terrainTypes;\nprivate final Vector<Integer> non_terrainTypes;\nprivate final double CLEAR_PERCENTAGE = 0.98; // ie. % of map that is\n// clear (on avg.)\npublic TerrainRandomiser(Vector<Integer> num, Vector<Integer> num2) {\nterrainTypes = num;\nnon_terrainTypes = num2;\n}\npublic int getNewType(int type) {\nint newType = type;\ndouble value;\ndouble divide = 1.0 / terrainTypes.size();\n// allow any terrain type to be drawn over except those listed in\n// non_terrainTypes\nif (!non_terrainTypes.contains(new Integer(newType))) {\nif (Math.random() < CLEAR_PERCENTAGE) {\n// make the tile Clear\nreturn 4;\n}\nvalue = Math.random();\n/*\n* at the moment, this logic produces a balanced and even\n* distribution of the different country tiles (currently 3).\n* somehow it would be better to have the actual proportions of\n* Farms, Jungle and Desert etc vary. dunno how.\n*/\nfor (int i = 0; i < terrainTypes.size(); i++) {\nif ((value > (i * divide)) && (value <= ((i + 1) * divide))) {\nreturn terrainTypes.elementAt(i).intValue();\n}\n}\n}\nreturn newType;\n}\n}"}
{"className":"jfreerails.server.CityEconomicModel","javaDoc":"/**\n* This class is lets the server analyse and alter cities.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class is lets the server analyse and alter cities.\n*\n* @author Luke\n*\n*/\nclass CityEconomicModel {\n/** Stores a tile type and its location. */\nprivate class Tile {\nfinal Point p;\nfinal TerrainType type;\npublic Tile(final Point p, final TerrainType type) {\nthis.p = p;\nthis.type = type;\n}\n}\nfinal ArrayList<Tile> urbanTiles = new ArrayList<Tile>();\nfinal ArrayList<Tile> industryTiles = new ArrayList<Tile>();\nfinal ArrayList<TerrainType> industriesNotAtCity = new ArrayList<TerrainType>();\nfinal ArrayList<Tile> resourceTiles = new ArrayList<Tile>();\nfinal ArrayList<Point> clearTiles = new ArrayList<Point>();\n/** The number of stations within this city's bounds. */\nint stations = 0;\nvoid addTile(TerrainType type) {\nRandom rand = new Random();\n// Pick a spot at random at which to place the tile.\nif (clearTiles.size() > 0) {\nint tilePos = rand.nextInt(clearTiles.size());\nPoint p = clearTiles.remove(tilePos);\nif (type.getCategory().equals(TerrainType.Category.Urban)) {\nurbanTiles.add(new Tile(p, type));\n} else if (type.getCategory().equals(TerrainType.Category.Industry)) {\nindustryTiles.add(new Tile(p, type));\nindustriesNotAtCity.remove(type);\n} else if (type.getCategory().equals(TerrainType.Category.Country)) {\nthrow new IllegalArgumentException(\n\"call remove(.) to replace a city tile with a country tile!\");\n} else if (type.getCategory().equals(TerrainType.Category.Resource)) {\nresourceTiles.add(new Tile(p, type));\n}\n}\n}\nvoid loadFromMap(ReadOnlyWorld w, int cityID) {\n/* Reset lists of tiles. */\nurbanTiles.clear();\nindustryTiles.clear();\nclearTiles.clear();\nresourceTiles.clear();\n/* Set up the list of industries not at the city. */\nindustriesNotAtCity.clear();\nfor (int i = 0; i < w.size(SKEY.TERRAIN_TYPES); i++) {\nTerrainType type = (TerrainType) w.get(SKEY.TERRAIN_TYPES, i);\nif (type.getCategory().equals(TerrainType.Category.Industry)) {\nindustriesNotAtCity.add(type);\n}\n}\nstations = 0;\n/* Identify city's bounds. */\nRectangle mapRect = new Rectangle(0, 0, w.getMapWidth(), w\n.getMapHeight());\nCityModel city = (CityModel) w.get(SKEY.CITIES, cityID);\nRectangle cityArea = new Rectangle(city.getCityX() - 3,\ncity.getCityY() - 3, 7, 7);\ncityArea = cityArea.intersection(mapRect);\n/* Count tile types. */\nfor (int x = cityArea.x; x < cityArea.x + cityArea.width; x++) {\nfor (int y = cityArea.y; y < cityArea.y + cityArea.height; y++) {\nFreerailsTile tile = (FreerailsTile) w.getTile(x, y);\n/* Count the number of stations at the city. */\nif (tile.getTrackPiece().getTrackRule().isStation()) {\nstations++;\n}\nint terrainTypeNumber = tile.getTerrainTypeID();\nTerrainType type = (TerrainType) w.get(SKEY.TERRAIN_TYPES,\nterrainTypeNumber);\nif (type.getCategory().equals(TerrainType.Category.Urban)) {\nurbanTiles.add(new Tile(new Point(x, y), type));\n} else if (type.getCategory().equals(\nTerrainType.Category.Industry)) {\nindustryTiles.add(new Tile(new Point(x, y), type));\nindustriesNotAtCity.remove(type);\n} else if (type.getCategory().equals(\nTerrainType.Category.Country)) {\nclearTiles.add(new Point(x, y));\n} else if (type.getCategory().equals(\nTerrainType.Category.Resource)) {\nresourceTiles.add(new Tile(new Point(x, y), type));\n}\n}\n}\n}\nint size() {\nreturn this.urbanTiles.size() + this.industryTiles.size()\n+ this.resourceTiles.size();\n}\nvoid write2map(World w) {\nfor (int i = 0; i < urbanTiles.size(); i++) {\nwriteTile(w, urbanTiles.get(i));\n}\nfor (int i = 0; i < industryTiles.size(); i++) {\nwriteTile(w, industryTiles.get(i));\n}\nfor (int i = 0; i < resourceTiles.size(); i++) {\nwriteTile(w, resourceTiles.get(i));\n}\n}\nprivate void writeTile(World w, Tile tile) {\nint type = 0;\nwhile (!w.get(SKEY.TERRAIN_TYPES, type).equals(tile.type)) {\ntype++;\n}\nint x = tile.p.x;\nint y = tile.p.y;\nFreerailsTile fTile = (FreerailsTile) w.getTile(x, y);\nfTile = FreerailsTile.getInstance(type, fTile.getTrackPiece());\nw.setTile(x, y, fTile);\n}\n}"}
{"className":"jfreerails.server.InputCityNames","javaDoc":"/**\n* Class that calls the object to input the City names and co-ords from an xml\n* file.\n*\n* @author Scott Bennett Date: 31st March 2003\n*/","code":"/**\n* Class that calls the object to input the City names and co-ords from an xml\n* file.\n*\n* @author Scott Bennett Date: 31st March 2003\n*/\npublic class InputCityNames {\npublic static void readCityNames(World w, URL filename) throws SAXException {\nInputSource is = new InputSource(filename.toString());\nDefaultHandler handler = new CitySAXParser(w);\nSAXParserFactory factory = SAXParserFactory.newInstance();\ntry {\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(is, handler);\n} catch (IOException e) {\ne.printStackTrace();\n} catch (ParserConfigurationException pce) {\npce.printStackTrace();\n}\n}\n}"}
{"className":"jfreerails.server.CargoAtStationsGenerator","javaDoc":"/**\n* This class loops over the list of stations and adds cargo depending on what\n* the surrounding tiles supply.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class loops over the list of stations and adds cargo depending on what\n* the surrounding tiles supply.\n*\n* @author Luke\n*\n*/\npublic class CargoAtStationsGenerator implements FreerailsServerSerializable {\nprivate static final long serialVersionUID = 3834596504072959796L;\npublic CargoAtStationsGenerator() {\n}\n/** Call this method once a month. */\npublic void update(World w, MoveReceiver moveReceiver) {\nfor (int k = 0; k < w.getNumberOfPlayers(); k++) {\nFreerailsPrincipal principal = w.getPlayer(k).getPrincipal();\nNonNullElements nonNullStations = new NonNullElements(KEY.STATIONS,\nw, principal);\nwhile (nonNullStations.next()) {\nStationModel station = (StationModel) nonNullStations\n.getElement();\nSupplyAtStation supply = station.getSupply();\nImmutableCargoBundle cargoBundle = (ImmutableCargoBundle) w\n.get(principal, KEY.CARGO_BUNDLES,\nstation.getCargoBundleID());\nMutableCargoBundle before = new MutableCargoBundle(cargoBundle);\nMutableCargoBundle after = new MutableCargoBundle(cargoBundle);\nint stationNumber = nonNullStations.getIndex();\n/*\n* Get the iterator from a copy to avoid a\n* ConcurrentModificationException if the amount gets set to\n* zero and the CargoBatch removed from the cargo bundle. LL\n*/\nIterator<CargoBatch> it = after.toImmutableCargoBundle()\n.cargoBatchIterator();\nwhile (it.hasNext()) {\nCargoBatch cb = it.next();\nint amount = after.getAmount(cb);\nif (amount > 0) {\n// (23/24)^12 = 0.60\nafter.setAmount(cb, amount * 23 / 24);\n}\n}\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\nint amountSupplied = supply.getSupply(i);\nif (amountSupplied > 0) {\nCargoBatch cb = new CargoBatch(i, station.x, station.y,\n0, stationNumber);\nint amountAlready = after.getAmount(cb);\n// Obtain the month\nGameTime time = w.currentTime();\nGameCalendar calendar = (GameCalendar) w\n.get(ITEM.CALENDAR);\nint month = calendar.getMonth(time.getTicks());\nint amountAfter = calculateAmountToAdd(amountSupplied,\nmonth)\n+ amountAlready;\nafter.setAmount(cb, amountAfter);\n}\n}\nMove m = new ChangeCargoBundleMove(before\n.toImmutableCargoBundle(), after\n.toImmutableCargoBundle(), station.getCargoBundleID(),\nprincipal);\nmoveReceiver.processMove(m);\n}\n}\n}\nint calculateAmountToAdd(int amountSuppliedPerYear, int month) {\n// Note, jan is month 0.\nint totalAtMonthEnd = amountSuppliedPerYear * (month + 1) / 12;\nint totalAtMonthStart = amountSuppliedPerYear * (month) / 12;\nint amount = totalAtMonthEnd - totalAtMonthStart;\nreturn amount;\n}\n}"}
{"className":"jfreerails.server.OldWorldImpl","javaDoc":"/**\n* This class sets up a World object.\n*\n* @author luke\n*/","code":"/**\n* This class sets up a World object.\n*\n* @author luke\n*/\npublic class OldWorldImpl {\n/** Note, the map name is converted to lower case and any spaces\n* are replaced with underscores.\n*\n*/\npublic static World createWorldFromMapFile(String mapName,\nFreerailsProgressMonitor pm) {\nmapName = mapName.toLowerCase();\nmapName = mapName.replace(' ', '_');\npm.setValue(0);\npm.nextStep(7);\nint progress = 0;\nTileSetFactory tileFactory = new TileSetFactoryImpl();\npm.setValue(++progress);\nWorldImpl w = new WorldImpl();\npm.setValue(++progress);\nWagonAndEngineTypesFactory wetf = new WagonAndEngineTypesFactory();\npm.setValue(++progress);\nwetf.addTypesToWorld(w);\npm.setValue(++progress);\ntileFactory.addTerrainTileTypesList(w);\npm.setValue(++progress);\nURL track_xml_url = OldWorldImpl.class\n.getResource(\"/jfreerails/data/track_tiles.xml\");\nTrack_TilesHandlerImpl trackSetFactory = new Track_TilesHandlerImpl(\ntrack_xml_url);\npm.setValue(++progress);\ntrackSetFactory.addTrackRules(w);\npm.setValue(++progress);\n// Load the terrain map\nURL map_url = OldWorldImpl.class.getResource(\"/jfreerails/data/\"\n+ mapName + \".png\");\nMapFactory.setupMap(map_url, w, pm);\n// Load the city names\nURL cities_xml_url = OldWorldImpl.class.getResource(\"/jfreerails/data/\"\n+ mapName + \"_cities.xml\");\ntry {\nInputCityNames.readCityNames(w, cities_xml_url);\n} catch (SAXException e) {\n}\n// Randomly position the city tiles\nCityTilePositioner ctp = new CityTilePositioner(w);\nctp.initCities();\n// Set the time..\nw.set(ITEM.CALENDAR, new GameCalendar(1200, 1840));\nw.setTime(new GameTime(0));\nw.set(ITEM.GAME_SPEED, new GameSpeed(10));\nw.set(ITEM.GAME_RULES, GameRules.DEFAULT_RULES);\n/*\n* Note, money used to get added to player accounts here, now it is done\n* when players are added. See AddPlayerMove\n*/\nreturn w;\n}\n}"}
{"className":"jfreerails.server.MapCustomizer","javaDoc":"/**\n* Provides methods to customize a map by adding track, stations and trains.\n* Intended for use in unit tests.\n*\n* @author Luke\n*/","code":"/**\n* Provides methods to customize a map by adding track, stations and trains.\n* Intended for use in unit tests.\n*\n* @author Luke\n*/\npublic class MapCustomizer {\npublic final World w;\nprivate final TrackMoveProducer producer;\nprivate final TrackPathFinder pathFinder;\nprivate final StationBuilder stationBuilder;\nprivate final BuildTrackStrategy bts;\npublic MapCustomizer() {\nthis(MapFixtureFactory2.getCopy());\n}\npublic MapCustomizer(World w) {\nthis.w = w;\nMoveExecutor me = new SimpleMoveExecutor(w, 0);\nModelRoot mr = new ModelRootImpl();\nproducer = new TrackMoveProducer(me, w, mr);\nFreerailsPrincipal principal = w.getPlayer(0).getPrincipal();\npathFinder = new TrackPathFinder(w, principal);\nstationBuilder = new StationBuilder(me);\nint terminalTypeID = stationBuilder.getTrackTypeID(\"terminal\");\nstationBuilder.setStationType(terminalTypeID);\nbts = BuildTrackStrategy.getDefault(w);\n}\npublic MapCustomizer buildTrack(ImPoint a, ImPoint b) throws PathNotFoundException {\npathFinder.setupSearch(a, b, bts);\npathFinder.search(-1);\nList<ImPoint> pathAsPoints = pathFinder.pathAsPoints();\nImPoint from = a;\nfor (int i = 0; i < pathAsPoints.size(); i++) {\nImPoint to = pathAsPoints.get(i);\nStep vector = Step.getInstance(to.x - from.x, to.y\n- from.y);\nFreerailsTile tile = (FreerailsTile) w.getTile(\nfrom.x, from.y);\nif (!tile.getTrackPiece().getTrackConfiguration().contains(vector)) {\nproducer.buildTrack(from, vector);\n}\nfrom = to;\n}\nreturn this;\n}\npublic MapCustomizer buildStation(ImPoint a) {\nMoveStatus ms = stationBuilder.buildStation(a);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\nreturn this;\n}\npublic MapCustomizer buildTrain(ImPoint a, int... stops) {\nFreerailsPrincipal principal = w.getPlayer(0).getPrincipal();\nMutableSchedule s = new MutableSchedule();\nfor (int stop : stops) {\ns.addOrder(new TrainOrdersModel(stop, null, false, true));\n}\nImmutableSchedule defaultSchedule = s.toImmutableSchedule();\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(),\na, principal, defaultSchedule);\nMove m = preMove.generateMove(w);\nMoveStatus status = m.doMove(w, Player.AUTHORITATIVE);\nif (!status.ok) {\nthrow new IllegalStateException(status.message);\n}\nreturn this;\n}\n/**\n* Returns -1 if no station here or the id of the station if one is\n* present.\n*/\npublic int getStationId(ImPoint location) {\nFreerailsPrincipal principal = w.getPlayer(0).getPrincipal();\nFreerailsTile tile = (FreerailsTile) w.getTile(location.x, location.y);\nTrackRule trackRule = tile.getTrackPiece().getTrackRule();\nif (trackRule.isStation()\n&& tile.getTrackPiece().getOwnerID() == w.getID(principal)) {\nfor (int i = 0; i < w.size(principal, KEY.STATIONS); i++) {\nStationModel station = (StationModel) w.get(principal,\nKEY.STATIONS, i);\nif (null != station && station.getLocation().equals(location)) {\nreturn i;\n}\n}\nthrow new IllegalStateException();\n} else {\nreturn -1;\n}\n}\n}"}
{"className":"jfreerails.server.CalcSupplyAtStations","javaDoc":"/**\n* This class loops through all of the known stations and recalculates the\n* cargoes that they supply, demand, and convert.\n*\n* @author Scott Bennett Created: 19th May 2003\n*/","code":"/**\n* This class loops through all of the known stations and recalculates the\n* cargoes that they supply, demand, and convert.\n*\n* @author Scott Bennett Created: 19th May 2003\n*/\npublic class CalcSupplyAtStations {\nprivate final World w;\nprivate final MoveReceiver moveReceiver;\n/**\n*\n* Constructor, currently called from GUIComponentFactory.\n*\n* @param world\n* The World object that contains all about the game world\n*\n*/\npublic CalcSupplyAtStations(World world, MoveReceiver mr) {\nthis.w = world;\nthis.moveReceiver = mr;\n}\n/**\n*\n* Loop through each known station, call calculations method.\n*\n*/\npublic void doProcessing() {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\nNonNullElements iterator = new NonNullElements(KEY.STATIONS, w,\nprincipal);\nwhile (iterator.next()) {\nStationModel stationBefore = (StationModel) iterator\n.getElement();\nCalcCargoSupplyRateAtStation supplyRate;\nsupplyRate = new CalcCargoSupplyRateAtStation(w,\nstationBefore.x, stationBefore.y);\nStationModel stationAfter = supplyRate\n.calculations(stationBefore);\nif (!stationAfter.equals(stationBefore)) {\nMove move = new ChangeStationMove(iterator.getIndex(),\nstationBefore, stationAfter, principal);\nthis.moveReceiver.processMove(move);\n}\n}\n}\n}\n}"}
{"className":"jfreerails.server.TrainUpdater","javaDoc":"/**\n* This class is used by the server to generate moves that add trains, move\n* trains, and handle stops at stations. Note, the client should not use this\n* class to build trains, instead it should request that a train gets built by\n* setting production at an engine shop.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/","code":"/**\n* This class is used by the server to generate moves that add trains, move\n* trains, and handle stops at stations. Note, the client should not use this\n* class to build trains, instead it should request that a train gets built by\n* setting production at an engine shop.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/\npublic class TrainUpdater implements ServerAutomaton {\nprivate static final long serialVersionUID = 3258410646839243577L;\n/**\n* @return a move that initialises the trains schedule.\n*/\npublic static Move initTarget(TrainModel train, int trainID,\nImmutableSchedule currentSchedule, FreerailsPrincipal principal) {\nVector<Move> moves = new Vector<Move>();\nint scheduleID = train.getScheduleID();\nMutableSchedule schedule = new MutableSchedule(currentSchedule);\nImInts wagonsToAdd = schedule.getWagonsToAdd();\nif (null != wagonsToAdd) {\nint engine = train.getEngineType();\nChangeTrainMove move = ChangeTrainMove.generateMove(trainID, train,\nengine, wagonsToAdd, principal);\nmoves.add(move);\n}\nschedule.gotoNextStation();\nImmutableSchedule newSchedule = schedule.toImmutableSchedule();\nChangeTrainScheduleMove move = new ChangeTrainScheduleMove(scheduleID,\ncurrentSchedule, newSchedule, principal);\nmoves.add(move);\nreturn new CompositeMove(moves.toArray(new Move[1]));\n}\nstatic TrainPositionOnMap setInitialTrainPosition(TrainModel train,\nFreerailsPathIterator from) {\nint trainLength = train.getLength();\nPathWalker fromPathWalker = new PathWalkerImpl(from);\nassert fromPathWalker.canStepForward();\nfromPathWalker.stepForward(trainLength);\nTrainPositionOnMap initialPosition = TrainPositionOnMap\n.createInSameDirectionAsPath(fromPathWalker);\nreturn initialPosition;\n}\npublic static ImPoint[] trainPos2Tiles(TrainPositionOnMap pos) {\nImPoint[] returnValue = new ImPoint[pos.getLength()];\nfinal int TILE_WIDTH = 30;\nfor (int i = 0; i < returnValue.length; i++) {\nreturnValue[i] = new ImPoint(pos.getX(i) / TILE_WIDTH, pos.getY(i)\n/ TILE_WIDTH);\n}\nreturn returnValue;\n}\nprivate transient MoveReceiver moveReceiver;\npublic TrainUpdater(MoveReceiver mr) {\nmoveReceiver = mr;\nif (null == mr) {\nthrow new NullPointerException();\n}\n}\npublic void buildTrain(int engineTypeId, ImInts wagons, ImPoint p,\nFreerailsPrincipal principal, ReadOnlyWorld world) {\n// If there are no wagons, setup an automatic schedule.\nboolean autoSchedule = 0 == wagons.size();\nImmutableSchedule is = generateInitialSchedule(principal, world,\nautoSchedule);\nPreMove addTrain = new AddTrainPreMove(engineTypeId, wagons, p,\nprincipal, is);\nMove m = addTrain.generateMove(world);\nmoveReceiver.processMove(m);\n}\n// /**\n// * Generates a composite move that adds a train to the train list, adds a\n// * cargo bundle for the train to the cargo bundles list, and sets the\n// * train's initial position. The move is sent to the moveProcessor and a\n// * TrainMover object to update the trains position is returned.\n// *\n// * @param engineTypeId\n// * type of the engine\n// * @param wagons\n// * array of wagon types\n// * @param p\n// * point at which to add train on map.\n// *\n// *\n// */\n// public TrainMover buildTrain(int engineTypeId, ImInts wagons, ImPoint p,\n// FreerailsPrincipal principal, ReadOnlyWorld world) {\n// /* Check that the specified position is on the track. */\n// FreerailsTile tile = (FreerailsTile) world.getTile(p.x, p.y);\n// if (NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER != tile.getTrackTypeID()) {\n// /* Create the move that sets up the train's cargo bundle. */\n// int cargoBundleId = world.size(principal, KEY.CARGO_BUNDLES);\n// Move addCargoBundleMove = new AddCargoBundleMove(cargoBundleId,\n// ImmutableCargoBundle.EMPTY_BUNDLE, principal);\n//\n// /* Create the train model object. */\n// int scheduleId = world.size(principal, KEY.TRAIN_SCHEDULES);\n//\n// TrainModel train = new TrainModel(engineTypeId, wagons, scheduleId,\n// cargoBundleId);\n//\n// /* Create the move that sets up the train's schedule. */\n//\n// // If there are no wagons, setup an automatic schedule.\n// boolean autoSchedule = 0 == wagons.size();\n//\n// ImmutableSchedule is = generateInitialSchedule(principal, world,\n// autoSchedule);\n// int trainId = world.size(principal, KEY.TRAINS);\n// Move setupScheduleMove = TrainUpdater.initTarget(train, trainId,\n// is, principal);\n//\n// /* Create the move that sets the train's initial position. */\n// FreerailsPathIterator from = getRandomPathToFollow(p, world);\n// TrainPositionOnMap initialPosition = TrainUpdater\n// .setInitialTrainPosition(train, from);\n// Move positionMove = new InitialiseTrainPositionMove(trainId,\n// initialPosition, principal);\n//\n// /* Determine the price of the train. */\n// EngineType engineType = (EngineType) world.get(SKEY.ENGINE_TYPES,\n// engineTypeId);\n// Money price = engineType.getPrice();\n//\n// /* Create the move that adds the train to the train list. */\n// AddTrainMove addTrainMove = AddTrainMove.generateMove(trainId,\n// train, price, is, principal);\n//\n// /* Create a composite move made up of the moves created above. */\n// Move compositeMove = new CompositeMove(new Move[] {\n// addCargoBundleMove, addTrainMove, setupScheduleMove });\n//\n// /* Execute the move. */\n// moveReceiver.processMove(compositeMove);\n// moveReceiver.processMove(positionMove);\n//\n// /* Create a TrainMover to update the train's position. */\n// TrainPathFinder tpf = getPathToFollow(p, world, trainId, principal);\n// TrainMover trainMover = new TrainMover(tpf, world, trainId,\n// principal);\n//\n// return trainMover;\n// }\n// throw new IllegalArgumentException(\"No track here (\" + p.x + \", \" + p.y\n// + \") so cannot build train\");\n// }\n/**\n* Iterator over the stations and build trains at any that have their\n* production field set.\n*\n*/\nvoid buildTrains(ReadOnlyWorld world) {\nfor (int k = 0; k < world.getNumberOfPlayers(); k++) {\nFreerailsPrincipal principal = world.getPlayer(k).getPrincipal();\nfor (int i = 0; i < world.size(principal, KEY.STATIONS); i++) {\nStationModel station = (StationModel) world.get(principal,\nKEY.STATIONS, i);\nif (null != station) {\nImList<PlannedTrain> production = station\n.getProduction();\nif (production.size() > 0) {\nImPoint p = new ImPoint(station.x, station.y);\nfor (int j = 0; j < production.size(); j++) {\nint engineType = production.get(j).getEngineType();\nImInts wagonTypes = production.get(j)\n.getWagonTypes();\nthis.buildTrain(engineType, wagonTypes, p,\nprincipal, world);\n// TrainMover trainMover =\n// this.buildTrain(engineType, wagonTypes, p,\n// principal, world);\n// this.addTrainMover(trainMover);\n}\nChangeProductionAtEngineShopMove move = new ChangeProductionAtEngineShopMove(\nproduction,\nnew ImList<PlannedTrain>(), i,\nprincipal);\nmoveReceiver.processMove(move);\n}\n}\n}\n}\n}\nprivate ImmutableSchedule generateInitialSchedule(\nFreerailsPrincipal principal, ReadOnlyWorld world,\nboolean autoSchedule) {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, world, principal);\nMutableSchedule s = new MutableSchedule();\n// Add upto 4 stations to the schedule.\nwhile (wi.next() && s.getNumOrders() < 5) {\nTrainOrdersModel orders = new TrainOrdersModel(wi.getIndex(), null,\nfalse, autoSchedule);\ns.addOrder(orders);\n}\ns.setOrderToGoto(0);\nImmutableSchedule is = s.toImmutableSchedule();\nreturn is;\n}\npublic void initAutomaton(MoveReceiver mr) {\nmoveReceiver = mr;\n}\nvoid moveTrains(ReadOnlyWorld world) {\nint time = world.currentTime().getTicks();\nfor (int k = 0; k < world.getNumberOfPlayers(); k++) {\nFreerailsPrincipal principal = world.getPlayer(k).getPrincipal();\n//If a train is moving, we want it to keep moving rather than stop\n//to allow an already stationary train to start moving. To achieve this\n//we process moving trains first.\nArrayList<Integer> movingTrains = new ArrayList<Integer>();\nArrayList<Integer> stoppedTrains = new ArrayList<Integer>();\nfor (int i = 0; i < world.size(principal, KEY.TRAINS); i++) {\nTrainModel train = (TrainModel) world.get(principal,\nKEY.TRAINS, i);\nif (null == train) {\ncontinue;\n}\nTrainAccessor ta = new TrainAccessor(world, principal, i);\nif (ta.isMoving(time)) {\nmovingTrains.add(i);\n} else {\nstoppedTrains.add(i);\n}\n}\nfor (int trainId : movingTrains) {\nmoveTrain(world, principal, trainId);\n}\nfor (int trainId : stoppedTrains) {\nmoveTrain(world, principal, trainId);\n}\n}\n}\nprivate void moveTrain(ReadOnlyWorld world, FreerailsPrincipal principal, int trainId) {\nMoveTrainPreMove preMove = new MoveTrainPreMove(trainId, principal);\nif (preMove.isUpdateDue(world)) {\nTrainAccessor ta = new TrainAccessor(world, principal, trainId);\nif (!ta.trackExists()) {\nSystem.out.println(\"Track under train does not exist. Retiring train..\");\nthis.retireTrain(world, principal, trainId);\n} else {\nMove m = preMove.generateMove(world);\nmoveReceiver.processMove(m);\n}\n}\n}\nprivate void retireTrain(ReadOnlyWorld world, FreerailsPrincipal principal, int trainId) {\nMove m = RemoveTrainMove.getInstance(trainId, principal, world);\nmoveReceiver.processMove(m);\n}\n}"}
{"className":"jfreerails.server.common.TileSetFactory","javaDoc":"/**\n* This interface defines a method to add the terrain types to the world.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* This interface defines a method to add the terrain types to the world.\n*\n* @author Luke Lindsay 09 October 2001\n*/\npublic interface TileSetFactory {\nvoid addTerrainTileTypesList(World w);\n}"}
{"className":"jfreerails.server.parser.RunTypesParser","javaDoc":"/**\n* The main method on this class uses CargoAndTerrainParser to the parse cargo\n* and terrain types xml file - use it to test the parser and xml file work\n* together.\n*\n* @author Luke\n*/","code":"/**\n* The main method on this class uses CargoAndTerrainParser to the parse cargo\n* and terrain types xml file - use it to test the parser and xml file work\n* together.\n*\n* @author Luke\n*/\npublic class RunTypesParser {\nprivate static final Logger logger = Logger.getLogger(RunTypesParser.class\n.getName());\npublic static void main(String[] args) {\ntry {\njava.net.URL url = RunTypesParser.class\n.getResource(\"/jfreerails/data/cargo_and_terrain.xml\");\nCargoAndTerrainParser.parse(url, new CargoAndTerrainHandlerImpl(\nnew WorldImpl()));\nlogger.info(\"It worked\");\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}"}
{"className":"jfreerails.server.parser.Track_TilesHandlerImpl","javaDoc":"/**\n* Processes Track_TilesHandle events, generates track rules, and provides a\n* methods to add the track rules to the world object.\n*\n* @author lindsal\n* @version generated by FFJ XML module\n* @see Track_TilesParser\n*/","code":"/**\n* Processes Track_TilesHandle events, generates track rules, and provides a\n* methods to add the track rules to the world object.\n*\n* @author lindsal\n* @version generated by FFJ XML module\n* @see Track_TilesParser\n*/\npublic class Track_TilesHandlerImpl implements Track_TilesHandler {\nint maxConsequ;\nprotected List<TrackRule> ruleList;\nprotected jfreerails.world.track.TrackRuleProperties trackRuleProperties;\nprotected jfreerails.world.track.LegalTrackConfigurations legalTrackConfigurations;\nprotected ArrayList<String> legalTemplates;\nprotected HashSet<TerrainType.Category> terrainTypes;\nprotected LegalTrackPlacement legalTrackPlacement;\npublic void start_CanOnlyBuildOnTheseTerrainTypes(final Attributes meta)\nthrows SAXException {\nterrainTypes = new HashSet<TerrainType.Category>();\n}\npublic void end_CanOnlyBuildOnTheseTerrainTypes() throws SAXException {\nlegalTrackPlacement = new LegalTrackPlacement(terrainTypes,\nLegalTrackPlacement.PlacementRule.ONLY_ON_THESE);\nterrainTypes = null;\n}\npublic void start_ListOfTrackPieceTemplates(final Attributes meta)\nthrows SAXException {\nlegalTemplates = new ArrayList<String>();\n}\npublic void end_ListOfTrackPieceTemplates() throws SAXException {\nlegalTrackConfigurations = new jfreerails.world.track.LegalTrackConfigurations(\nmaxConsequ, legalTemplates);\nlegalTemplates = null;\n}\npublic void start_ListOfLegalRoutesAcrossNode(final Attributes meta)\nthrows SAXException {\n}\npublic void end_ListOfLegalRoutesAcrossNode() throws SAXException {\n}\npublic void handle_LegalRouteAcrossNode(final Attributes meta)\nthrows SAXException {\n}\npublic void start_CannotBuildOnTheseTerrainTypes(final Attributes meta)\nthrows SAXException {\nterrainTypes = new java.util.HashSet<TerrainType.Category>();\n}\npublic void end_CannotBuildOnTheseTerrainTypes() throws SAXException {\nlegalTrackPlacement = new LegalTrackPlacement(terrainTypes,\nLegalTrackPlacement.PlacementRule.ANYWHERE_EXCEPT_ON_THESE);\nterrainTypes = null;\n}\npublic void start_TrackType(final Attributes meta) throws SAXException {\nint rGBvalue;\nString rgbString = meta.getValue(\"RGBvalue\");\nrGBvalue = Integer.parseInt(rgbString, 16);\n/*\n* We need to change the format of the rgb value to the same one as used\n* by the the BufferedImage that stores the map. See\n* jfreerails.common.Map\n*/\nrGBvalue = new java.awt.Color(rGBvalue).getRGB();\nTrackRule.TrackCategories category = TrackRule.TrackCategories\n.valueOf(meta.getValue(\"category\"));\nboolean enableDoubleTrack = Boolean.valueOf(\nmeta.getValue(\"doubleTrack\")).booleanValue();\nString typeName = meta.getValue(\"type\");\nmaxConsequ = Integer.parseInt(meta.getValue(\"maxConsecuativePieces\"));\nString stationRadiusString = meta.getValue(\"stationRadius\");\nint stationRadius;\nif (null != stationRadiusString) {\nstationRadius = Integer.parseInt(stationRadiusString);\n} else {\nstationRadius = 0;\n}\nString priceString = meta.getValue(\"price\");\nint price = Integer.parseInt(priceString);\nString fixedCostString = meta.getValue(\"fixedCost\");\nint fixedCost;\nif (null != fixedCostString) {\nfixedCost = Integer.parseInt(fixedCostString);\n} else {\nfixedCost = 0;\n}\nString maintenanceString = meta.getValue(\"maintenance\");\nint maintenance = Integer.parseInt(maintenanceString);\ntrackRuleProperties = new TrackRuleProperties(rGBvalue,\nenableDoubleTrack, typeName, category, stationRadius, price,\nmaintenance, fixedCost);\n}\npublic void end_TrackType() throws SAXException {\nTrackRuleImpl trackRuleImpl = new jfreerails.world.track.TrackRuleImpl(\ntrackRuleProperties, legalTrackConfigurations,\nlegalTrackPlacement);\nruleList.add(trackRuleImpl);\nlegalTrackConfigurations = null;\ntrackRuleProperties = null;\nlegalTrackPlacement = null;\n}\npublic void handle_TerrainType(final Attributes meta) throws SAXException {\nTerrainType.Category cat = TerrainType.Category.valueOf(meta\n.getValue(\"name\"));\nterrainTypes.add(cat);\n}\npublic void start_Tiles(final Attributes meta) throws SAXException {\n}\npublic void end_Tiles() throws SAXException {\n// Sort the track tiles by category then price.\nCollections.sort(ruleList);\n}\npublic void start_TrackPieceTemplate(final Attributes meta)\nthrows SAXException {\nlegalTemplates.add(meta.getValue(\"trackTemplate\"));\n}\npublic void end_TrackPieceTemplate() throws SAXException {\n// do nothing.\n}\npublic void start_TrackSet(final Attributes meta) throws SAXException {\nruleList = new ArrayList<TrackRule>();\n}\npublic void end_TrackSet() throws SAXException {\n}\npublic Track_TilesHandlerImpl(java.net.URL trackXmlUrl) {\ntry {\nTrack_TilesParser.parse(trackXmlUrl, this);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\npublic void addTrackRules(World w) {\nfor (int i = 0; i < this.ruleList.size(); i++) {\nTrackRule r = ruleList.get(i);\nw.add(SKEY.TRACK_RULES, r);\n}\n}\npublic List<TrackRule> getRuleList() {\nreturn ruleList;\n}\n}"}
{"className":"jfreerails.server.parser.CargoAndTerrainHandler","javaDoc":"/**\n* Defines methods to handle parsing the cargo and terrain types XML.\n*\n* @author Luke\n* @version generated by NetBeans XML module\n*/","code":"/**\n* Defines methods to handle parsing the cargo and terrain types XML.\n*\n* @author Luke\n* @version generated by NetBeans XML module\n*/\npublic interface CargoAndTerrainHandler {\n/**\n* An empty element event handling method.\n*\n*/\npublic void handle_Converts(final Attributes meta) throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*\n*/\npublic void start_Tile(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*\n*/\npublic void end_Tile() throws SAXException;\n/**\n* An empty element event handling method.\n*\n*/\npublic void handle_Cargo(final Attributes meta) throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*\n*/\npublic void start_Cargo_Types(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*\n*/\npublic void end_Cargo_Types() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*\n*/\npublic void start_Terrain_Types(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*\n*/\npublic void end_Terrain_Types() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*\n*/\npublic void start_Types(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*\n*/\npublic void end_Types() throws SAXException;\n/**\n* An empty element event handling method.\n*\n*/\npublic void handle_Consumes(final Attributes meta) throws SAXException;\n/**\n* An empty element event handling method.\n*\n*/\npublic void handle_Produces(final Attributes meta) throws SAXException;\n}"}
{"className":"jfreerails.server.parser.Track_TilesHandler","javaDoc":"/**\n* Defines methods to handle parsing the track types XML.\n*\n* @author lindsal\n* @version generated by FFJ XML module\n*/","code":"/**\n* Defines methods to handle parsing the track types XML.\n*\n* @author lindsal\n* @version generated by FFJ XML module\n*/\npublic interface Track_TilesHandler {\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_CanOnlyBuildOnTheseTerrainTypes(final Attributes meta)\nthrows SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_CanOnlyBuildOnTheseTerrainTypes() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_ListOfTrackPieceTemplates(final Attributes meta)\nthrows SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_ListOfTrackPieceTemplates() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_ListOfLegalRoutesAcrossNode(final Attributes meta)\nthrows SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_ListOfLegalRoutesAcrossNode() throws SAXException;\n/**\n* An empty element event handling method.\n*/\nvoid handle_LegalRouteAcrossNode(final Attributes meta) throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_CannotBuildOnTheseTerrainTypes(final Attributes meta)\nthrows SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_CannotBuildOnTheseTerrainTypes() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_TrackType(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_TrackType() throws SAXException;\n/**\n* An empty element event handling method.\n*/\nvoid handle_TerrainType(final Attributes meta) throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_Tiles(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_Tiles() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_TrackPieceTemplate(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_TrackPieceTemplate() throws SAXException;\n/**\n* A container element start event handling method.\n*\n* @param meta\n* attributes\n*/\nvoid start_TrackSet(final Attributes meta) throws SAXException;\n/**\n* A container element end event handling method.\n*/\nvoid end_TrackSet() throws SAXException;\n}"}
{"className":"jfreerails.server.parser.CargoAndTerrainParser","javaDoc":"/**\n* The class reads XML documents according to specified DTD and translates all\n* related events into CargoAndTerrainHandler events.\n* <p>\n* Usage sample:\n*\n* <pre>\n* RulesParser parser = new RulesParser(...);\n* parser.parse(new InputSource(&quot;...&quot;));\n* </pre>\n*\n* <p>\n* <b>Warning:</b> the class is machine generated. DO NOT MODIFY\n* </p>\n*\n* @author Luke\n*/","code":"/**\n* The class reads XML documents according to specified DTD and translates all\n* related events into CargoAndTerrainHandler events.\n* <p>\n* Usage sample:\n*\n* <pre>\n* RulesParser parser = new RulesParser(...);\n* parser.parse(new InputSource(&quot;...&quot;));\n* </pre>\n*\n* <p>\n* <b>Warning:</b> the class is machine generated. DO NOT MODIFY\n* </p>\n*\n* @author Luke\n*/\npublic class CargoAndTerrainParser implements ContentHandler {\nprivate static final Logger logger = Logger\n.getLogger(CargoAndTerrainParser.class.getName());\nprivate java.lang.StringBuffer buffer;\nprivate CargoAndTerrainHandler handler;\nprivate java.util.Stack<Object[]> context;\nprivate EntityResolver resolver;\n/**\n* Creates a parser instance.\n*\n* @param handler\n* handler interface implementation (never <code>null</code>\n* @param resolver\n* SAX entity resolver implementation or <code>null</code>. It\n* is recommended that it could be able to resolve at least the\n* DTD.\n*/\npublic CargoAndTerrainParser(final CargoAndTerrainHandler handler,\nfinal EntityResolver resolver) {\nthis.handler = handler;\nthis.resolver = resolver;\nbuffer = new StringBuffer(111);\ncontext = new java.util.Stack<Object[]>();\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void setDocumentLocator(Locator locator) {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void startDocument() throws SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void endDocument() throws SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void startElement(java.lang.String ns, java.lang.String name,\njava.lang.String qname, Attributes attrs) throws SAXException {\ndispatch(true);\ncontext.push(new Object[] { qname,\nnew org.xml.sax.helpers.AttributesImpl(attrs) });\nif (\"Converts\".equals(name)) {\nhandler.handle_Converts(attrs);\n} else if (\"Tile\".equals(name)) {\nhandler.start_Tile(attrs);\n} else if (\"Cargo\".equals(name)) {\nhandler.handle_Cargo(attrs);\n} else if (\"Cargo_Types\".equals(name)) {\nhandler.start_Cargo_Types(attrs);\n} else if (\"Terrain_Types\".equals(name)) {\nhandler.start_Terrain_Types(attrs);\n} else if (\"Types\".equals(name)) {\nhandler.start_Types(attrs);\n} else if (\"Consumes\".equals(name)) {\nhandler.handle_Consumes(attrs);\n} else if (\"Produces\".equals(name)) {\nhandler.handle_Produces(attrs);\n}\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void endElement(java.lang.String ns, java.lang.String name,\njava.lang.String qname) throws SAXException {\ndispatch(false);\ncontext.pop();\nif (\"Tile\".equals(name)) {\nhandler.end_Tile();\n} else if (\"Cargo_Types\".equals(name)) {\nhandler.end_Cargo_Types();\n} else if (\"Terrain_Types\".equals(name)) {\nhandler.end_Terrain_Types();\n} else if (\"Types\".equals(name)) {\nhandler.end_Types();\n}\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void characters(char[] chars, int start, int len)\nthrows SAXException {\nbuffer.append(chars, start, len);\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void ignorableWhitespace(char[] chars, int start, int len)\nthrows SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void processingInstruction(java.lang.String target,\njava.lang.String data) throws SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void startPrefixMapping(final java.lang.String prefix,\nfinal java.lang.String uri) throws SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void endPrefixMapping(final java.lang.String prefix)\nthrows SAXException {\n}\n/**\n* This SAX interface method is implemented by the parser.\n*\n*/\npublic final void skippedEntity(java.lang.String name) throws SAXException {\n}\nprivate void dispatch(final boolean fireOnlyIfMixed) throws SAXException {\nif (fireOnlyIfMixed && buffer.length() == 0) {\nreturn; // skip it\n}\nbuffer.delete(0, buffer.length());\n}\n/**\n* The recognizer entry method taking an Inputsource.\n*\n* @param input\n* InputSource to be parsed.\n* @throws java.io.IOException\n* on I/O error.\n* @throws SAXException\n* propagated exception thrown by a DocumentHandler.\n* @throws javax.xml.parsers.ParserConfigurationException\n* a parser satisfying requested configuration can not be\n* created.\n*\n*/\npublic static void parse(final InputSource input,\nfinal CargoAndTerrainHandler handler) throws SAXException,\njavax.xml.parsers.ParserConfigurationException, java.io.IOException {\nparse(input, new CargoAndTerrainParser(handler, null));\n}\n/**\n* The recognizer entry method taking a URL.\n*\n* @param url\n* URL source to be parsed.\n* @throws java.io.IOException\n* on I/O error.\n* @throws SAXException\n* propagated exception thrown by a DocumentHandler.\n* @throws javax.xml.parsers.ParserConfigurationException\n* a parser satisfying requested configuration can not be\n* created.\n*\n*/\npublic static void parse(final java.net.URL url,\nfinal CargoAndTerrainHandler handler) throws SAXException,\njavax.xml.parsers.ParserConfigurationException, java.io.IOException {\nparse(new InputSource(url.toExternalForm()), handler);\n}\nprivate static void parse(final InputSource input,\nfinal CargoAndTerrainParser recognizer) throws SAXException,\njavax.xml.parsers.ParserConfigurationException, java.io.IOException {\njavax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory\n.newInstance();\nfactory.setValidating(true); // the code was generated according DTD\nfactory.setNamespaceAware(true); // the code was generated according\n// DTD\nXMLReader parser = factory.newSAXParser().getXMLReader();\nparser.setContentHandler(recognizer);\nparser.setErrorHandler(recognizer.getDefaultErrorHandler());\nif (recognizer.resolver != null) {\nparser.setEntityResolver(recognizer.resolver);\n}\nparser.parse(input);\n}\n/**\n* Creates default error handler used by this parser.\n*\n* @return org.xml.sax.ErrorHandler implementation\n*\n*/\nprotected ErrorHandler getDefaultErrorHandler() {\nreturn new ErrorHandler() {\npublic void error(SAXParseException ex) throws SAXException {\nif (context.isEmpty()) {\nlogger.severe(\"Missing DOCTYPE.\");\n}\nthrow ex;\n}\npublic void fatalError(SAXParseException ex) throws SAXException {\nthrow ex;\n}\npublic void warning(SAXParseException ex) throws SAXException {\n// ignore\n}\n};\n}\n}"}
{"className":"jfreerails.server.parser.CargoAndTerrainHandlerImpl","javaDoc":"/**\n* Processes CargoAndTerrainHandler events and adds terrain and cargo types to\n* the world object.\n*\n* @see CargoAndTerrainHandler\n* @see CargoAndTerrainParser\n* @author Luke\n* @version generated by NetBeans XML module\n*/","code":"/**\n* Processes CargoAndTerrainHandler events and adds terrain and cargo types to\n* the world object.\n*\n* @see CargoAndTerrainHandler\n* @see CargoAndTerrainParser\n* @author Luke\n* @version generated by NetBeans XML module\n*/\npublic class CargoAndTerrainHandlerImpl implements CargoAndTerrainHandler {\nprivate final World world;\nHashMap<String, Integer> cargoName2cargoTypeNumber = new HashMap<String, Integer>();\nHashSet<Integer> rgbValuesAlreadyUsed = new HashSet<Integer>();\n// Parsing variables for Tile\nString tileID;\nTerrainType.Category tileCategory;\nint tileRGB;\nint tileROW;\nint tileBuildCost;\nArrayList<Consumption> typeConsumes = new ArrayList<Consumption>();\nArrayList<Production> typeProduces = new ArrayList<Production>();\nArrayList<Conversion> typeConverts = new ArrayList<Conversion>();\npublic CargoAndTerrainHandlerImpl(World w) {\nworld = w;\n}\npublic void handle_Converts(final Attributes meta) throws SAXException {\nString inputCargo = meta.getValue(\"input\");\nString outputCargo = meta.getValue(\"output\");\nint input = string2CargoID(inputCargo);\nint output = string2CargoID(outputCargo);\nConversion conversion = new Conversion(input, output);\ntypeConverts.add(conversion);\n}\npublic void start_Tile(final Attributes meta) throws SAXException {\ntypeConsumes.clear();\ntypeProduces.clear();\ntypeConverts.clear();\ntileID = meta.getValue(\"id\");\ntileCategory = TerrainType.Category.valueOf(meta.getValue(\"Category\"));\nString rgbString = meta.getValue(\"rgb\");\ntileRGB = string2RGBValue(rgbString);\nString buildCostString = meta.getValue(\"build_cost\");\nif (null != buildCostString) {\ntileBuildCost = Integer.parseInt(buildCostString);\n} else {\ntileBuildCost = -1;\n}\n// Check if another type is already using this rgb value..\nInteger rgbInteger = new Integer(tileRGB);\nif (rgbValuesAlreadyUsed.contains(rgbInteger)) {\nthrow new SAXException(tileID + \" can't using rgb value \"\n+ rgbString\n+ \" because it is being used by another tile type!\");\n}\nrgbValuesAlreadyUsed.add(rgbInteger);\ntileROW = Integer.parseInt(meta.getValue(\"right-of-way\"));\n}\npublic void end_Tile() throws SAXException {\nConsumption[] consumes = new Consumption[typeConsumes.size()];\nfor (int i = 0; i < typeConsumes.size(); i++) {\nconsumes[i] = typeConsumes.get(i);\n}\nProduction[] produces = new Production[typeProduces.size()];\nfor (int i = 0; i < typeProduces.size(); i++) {\nproduces[i] = typeProduces.get(i);\n}\nConversion[] converts = new Conversion[typeConverts.size()];\nfor (int i = 0; i < typeConverts.size(); i++) {\nconverts[i] = typeConverts.get(i);\n}\nTileTypeImpl tileType = new TileTypeImpl(tileRGB, tileCategory, tileID,\ntileROW, produces, consumes, converts, tileBuildCost);\nworld.add(SKEY.TERRAIN_TYPES, tileType);\n}\npublic void handle_Cargo(final Attributes meta) throws SAXException {\nString cargoID = meta.getValue(\"id\");\nString cargoCategory = meta.getValue(\"Category\");\nint unitWeight = Integer.parseInt(meta.getValue(\"unitWeight\"));\nCargoType cargoType = new CargoType(unitWeight, cargoID, Categories\n.getCategory(cargoCategory));\nint cargoNumber = world.size(SKEY.CARGO_TYPES);\ncargoName2cargoTypeNumber.put(cargoID, new Integer(cargoNumber));\nworld.add(SKEY.CARGO_TYPES, cargoType);\n}\npublic void start_Cargo_Types(final Attributes meta) throws SAXException {\n// no need to do anything here.\n}\npublic void end_Cargo_Types() throws SAXException {\n// no need to do anything here.\n}\npublic void start_Terrain_Types(final Attributes meta) throws SAXException {\n// no need to do anything here.\n}\npublic void end_Terrain_Types() throws SAXException {\n// no need to do anything here.\n}\npublic void start_Types(final Attributes meta) throws SAXException {\n// no need to do anything here.\n}\npublic void end_Types() throws SAXException {\n// no need to do anything here.\n}\npublic void handle_Consumes(final Attributes meta) throws SAXException {\nint cargoConsumed = string2CargoID(meta.getValue(\"Cargo\"));\nString prerequisiteString = meta.getValue(\"Prerequisite\");\n// \"Prerequisite\" is an optional attribute, so may be null.\nint prerequisiteForConsumption = (null == prerequisiteString ? 1\n: Integer.parseInt(prerequisiteString));\nConsumption consumption = new Consumption(cargoConsumed,\nprerequisiteForConsumption);\ntypeConsumes.add(consumption);\n}\npublic void handle_Produces(final Attributes meta) throws SAXException {\nint cargoProduced = string2CargoID(meta.getValue(\"Cargo\"));\nint rateOfProduction = Integer.parseInt(meta.getValue(\"Rate\"));\nProduction production = new Production(cargoProduced, rateOfProduction);\ntypeProduces.add(production);\n}\nprivate int string2RGBValue(String temp_number) {\nint rgb = Integer.parseInt(temp_number, 16);\n/*\n* We need to change the format of the rgb value to the same one as used\n* by the the BufferedImage that stores the map. See\n* jfreerails.common.Map\n*/\nrgb = new java.awt.Color(rgb).getRGB();\nreturn rgb;\n}\n/** Returns the index number of the cargo with the specified name. */\nprivate int string2CargoID(String cargoName) throws SAXException {\nif (cargoName2cargoTypeNumber.containsKey(cargoName)) {\nInteger integer = cargoName2cargoTypeNumber.get(cargoName);\nreturn integer.intValue();\n}\nthrow new SAXException(\"Unknown cargo type: \" + cargoName);\n}\n}"}
{"className":"jfreerails.server.parser.Track_TilesParser","javaDoc":"/**\n* The class reads XML documents according to specified DTD and translates all\n* related events into Track_TilesHandler events.\n* <p>\n* Usage sample:\n*\n* <pre>\n* Track_TilesParser parser = new Track_TilesParser(...);\n* parser.parse(new InputSource(&quot;...&quot;));\n* </pre>\n*\n* Date: 21 January 2002 18:00\n*\n* @author lindsal\n* @version generated by FFJ XML module\n*/","code":"/**\n* The class reads XML documents according to specified DTD and translates all\n* related events into Track_TilesHandler events.\n* <p>\n* Usage sample:\n*\n* <pre>\n* Track_TilesParser parser = new Track_TilesParser(...);\n* parser.parse(new InputSource(&quot;...&quot;));\n* </pre>\n*\n* Date: 21 January 2002 18:00\n*\n* @author lindsal\n* @version generated by FFJ XML module\n*/\nfinal public class Track_TilesParser implements org.xml.sax.ContentHandler {\nprivate static final Logger logger = Logger\n.getLogger(Track_TilesParser.class.getName());\nprivate java.lang.StringBuffer buffer;\nprivate Track_TilesHandler handler;\nprivate java.util.Stack<Object[]> context;\npublic Track_TilesParser(final Track_TilesHandler handler) {\nthis.handler = handler;\nbuffer = new StringBuffer(111);\ncontext = new java.util.Stack<Object[]>();\n}\npublic void setDocumentLocator(org.xml.sax.Locator locator) {\n}\npublic void startDocument() throws SAXException {\n}\npublic void endDocument() throws SAXException {\n}\npublic void startElement(java.lang.String ns, java.lang.String name,\njava.lang.String qname, org.xml.sax.Attributes attrs)\nthrows SAXException {\ndispatch(true);\ncontext.push(new Object[] { qname,\nnew org.xml.sax.helpers.AttributesImpl(attrs) });\nif (\"CanOnlyBuildOnTheseTerrainTypes\".equals(qname)) {\nhandler.start_CanOnlyBuildOnTheseTerrainTypes(attrs);\n} else if (\"ListOfTrackPieceTemplates\".equals(qname)) {\nhandler.start_ListOfTrackPieceTemplates(attrs);\n} else if (\"ListOfLegalRoutesAcrossNode\".equals(qname)) {\nhandler.start_ListOfLegalRoutesAcrossNode(attrs);\n} else if (\"LegalRouteAcrossNode\".equals(qname)) {\nhandler.handle_LegalRouteAcrossNode(attrs);\n} else if (\"CannotBuildOnTheseTerrainTypes\".equals(qname)) {\nhandler.start_CannotBuildOnTheseTerrainTypes(attrs);\n} else if (\"TrackType\".equals(qname)) {\nhandler.start_TrackType(attrs);\n} else if (\"TerrainType\".equals(qname)) {\nhandler.handle_TerrainType(attrs);\n} else if (\"Tiles\".equals(qname)) {\nhandler.start_Tiles(attrs);\n} else if (\"TrackPieceTemplate\".equals(qname)) {\nhandler.start_TrackPieceTemplate(attrs);\n} else if (\"TrackSet\".equals(qname)) {\nhandler.start_TrackSet(attrs);\n}\n}\npublic void endElement(java.lang.String ns, java.lang.String name,\njava.lang.String qname) throws SAXException {\ndispatch(false);\ncontext.pop();\nif (\"CanOnlyBuildOnTheseTerrainTypes\".equals(qname)) {\nhandler.end_CanOnlyBuildOnTheseTerrainTypes();\n} else if (\"ListOfTrackPieceTemplates\".equals(qname)) {\nhandler.end_ListOfTrackPieceTemplates();\n} else if (\"ListOfLegalRoutesAcrossNode\".equals(qname)) {\nhandler.end_ListOfLegalRoutesAcrossNode();\n} else if (\"CannotBuildOnTheseTerrainTypes\".equals(qname)) {\nhandler.end_CannotBuildOnTheseTerrainTypes();\n} else if (\"TrackType\".equals(qname)) {\nhandler.end_TrackType();\n} else if (\"Tiles\".equals(qname)) {\nhandler.end_Tiles();\n} else if (\"TrackPieceTemplate\".equals(qname)) {\nhandler.end_TrackPieceTemplate();\n} else if (\"TrackSet\".equals(qname)) {\nhandler.end_TrackSet();\n}\n}\npublic void characters(char[] chars, int start, int len)\nthrows SAXException {\nbuffer.append(chars, start, len);\n}\npublic void ignorableWhitespace(char[] chars, int start, int len)\nthrows SAXException {\n}\npublic void processingInstruction(java.lang.String target,\njava.lang.String data) throws SAXException {\n}\npublic void startPrefixMapping(final java.lang.String prefix,\nfinal java.lang.String uri) throws SAXException {\n}\npublic void endPrefixMapping(final java.lang.String prefix)\nthrows SAXException {\n}\npublic void skippedEntity(java.lang.String name) throws SAXException {\n}\nprivate void dispatch(final boolean fireOnlyIfMixed) throws SAXException {\nif (fireOnlyIfMixed && buffer.length() == 0) {\nreturn; // skip it\n}\nbuffer.delete(0, buffer.length());\n}\n/**\n* The recognizer entry method taking an Inputsource.\n*\n* @param input\n* InputSource to be parsed.\n* @throws java.io.IOException\n* on I/O error.\n* @throws SAXException\n* propagated exception thrown by a DocumentHandler.\n* @throws javax.xml.parsers.ParserConfigurationException\n* a parser satisfying requested configuration can not be\n* created.\n*/\npublic static void parse(final InputSource input,\nfinal Track_TilesHandler handler) throws SAXException,\nParserConfigurationException, IOException {\nparse(input, new Track_TilesParser(handler));\n}\n/**\n* The recognizer entry method taking a URL.\n*\n* @param url\n* URL source to be parsed.\n* @throws java.io.IOException\n* on I/O error.\n* @throws SAXException\n* propagated exception thrown by a DocumentHandler.\n* @throws javax.xml.parsers.ParserConfigurationException\n* a parser satisfying requested configuration can not be\n* created.\n*/\npublic static void parse(final java.net.URL url,\nfinal Track_TilesHandler handler) throws SAXException,\nParserConfigurationException, IOException {\nparse(new InputSource(url.toExternalForm()), handler);\n}\nprivate static void parse(final InputSource input,\nfinal Track_TilesParser recognizer) throws SAXException,\nParserConfigurationException, IOException {\njavax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory\n.newInstance();\nfactory.setValidating(true); // the code was generated according DTD\nfactory.setNamespaceAware(false); // the code was generated according\n// DTD\norg.xml.sax.XMLReader parser = factory.newSAXParser().getXMLReader();\nparser.setContentHandler(recognizer);\nparser.setErrorHandler(recognizer.getDefaultErrorHandler());\nparser.parse(input);\n}\nprivate org.xml.sax.ErrorHandler getDefaultErrorHandler() {\nreturn new org.xml.sax.ErrorHandler() {\npublic void error(org.xml.sax.SAXParseException ex)\nthrows SAXException {\nif (context.isEmpty()) {\nlogger.severe(\"Missing DOCTYPE.\");\n}\nthrow ex;\n}\npublic void fatalError(org.xml.sax.SAXParseException ex)\nthrows SAXException {\nthrow ex;\n}\npublic void warning(org.xml.sax.SAXParseException ex)\nthrows SAXException {\n// ignore\n}\n};\n}\n}"}
{"className":"jfreerails.network.SynchronizedQueue","javaDoc":"/**\n* Intended to let objects be safely passed between threads.\n*\n* @author Luke\n*\n*/","code":"/**\n* Intended to let objects be safely passed between threads.\n*\n* @author Luke\n*\n*/\npublic class SynchronizedQueue {\nprivate final LinkedList<FreerailsSerializable> queue = new LinkedList<FreerailsSerializable>();\npublic synchronized void write(FreerailsSerializable f) {\nqueue.add(f);\n}\npublic synchronized FreerailsSerializable[] read() {\nint length = queue.size();\nFreerailsSerializable[] read = new FreerailsSerializable[length];\nfor (int i = 0; i < length; i++) {\nread[i] = queue.removeFirst();\n}\nreturn read;\n}\npublic synchronized int size() {\nreturn queue.size();\n}\npublic synchronized FreerailsSerializable getFirst() {\nreturn queue.removeFirst();\n}\n}"}
{"className":"jfreerails.network.Connection2Server","javaDoc":"/**\n* Defines the methods a client can use to send messages to the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines the methods a client can use to send messages to the server.\n*\n* @author Luke\n*\n*/\npublic interface Connection2Server {\n/** Returns true if this connection is open. */\nboolean isOpen();\n/**\n* Returns an array containing all the objects read from the server since\n* the last time this method or waitForObjectFromServer() was called, if no\n* objects have been received, it returns an empty array rather than\n* blocking.\n*/\nFreerailsSerializable[] readFromServer() throws IOException;\n/**\n* Returns the next object read from the server, blocking if non is\n* available.\n*/\nFreerailsSerializable waitForObjectFromServer() throws IOException,\nInterruptedException;\n/** Sends the specified object to the server. */\nvoid writeToServer(FreerailsSerializable object) throws IOException;\n/**\n* Disconnect from the server. When this method returns, calling isOpen() on\n* this object returns false <b>and</b> calling isOpen() on the\n* corresponding Connection2Client held by the server also returns false.\n*\n* @throws IOException\n*/\nvoid disconnect() throws IOException;\n/** Flush the underlying stream. */\nvoid flush() throws IOException;\nString getServerDetails();\n}"}
{"className":"jfreerails.network.EchoGameServer","javaDoc":"/**\n* Implementation of GameServer that simply echoes whatever clients send it.\n*\n* @author Luke\n*\n*/","code":"/**\n* Implementation of GameServer that simply echoes whatever clients send it.\n*\n* @author Luke\n*\n*/\npublic class EchoGameServer implements GameServer, Runnable {\nprivate static final Logger logger = Logger.getLogger(EchoGameServer.class\n.getName());\nprivate final Vector<Connection2Client> connections = new Vector<Connection2Client>();\nprivate final SynchronizedFlag status = new SynchronizedFlag(false);\nprivate final LinkedList<FreerailsSerializable> messages2send = new LinkedList<FreerailsSerializable>();\nprivate EchoGameServer() {\n}\n/**\n* Creates an EchoGameServer, starts it in a new Thread, and waits for its\n* status to change to isOpen before returning.\n*/\npublic static EchoGameServer startServer() {\nEchoGameServer server = new EchoGameServer();\nThread t = new Thread(server);\nt.start();\ntry {\n/* Wait for the server to start before returning. */\nsynchronized (server.status) {\nserver.status.wait();\n}\nreturn server;\n} catch (InterruptedException e) {\ne.printStackTrace();\nthrow new IllegalStateException();\n}\n}\npublic synchronized void addConnection(Connection2Client connection) {\nif (null == connection) {\nthrow new NullPointerException();\n}\nif (!status.isOpen()) {\nthrow new IllegalArgumentException();\n}\nconnections.add(connection);\n}\npublic synchronized int countOpenConnections() {\nIterator<Connection2Client> it = connections.iterator();\nwhile (it.hasNext()) {\nConnection2Client connection = it.next();\nif (!connection.isOpen()) {\nit.remove();\n}\n}\nreturn connections.size();\n}\npublic synchronized void stop() {\nstatus.close();\nfor (int i = 0; i < connections.size(); i++) {\nAbstractInetConnection connection = (AbstractInetConnection) connections\n.get(i);\nif (connection.isOpen()) {\ntry {\nconnection.setTimeOut(0);\nconnection.disconnect();\n} catch (Exception e) {\n// Do nothing.\n}\n}\n}\n}\npublic void run() {\nstatus.open();\nwhile (status.isOpen()) {\nupdate();\ntry {\nThread.sleep(20);\n} catch (InterruptedException e) {\n// do nothing.\n}\n}\n}\nsynchronized void sendMessage(FreerailsSerializable m) {\n/* Send messages. */\nfor (int i = 0; i < connections.size(); i++) {\nConnection2Client connection = connections.get(i);\ntry {\nconnection.writeToClient(m);\nconnection.flush();\nlogger.fine(\"Sent ok: \" + m);\n} catch (IOException e) {\ntry {\nif (connection.isOpen()) {\nconnection.disconnect();\n}\n} catch (IOException e1) {\n// hope this doesn't happen.\ne1.printStackTrace();\n}\n}\n}\n}\npublic void update() {\nsynchronized (this) {\n/* Read messages. */\nfor (int i = 0; i < connections.size(); i++) {\nConnection2Client connection = connections.get(i);\ntry {\nFreerailsSerializable[] messages = connection\n.readFromClient();\nfor (int j = 0; j < messages.length; j++) {\nmessages2send.add(messages[j]);\n}\n} catch (IOException e) {\ntry {\nif (connection.isOpen()) {\nconnection.disconnect();\n}\n} catch (IOException e1) {\n//\ne1.printStackTrace();\n}\n}\n}\n/* Send messages. */\nIterator<FreerailsSerializable> messagesIterator = messages2send\n.iterator();\nwhile (messagesIterator.hasNext()) {\nFreerailsSerializable message = messagesIterator.next();\nsendMessage(message);\n}\n}\n}\n}"}
{"className":"jfreerails.network.AbstractInetConnection","javaDoc":"/**\n* This class has the code that is shared by the client and server versions of\n* InetConnection.\n*\n* @author Luke\n*/","code":"/**\n* This class has the code that is shared by the client and server versions of\n* InetConnection.\n*\n* @author Luke\n*/\npublic abstract class AbstractInetConnection implements Runnable {\nprivate static final Logger logger = Logger\n.getLogger(AbstractInetConnection.class.getName());\nprivate final SynchronizedQueue inbound = new SynchronizedQueue();\nprivate final InetConnection inetConnection;\nprivate final SynchronizedFlag readerThreadStatus = new SynchronizedFlag(\nfalse);\nprivate final SynchronizedFlag status = new SynchronizedFlag(true);\nprivate int timeout = 1000 * 5; // 5 seconds.\npublic AbstractInetConnection(Socket s) throws IOException {\ninetConnection = new InetConnection(s);\nopen();\n}\npublic AbstractInetConnection(String ip, int port) throws IOException {\ninetConnection = new InetConnection(ip, port);\nopen();\n}\npublic void disconnect() throws IOException {\nlogger.fine(this + \"Initiating shutdown..\");\nshutdownOutput();\nlong waitUntil = System.currentTimeMillis() + timeout;\nsynchronized (readerThreadStatus) {\nwhile (readerThreadStatus.isOpen()) {\nlong currentTime = System.currentTimeMillis();\nif (currentTime >= waitUntil) {\nshutDownInput();\nthrow new IOException(\n\"Time-out while trying to disconnect.\");\n}\ntry {\nreaderThreadStatus.wait(timeout);\n} catch (InterruptedException e) {\n// do nothing.\n}\n}\n}\nlogger.fine(this + \"Finished shutdown!! --status=\"\n+ String.valueOf(status.isOpen()));\n}\npublic void flush() throws IOException {\ninetConnection.flush();\n}\npublic synchronized boolean isOpen() {\nreturn status.isOpen();\n}\npublic void run() {\ntry {\nwhile (true) {\nFreerailsSerializable fs = inetConnection.receive();\nsynchronized (inbound) {\ninbound.write(fs);\ninbound.notifyAll();\n}\n}\n} catch (EOFException e) {\n} catch (IOException e) {\ne.printStackTrace();\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\nlogger.fine(this + \"Reciprocating shutdown..\");\nshutDownInput();\nreaderThreadStatus.close();\n}\nprivate synchronized void open() throws IOException {\nThread t = new Thread(this);\nt.setName(getThreadName());\ninetConnection.open();\nt.start();\nreaderThreadStatus.open();\n}\nprivate synchronized void shutDownInput() {\ntry {\ninetConnection.shutdownInput();\nlogger.fine(this + \"Shut down input.\");\nif (status.isOpen()) {\nshutdownOutput();\n}\n} catch (IOException e1) {\ne1.printStackTrace();\n}\n}\nprivate synchronized void shutdownOutput() throws IOException {\nif (!status.isOpen()) {\nthrow new IllegalStateException();\n}\nstatus.close();\ninetConnection.shutdownOutput();\nlogger.fine(this + \"Shut down output.\");\n}\nabstract String getThreadName();\nFreerailsSerializable[] read() throws IOException {\nif (status.isOpen()) {\nreturn inbound.read();\n}\nthrow new IOException();\n}\nvoid send(FreerailsSerializable object) throws IOException {\ninetConnection.send(object);\n}\nvoid setTimeOut(int i) {\ntimeout = i;\n}\nFreerailsSerializable waitForObject() throws InterruptedException,\nIOException {\nif (status.isOpen()) {\nsynchronized (inbound) {\nif (inbound.size() > 0) {\nreturn inbound.getFirst();\n}\ninbound.wait();\nif (inbound.size() > 0) {\nreturn inbound.getFirst();\n}\nthrow new IllegalStateException();\n}\n}\nthrow new IOException(\"The connection is close.\");\n}\n}"}
{"className":"jfreerails.network.InetConnection2Client","javaDoc":"/**\n* Lets the server send messages to a client over the Internet.\n*\n* @author Luke\n*\n*/","code":"/**\n* Lets the server send messages to a client over the Internet.\n*\n* @author Luke\n*\n*/\npublic class InetConnection2Client extends AbstractInetConnection implements\nConnection2Client {\npublic InetConnection2Client(Socket s) throws IOException {\nsuper(s);\n}\npublic FreerailsSerializable[] readFromClient() throws IOException {\nreturn read();\n}\npublic FreerailsSerializable waitForObjectFromClient() throws IOException,\nInterruptedException {\nreturn waitForObject();\n}\npublic void writeToClient(FreerailsSerializable object) throws IOException {\nsend(object);\n}\n@Override\nString getThreadName() {\nreturn \"InetConnection2Client\";\n}\n}"}
{"className":"jfreerails.network.InetConnection2Server","javaDoc":"/**\n* Lets a client send messages to the server over the Internet.\n*\n* @author Luke\n*\n*/","code":"/**\n* Lets a client send messages to the server over the Internet.\n*\n* @author Luke\n*\n*/\npublic class InetConnection2Server extends AbstractInetConnection implements\nConnection2Server {\nfinal String serverDetails;\npublic InetConnection2Server(String ip, int port) throws IOException {\nsuper(ip, port);\nserverDetails = \"server at \" + ip + \":\" + port;\n}\npublic FreerailsSerializable[] readFromServer() throws IOException {\nreturn read();\n}\npublic FreerailsSerializable waitForObjectFromServer() throws IOException,\nInterruptedException {\nreturn waitForObject();\n}\npublic void writeToServer(FreerailsSerializable object) throws IOException {\nsend(object);\n}\n@Override\nString getThreadName() {\nreturn \"InetConnection2Server\";\n}\npublic String getServerDetails() {\nreturn serverDetails;\n}\n}"}
{"className":"jfreerails.network.SynchronizedFlag","javaDoc":"/**\n* Synchronized flag - used to tell threads whether they should keep going.\n* Note, thought about using volatile keyword but wasn't sure if it is\n* implemented on all JVMs\n*\n* @author Luke\n*/","code":"/**\n* Synchronized flag - used to tell threads whether they should keep going.\n* Note, thought about using volatile keyword but wasn't sure if it is\n* implemented on all JVMs\n*\n* @author Luke\n*/\npublic class SynchronizedFlag {\npublic SynchronizedFlag(boolean b) {\nthis.isOpen = b;\n}\nprivate boolean isOpen = true;\npublic synchronized boolean isOpen() {\nreturn isOpen;\n}\npublic synchronized void close() {\nthis.isOpen = false;\nnotifyAll();\n}\npublic synchronized void open() {\nthis.isOpen = true;\nnotifyAll();\n}\n}"}
{"className":"jfreerails.network.InetConnection","javaDoc":"/**\n* Provides methods send objects over the Internet, and connect and disconnect\n* gracefully.\n*\n* @author Luke\n*\n*/","code":"/**\n* Provides methods send objects over the Internet, and connect and disconnect\n* gracefully.\n*\n* @author Luke\n*\n*/\npublic class InetConnection {\nprivate final Socket socket;\n// Note compression commented out since it was causing junit tests to fail.\n// Not\n// sure why. LL\n// private DeflaterOutputStream deflaterOutputStream;\n// private InflaterInputStream inflaterInputStream;\nprivate ObjectOutputStream objectOutputStream;\nprivate ObjectInputStream objectInputStream;\nprivate static final String CONNECTION_OPEN = \"CONNECTION_OPEN\";\nInetConnection(Socket acceptedConnection) throws IOException {\nsocket = acceptedConnection;\n}\nInetConnection(String s, int port) throws IOException {\nthis(new Socket(s, port));\n}\n/**\n* Sets up the input and output streams, then sends the String\n* \"CONNECTION_OPEN\" and attempts to read the same String back.\n*/\nsynchronized void open() throws IOException {\nOutputStream outputStream = socket.getOutputStream();\nBufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\noutputStream);\n// deflaterOutputStream = new DeflaterOutputStream(outputStream);\n// objectOutputStream = new ObjectOutputStream(deflaterOutputStream);\nobjectOutputStream = new ObjectOutputStream(bufferedOutputStream);\nobjectOutputStream.writeObject(CONNECTION_OPEN);\nobjectOutputStream.flush();\nInputStream inputStream = socket.getInputStream();\n// inflaterInputStream = new InflaterInputStream(inputStream);\n// objectInputStream = new ObjectInputStream(inflaterInputStream);\nobjectInputStream = new ObjectInputStream(inputStream);\ntry {\nString s = (String) objectInputStream.readObject();\nif (!s.equals(CONNECTION_OPEN)) {\nthrow new IllegalStateException(s);\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\nthrow new IOException(e.getMessage());\n}\n}\nsynchronized void send(FreerailsSerializable object) throws IOException {\nobjectOutputStream.writeObject(object);\nflush();\n}\nFreerailsSerializable receive() throws IOException, ClassNotFoundException {\nObject object = objectInputStream.readObject();\nreturn (FreerailsSerializable) object;\n}\nsynchronized boolean isOpen() {\nboolean isClosed = socket.isClosed();\nreturn !isClosed;\n}\nsynchronized void flush() throws IOException {\nobjectOutputStream.flush();\n// deflaterOutputStream.flush();\n// deflaterOutputStream.finish();\n// deflaterOutputStream.flush();\n}\nsynchronized void shutdownOutput() throws IOException {\nsocket.shutdownOutput();\nif (socket.isInputShutdown() && socket.isOutputShutdown()) {\nsocket.close();\n}\n}\nsynchronized void shutdownInput() throws IOException {\nsocket.shutdownInput();\nif (socket.isInputShutdown() && socket.isOutputShutdown()) {\nsocket.close();\n}\n}\n}"}
{"className":"jfreerails.network.LocalConnection","javaDoc":"/**\n* A connection between the a client and server in the same JVM.\n*\n* @author Luke\n*\n*/","code":"/**\n* A connection between the a client and server in the same JVM.\n*\n* @author Luke\n*\n*/\npublic class LocalConnection implements Connection2Client, Connection2Server {\npublic static final String SERVER_IN_SAME_JVM = \"server in same JVM\";\nprivate final SynchronizedQueue fromServer = new SynchronizedQueue();\nprivate final SynchronizedQueue fromClient = new SynchronizedQueue();\nprivate final SynchronizedFlag status = new SynchronizedFlag(true);\npublic LocalConnection() {\n}\npublic FreerailsSerializable[] readFromClient() throws IOException {\nif (status.isOpen()) {\nreturn fromClient.read();\n}\nthrow new IOException();\n}\npublic FreerailsSerializable waitForObjectFromClient() throws IOException,\nInterruptedException {\nsynchronized (fromClient) {\nif (fromClient.size() == 0) {\nfromClient.wait();\n}\nif (status.isOpen()) {\nreturn fromClient.getFirst();\n}\nthrow new IOException();\n}\n}\npublic void writeToClient(FreerailsSerializable object) throws IOException {\nif (status.isOpen()) {\nsynchronized (fromServer) {\nfromServer.write(object);\nfromServer.notifyAll();\n}\n} else {\nthrow new IOException();\n}\n}\npublic FreerailsSerializable[] readFromServer() throws IOException {\nif (status.isOpen()) {\nreturn fromServer.read();\n}\nthrow new IOException();\n}\npublic FreerailsSerializable waitForObjectFromServer() throws IOException,\nInterruptedException {\nif (status.isOpen()) {\nsynchronized (fromServer) {\nif (fromServer.size() == 0) {\nfromServer.wait();\n}\nreturn fromServer.getFirst();\n}\n}\nthrow new IOException();\n}\npublic void writeToServer(FreerailsSerializable object) throws IOException {\nif (status.isOpen()) {\nsynchronized (fromClient) {\nfromClient.write(object);\nfromClient.notifyAll();\n}\n} else {\nthrow new IOException();\n}\n}\npublic boolean isOpen() {\nreturn status.isOpen();\n}\npublic void flush() {\n// No need to do anything.\n}\npublic synchronized void disconnect() {\nstatus.close();\n}\npublic String getServerDetails() {\nreturn SERVER_IN_SAME_JVM;\n}\n}"}
{"className":"jfreerails.network.GameServer","javaDoc":"/**\n* Defines a server that can accept connections to clients.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a server that can accept connections to clients.\n*\n* @author Luke\n*\n*/\npublic interface GameServer extends GameModel {\nvoid addConnection(Connection2Client connection);\nint countOpenConnections();\nvoid stop();\n}"}
{"className":"jfreerails.network.InetConnectionAccepter","javaDoc":"/**\n* When this class is run in a thread it accepts new connections to its Server\n* Socket and adds them to the NewGameServer that was passed to its constructor.\n*\n* @author Luke\n*/","code":"/**\n* When this class is run in a thread it accepts new connections to its Server\n* Socket and adds them to the NewGameServer that was passed to its constructor.\n*\n* @author Luke\n*/\npublic class InetConnectionAccepter implements Runnable {\nprivate static final Logger logger = Logger\n.getLogger(InetConnectionAccepter.class.getName());\npublic static void main(String[] args) {\ntry {\nGameServer echoGameServer = EchoGameServer.startServer();\nInetConnectionAccepter accepter = new InetConnectionAccepter(6666,\nechoGameServer);\nThread t = new Thread(accepter);\nt.start();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\nprivate final GameServer gameServer;\nprivate final SynchronizedFlag keepRunning = new SynchronizedFlag(true);\nprivate final ServerSocket serverSocket;\npublic InetConnectionAccepter(int port, GameServer gameServer)\nthrows IOException {\nif (null == gameServer)\nthrow new NullPointerException();\nthis.gameServer = gameServer;\nserverSocket = new ServerSocket(port);\n}\npublic void run() {\nThread.currentThread().setName(\n\"InetConnectionAccepter, port \" + serverSocket.getLocalPort());\ntry {\nlogger.fine(\"Accepting connections on port \"\n+ serverSocket.getLocalPort());\nwhile (isKeepRunning()) {\nSocket socket = serverSocket.accept();\nlogger.fine(\"Incoming connection from \"\n+ socket.getRemoteSocketAddress());\nsynchronized (this) {\nsynchronized (gameServer) {\nInetConnection2Client connection = new InetConnection2Client(\nsocket);\ngameServer.addConnection(connection);\n}\n}\n}\n} catch (IOException e) {\ntry {\nstop();\n} catch (IOException e1) {\n// TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}\n}\npublic synchronized void stop() throws IOException {\nthis.keepRunning.close();\nserverSocket.close();\n// Commented out since it causes exceptions to be thrown, fixes bug\n// 979831\n// gameServer.stop();\n}\nprivate boolean isKeepRunning() {\nreturn keepRunning.isOpen();\n}\npublic int getLocalPort() {\nreturn serverSocket.getLocalPort();\n}\n}"}
{"className":"jfreerails.network.Connection2Client","javaDoc":"/**\n* Defines the methods the server can use to send messages to the client.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines the methods the server can use to send messages to the client.\n*\n* @author Luke\n*\n*/\npublic interface Connection2Client {\n/** Returns true if this connection is open. */\nboolean isOpen();\n/**\n* Returns an array containing all the objects read from the client since\n* the last time this method or waitForObjectFromClient() was called, if no\n* objects have been received, it returns an empty array rather than\n* blocking.\n*/\nFreerailsSerializable[] readFromClient() throws IOException;\n/**\n* Returns the next object read from the client, blocking if non is\n* available.\n*/\nFreerailsSerializable waitForObjectFromClient() throws IOException,\nInterruptedException;\n/** Sends the specified object to the client. */\nvoid writeToClient(FreerailsSerializable object) throws IOException;\n/** Flush the underlying stream. */\nvoid flush() throws IOException;\n/**\n* Disconnect from the client. When this method returns, calling isOpen() on\n* this object returns false <b>and</b> calling isOpen() on the\n* corresponding Connection2Server held by the client also returns false.\n*\n* @throws IOException\n*/\nvoid disconnect() throws IOException;\n}"}
{"className":"jfreerails.network.specifics.NewGameMessage2Server","javaDoc":"/**\n* Request to start a game on a new map.\n*\n* @author Luke\n*\n*/","code":"/**\n* Request to start a game on a new map.\n*\n* @author Luke\n*\n*/\npublic class NewGameMessage2Server implements Message2Server {\nprivate static final long serialVersionUID = 3256723961743422513L;\nprivate final int id;\nprivate final String mapName;\npublic NewGameMessage2Server(int id, String s) {\nthis.id = id;\nthis.mapName = s;\n}\npublic int getID() {\nreturn id;\n}\npublic MessageStatus execute(ServerControlInterface server) {\ntry {\nserver.newGame(mapName);\nreturn new MessageStatus(id, true);\n} catch (Exception e) {\nreturn new MessageStatus(id, false, e.getMessage());\n}\n}\n/**\n* TODO This would be better implemented in a config file, or better still\n* dynamically determined by scanning the directory.\n*/\npublic static String[] getMapNames() {\nreturn new String[] { \"South America\", \"Small South America\" };\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof NewGameMessage2Server))\nreturn false;\nfinal NewGameMessage2Server newGameMessage2Server = (NewGameMessage2Server) o;\nif (id != newGameMessage2Server.id)\nreturn false;\nif (!mapName.equals(newGameMessage2Server.mapName))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + mapName.hashCode();\nreturn result;\n}\n}"}
{"className":"jfreerails.network.specifics.MoveReceiver","javaDoc":"/**\n* Accepts a Move without the caller knowing where its going. TODO replace with\n* MoveExecutor where the moves are expected to be executed.\n*\n* @author Luke\n*/","code":"/**\n* Accepts a Move without the caller knowing where its going. TODO replace with\n* MoveExecutor where the moves are expected to be executed.\n*\n* @author Luke\n*/\npublic interface MoveReceiver {\nvoid processMove(Move move);\n}"}
{"className":"jfreerails.network.specifics.MoveChainFork","javaDoc":"/**\n*\n* A central point at which a client may register to receive moves which have\n* been committed.\n*\n* @author Luke\n* @author rob\n*/","code":"/**\n*\n* A central point at which a client may register to receive moves which have\n* been committed.\n*\n* @author Luke\n* @author rob\n*/\nfinal public class MoveChainFork implements MoveReceiver {\nprivate final ArrayList<MoveReceiver> moveReceivers = new ArrayList<MoveReceiver>();\nprivate final ArrayList<MoveReceiver> splitMoveReceivers = new ArrayList<MoveReceiver>();\nprivate final ArrayList<WorldListListener> listListeners = new ArrayList<WorldListListener>();\nprivate final ArrayList<WorldMapListener> mapListeners = new ArrayList<WorldMapListener>();\nprivate long lastTickTime = System.currentTimeMillis();\npublic long getLastTickTime() {\nreturn lastTickTime;\n}\npublic MoveChainFork() {\n// do nothing\n}\npublic void addMapListener(WorldMapListener l) {\nmapListeners.add(l);\n}\npublic void removeMapListener(WorldMapListener l) {\nmapListeners.remove(l);\n}\npublic void removeCompleteMoveReceiver(MoveReceiver moveReceiver) {\nif (null == moveReceiver) {\nthrow new NullPointerException();\n}\nmoveReceivers.remove(moveReceiver);\n}\npublic void addCompleteMoveReceiver(MoveReceiver moveReceiver) {\nif (null == moveReceiver) {\nthrow new NullPointerException();\n}\nmoveReceivers.add(moveReceiver);\n}\npublic void addSplitMoveReceiver(MoveReceiver moveReceiver) {\nif (null == moveReceiver) {\nthrow new NullPointerException();\n}\nsplitMoveReceivers.add(moveReceiver);\n}\npublic void addListListener(WorldListListener listener) {\nif (null == listener) {\nthrow new NullPointerException();\n}\nlistListeners.add(listener);\n}\npublic void processMove(Move move) {\nfor (int i = 0; i < moveReceivers.size(); i++) {\nMoveReceiver m = moveReceivers.get(i);\nm.processMove(move);\n}\nsplitMove(move);\n}\nprivate void splitMove(Move move) {\nif (move instanceof UndoMove) {\nUndoMove undoneMove = (UndoMove) move;\nmove = undoneMove.getUndoneMove();\n}\nif (move instanceof CompositeMove) {\nImList<Move> moves = ((CompositeMove) move).getMoves();\nfor (int i = 0; i < moves.size(); i++) {\nsplitMove(moves.get(i));\n}\n} else {\nfor (int i = 0; i < splitMoveReceivers.size(); i++) {\nMoveReceiver m = splitMoveReceivers.get(i);\nm.processMove(move);\n}\nif (move instanceof AddItemToListMove) {\nAddItemToListMove mm = (AddItemToListMove) move;\nsendItemAdded(mm.getKey(), mm.getIndex(), mm.getPrincipal());\n} else if (move instanceof ChangeItemInListMove) {\nChangeItemInListMove mm = (ChangeItemInListMove) move;\nsendListUpdated(mm.getKey(), mm.getIndex(), mm.getPrincipal());\n} else if (move instanceof RemoveItemFromListMove) {\nRemoveItemFromListMove mm = (RemoveItemFromListMove) move;\nsendItemRemoved(mm.getKey(), mm.getIndex(), mm.getPrincipal());\n} else if (move instanceof MapUpdateMove) {\nRectangle r = ((MapUpdateMove) move).getUpdatedTiles();\nsendMapUpdated(r);\n} else if (move instanceof TimeTickMove) {\nlong currentTime = System.currentTimeMillis();\nlastTickTime = currentTime;\n}\n}\n}\nprivate void sendMapUpdated(Rectangle r) {\nfor (int i = 0; i < mapListeners.size(); i++) {\nWorldMapListener l = mapListeners.get(i);\nl.tilesChanged(r);\n}\n}\nprivate void sendItemAdded(KEY key, int index, FreerailsPrincipal p) {\nfor (int i = 0; i < listListeners.size(); i++) {\nWorldListListener l = listListeners.get(i);\nl.itemAdded(key, index, p);\n}\n}\nprivate void sendItemRemoved(KEY key, int index, FreerailsPrincipal p) {\nfor (int i = 0; i < listListeners.size(); i++) {\nWorldListListener l = listListeners.get(i);\nl.itemRemoved(key, index, p);\n}\n}\nprivate void sendListUpdated(KEY key, int index, FreerailsPrincipal p) {\nfor (int i = 0; i < listListeners.size(); i++) {\nWorldListListener l = listListeners.get(i);\nl.listUpdated(key, index, p);\n}\n}\n}"}
{"className":"jfreerails.network.specifics.LogOnResponse","javaDoc":"/**\n* Stores the result of a request to log onto the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* Stores the result of a request to log onto the server.\n*\n* @author Luke\n*\n*/\npublic class LogOnResponse implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3690479099844311344L;\nprivate final boolean successful;\nprivate final int playerNumber;\nprivate final String message;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof LogOnResponse))\nreturn false;\nfinal LogOnResponse logOnResponse = (LogOnResponse) o;\nif (playerNumber != logOnResponse.playerNumber)\nreturn false;\nif (successful != logOnResponse.successful)\nreturn false;\nif (message != null ? !message.equals(logOnResponse.message)\n: logOnResponse.message != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (successful ? 1 : 0);\nresult = 29 * result + playerNumber;\nresult = 29 * result + (message != null ? message.hashCode() : 0);\nreturn result;\n}\nprivate LogOnResponse(boolean success, int i, String s) {\nthis.successful = success;\nthis.playerNumber = i;\nthis.message = s;\n}\npublic static LogOnResponse accepted(int playerNumber) {\nreturn new LogOnResponse(true, playerNumber, null);\n}\npublic static LogOnResponse rejected(String reason) {\nreturn new LogOnResponse(false, -1, reason);\n}\npublic int getPlayerID() {\nreturn playerNumber;\n}\npublic String getMessage() {\nreturn message;\n}\npublic boolean isSuccessful() {\nreturn successful;\n}\n}"}
{"className":"jfreerails.network.specifics.ServerGameModel","javaDoc":"/**\n* Defines methods on a GameModel that let the server load and initiate, and\n* save it.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines methods on a GameModel that let the server load and initiate, and\n* save it.\n*\n* @author Luke\n*\n*/\npublic interface ServerGameModel extends GameModel, Serializable {\nvoid setWorld(World w, String[] passwords);\nWorld getWorld();\nString[] getPasswords();\nvoid init(MoveReceiver moveExecutor);\nvoid write(ObjectOutputStream objectOut) throws IOException;\n}"}
{"className":"jfreerails.network.specifics.MovePrecommitter","javaDoc":"/**\n* The class pre-commits moves we intend to send to the server and either fully\n* commits or undoes them depending on the server's response. Note, this class\n* does not actually send or receive moves, instead you should call\n* <code>toServer(.)</code> when a move has been sent to the server and\n* <code>fromServer(.)</code> when a Move or MoveStatus has been received from\n* the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* The class pre-commits moves we intend to send to the server and either fully\n* commits or undoes them depending on the server's response. Note, this class\n* does not actually send or receive moves, instead you should call\n* <code>toServer(.)</code> when a move has been sent to the server and\n* <code>fromServer(.)</code> when a Move or MoveStatus has been received from\n* the server.\n*\n* @author Luke\n*\n*/\npublic class MovePrecommitter {\nprivate static class PreMoveAndMove implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3256443607635342897L;\nfinal Move m;\nfinal PreMove pm;\nPreMoveAndMove(PreMove preMove, Move move) {\nm = move;\npm = preMove;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof PreMoveAndMove))\nreturn false;\nfinal PreMoveAndMove preMoveAndMove = (PreMoveAndMove) o;\nif (m != null ? !m.equals(preMoveAndMove.m)\n: preMoveAndMove.m != null)\nreturn false;\nif (pm != null ? !pm.equals(preMoveAndMove.pm)\n: preMoveAndMove.pm != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (m != null ? m.hashCode() : 0);\nresult = 29 * result + (pm != null ? pm.hashCode() : 0);\nreturn result;\n}\n}\nprivate static final Logger logger = Logger\n.getLogger(MovePrecommitter.class.getName());\n/**\n* Whether the first move on the uncommitted list failed to go through on\n* the last try.\n*/\nboolean blocked = false;\n/**\n* List of moves and premoves that have been sent to the server and executed\n* on the local world object.\n*/\nfinal LinkedList<FreerailsSerializable> precomitted = new LinkedList<FreerailsSerializable>();\n/**\n* List of moves and premoves that have been sent to the server but not\n* executed on the local world object.\n*/\nfinal LinkedList<FreerailsSerializable> uncomitted = new LinkedList<FreerailsSerializable>();\nprivate final World w;\nMovePrecommitter(World w) {\nthis.w = w;\n}\nvoid fromServer(Move m) {\nlogger.finest(\"Move from server: \" + m.toString());\nrollBackPrecommittedMoves();\nMoveStatus ms = m.doMove(w, Player.AUTHORITATIVE);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\n}\n/** Indicates that the server has processed a move we sent. */\nvoid fromServer(MoveStatus ms) {\nprecommitMoves();\nif (precomitted.size() > 0) {\nMove m = (Move) precomitted.removeFirst();\nif (!ms.ok) {\nlogger.info(\"Move rejected by server: \" + ms.message);\nMoveStatus undoStatus = m.undoMove(w, Player.AUTHORITATIVE);\nif (!undoStatus.ok) {\nthrow new IllegalStateException();\n}\n} else {\nlogger.finest(\"Move accepted by server: \" + m.toString());\n}\n} else {\nif (!ms.ok) {\nlogger.fine(\"Clear the blockage \" + ms.message);\nuncomitted.removeFirst();\nprecommitMoves();\n} else {\nthrow new IllegalStateException();\n}\n}\n}\nMove fromServer(PreMove pm) {\nMove generatedMove = pm.generateMove(w);\nfromServer(generatedMove);\nreturn generatedMove;\n}\nvoid fromServer(PreMoveStatus pms) {\nrollBackPrecommittedMoves();\nPreMove pm = (PreMove) uncomitted.removeFirst();\nif (pms.ms.ok) {\nlogger.finest(\"PreMove accepted by server: \" + pms.toString());\nMove m = pm.generateMove(w);\nMoveStatus ms = m.doMove(w, Player.AUTHORITATIVE);\nif (!ms.ok) {\nthrow new IllegalStateException();\n}\n} else {\nlogger.info(\"PreMove rejected by server: \" + pms.ms.message);\n}\nprecommitMoves();\n}\nvoid precommitMoves() {\nblocked = false;\nwhile (uncomitted.size() > 0 && !blocked) {\nObject first = uncomitted.getFirst();\nif (first instanceof Move) {\nMove m = (Move) first;\nMoveStatus ms = m.doMove(w, Player.AUTHORITATIVE);\nif (ms.ok) {\nuncomitted.removeFirst();\nprecomitted.addLast(m);\n} else {\nblocked = true;\n}\n} else if (first instanceof PreMove) {\nPreMove pm = (PreMove) first;\nMove m = pm.generateMove(w);\nMoveStatus ms = m.doMove(w, Player.AUTHORITATIVE);\nif (ms.ok) {\nuncomitted.removeFirst();\nPreMoveAndMove pmam = new PreMoveAndMove(pm, m);\nprecomitted.addLast(pmam);\n} else {\nblocked = true;\n}\n}\n}\n}\n/**\n* Undoes each of the precommitted moves and puts them back on the\n* uncommitted list.\n*/\nprivate void rollBackPrecommittedMoves() {\nwhile (precomitted.size() > 0) {\nObject last = precomitted.removeLast();\nMove move2undo;\nFreerailsSerializable obj2add2uncomitted;\nif (last instanceof Move) {\nmove2undo = (Move) last;\nobj2add2uncomitted = move2undo;\n} else if (last instanceof PreMoveAndMove) {\nPreMoveAndMove pmam = (PreMoveAndMove) last;\nmove2undo = pmam.m;\nobj2add2uncomitted = pmam.pm;\n} else {\nthrow new IllegalStateException();\n}\nMoveStatus ms = move2undo.undoMove(w, Player.AUTHORITATIVE);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\nuncomitted.addFirst(obj2add2uncomitted);\n}\n}\nvoid toServer(Move m) {\nuncomitted.addLast(m);\nprecommitMoves();\n}\nMove toServer(PreMove pm) {\nuncomitted.addLast(pm);\nprecommitMoves();\nif (blocked) {\nreturn pm.generateMove(w);\n}\nPreMoveAndMove pmam = (PreMoveAndMove) precomitted.getLast();\nreturn pmam.m;\n}\n}"}
{"className":"jfreerails.network.specifics.SetPropertyMessage2Client","javaDoc":"/**\n* A Message2Client that lets the server set a property (for example, the list\n* of saved games available) on a client.\n*\n* @author Luke\n*\n*/","code":"/**\n* A Message2Client that lets the server set a property (for example, the list\n* of saved games available) on a client.\n*\n* @author Luke\n*\n*/\npublic class SetPropertyMessage2Client implements Message2Client {\nprivate static final long serialVersionUID = 3544392521746034740L;\nprivate final int id;\nprivate final ClientProperty key;\nprivate final FreerailsSerializable value;\npublic SetPropertyMessage2Client(int id, ClientProperty key,\nFreerailsSerializable value) {\nif (null == key || null == value)\nthrow new NullPointerException();\nthis.id = id;\nthis.key = key;\nthis.value = value;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof SetPropertyMessage2Client))\nreturn false;\nfinal SetPropertyMessage2Client setPropertyMessage2Client = (SetPropertyMessage2Client) o;\nif (id != setPropertyMessage2Client.id)\nreturn false;\nif (!key.equals(setPropertyMessage2Client.key))\nreturn false;\nif (!value.equals(setPropertyMessage2Client.value))\nreturn false;\nreturn true;\n}\npublic MessageStatus execute(ClientControlInterface client) {\nclient.setProperty(key, value);\nreturn new MessageStatus(id, true);\n}\npublic int getID() {\nreturn id;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + key.hashCode();\nresult = 29 * result + value.hashCode();\nreturn result;\n}\n}"}
{"className":"jfreerails.network.specifics.SavedGamesManager","javaDoc":"/**\n* Defines methods that let the server load and save game states, and get blank\n* maps for new games.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines methods that let the server load and save game states, and get blank\n* maps for new games.\n*\n* @author Luke\n*\n*/\npublic interface SavedGamesManager {\nString[] getSaveGameNames();\nString[] getNewMapNames();\nvoid saveGame(Serializable w, String s) throws IOException;\nSerializable loadGame(String name) throws IOException;\nSerializable newMap(String name) throws IOException;\n}"}
{"className":"jfreerails.network.specifics.SaveGameMessage2Server","javaDoc":"/**\n* A request to save the game.\n*\n* @author Luke\n*\n*/","code":"/**\n* A request to save the game.\n*\n* @author Luke\n*\n*/\npublic class SaveGameMessage2Server implements Message2Server {\nprivate static final long serialVersionUID = 3257281452725777209L;\nprivate final int id;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof SaveGameMessage2Server))\nreturn false;\nfinal SaveGameMessage2Server saveGameMessage2Server = (SaveGameMessage2Server) o;\nif (id != saveGameMessage2Server.id)\nreturn false;\nif (!filename.equals(saveGameMessage2Server.filename))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + filename.hashCode();\nreturn result;\n}\nprivate final String filename;\npublic SaveGameMessage2Server(int id, String s) {\nthis.id = id;\nthis.filename = s;\n}\npublic int getID() {\nreturn id;\n}\npublic MessageStatus execute(ServerControlInterface server) {\ntry {\nserver.savegame(filename);\nreturn new MessageStatus(id, true);\n} catch (Exception e) {\nreturn new MessageStatus(id, false, e.getMessage());\n}\n}\n}"}
{"className":"jfreerails.network.specifics.UntriedMoveReceiver","javaDoc":"/**\n* Lets the caller test moves.\n*\n* @author rob\n*\n*/","code":"/**\n* Lets the caller test moves.\n*\n* @author rob\n*\n*/\npublic interface UntriedMoveReceiver extends MoveReceiver {\nMoveStatus tryDoMove(Move move);\nvoid processPreMove(PreMove pm);\n}"}
{"className":"jfreerails.network.specifics.SetWorldMessage2Client","javaDoc":"/**\n* Sent from the server to the client when (i) a new game is started, (ii) a\n* game is loaded, or (iii) the client connects to a game in progress.\n*\n* @author Luke\n*\n*/","code":"/**\n* Sent from the server to the client when (i) a new game is started, (ii) a\n* game is loaded, or (iii) the client connects to a game in progress.\n*\n* @author Luke\n*\n*/\n@Immutable\npublic class SetWorldMessage2Client implements Message2Client {\nprivate static final long serialVersionUID = 3257570619972269362L;\nprivate final int id;\nprivate final World world;\n/**\n* Note, makes a defensive copy of the world object passed to it.\n*/\npublic SetWorldMessage2Client(int id, World world) {\nthis.id = id;\nthis.world = world.defensiveCopy();\n}\npublic MessageStatus execute(ClientControlInterface client) {\nclient.setGameModel(world.defensiveCopy());\nreturn new MessageStatus(id, true);\n}\npublic int getID() {\nreturn id;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof SetWorldMessage2Client))\nreturn false;\nfinal SetWorldMessage2Client setWorldMessage2Client = (SetWorldMessage2Client) o;\nif (id != setWorldMessage2Client.id)\nreturn false;\nif (!world.equals(setWorldMessage2Client.world))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + world.hashCode();\nreturn result;\n}\n}"}
{"className":"jfreerails.network.specifics.RefreshListOfGamesMessage2Server","javaDoc":"/** Tells the server to check the filesystem for changes to the available new maps and saved games.\n* @author Luke\n* */","code":"/** Tells the server to check the filesystem for changes to the available new maps and saved games.\n* @author Luke\n* */\npublic class RefreshListOfGamesMessage2Server implements Message2Server {\nprivate static final long serialVersionUID = -8745171955732354168L;\nprivate final int id;\npublic MessageStatus execute(ServerControlInterface server) {\nserver.refreshSavedGames();\nreturn new MessageStatus(id, true);\n}\npublic int getID() {\nreturn id;\n}\npublic RefreshListOfGamesMessage2Server(final int id) {\nsuper();\nthis.id = id;\n}\n@Override\npublic int hashCode() {\nfinal int PRIME = 31;\nint result = 1;\nresult = PRIME * result + id;\nreturn result;\n}\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null)\nreturn false;\nif (getClass() != obj.getClass())\nreturn false;\nfinal RefreshListOfGamesMessage2Server other = (RefreshListOfGamesMessage2Server) obj;\nif (id != other.id)\nreturn false;\nreturn true;\n}\n}"}
{"className":"jfreerails.network.specifics.FreerailsGameServer","javaDoc":"/**\n* When executed by a thread, this class does the following: reads and executes\n* moves and commands received from connected clients; sends moves and commands\n* to connected clients.\n*\n* @see InetConnectionAccepter\n* @see Connection2Client\n*\n* @author Luke\n*\n*/","code":"/**\n* When executed by a thread, this class does the following: reads and executes\n* moves and commands received from connected clients; sends moves and commands\n* to connected clients.\n*\n* @see InetConnectionAccepter\n* @see Connection2Client\n*\n* @author Luke\n*\n*/\npublic class FreerailsGameServer implements ServerControlInterface, GameServer,\nRunnable {\n/** Used as a property name for property change events. */\npublic static final String CONNECTED_PLAYERS = \"CONNECTED_PLAYERS\";\nprivate static final Logger logger = Logger\n.getLogger(FreerailsGameServer.class.getName());\npublic static FreerailsGameServer startServer(SavedGamesManager gamesManager) {\nFreerailsGameServer server = new FreerailsGameServer(gamesManager);\nThread t = new Thread(server);\nt.start();\ntry {\n/* Wait for the server to start before returning. */\nsynchronized (server.status) {\nserver.status.wait();\n}\nreturn server;\n} catch (InterruptedException e) {\ne.printStackTrace();\nthrow new IllegalStateException();\n}\n}\nprivate final HashMap<NameAndPassword, Connection2Client> acceptedConnections = new HashMap<NameAndPassword, Connection2Client>();\nprivate int commandID = 0;\n/**\n* ID of the last SetWorldMessage2Client sent out. Used to keep track of\n* which clients have updated their world object to the current version.\n*/\nprivate int confirmationID = Integer.MIN_VALUE; /*\n* Don't default 0 to avoid\n* mistaken confirmations.\n*/\n/**\n* The players who have confirmed that they have received the last copy of\n* the world object sent.\n*/\nprivate HashSet<NameAndPassword> confirmedPlayers = new HashSet<NameAndPassword>();\n/* Contains the user names of the players who are currently logged on. */\nprivate HashSet<NameAndPassword> currentlyLoggedOn = new HashSet<NameAndPassword>();\nprivate boolean newPlayersAllowed = true;\nprivate ArrayList<NameAndPassword> players = new ArrayList<NameAndPassword>();\nprivate final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(\nthis);\nprivate final SavedGamesManager savedGamesManager;\nprivate ServerGameModel serverGameModel = new SimpleServerGameModel();\nprivate final SynchronizedFlag status = new SynchronizedFlag(false);\npublic FreerailsGameServer(SavedGamesManager gamesManager) {\nthis.savedGamesManager = gamesManager;\n}\npublic synchronized void addConnection(Connection2Client connection) {\nString[] before = getPlayerNames();\nlogger.fine(\"Adding connection..\");\nlogger.fine(\"Waiting for login details..\");\ntry {\nLogOnRequest request = (LogOnRequest) connection\n.waitForObjectFromClient();\nlogger.fine(\"Trying to login player: \" + request.getUsername());\nLogOnResponse response = this.logon(request);\nconnection.writeToClient(response);\nconnection.flush();\nNameAndPassword p = new NameAndPassword(request.getUsername(),\nrequest.getPassword());\nif (response.isSuccessful()) {\nlogger.fine(\"Login successful\");\nsynchronized (acceptedConnections) {\nacceptedConnections.put(p, connection);\n}\n/* Just send to the new client. */\nMessage2Client setMaps = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.MAPS_AVAILABLE,\nnew ImStringList(savedGamesManager.getNewMapNames()));\nImStringList savedGameNames = new ImStringList(\nsavedGamesManager.getSaveGameNames());\nMessage2Client setSaveGames = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.SAVED_GAMES, savedGameNames);\nconnection.writeToClient(setMaps);\nconnection.writeToClient(setSaveGames);\n// no need to flush since it is done in\n// sendListOfConnectedPlayers2Clients()\n/*\n* If there is a game in progress, we need to send the client a\n* copy of the world object.\n*/\nif (null != serverGameModel && null != getWorld()) {\nSetWorldMessage2Client command = new SetWorldMessage2Client(\nconfirmationID, getWorld());\nconnection.writeToClient(command);\n}\n/* Send to all clients. */\nsendListOfConnectedPlayers2Clients();\nString[] after = getPlayerNames();\npropertyChangeSupport.firePropertyChange(\"CONNECTED_PLAYERS\",\nbefore, after);\n} else {\nconnection.disconnect();\n}\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n} catch (InterruptedException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n}\npublic void addPropertyChangeListener(PropertyChangeListener l) {\npropertyChangeSupport.addPropertyChangeListener(l);\n}\npublic synchronized int countOpenConnections() {\nIterator<NameAndPassword> it = acceptedConnections.keySet().iterator();\nint numConnections = 0;\nwhile (it.hasNext()) {\nConnection2Client connection = acceptedConnections.get(it.next());\nif (connection.isOpen()) {\nnumConnections++;\n}\n}\nreturn numConnections;\n}\nWorld getCopyOfWorld() {\nreturn this.getWorld().defensiveCopy();\n}\nprivate int getNextClientCommandId() {\nreturn commandID++;\n}\npublic String[] getPlayerNames() {\nString[] playerNames = new String[players.size()];\nfor (int i = 0; i < players.size(); i++) {\nplayerNames[i] = players.get(i).username;\n}\nreturn playerNames;\n}\nprivate World getWorld() {\nreturn serverGameModel.getWorld();\n}\nboolean isConfirmed(int player) {\nlogger.fine(\"confirmedPlayers.size()=\" + confirmedPlayers.size());\nboolean isConfirmed = confirmedPlayers.contains(players.get(player));\nreturn isConfirmed;\n}\npublic boolean isNewPlayersAllowed() {\nreturn newPlayersAllowed;\n}\nprivate boolean isPlayer(String username) {\nfor (NameAndPassword p : players) {\nif (p.username.equals(username))\nreturn true;\n}\nreturn false;\n}\npublic void loadgame(String saveGameName) throws IOException {\nlogger.info(\"load game \" + saveGameName);\nnewPlayersAllowed = false;\nconfirmedPlayers.clear();\nServerGameModel loadedGame;\nloadedGame = (ServerGameModel) savedGamesManager.loadGame(saveGameName);\nString[] passwords = loadedGame.getPasswords();\nWorld w = loadedGame.getWorld();\nassert passwords.length == w.getNumberOfPlayers();\nArrayList<NameAndPassword> newPlayers = new ArrayList<NameAndPassword>();\nfor (int i = 0; i < passwords.length; i++) {\nPlayer player = w.getPlayer(i);\nNameAndPassword nap = new NameAndPassword(player.getName(),\npasswords[i]);\nnewPlayers.add(nap);\n}\n/*\n* Remove any currently logged on players who are not participants in\n* the game we are loading.\n*/\nfor (NameAndPassword nap : players) {\nif (!newPlayers.contains(nap) && currentlyLoggedOn.contains(nap)) {\nremoveConnection(nap);\n}\n}\nplayers = newPlayers;\nsetServerGameModel(loadedGame);\nsendWorldUpdatedCommand();\n}\npublic void logoff(int player) {\nNameAndPassword np = players.get(player);\ncurrentlyLoggedOn.remove(np);\n}\npublic LogOnResponse logon(LogOnRequest lor) {\nNameAndPassword p = new NameAndPassword(lor.getUsername(), lor\n.getPassword());\nboolean isReturningPlayer = isPlayer(lor.getUsername());\nif (!this.newPlayersAllowed && !isReturningPlayer) {\nreturn LogOnResponse.rejected(\"New logins not allowed.\");\n}\nif (currentlyLoggedOn.contains(p)) {\nreturn LogOnResponse.rejected(\"Already logged on.\");\n}\nif (isReturningPlayer) {\nif (!players.contains(p)) {\nreturn LogOnResponse.rejected(\"Incorrect password.\");\n}\n} else {\nplayers.add(p);\n}\ncurrentlyLoggedOn.add(p);\nreturn LogOnResponse.accepted(players.indexOf(p));\n}\npublic void newGame(String mapName, int numAI) {\nfor (int i = 0; i < numAI; ++i) {\nNameAndPassword aiPlayer = new NameAndPassword(\"AI\" + i, null);\nplayers.add(aiPlayer);\n}\nthis.newGame(mapName);\n}\npublic void newGame(String mapName) {\nnewPlayersAllowed = false;\nconfirmedPlayers.clear();\ntry {\nWorld world = (World) savedGamesManager.newMap(mapName);\nString[] passwords = new String[players.size()];\n/* Add players to world. */\nfor (int i = 0; i < players.size(); i++) {\nString name = players.get(i).username;\nPlayer p = new Player(name, i);\nMove addPlayerMove = AddPlayerMove.generateMove(world, p);\nMoveStatus ms = addPlayerMove.doMove(world, Player.AUTHORITATIVE);\nif(!ms.ok) throw new IllegalStateException();\npasswords[i] = players.get(i).password;\n}\nserverGameModel.setWorld(world, passwords);\nsetServerGameModel(serverGameModel);\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\nsendWorldUpdatedCommand();\nlogger.fine(\"newGame\");\n}\nprivate void removeConnection(NameAndPassword p) throws IOException {\nString[] before = getPlayerNames();\nConnection2Client connection = acceptedConnections.get(p);\n/*\n* Fix for bug 1047439 Shutting down remote client crashes server We get\n* an IllegalStateException if we try to disconnect a connection that is\n* not open.\n*/\nif (connection.isOpen()) {\nconnection.disconnect();\n}\nthis.currentlyLoggedOn.remove(p);\nString[] after = getPlayerNames();\npropertyChangeSupport.firePropertyChange(\"CONNECTED_PLAYERS\", before,\nafter);\n}\npublic void removePropertyChangeListener(PropertyChangeListener l) {\npropertyChangeSupport.removePropertyChangeListener(l);\n}\npublic void run() {\nstatus.open();\nstatus.close();\n}\npublic void savegame(String saveGameName) {\nlogger.info(\"save game as \" + saveGameName);\ntry {\nsavedGamesManager.saveGame(serverGameModel, saveGameName);\nString[] saves = savedGamesManager.getSaveGameNames();\nMessage2Client request = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.SAVED_GAMES, new ImStringList(\nsaves));\nsend2All(request);\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n}\nprivate void send2All(FreerailsSerializable message) {\nsend2AllExcept(null, message);\n}\n/** Sends the specified message to all connections except the specified one. */\nprivate void send2AllExcept(Connection2Client dontSend2,\nFreerailsSerializable message) {\nIterator<NameAndPassword> it = acceptedConnections.keySet().iterator();\nwhile (it.hasNext()) {\nNameAndPassword p = it.next();\nConnection2Client connection = acceptedConnections.get(p);\nif (dontSend2 != connection) {\ntry {\nconnection.writeToClient(message);\nconnection.flush();\n} catch (Exception e) {\nif (connection.isOpen()) {\ne.printStackTrace();\ntry {\nremoveConnection(p);\n} catch (IOException e1) {\ne1.printStackTrace();\n}\n}\n}\n}\n}\n}\nprivate void sendListOfConnectedPlayers2Clients() throws IOException {\n/* Send the client the list of players. */\nString[] playerNames = getPlayerNames();\nMessage2Client request = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.CONNECTED_CLIENTS, new ImStringList(\nplayerNames));\nsend2All(request);\n}\nprivate void sendWorldUpdatedCommand() {\n/* Send the world to the clients. */\nconfirmationID = getNextClientCommandId();\nSetWorldMessage2Client command = new SetWorldMessage2Client(\nconfirmationID, getWorld());\nsend2All(command);\n}\npublic void setNewPlayersAllowed(boolean newPlayersAllowed) {\nthis.newPlayersAllowed = newPlayersAllowed;\n}\npublic void setServerGameModel(ServerGameModel serverGameModel) {\nthis.serverGameModel = serverGameModel;\nMoveReceiver moveExecutor = new MoveReceiver() {\npublic void processMove(Move move) {\nMoveStatus ms = move.doMove(getWorld(), Player.AUTHORITATIVE);\nif (ms.ok) {\nsend2All(move);\n} else {\nlogger.warning(ms.message);\n}\n}\n};\nserverGameModel.init(moveExecutor);\n}\npublic void stop() {\n// TODO Auto-generated method stub\n}\npublic void stopGame() {\nlogger.info(\"Stop game.\");\n}\n/**\n* Updates the game model, then reads and deals with the outstanding\n* messages from each of the connected clients. This method is synchronized\n* to prevent moves being sent out while addConnection(.) is executing.\n*/\npublic synchronized void update() {\nif (null != serverGameModel) {\nserverGameModel.update();\n}\ntry {\nIterator<NameAndPassword> it = acceptedConnections.keySet()\n.iterator();\nwhile (it.hasNext()) {\nNameAndPassword player = it.next();\nConnection2Client connection = acceptedConnections.get(player);\nif (connection.isOpen()) {\nFreerailsSerializable[] messages = connection\n.readFromClient();\nfor (int i = 0; i < messages.length; i++) {\nif (messages[i] instanceof Message2Server) {\nMessage2Server message2 = (Message2Server) messages[i];\nMessageStatus cStatus = message2.execute(this);\nlogger.fine(message2.toString());\nconnection.writeToClient(cStatus);\n} else if (messages[i] instanceof MessageStatus) {\nMessageStatus messageStatus = (MessageStatus) messages[i];\nif (messageStatus.getId() == this.confirmationID) {\n/*\n* The client is confirming that they have\n* updated their world object to the current\n* version.\n*/\nthis.confirmedPlayers.add(player);\nlogger.fine(\"Confirmed player \" + player);\n}\nlogger.fine(messages[i].toString());\n} else if (messages[i] instanceof Move\n|| messages[i] instanceof PreMove) {\nPlayer player2 = getWorld().getPlayer(\nplayers.indexOf(player));\nFreerailsPrincipal principal = player2\n.getPrincipal();\nMove move;\nboolean isMove = messages[i] instanceof Move;\nif (isMove) {\nmove = (Move) messages[i];\n} else {\nPreMove pm = (PreMove) messages[i];\nmove = pm.generateMove(getWorld());\n}\nMoveStatus mStatus = move.tryDoMove(\nthis.getWorld(), principal);\nif (mStatus.isOk()) {\nmove.doMove(getWorld(), principal);\n/*\n* We don't send the move to the client that\n* submitted it.\n*/\nsend2AllExcept(connection, move);\n}\nif (isMove) {\nconnection.writeToClient(mStatus);\n} else {\nconnection.writeToClient(PreMoveStatus\n.fromMoveStatus(mStatus));\n}\n} else {\nlogger.fine(messages[i].toString());\n}\n}\nconnection.flush();\n} else {\n/* Remove connection. */\nthis.removeConnection(player);\n}\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\npublic void refreshSavedGames() {\nMessage2Client setMaps = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.MAPS_AVAILABLE,\nnew ImStringList(savedGamesManager.getNewMapNames()));\nImStringList savedGameNames = new ImStringList(\nsavedGamesManager.getSaveGameNames());\nMessage2Client setSaveGames = new SetPropertyMessage2Client(\ngetNextClientCommandId(),\nClientControlInterface.ClientProperty.SAVED_GAMES, savedGameNames);\nsend2All(setMaps);\nsend2All(setSaveGames);\n}\n}"}
{"className":"jfreerails.network.specifics.SimpleServerGameModel","javaDoc":"/**\n* A ServerGameModel that has a world object but no automation.\n*\n* @author Luke\n*\n*/","code":"/**\n* A ServerGameModel that has a world object but no automation.\n*\n* @author Luke\n*\n*/\npublic class SimpleServerGameModel implements ServerGameModel {\nprivate static final long serialVersionUID = 3546074757457131826L;\nprivate World w;\nprivate String[] passwords;\npublic void setWorld(World w, String[] passwords) {\nthis.w = w;\nthis.passwords = passwords.clone();\n}\npublic World getWorld() {\nreturn w;\n}\npublic void init(MoveReceiver moveExecuter) {\n}\npublic void write(ObjectOutputStream objectOut) throws IOException {\n}\npublic void update() {\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal principal) {\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal principal) {\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal principal) {\n}\npublic String[] getPasswords() {\nreturn passwords.clone();\n}\n}"}
{"className":"jfreerails.network.specifics.LogOnRequest","javaDoc":"/**\n* A client sends an instance of this class to the server when it wishes to log\n* on.\n*\n* @author Luke\n*\n*/","code":"/**\n* A client sends an instance of this class to the server when it wishes to log\n* on.\n*\n* @author Luke\n*\n*/\npublic class LogOnRequest implements FreerailsSerializable {\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof LogOnRequest))\nreturn false;\nfinal LogOnRequest logOnRequest = (LogOnRequest) o;\nif (password != null ? !password.equals(logOnRequest.password)\n: logOnRequest.password != null)\nreturn false;\nif (username != null ? !username.equals(logOnRequest.username)\n: logOnRequest.username != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (username != null ? username.hashCode() : 0);\nresult = 29 * result + (password != null ? password.hashCode() : 0);\nreturn result;\n}\nprivate static final long serialVersionUID = 3257854263924240949L;\nprivate final String username;\nprivate final String password;\npublic LogOnRequest(String username, String password) {\nthis.username = username;\nthis.password = password;\n}\npublic String getPassword() {\nreturn password;\n}\npublic String getUsername() {\nreturn username;\n}\n}"}
{"className":"jfreerails.network.specifics.FreerailsClient","javaDoc":"/**\n* A client for FreerailsGameServer.\n*\n* @author Luke\n*\n*/","code":"/**\n* A client for FreerailsGameServer.\n*\n* @author Luke\n*\n*/\npublic class FreerailsClient implements ClientControlInterface, GameModel,\nUntriedMoveReceiver, ServerCommandReceiver {\nprivate static final Logger logger = Logger.getLogger(FreerailsClient.class\n.getName());\nprotected Connection2Server connection2Server;\nprivate final HashMap<String, Serializable> properties = new HashMap<String, Serializable>();\nprivate final MoveChainFork moveFork;\nprivate World world;\nprivate MovePrecommitter committer;\npublic FreerailsClient() {\nmoveFork = new MoveChainFork();\n}\npublic final MoveChainFork getMoveFork() {\nreturn moveFork;\n}\n/**\n* Connects this client to a remote server.\n*/\npublic final LogOnResponse connect(String address, int port,\nString username, String password) {\nlogger.fine(\"Connect to remote server. \" + address + \":\" + port);\ntry {\nconnection2Server = new InetConnection2Server(address, port);\n} catch (IOException e) {\nreturn LogOnResponse.rejected(e.getMessage());\n}\ntry {\nLogOnRequest request = new LogOnRequest(username, password);\nconnection2Server.writeToServer(request);\nconnection2Server.flush();\nLogOnResponse response = (LogOnResponse) connection2Server\n.waitForObjectFromServer();\nreturn response;\n} catch (Exception e) {\ntry {\nconnection2Server.disconnect();\n} catch (IOException e1) {\ne1.printStackTrace();\n}\nreturn LogOnResponse.rejected(e.getMessage());\n}\n}\n/**\n* Connects this client to a local server.\n*/\npublic final LogOnResponse connect(GameServer server, String username,\nString password) {\ntry {\nLogOnRequest request = new LogOnRequest(username, password);\nconnection2Server = new LocalConnection();\nconnection2Server.writeToServer(request);\nserver.addConnection((LocalConnection) connection2Server);\nLogOnResponse response = (LogOnResponse) connection2Server\n.waitForObjectFromServer();\nreturn response;\n} catch (Exception e) {\ntry {\nconnection2Server.disconnect();\n} catch (IOException e1) {\ne1.printStackTrace();\n}\nreturn LogOnResponse.rejected(e.getMessage());\n}\n}\n/**\n* Disconnect the client from the server.\n*/\npublic final void disconnect() {\ntry {\nconnection2Server.disconnect();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\npublic final void setGameModel(FreerailsMutableSerializable o) {\nworld = (World) o;\ncommitter = new MovePrecommitter(world);\nnewWorld(world);\n}\n/**\n* Subclasses should override this method if they need to respond the the\n* world being changed.\n*/\nprotected void newWorld(World w) {\n}\npublic void setProperty(ClientProperty propertyName, Serializable value) {\nproperties.put(propertyName.name(), value);\n}\npublic final Serializable getProperty(ClientProperty propertyName) {\nreturn properties.get(propertyName.name());\n}\npublic final void resetProperties(HashMap newProperties) {\n// TODO Auto-generated method stub\nthrow new UnsupportedOperationException();\n}\nfinal FreerailsSerializable read() {\ntry {\nreturn this.connection2Server.waitForObjectFromServer();\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n} catch (InterruptedException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\nthrow new IllegalStateException();\n}\nfinal void write(FreerailsSerializable fs) {\ntry {\nconnection2Server.writeToServer(fs);\n} catch (IOException e) {\ne.printStackTrace();\nthrow new IllegalStateException();\n}\n}\n/** Reads and deals with all outstanding messages from the server. */\nfinal public void update() {\ntry {\nFreerailsSerializable[] messages = connection2Server\n.readFromServer();\nfor (int i = 0; i < messages.length; i++) {\nFreerailsSerializable message = messages[i];\nprocessMessage(message);\n}\nconnection2Server.flush();\nclientUpdates();\n} catch (IOException e) {\nReportBugTextGenerator.unexpectedException(e);\n}\n}\n/**\n* Empty method called by update(), subclasses should override this method\n* instead of overriding update().\n*\n*/\nprotected void clientUpdates() {\n}\n/** Processes a message received from the server. */\nfinal void processMessage(FreerailsSerializable message) throws IOException {\nif (message instanceof Message2Client) {\nMessage2Client request = (Message2Client) message;\nMessageStatus status = request.execute(this);\nlogger.fine(request.toString());\nconnection2Server.writeToServer(status);\n} else if (message instanceof Move) {\nMove m = (Move) message;\ncommitter.fromServer(m);\nmoveFork.processMove(m);\n} else if (message instanceof MoveStatus) {\nMoveStatus ms = (MoveStatus) message;\ncommitter.fromServer(ms);\n} else if (message instanceof PreMove) {\nPreMove pm = (PreMove) message;\nMove m = committer.fromServer(pm);\nmoveFork.processMove(m);\n} else if (message instanceof PreMoveStatus) {\nPreMoveStatus pms = (PreMoveStatus) message;\ncommitter.fromServer(pms);\n} else {\nlogger.fine(message.toString());\n}\n}\nfinal public World getWorld() {\nreturn world;\n}\n/** Sends move to the server. */\nfinal public void processMove(Move move) {\ncommitter.toServer(move);\nmoveFork.processMove(move);\nwrite(move);\n}\n/** Tests a move before sending it to the server. */\nfinal public MoveStatus tryDoMove(Move move) {\nreturn move.tryDoMove(world, Player.AUTHORITATIVE);\n}\npublic void sendCommand(Message2Server c) {\nwrite(c);\n}\npublic void processPreMove(PreMove pm) {\nMove m = committer.toServer(pm);\nmoveFork.processMove(m);\nwrite(pm);\n}\nprotected long getLastTickTime(){\nreturn moveFork.getLastTickTime();\n}\n}"}
{"className":"jfreerails.network.specifics.SavedGamesManager4UnitTests","javaDoc":"/**\n* Stores saved games in memory rather than on disk.\n*\n* @author Luke\n*\n*/","code":"/**\n* Stores saved games in memory rather than on disk.\n*\n* @author Luke\n*\n*/\npublic class SavedGamesManager4UnitTests implements SavedGamesManager {\nprivate String[] mapsAvailable = { \"map1\", \"map2\" };\nprivate final HashMap<String, Serializable> savedGames = new HashMap<String, Serializable>();\npublic String[] getSaveGameNames() {\nObject[] keys = savedGames.keySet().toArray();\nString[] names = new String[keys.length];\nfor (int i = 0; i < names.length; i++) {\nnames[i] = (String) keys[i];\n}\nreturn names;\n}\npublic String[] getNewMapNames() {\nreturn mapsAvailable.clone();\n}\npublic void saveGame(Serializable w, String name) throws IOException {\n// Make a copy so that the saved version's state cannot be changed.\nSerializable copy = Utils.cloneBySerialisation(w);\nthis.savedGames.put(name, copy);\n}\npublic Serializable loadGame(String name) throws IOException {\nSerializable o = savedGames.get(name);\nreturn Utils.cloneBySerialisation(o);\n}\npublic Serializable newMap(String name) throws IOException {\nreturn new WorldImpl(10, 10);\n}\n}"}
{"className":"jfreerails.network.specifics.ServerCommandReceiver","javaDoc":"/**\n* Defines a method that accepts a command to be sent to the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a method that accepts a command to be sent to the server.\n*\n* @author Luke\n*\n*/\npublic interface ServerCommandReceiver {\nvoid sendCommand(Message2Server c);\n}"}
{"className":"jfreerails.network.specifics.NameAndPassword","javaDoc":"/**\n* Used by the server to store a player's username and password.\n*\n* @author Luke\n*\n*/","code":"/**\n* Used by the server to store a player's username and password.\n*\n* @author Luke\n*\n*/\npublic class NameAndPassword implements Serializable {\nprivate static final long serialVersionUID = 3258409551740155956L;\npublic final String password;\npublic final String username;\npublic NameAndPassword(String u, String p) {\nusername = u;\npassword = p;\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof NameAndPassword))\nreturn false;\nNameAndPassword test = (NameAndPassword) obj;\nreturn test.password.equals(password) && test.username.equals(username);\n}\n@Override\npublic int hashCode() {\nint result = 17;\nresult = result * 37 + password.hashCode();\nresult = result * 37 + username.hashCode();\nreturn result;\n}\n@Override\npublic String toString() {\nreturn username;\n}\n}"}
{"className":"jfreerails.network.specifics.LoadGameMessage2Server","javaDoc":"/**\n* Request to load a game.\n*\n* @author Luke\n*\n*/","code":"/**\n* Request to load a game.\n*\n* @author Luke\n*\n*/\npublic class LoadGameMessage2Server implements Message2Server {\nprivate static final long serialVersionUID = 3256726186552930869L;\nprivate final int id;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof LoadGameMessage2Server))\nreturn false;\nfinal LoadGameMessage2Server loadGameMessage2Server = (LoadGameMessage2Server) o;\nif (id != loadGameMessage2Server.id)\nreturn false;\nif (!filename.equals(loadGameMessage2Server.filename))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + filename.hashCode();\nreturn result;\n}\nprivate final String filename;\npublic LoadGameMessage2Server(int id, String s) {\nthis.id = id;\nthis.filename = s;\n}\npublic int getID() {\nreturn id;\n}\npublic MessageStatus execute(ServerControlInterface server) {\ntry {\nserver.loadgame(filename);\nreturn new MessageStatus(id, true);\n} catch (Exception e) {\ne.printStackTrace();\nreturn new MessageStatus(id, false, e.getMessage());\n}\n}\n}"}
{"className":"jfreerails.launcher.LauncherInterface","javaDoc":"/**\n* Exposes the methods on the Launcher that the launcher panels may call.\n*\n* @author Luke\n*\n*/","code":"/**\n* Exposes the methods on the Launcher that the launcher panels may call.\n*\n* @author Luke\n*\n*/\npublic interface LauncherInterface {\npublic static final int INFO = 0;\npublic static final int WARNING = 1;\npublic static final int ERROR = 2;\nvoid setInfoText(String text, int status);\nvoid setNextEnabled(boolean enabled);\nvoid hideErrorMessages();\nvoid hideAllMessages();\nvoid setProperty(String key, String value);\nString getProperty(String key);\nvoid saveProps();\n}"}
{"className":"jfreerails.launcher.Launcher","javaDoc":"/**\n* Launcher GUI for both the server and/or client.\n*\n* TODO The code in the switch statements needs reviewing.\n*\n* @author rtuck99@users.sourceforge.net\n* @author Luke\n*/","code":"/**\n* Launcher GUI for both the server and/or client.\n*\n* TODO The code in the switch statements needs reviewing.\n*\n* @author rtuck99@users.sourceforge.net\n* @author Luke\n*/\npublic class Launcher extends javax.swing.JFrame implements LauncherInterface {\nprivate static final long serialVersionUID = 1L;\nprivate static final Logger logger = Logger.getLogger(Launcher.class\n.getName());\nprivate static String QUICKSTART = \"-quickstart\";\nprivate final Component[] wizardPages = new Component[4];\nprivate int currentPage = 0;\nprivate FreerailsGameServer server;\nprivate GUIClient client;\nprivate Properties props;\nprivate final ImageIcon errorIcon = new javax.swing.ImageIcon(getClass()\n.getResource(\"/jfreerails/client/graphics/icons/error.gif\"));\nprivate final ImageIcon warningIcon = new javax.swing.ImageIcon(getClass()\n.getResource(\"/jfreerails/client/graphics/icons/warning.gif\"));\nprivate final ImageIcon infoIcon = new javax.swing.ImageIcon(getClass()\n.getResource(\"/jfreerails/client/graphics/icons/info.gif\"));\nprivate final ProgressJPanel progressPanel = new ProgressJPanel(this);\npublic void setNextEnabled(boolean enabled) {\nnextButton.setEnabled(enabled);\nif (nextIsStart) {\nnextButton.setText(\"Start\");\n} else {\nnextButton.setText(\"Next...\");\n}\n}\nprivate boolean nextIsStart = false;\nprivate void startGame() {\nCardLayout cl = (CardLayout) jPanel1.getLayout();\ncl.show(jPanel1, \"4\");\nsetButtonsVisible(false);\nLauncherPanel1 lp = (LauncherPanel1) wizardPages[0];\nSelectMapJPanel msp = (SelectMapJPanel) wizardPages[1];\nClientOptionsJPanel cop = (ClientOptionsJPanel) wizardPages[2];\nConnectedPlayersJPanel cp = (ConnectedPlayersJPanel) wizardPages[3];\nboolean recover = false;\nint mode;\nswitch (lp.getMode()) {\ncase LauncherPanel1.MODE_SINGLE_PLAYER:\ntry {\nmode = cop.getScreenMode();\nclient = new GUIClient(cop.getPlayerName(), progressPanel,\nmode, cop.getDisplayMode());\nif (isNewGame()) {\ninitServer();\n}\nclient.connect(server, cop.getPlayerName(), \"password\");\nsetServerGameModel();\n} catch (IOException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} finally {\nif (recover) {\ncop.setControlsEnabled(true);\nprevButton.setEnabled(true);\nsetButtonsVisible(true);\ncurrentPage = 1;\ncl.show(jPanel1, \"1\");\nreturn;\n}\n}\nstartThread(server, client);\nbreak;\ncase LauncherPanel1.MODE_START_NETWORK_GAME:\n// LL: I don't think this code ever executes now that there is a\n// connected players screen.\ntry {\nsetServerGameModel();\ncurrentPage = 3;\nString[] playerNames = server.getPlayerNames();\nplayerNames = playerNames.length == 0 ? new String[] { \"No players are connected.\" }\n: playerNames;\ncp.setListOfPlayers(playerNames);\ncl.show(jPanel1, \"3\");\nsetNextEnabled(false);\n} catch (IOException e) {\n// We end up here if an Exception was thrown when loading a\n// saved game.\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} finally {\nif (recover) {\ncop.setControlsEnabled(true);\nprevButton.setEnabled(true);\nsetNextEnabled(true);\ncurrentPage = 1;\nsetButtonsVisible(true);\ncl.show(jPanel1, \"1\");\nreturn;\n}\n}\nbreak;\ncase LauncherPanel1.MODE_JOIN_NETWORK_GAME:\nmode = cop.getScreenMode();\ntry {\nInetSocketAddress serverInetAddress = cop\n.getRemoteServerAddress();\nif (null == serverInetAddress) {\nthrow new NullPointerException(\"Couldn't resolve hostname.\");\n}\nString playerName = cop.getPlayerName();\nclient = new GUIClient(playerName, progressPanel, mode, cop\n.getDisplayMode());\nString hostname = serverInetAddress.getHostName();\nint port = serverInetAddress.getPort();\nsetInfoText(\"Connecting to server...\", LauncherInterface.INFO);\nLogOnResponse logOnResponse = client.connect(hostname, port,\nplayerName, \"password\");\nif (logOnResponse.isSuccessful()) {\nsetInfoText(\"Logged on and waiting for game to start.\", LauncherInterface.INFO);\nstartThread(client);\n} else {\nrecover = true;\nsetInfoText(logOnResponse.getMessage(),\nLauncherInterface.WARNING);\n}\n} catch (IOException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} catch (NullPointerException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} finally {\nif (recover) {\ncop.setControlsEnabled(true);\nprevButton.setEnabled(true);\nsetButtonsVisible(true);\ncl.show(jPanel1, \"2\");\nreturn;\n}\n}\nbreak;\ncase LauncherPanel1.MODE_SERVER_ONLY:\nif (msp.validateInput()) {\ninitServer();\ntry {\nsetServerGameModel();\nprepare2HostNetworkGame(msp.getServerPort());\nsetNextEnabled(true);\n} catch (NullPointerException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} catch (IOException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\nrecover = true;\n} finally {\nif (recover) {\ncop.setControlsEnabled(true);\nprevButton.setEnabled(true);\nsetButtonsVisible(true);\nreturn;\n}\n}\n}\n}// End of switch statement\n}\nprivate void setServerGameModel() throws IOException {\nClientOptionsJPanel cop = (ClientOptionsJPanel) wizardPages[2];\nif (isNewGame()) {\nSelectMapJPanel msp2 = (SelectMapJPanel) wizardPages[1];\nserver.newGame(msp2.getNewMapName());\ncop.limitPlayerNames(null);\n} else {\n// Do nothing since the server is already set up.\n}\n}\nprivate boolean isNewGame() {\nSelectMapJPanel msp2 = (SelectMapJPanel) wizardPages[1];\nreturn msp2.getSelection().equals(SelectMapJPanel.Selection.NEW_GAME);\n}\n/** Starts the client and server in the same thread. */\nprivate static void startThread(final FreerailsGameServer server,\nfinal GUIClient client) {\ntry {\nRunnable run = new Runnable() {\npublic void run() {\nwhile (null == client.getWorld()) {\nclient.update();\nserver.update();\n}\nGameModel[] models = new GameModel[] { client, server };\nScreenHandler screenHandler = client.getScreenHandler();\nGameLoop gameLoop = new GameLoop(screenHandler, models);\n//screenHandler.apply();\ngameLoop.run();\n}\n};\nThread t = new Thread(run, \"Client + server main loop\");\nt.start();\n} catch (Exception e) {\nexit(e);\n}\n}\n/** Starts the client in a new thread. */\nprivate void startThread(final GUIClient guiClient) {\ntry {\nRunnable run = new Runnable() {\npublic void run() {\nwhile (null == guiClient.getWorld()) {\nguiClient.update();\ntry {\nThread.sleep(20);\n} catch (InterruptedException e) {\n// do nothing\n}\n}\nGameModel[] models = new GameModel[] { guiClient };\nScreenHandler screenHandler = guiClient.getScreenHandler();\nGameLoop gameLoop = new GameLoop(screenHandler, models);\ngameLoop.run();\n}\n};\nThread t = new Thread(run, \"Client main loop\");\nt.start();\n} catch (Exception e) {\nexit(e);\n}\n}\n/** Starts the server in a new thread. */\nprivate static void startThread(final FreerailsGameServer server) {\ntry {\nRunnable r = new Runnable() {\npublic void run() {\nwhile (true) {\nlong startTime = System.currentTimeMillis();\nserver.update();\nlong deltatime = System.currentTimeMillis() - startTime;\nif (deltatime < 20) {\ntry {\nThread.sleep(20 - deltatime);\n} catch (InterruptedException e) {\n// do nothing.\n}\n}\n}\n}\n};\nThread t = new Thread(r, \"FreerailsGameServer\");\nt.start();\n} catch (Exception e) {\nexit(e);\n}\n}\nprivate void initServer() {\nSavedGamesManager gamesManager = new SavedGamesManagerImpl();\nserver = new FreerailsGameServer(gamesManager);\nServerGameModelImpl serverGameModel = new ServerGameModelImpl();\nserver.setServerGameModel(serverGameModel);\n/*\n* Set the server field on the connected players panel so that it can\n* keep track of who is connected.\n*/\nConnectedPlayersJPanel cp = (ConnectedPlayersJPanel) wizardPages[3];\ncp.server = server;\nserver.addPropertyChangeListener(cp);\ncp.updateListOfPlayers();\n}\n/**\n* Runs the game.\n*/\npublic static void main(String args[]) {\n//SynchronizedEventQueue.use();\n// Let the user know if we are using a custom logging config.\nString loggingProperties = System\n.getProperty(\"java.util.logging.config.file\");\nif (null != loggingProperties) {\nlogger.info(\"Logging properties file: \" + loggingProperties);\n}\nlogger.fine(\"Started launcher.\");\nboolean quickstart = false;\nif (args.length > 0) {\nfor (int i = 0; i < args.length; i++) {\nif (QUICKSTART.equals(args[i]))\nquickstart = true;\n}\n}\nLauncher launcher = new Launcher(quickstart);\nlauncher.start(quickstart);\n}\n/**\n* Shows GUI. If <code>quickstart</code> is <code>true</code> runs the\n* game.\n*\n* @param quickstart\n* boolean\n*/\npublic void start(boolean quickstart) {\nsetVisible(true);\nif (quickstart) {\nstartGame();\n}\n}\n/** Starts a thread listening for new connections. */\nprivate void prepare2HostNetworkGame(int port) throws IOException {\nloadProps();\nif (isNewGame()) {\ninitServer();\n}\nInetConnectionAccepter accepter = new InetConnectionAccepter(port,\nserver);\n/*\n* Note, the thread's name gets set in the run method so there is no\n* point setting it here.\n*/\nThread t = new Thread(accepter);\nt.start();\nCardLayout cl = (CardLayout) jPanel1.getLayout();\ncl.show(jPanel1, \"3\");\ncurrentPage = 3;\n}\npublic Launcher(boolean quickstart) {\nloadProps();\ninitComponents();\nwizardPages[0] = new LauncherPanel1(this);\nwizardPages[1] = new SelectMapJPanel(this);\nwizardPages[2] = new ClientOptionsJPanel(this);\nwizardPages[3] = new ConnectedPlayersJPanel();\nif (!quickstart) {\njPanel1.add(wizardPages[0], \"0\");\njPanel1.add(wizardPages[1], \"1\");\njPanel1.add(wizardPages[2], \"2\");\njPanel1.add(wizardPages[3], \"3\");\njPanel1.add(progressPanel, \"4\");\npack();\n} else {\nprevButton.setVisible(false);\nnextButton.setVisible(false);\npack();\n}\nhideAllMessages();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\njPanel1 = new javax.swing.JPanel();\nnextButton = new javax.swing.JButton();\nprevButton = new javax.swing.JButton();\ninfoLabel = new javax.swing.JLabel();\ngetContentPane().setLayout(new java.awt.GridBagLayout());\nsetTitle(\"Freerails Launcher\");\naddWindowListener(new java.awt.event.WindowAdapter() {\n@Override\npublic void windowClosing(java.awt.event.WindowEvent evt) {\nexitForm(evt);\n}\n});\njPanel1.setLayout(new java.awt.CardLayout());\njPanel1.setPreferredSize(new java.awt.Dimension(400, 300));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngetContentPane().add(jPanel1, gridBagConstraints);\nnextButton.setText(\"Next...\");\nnextButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nnextButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngetContentPane().add(nextButton, gridBagConstraints);\nprevButton.setText(\"Back...\");\nprevButton.setEnabled(false);\nprevButton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nprevButtonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngetContentPane().add(prevButton, gridBagConstraints);\ninfoLabel.setText(\"Error messages go here!\");\ninfoLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);\ninfoLabel.setMinimumSize(new java.awt.Dimension(20, 20));\ninfoLabel.setPreferredSize(new java.awt.Dimension(20, 20));\ninfoLabel.setVerifyInputWhenFocusTarget(false);\ninfoLabel.setVerticalTextPosition(javax.swing.SwingConstants.TOP);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.gridwidth = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);\ngetContentPane().add(infoLabel, gridBagConstraints);\npack();\n}// GEN-END:initComponents\nprivate void prevButtonActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_prevButtonActionPerformed\nCardLayout cl = (CardLayout) jPanel1.getLayout();\nnextIsStart = false;\nhideAllMessages();\nswitch (currentPage) {\ncase 1:\ncl.previous(jPanel1);\ncurrentPage--;\nprevButton.setEnabled(false);\nbreak;\ncase 2:\nLauncherPanel1 panel = (LauncherPanel1) wizardPages[0];\nif (panel.getMode() == LauncherPanel1.MODE_JOIN_NETWORK_GAME) {\ncurrentPage = 0;\ncl.show(jPanel1, \"0\");\nprevButton.setEnabled(false);\n} else {\ncurrentPage--;\ncl.previous(jPanel1);\n}\n}\n}// GEN-LAST:event_prevButtonActionPerformed\nprivate void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_nextButtonActionPerformed\ntry {\nCardLayout cl = (CardLayout) jPanel1.getLayout();\nLauncherPanel1 panel = (LauncherPanel1) wizardPages[0];\nSelectMapJPanel msp = (SelectMapJPanel) wizardPages[1];\nClientOptionsJPanel cop = (ClientOptionsJPanel) wizardPages[2];\nhideAllMessages();\nswitch (currentPage) {\ncase 0:\nmsp.validateInput();\n/* Initial game selection page */\nswitch (panel.getMode()) {\ncase LauncherPanel1.MODE_SERVER_ONLY:\n/* go to map selection screen */\ncl.next(jPanel1);\nmsp.setServerPortPanelVisible(true);\ncurrentPage++;\nbreak;\ncase LauncherPanel1.MODE_SINGLE_PLAYER:\n/* go to map selection screen */\ncl.next(jPanel1);\nmsp.setServerPortPanelVisible(false);\ncop.setRemoteServerPanelVisible(false);\ncurrentPage++;\nbreak;\ncase LauncherPanel1.MODE_START_NETWORK_GAME:\n/* go to map selection screen */\nmsp.setServerPortPanelVisible(true);\ncop.setRemoteServerPanelVisible(false);\ncl.next(jPanel1);\ncurrentPage++;\nbreak;\ncase LauncherPanel1.MODE_JOIN_NETWORK_GAME:\n/* client display options */\nnextIsStart = true;\ncl.show(jPanel1, \"2\");\ncurrentPage = 2;\nmsp.setServerPortPanelVisible(false);\ncop.setRemoteServerPanelVisible(true);\ncop.limitPlayerNames(null);\nbreak;\n}\nprevButton.setEnabled(true);\nbreak;\ncase 1:\n/* map selection page */\nif (panel.getMode() == LauncherPanel1.MODE_SERVER_ONLY) {\nif (msp.validateInput()) {\nprevButton.setEnabled(false);\ntry {\nif (!isNewGame()) {\ninitServer();\nserver\n.loadgame(ServerControlInterface.FREERAILS_SAV);\n}\nprepare2HostNetworkGame(msp.getServerPort());\n} catch (BindException be) {\n// When the port is already in use.\nprevButton.setEnabled(true);\nsetInfoText(be.getMessage(),\nLauncherInterface.WARNING);\n}\n}\n} else {\nif (isNewGame()) {\ncop.limitPlayerNames(null);\n} else {\ninitServer();\nserver.loadgame(msp.getSaveGameName());\nString[] playernames = server.getPlayerNames();\ncop.limitPlayerNames(playernames);\n}\nnextIsStart = true;\nprevButton.setEnabled(true);\nsetNextEnabled(true);\ncurrentPage++;\ncl.next(jPanel1);\n}\nbreak;\ncase 2:\n/* display mode selection */\nif (panel.getMode() == LauncherPanel1.MODE_START_NETWORK_GAME) {\nif (msp.validateInput()) {\nprevButton.setEnabled(false);\nint mode = cop.getScreenMode();\nprepare2HostNetworkGame(msp.getServerPort());\nclient = new GUIClient(cop.getPlayerName(),\nprogressPanel, mode, cop.getDisplayMode());\nclient.connect(server, cop.getPlayerName(), \"password\");\n}\n} else {\nprevButton.setEnabled(false);\ncop.setControlsEnabled(false);\nstartGame();\n}\nbreak;\ncase 3:\ntry {\n/* Connection status screen */\nprevButton.setEnabled(false);\nsetServerGameModel();// TODO catch exception\nif (panel.getMode() == LauncherPanel1.MODE_START_NETWORK_GAME) {\nstartThread(server, client);\ncl.show(jPanel1, \"4\");\n} else {\n/* Start a stand alone server. */\nstartThread(server);\nsetVisible(false);\n}\nsetButtonsVisible(false);\nsetNextEnabled(false);\n} catch (IOException e) {\nsetInfoText(e.getMessage(), LauncherInterface.WARNING);\ncop.setControlsEnabled(true);\nprevButton.setEnabled(true);\nsetNextEnabled(true);\ncurrentPage = 1;\ncl.show(jPanel1, \"1\");\nreturn;\n}\nbreak;\ndefault:\nthrow new IllegalArgumentException(String.valueOf(currentPage));\n}\n} catch (Exception e) {\nexit(e);\n}\n}// GEN-LAST:event_nextButtonActionPerformed\nprivate static void exit(Exception e) {\nReportBugTextGenerator.unexpectedException(e);\n}\n/** Exit the Application. */\nprivate void exitForm(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_exitForm\nSystem.exit(0);\n}// GEN-LAST:event_exitForm\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JLabel infoLabel;\njavax.swing.JPanel jPanel1;\njavax.swing.JButton nextButton;\njavax.swing.JButton prevButton;\n// End of variables declaration//GEN-END:variables\npublic void setInfoText(String text, int status) {\ninfoLabel.setText(text);\nswitch (status) {\ncase LauncherInterface.ERROR:\ninfoLabel.setIcon(errorIcon);\nnextButton.setEnabled(false);\nbreak;\ncase LauncherInterface.INFO:\ninfoLabel.setIcon(infoIcon);\nnextButton.setEnabled(true);\nbreak;\ncase LauncherInterface.WARNING:\ninfoLabel.setIcon(warningIcon);\nnextButton.setEnabled(true);\nbreak;\ndefault:\nthrow new IllegalArgumentException(String.valueOf(status));\n}\n}\npublic void hideAllMessages() {\ninfoLabel.setText(null);\ninfoLabel.setIcon(null);\nnextButton.setEnabled(true);\n}\npublic void setButtonsVisible(boolean b){\nnextButton.setVisible(b);\nprevButton.setVisible(b);\n}\npublic void hideErrorMessages() {\nif (infoLabel.getIcon() == errorIcon) {\ninfoLabel.setText(null);\ninfoLabel.setIcon(null);\nnextButton.setEnabled(true);\n}\n}\nprivate void loadProps(){\ntry{\nprops = new Properties();\nFileInputStream in = new FileInputStream(\"freerails.properties\");\nprops.load(in);\nin.close();\nif(!props.containsKey(\"freerails.server.port\") ||\n!props.containsKey(\"freerails.server.port\") ||\n!props.containsKey(\"freerails.server.port\")){\nthrow new Exception();\n}\n}catch (Exception e){\nprops = new Properties();\nprops.setProperty(\"freerails.server.port\", \"55000\");\nprops.setProperty(\"freerails.player.name\", System.getProperty(\"user.name\"));\nprops.setProperty(\"freerails.server.ip.address\", \"127.0.0.1\");\n}\n}\npublic void saveProps(){\ntry{\nFileOutputStream out = new FileOutputStream(\"freerails.properties\");\nprops.store(out, \"---No Comment---\");\nout.close();\n//Copy key-value pairs to System.Properties so\n//that they are visible in the game via the\n//show java properties menu item.\nSystem.getProperties().putAll(props);\n}catch (Exception e){\nlogger.warning(e.getMessage());\n}\n}\npublic void setProperty(String key, String value){\nprops.setProperty(key, value);\n}\npublic String getProperty(String key){\nreturn props.getProperty(key);\n}\n}"}
{"className":"jfreerails.launcher.LauncherPanel1","javaDoc":"/**\n* The first launcher panel, lets you choose 'single player', 'start network\n* game' etc.\n*\n* @author rtuck99@users.sourceforge.net\n*/","code":"/**\n* The first launcher panel, lets you choose 'single player', 'start network\n* game' etc.\n*\n* @author rtuck99@users.sourceforge.net\n*/\nfinal class LauncherPanel1 extends javax.swing.JPanel {\nprivate static final long serialVersionUID = 3257850965422913590L;\nstatic final int MODE_SINGLE_PLAYER = 0;\nstatic final int MODE_START_NETWORK_GAME = 1;\nstatic final int MODE_JOIN_NETWORK_GAME = 2;\nstatic final int MODE_SERVER_ONLY = 3;\nprivate final ButtonModel[] buttonModels = new ButtonModel[4];\nint getMode() {\nfor (int i = 0; i < buttonModels.length; i++) {\nif (buttonGroup1.getSelection() == buttonModels[i]) {\nreturn i;\n}\n}\nassert false;\nreturn 0;\n}\n/*\n* private void validateSettings() { boolean isValid = false; String\n* infoText = null;\n*\n* switch (getMode()) {\n*\n* case MODE_SINGLE_PLAYER: isValid = true; break; case\n* MODE_START_NETWORK_GAME: case MODE_SERVER_ONLY: isValid = true; break;\n* case MODE_JOIN_NETWORK_GAME: isValid = true; break; }\n* owner.setInfoText(infoText, LauncherInterface.WARNING);\n* owner.setNextEnabled(isValid); }\n*/\npublic LauncherPanel1(LauncherInterface owner) {\ninitComponents();\nbuttonModels[MODE_SINGLE_PLAYER] = singlePlayerButton.getModel();\nbuttonModels[MODE_START_NETWORK_GAME] = startNetworkButton.getModel();\nbuttonModels[MODE_JOIN_NETWORK_GAME] = joinNetworkButton.getModel();\nbuttonModels[MODE_SERVER_ONLY] = serverOnlyButton.getModel();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nbuttonGroup1 = new javax.swing.ButtonGroup();\nsinglePlayerButton = new javax.swing.JRadioButton();\nstartNetworkButton = new javax.swing.JRadioButton();\njoinNetworkButton = new javax.swing.JRadioButton();\nserverOnlyButton = new javax.swing.JRadioButton();\npaddingJPanel = new javax.swing.JPanel();\nsetLayout(new java.awt.GridBagLayout());\nsetBorder(new javax.swing.border.TitledBorder(\nnew javax.swing.border.EtchedBorder(), \"Select Game Type\"));\nbuttonGroup1.add(singlePlayerButton);\nsinglePlayerButton.setSelected(true);\nsinglePlayerButton.setText(\"Single-Player\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\nadd(singlePlayerButton, gridBagConstraints);\nbuttonGroup1.add(startNetworkButton);\nstartNetworkButton.setText(\"Start a network game\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\nadd(startNetworkButton, gridBagConstraints);\nbuttonGroup1.add(joinNetworkButton);\njoinNetworkButton.setText(\"Join a network game\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\nadd(joinNetworkButton, gridBagConstraints);\nbuttonGroup1.add(serverOnlyButton);\nserverOnlyButton.setText(\"Server only\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.weightx = 1.0;\nadd(serverOnlyButton, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 4;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(paddingJPanel, gridBagConstraints);\n}// GEN-END:initComponents\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.ButtonGroup buttonGroup1;\njavax.swing.JRadioButton joinNetworkButton;\njavax.swing.JPanel paddingJPanel;\njavax.swing.JRadioButton serverOnlyButton;\njavax.swing.JRadioButton singlePlayerButton;\njavax.swing.JRadioButton startNetworkButton;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.launcher.ClientOptionsJPanel","javaDoc":"/**\n* The Launcher panel that lets you choose fullscreen or windowed mode and the\n* screen resolution etc.\n*\n* @author rtuck99@users.sourceforge.net\n* @author Luke Lindsay\n*/","code":"/**\n* The Launcher panel that lets you choose fullscreen or windowed mode and the\n* screen resolution etc.\n*\n* @author rtuck99@users.sourceforge.net\n* @author Luke Lindsay\n*/\nclass ClientOptionsJPanel extends javax.swing.JPanel implements LauncherPanel {\nprivate static final long serialVersionUID = 3256721779883325748L;\nprivate static final Logger logger = Logger\n.getLogger(ClientOptionsJPanel.class.getName());\nprivate final LauncherInterface owner;\nprivate String[] names;\nprivate static final String INVALID_PORT = \"A valid port value is between between 0 and 65535.\";\nprivate final DocumentListener documentListener = new DocumentListener() {\npublic void insertUpdate(DocumentEvent e) {\nvalidateInput();\n}\npublic void removeUpdate(DocumentEvent e) {\nvalidateInput();\n}\npublic void changedUpdate(DocumentEvent e) {\nvalidateInput();\n}\n};\n/**\n* If the user has opted to load a game, we need to limit the list of\n* players to participants in the game we are loading. Otherwise, any player\n* name is OK. Either, pass in a array of names or null if any name is OK.\n*/\nvoid limitPlayerNames(String[] n) {\nthis.names = n;\nif (names == null) {\nplayerName.setVisible(true);\nplayerNames.setVisible(false);\nplayerName.setEditable(true);\n} else {\nif (names.length == 1) {\nplayerName.setVisible(true);\nplayerNames.setVisible(false);\nplayerName.setText(n[0]);\nplayerName.setEditable(false);\n} else {\nplayerName.setVisible(false);\nplayerNames.setVisible(true);\nComboBoxModel model = new DefaultComboBoxModel(names);\nplayerNames.setModel(model);\n}\n}\nthis.revalidate();\n}\nString getPlayerName() {\nif (playerName.isVisible()) {\nreturn playerName.getText();\n}\nint index = playerNames.getSelectedIndex();\nif (index < 0)\nreturn null; // no selection.\nreturn names[index];\n}\nDisplayMode getDisplayMode() {\nif (this.fullScreenButton.isSelected()) {\nMyDisplayMode displayMode = ((MyDisplayMode) jList1\n.getSelectedValue());\nlogger.fine(\"The selected display mode is \"\n+ displayMode.toString());\nreturn displayMode.displayMode;\n}\nreturn null;\n}\nInetSocketAddress getRemoteServerAddress() {\nString portStr = remotePort.getText();\nif (portStr == null) {\nreturn null;\n}\nint port;\ntry {\nport = Integer.parseInt(portStr);\n} catch (NumberFormatException e) {\nreturn null;\n}\nInetSocketAddress address;\ntry {\naddress = new InetSocketAddress(remoteIP.getText(), port);\n} catch (IllegalArgumentException e) {\nreturn null;\n}\n/*\n* cut and pasted InetSocketAddress isa = getRemoteServerAddress(); if\n* (isa == null) { infoText = \"Please enter a valid remote server\n* address\"; } else if (isa.isUnresolved()) { infoText = \"Couldn't\n* resolve remote server address\"; } else { isValid = true; }\n*/\nreturn address;\n}\npublic boolean validateInput() {\n/* Validate player name. */\nif (playerName.getText() == null || playerName.getText().equals(\"\")) {\nowner.setInfoText(\"Please set a name for your player\",\nLauncherInterface.ERROR);\nreturn false;\n}\n/* Validate host name. */\nif (remoteIP.getText() == null || remoteIP.getText().equals(\"\")) {\nowner.setInfoText(\"Please enter a host name\",\nLauncherInterface.ERROR);\nreturn false;\n}\n/* Validate port. */\ntry {\nint port = Integer.parseInt(remotePort.getText());\nif (port < 0 || port > 65535) {\nowner.setInfoText(INVALID_PORT, LauncherInterface.ERROR);\nreturn false;\n}\n} catch (Exception e) {\nowner.setInfoText(INVALID_PORT, LauncherInterface.ERROR);\nreturn false;\n}\n/*\n* Validate display-mode selection. Note, on some systems the display\n* mode can't be changed, in which case the list of selectable display\n* modes will have length 0.\n*/\nif (fullScreenButton.isSelected() && jList1.getModel().getSize() > 0\n&& jList1.getSelectedIndex() == -1) {\nowner\n.setInfoText(\"Select a display-mode.\",\nLauncherInterface.ERROR);\nreturn false;\n}\n/* Everything is ok. */\nowner.hideErrorMessages();\nowner.setProperty(\"freerails.server.port\", this.remotePort.getText());\nowner.setProperty(\"freerails.player.name\", this.playerName.getText());\nowner.setProperty(\"freerails.server.ip.address\", this.remoteIP.getText());\nowner.saveProps();\nreturn true;\n}\nint getScreenMode() {\nif (this.fullScreenButton.isSelected()) {\nreturn ScreenHandler.FULL_SCREEN;\n} else if (this.windowedButton.isSelected()) {\nreturn ScreenHandler.WINDOWED_MODE;\n} else if (this.fixedSizeButton.isSelected()) {\nreturn ScreenHandler.FIXED_SIZE_WINDOWED_MODE;\n} else {\nthrow new IllegalStateException();\n}\n}\npublic void setControlsEnabled(boolean enabled) {\nwindowedButton.setEnabled(enabled);\nfullScreenButton.setEnabled(enabled);\nfixedSizeButton.setEnabled(enabled);\nif (fullScreenButton.isSelected()) {\njList1.setEnabled(enabled);\n}\n}\nprivate final DisplayModesComboBoxModels listModel;\nvoid setRemoteServerPanelVisible(boolean b) {\nthis.jPanel4.setVisible(b);\n}\npublic ClientOptionsJPanel(LauncherInterface owner) {\nthis.owner = owner;\ninitComponents();\nlistModel = new DisplayModesComboBoxModels();\nlistModel.removeDisplayModesBelow(640, 480, 16);\njList1.setModel(listModel);\njList1.setSelectedIndex(0);\nvalidateInput();\n// Listen for changes in the server port text box.\nremotePort.getDocument().addDocumentListener(documentListener);\nremoteIP.getDocument().addDocumentListener(documentListener);\nplayerName.getDocument().addDocumentListener(documentListener);\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\nbuttonGroup1 = new javax.swing.ButtonGroup();\njPanel3 = new javax.swing.JPanel();\njLabel1 = new javax.swing.JLabel();\nplayerName = new javax.swing.JTextField();\nplayerNames = new javax.swing.JComboBox();\njPanel4 = new javax.swing.JPanel();\njLabel2 = new javax.swing.JLabel();\nremoteIP = new javax.swing.JTextField();\njLabel3 = new javax.swing.JLabel();\nremotePort = new javax.swing.JTextField();\nspacer = new javax.swing.JPanel();\njPanel1 = new javax.swing.JPanel();\njScrollPane1 = new javax.swing.JScrollPane();\njList1 = new javax.swing.JList();\njPanel2 = new javax.swing.JPanel();\nwindowedButton = new javax.swing.JRadioButton();\nfixedSizeButton = new javax.swing.JRadioButton();\nfullScreenButton = new javax.swing.JRadioButton();\nsetLayout(new java.awt.GridBagLayout());\naddComponentListener(new java.awt.event.ComponentAdapter() {\n@Override\npublic void componentShown(java.awt.event.ComponentEvent evt) {\nformComponentShown(evt);\n}\n});\njPanel3.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));\njPanel3.setBorder(new javax.swing.border.TitledBorder(\nnew javax.swing.border.EtchedBorder(), \"Player Details\"));\njLabel1.setText(\"Player name:\");\njPanel3.add(jLabel1);\nplayerName.setColumns(12);\nplayerName.setText(owner.getProperty(\"freerails.player.name\"));\njPanel3.add(playerName);\nplayerNames.setToolTipText(\"Select a player from the saved game.\");\njPanel3.add(playerNames);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\nadd(jPanel3, gridBagConstraints);\njPanel4.setLayout(new java.awt.GridBagLayout());\njPanel4\n.setBorder(new javax.swing.border.TitledBorder(\nnew javax.swing.border.EtchedBorder(),\n\"Remote server address\"));\njPanel4.setEnabled(false);\njLabel2.setText(\"IP Address:\");\njPanel4.add(jLabel2, new java.awt.GridBagConstraints());\nremoteIP.setColumns(15);\nremoteIP.setText(owner.getProperty(\"freerails.server.ip.address\"));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\njPanel4.add(remoteIP, gridBagConstraints);\njLabel3.setText(\"port\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\njPanel4.add(jLabel3, gridBagConstraints);\nremotePort.setColumns(5);\nremotePort.setText(owner.getProperty(\"freerails.server.port\"));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;\ngridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);\njPanel4.add(remotePort, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.weightx = 1.0;\njPanel4.add(spacer, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\ngridBagConstraints.weightx = 1.0;\nadd(jPanel4, gridBagConstraints);\njPanel1.setLayout(new java.awt.BorderLayout());\njPanel1.setBorder(new javax.swing.border.TitledBorder(\nnew javax.swing.border.EtchedBorder(), \"Select Display Mode\"));\njScrollPane1.setBorder(new javax.swing.border.BevelBorder(\njavax.swing.border.BevelBorder.LOWERED));\njList1\n.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\njList1.setEnabled(false);\njList1\n.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(\njavax.swing.event.ListSelectionEvent evt) {\njList1ValueChanged(evt);\n}\n});\njScrollPane1.setViewportView(jList1);\njPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);\njPanel2.setLayout(new javax.swing.BoxLayout(jPanel2,\njavax.swing.BoxLayout.Y_AXIS));\nbuttonGroup1.add(windowedButton);\nwindowedButton.setSelected(true);\nwindowedButton.setText(\"Windowed\");\njPanel2.add(windowedButton);\nbuttonGroup1.add(fixedSizeButton);\nfixedSizeButton.setText(\"Windowed (fixed size 640*480)\");\njPanel2.add(fixedSizeButton);\nbuttonGroup1.add(fullScreenButton);\nfullScreenButton.setText(\"Full screen\");\nfullScreenButton\n.addChangeListener(new javax.swing.event.ChangeListener() {\npublic void stateChanged(javax.swing.event.ChangeEvent evt) {\nfullScreenButtonStateChanged(evt);\n}\n});\njPanel2.add(fullScreenButton);\njPanel1.add(jPanel2, java.awt.BorderLayout.NORTH);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jPanel1, gridBagConstraints);\n}// GEN-END:initComponents\nprivate void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {// GEN-FIRST:event_jList1ValueChanged\nvalidateInput();\n}// GEN-LAST:event_jList1ValueChanged\nprivate void formComponentShown(java.awt.event.ComponentEvent evt) {// GEN-FIRST:event_formComponentShown\nvalidateInput();\n}// GEN-LAST:event_formComponentShown\nprivate void fullScreenButtonStateChanged(javax.swing.event.ChangeEvent evt) {// GEN-FIRST:event_fullScreenButtonStateChanged\njList1.setEnabled(fullScreenButton.isSelected());\nvalidateInput();\n}// GEN-LAST:event_fullScreenButtonStateChanged\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.ButtonGroup buttonGroup1;\njavax.swing.JRadioButton fixedSizeButton;\njavax.swing.JRadioButton fullScreenButton;\njavax.swing.JLabel jLabel1;\njavax.swing.JLabel jLabel2;\njavax.swing.JLabel jLabel3;\njavax.swing.JList jList1;\njavax.swing.JPanel jPanel1;\njavax.swing.JPanel jPanel2;\njavax.swing.JPanel jPanel3;\njavax.swing.JPanel jPanel4;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JTextField playerName;\njavax.swing.JComboBox playerNames;\njavax.swing.JTextField remoteIP;\njavax.swing.JTextField remotePort;\njavax.swing.JPanel spacer;\njavax.swing.JRadioButton windowedButton;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.launcher.ProgressJPanel","javaDoc":"/**\n* A JPanel that displays a splash screen and a progress bar.\n*\n* @author Luke\n*/","code":"/**\n* A JPanel that displays a splash screen and a progress bar.\n*\n* @author Luke\n*/\npublic class ProgressJPanel extends javax.swing.JPanel implements\nFreerailsProgressMonitor{\nprivate static final long serialVersionUID = 3256445798203273776L;\nint step, stepSize;\nfinal int numSteps = 5;\nLauncherInterface owner;\npublic void setValue(int i) {\nint value = i * 100 / stepSize;\nvalue += 100 * step;\nprogressBar.setValue(value);\n}\npublic void nextStep(int max) {\n//So that the waiting for game to start message\n//goes away.\nowner.hideAllMessages();\nstep++;\nstepSize = max;\nif(numSteps < step)\nthrow new IllegalStateException();\n}\npublic void finished() {\nif(numSteps-1 != step)\nthrow new IllegalStateException(numSteps +\"!=\"+ step);\ngetTopLevelAncestor().setVisible(false);\n}\n/** Creates new form ProgressJPanel */\npublic ProgressJPanel(LauncherInterface owner) {\nthis.owner = owner;\ninitComponents();\nprogressBar.setMaximum(numSteps * 100);\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\nprogressBar = new javax.swing.JProgressBar();\nsplashImage = new javax.swing.JLabel();\nsetLayout(new java.awt.GridBagLayout());\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\ngridBagConstraints.insets = new java.awt.Insets(3, 7, 3, 7);\nadd(progressBar, gridBagConstraints);\nsplashImage.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\nsplashImage.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/jfreerails/client/graphics/splash_screen.jpg\")));\nadd(splashImage, new java.awt.GridBagConstraints());\n}\n// </editor-fold>//GEN-END:initComponents\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JProgressBar progressBar;\njavax.swing.JLabel splashImage;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.launcher.ConnectedPlayersJPanel","javaDoc":"/**\n* A JPanel that shows the players currently logged in to the server.\n*\n* @author Luke\n*/","code":"/**\n* A JPanel that shows the players currently logged in to the server.\n*\n* @author Luke\n*/\npublic class ConnectedPlayersJPanel extends javax.swing.JPanel implements\nPropertyChangeListener {\nprivate static final long serialVersionUID = 4049080453489111344L;\nFreerailsGameServer server = null;\n/** Creates new form ConnectedPlayersJPanel */\npublic ConnectedPlayersJPanel() {\ninitComponents();\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the Form Editor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njava.awt.GridBagConstraints gridBagConstraints;\ntitle = new javax.swing.JLabel();\njScrollPane1 = new javax.swing.JScrollPane();\njList1 = new javax.swing.JList();\nsetLayout(new java.awt.GridBagLayout());\ntitle.setText(\"Connected Players\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\nadd(title, gridBagConstraints);\njList1.setModel(new javax.swing.AbstractListModel() {\nprivate static final long serialVersionUID = 1L;\nString[] strings = { \"No players are logged on!\" };\npublic int getSize() {\nreturn strings.length;\n}\npublic Object getElementAt(int i) {\nreturn strings[i];\n}\n});\njScrollPane1.setViewportView(jList1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\n}// GEN-END:initComponents\nvoid updateListOfPlayers() {\nif (null != server) {\nString[] playerNames = server.getPlayerNames();\nplayerNames = playerNames.length == 0 ? new String[] { \"No players are logged on!\" }\n: playerNames;\nsetListOfPlayers(playerNames);\n}\n}\nvoid setListOfPlayers(String[] players) {\njList1.setListData(players);\n}\n/** Called by the server when a player is added or removed. */\npublic void propertyChange(PropertyChangeEvent evt) {\nif (evt.getPropertyName().equals(FreerailsGameServer.CONNECTED_PLAYERS)) {\nif (EventQueue.isDispatchThread()) {\nupdateListOfPlayers();\n} else {\nEventQueue.invokeLater(new Runnable() {\npublic void run() {\nupdateListOfPlayers();\n}\n});\n}\n}\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JList jList1;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JLabel title;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.launcher.SelectMapJPanel","javaDoc":"/**\n* The Launcher panel that lets you load a game or start a new game with a\n* choice of maps.\n* @author Luke\n*/","code":"/**\n* The Launcher panel that lets you load a game or start a new game with a\n* choice of maps.\n* @author Luke\n*/\npublic class SelectMapJPanel extends javax.swing.JPanel implements LauncherPanel {\nprivate static final long serialVersionUID = 3763096353857024568L;\nprivate static final String SELECT_A_MAP = \"Select a map.\";\nprivate static final String INVALID_PORT = \"A valid port value is between between 0 and 65535.\";\nprivate final LauncherInterface owner;\npublic enum Selection {NONE, NEW_GAME, LOAD_GAME};\nSelection getSelection() {\nif( newmapsJList.getSelectedIndex() != -1 ){\nsavedmapsJList.setSelectedIndex(-1);\nreturn Selection.NEW_GAME;\n}\nif(savedmapsJList.getSelectedIndex() != -1){\nreturn Selection.LOAD_GAME;\n}\nreturn Selection.NONE;\n}\nvoid setServerPortPanelVisible(boolean b) {\nthis.jPanel3.setVisible(b);\n}\npublic String getNewMapName() {\nreturn (String) newmapsJList.getSelectedValue();\n}\npublic String getSaveGameName() {\nreturn (String) savedmapsJList.getSelectedValue();\n}\nSelectMapJPanel(LauncherInterface owner) {\nthis.owner = owner;\ninitComponents();\n/* initialise the map list */\nSavedGamesManagerImpl sgm = new SavedGamesManagerImpl();\nnewmapsJList.setListData(sgm.getNewMapNames());\nnewmapsJList.setSelectedIndex(0);\nsavedmapsJList.setListData(sgm.getSaveGameNames());\nowner.setNextEnabled(true);\n// Listen for changes in the server port text box.\nserverPort.getDocument().addDocumentListener(new DocumentListener() {\npublic void insertUpdate(DocumentEvent e) {\nvalidateInput();\n}\npublic void removeUpdate(DocumentEvent e) {\nvalidateInput();\n}\npublic void changedUpdate(DocumentEvent e) {\nvalidateInput();\n}\n});\n}\nint getServerPort() {\nString s = serverPort.getText();\nreturn Integer.parseInt(s);\n}\npublic boolean validateInput() {\n/* Validate map selection. */\nif (this.getSelection().equals(Selection.NONE)) {\nowner.setInfoText(SELECT_A_MAP, LauncherInterface.ERROR);\nreturn false;\n}\n/* Validate port. */\ntry {\nint port = getServerPort();\nif (port < 0 || port > 65535) {\nowner.setInfoText(INVALID_PORT, LauncherInterface.ERROR);\nreturn false;\n}\n} catch (Exception e) {\nowner.setInfoText(INVALID_PORT, LauncherInterface.ERROR);\nreturn false;\n}\n/* Everything is ok. */\nowner.hideErrorMessages();\nowner.setProperty(\"freerails.server.port\", this.serverPort.getText());\nowner.saveProps();\nreturn true;\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\njPanel1 = new javax.swing.JPanel();\njScrollPane1 = new javax.swing.JScrollPane();\nnewmapsJList = new javax.swing.JList();\njPanel4 = new javax.swing.JPanel();\njScrollPane2 = new javax.swing.JScrollPane();\nsavedmapsJList = new javax.swing.JList();\njPanel3 = new javax.swing.JPanel();\nportLabel = new javax.swing.JLabel();\nserverPort = new javax.swing.JTextField();\njPanel2 = new javax.swing.JPanel();\nsetLayout(new java.awt.GridBagLayout());\njPanel1.setLayout(new java.awt.BorderLayout());\njPanel1.setBorder(new javax.swing.border.TitledBorder(new javax.swing.border.EtchedBorder(), \"New Game\"));\njPanel1.setPreferredSize(null);\njScrollPane1.setViewportBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\nnewmapsJList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\nnewmapsJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(javax.swing.event.ListSelectionEvent evt) {\nnewmapsJListValueChanged(evt);\n}\n});\njScrollPane1.setViewportView(newmapsJList);\njPanel1.add(jScrollPane1, java.awt.BorderLayout.CENTER);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jPanel1, gridBagConstraints);\njPanel4.setLayout(new java.awt.BorderLayout());\njPanel4.setBorder(new javax.swing.border.TitledBorder(new javax.swing.border.EtchedBorder(), \"Load game\"));\njPanel4.setPreferredSize(null);\njPanel4.setRequestFocusEnabled(false);\njScrollPane2.setViewportBorder(new javax.swing.border.BevelBorder(javax.swing.border.BevelBorder.LOWERED));\nsavedmapsJList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);\nsavedmapsJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {\npublic void valueChanged(javax.swing.event.ListSelectionEvent evt) {\nsavedmapsJListValueChanged(evt);\n}\n});\njScrollPane2.setViewportView(savedmapsJList);\njPanel4.add(jScrollPane2, java.awt.BorderLayout.CENTER);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jPanel4, gridBagConstraints);\njPanel3.setLayout(new java.awt.GridBagLayout());\njPanel3.setBorder(new javax.swing.border.TitledBorder(new javax.swing.border.EtchedBorder(), \"Server port\"));\nportLabel.setText(\"Port:\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\njPanel3.add(portLabel, gridBagConstraints);\nserverPort.setColumns(6);\nserverPort.setText( owner.getProperty(\"freerails.server.port\"));\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 1;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\njPanel3.add(serverPort, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\njPanel3.add(jPanel2, gridBagConstraints);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 2;\ngridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\nadd(jPanel3, gridBagConstraints);\n}\n// </editor-fold>//GEN-END:initComponents\nprivate void savedmapsJListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_savedmapsJListValueChanged\nif(savedmapsJList.getSelectedIndex() != -1)\nnewmapsJList.clearSelection();\nvalidateInput();\n}//GEN-LAST:event_savedmapsJListValueChanged\nprivate void newmapsJListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_newmapsJListValueChanged\nif(newmapsJList.getSelectedIndex() != -1)\nsavedmapsJList.clearSelection();\nvalidateInput();\n}//GEN-LAST:event_newmapsJListValueChanged\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JPanel jPanel1;\njavax.swing.JPanel jPanel2;\njavax.swing.JPanel jPanel3;\njavax.swing.JPanel jPanel4;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JScrollPane jScrollPane2;\njavax.swing.JList newmapsJList;\njavax.swing.JLabel portLabel;\njavax.swing.JList savedmapsJList;\njavax.swing.JTextField serverPort;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.launcher.LauncherPanel","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic interface LauncherPanel {\nboolean validateInput();\n}"}
{"className":"jfreerails.launcher.GUIClient","javaDoc":"/**\n* A swing freerails client.\n*\n* @author Luke\n*\n*/","code":"/**\n* A swing freerails client.\n*\n* @author Luke\n*\n*/\npublic class GUIClient extends FreerailsClient implements\nFreerailsProgressMonitor {\npublic static void main(String[] args) {\ntry {\nGUIClient client = new GUIClient(\"Test\", null,\nScreenHandler.WINDOWED_MODE, null);\nclient.start();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\nprivate final ActionRoot actionRoot;\nprivate final GUIComponentFactoryImpl factory;\nprivate final ModelRootImpl modelRoot;\nprivate final FreerailsProgressMonitor monitor;\nprivate final String name;\nprivate final ScreenHandler screenHandler;\nprivate RenderersRoot vl;\npublic GUIClient(String name, FreerailsProgressMonitor fm, int screenMode,\nDisplayMode dm) throws IOException {\nthis.name = name;\nthis.monitor = null == fm ? this : fm;\n// Set up model root and action root.\nmodelRoot = new ModelRootImpl();\nmodelRoot.setMoveFork(this.getMoveFork());\nmodelRoot.setMoveReceiver(this);\nmodelRoot.setServerCommandReceiver(this);\nactionRoot = new ActionRoot(modelRoot);\n// Create GUI components\nfactory = new GUIComponentFactoryImpl(modelRoot, actionRoot);\nJFrame createClientJFrame = factory.createClientJFrame(name);\nscreenHandler = new ScreenHandler(createClientJFrame, screenMode, dm);\n}\n@Override\nprotected void clientUpdates() {\nif (factory.isSetup()) {\nfactory.getBuildTrackController().update();\n// Update sub tick time.\nlong currentTime = System.currentTimeMillis();\nlong lastTick = getLastTickTime();\ndouble dt = currentTime - lastTick;\nReadOnlyWorld world2 = modelRoot.getWorld();\nGameSpeed gameSpeed = (GameSpeed) world2.get(ITEM.GAME_SPEED);\nGameTime currentGameTime = world2.currentTime();\ndouble ticks = currentGameTime.getTicks();\nif(!gameSpeed.isPaused()){\ndouble milliSecondsPerTick = 1000/ gameSpeed.getSpeed();\ndouble subTicks = dt / milliSecondsPerTick;\nsubTicks = Math.min(dt, 1d);\nticks += subTicks;\n}\nmodelRoot.setProperty(Property.TIME, new Double(ticks));\n}\n}\npublic void finished() {\n// TODO Auto-generated method stub\n}\npublic ScreenHandler getScreenHandler() {\nreturn screenHandler;\n}\n@Override\nprotected void newWorld(World w) {\ntry {\nif (null == vl || !vl.validate(w)) {\ntry {\nvl = new RenderersRootImpl(w, monitor);\nmonitor.finished();\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n}\n// Should be a smarter way of doing this..\nfor (int player = 0; player < w.getNumberOfPlayers(); player++) {\nPlayer p = w.getPlayer(player);\nif (p.getName().equals(this.name)) {\nmodelRoot.setup(w, p.getPrincipal());\n}\n}\nmodelRoot.setProperty(ModelRoot.Property.SERVER, connection2Server\n.getServerDetails());\nactionRoot.setup(modelRoot, vl);\nfactory.setup(vl, w);\n} catch (Exception e) {\nReportBugTextGenerator.unexpectedException(e);\n}\n}\npublic void nextStep(int max) {\n// TODO Auto-generated method stub\n}\npublic void setMessage(String s) {\nSystem.out.println(s);\n}\npublic void setValue(int i) {\n// TODO Auto-generated method stub\n}\n@Override\npublic void setProperty(ClientProperty propertyName, Serializable value) {\nsuper.setProperty(propertyName, value);\nswitch (propertyName) {\ncase SAVED_GAMES:\nmodelRoot.setProperty(Property.SAVED_GAMES_LIST, value);\nbreak;\ndefault:\nbreak;\n}\n}\nvoid start() {\n// Set up world.\nSavedGamesManager gamesManager = new SavedGamesManagerImpl();\nFreerailsGameServer server = new FreerailsGameServer(gamesManager);\nString mapName = gamesManager.getNewMapNames()[0];\nServerGameModelImpl serverGameModel = new ServerGameModelImpl();\nserver.setServerGameModel(serverGameModel);\nthis.connect(server, name, \"password\");\nserver.newGame(mapName);\nwhile (null == this.getWorld()) {\nthis.update();\nserver.update();\n}\nGameModel[] models = new GameModel[] { this, server };\n// Start the game loop\nGameLoop gameLoop = new GameLoop(screenHandler, models);\nThread t = new Thread(gameLoop);\nt.start();\n}\n}"}
{"className":"jfreerails.controller.JFrameMinimumSizeEnforcer","javaDoc":"/**\n* Since there is no setMinimum size method on JFrame, we use an instance of\n* this class to do the job.\n*\n* @author Luke\n*\n*/","code":"/**\n* Since there is no setMinimum size method on JFrame, we use an instance of\n* this class to do the job.\n*\n* @author Luke\n*\n*/\npublic class JFrameMinimumSizeEnforcer implements ComponentListener {\nprivate final int minWidth;\nprivate final int minHeight;\npublic JFrameMinimumSizeEnforcer(int w, int h) {\nthis.minHeight = h;\nthis.minWidth = w;\n}\npublic void componentResized(ComponentEvent arg0) {\nComponent c = arg0.getComponent();\nint width = c.getWidth();\nint height = c.getHeight();\n// we check if either the width\n// or the height are below minimum\nboolean resize = false;\nif (width < minWidth) {\nresize = true;\nwidth = minWidth;\n}\nif (height < minHeight) {\nresize = true;\nheight = minHeight;\n}\nif (resize) {\nc.setSize(width, height);\n}\n}\npublic void componentMoved(ComponentEvent arg0) {\n}\npublic void componentShown(ComponentEvent arg0) {\n}\npublic void componentHidden(ComponentEvent arg0) {\n}\n}"}
{"className":"jfreerails.controller.AddTrainPreMove","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class AddTrainPreMove implements PreMove {\nprivate static final long serialVersionUID = 4050201951105069624L;\nprivate final int engineTypeId;\nprivate final ImInts wagons;\n@Override\npublic boolean equals(Object o) {\nif (this == o) {\nreturn true;\n}\nif (!(o instanceof AddTrainPreMove)) {\nreturn false;\n}\nfinal AddTrainPreMove addTrainPreMove = (AddTrainPreMove) o;\nif (engineTypeId != addTrainPreMove.engineTypeId) {\nreturn false;\n}\nif (!point.equals(addTrainPreMove.point)) {\nreturn false;\n}\nif (!principal.equals(addTrainPreMove.principal)) {\nreturn false;\n}\nif (!schedule.equals(addTrainPreMove.schedule)) {\nreturn false;\n}\nif (!wagons.equals(addTrainPreMove.wagons)) {\nreturn false;\n}\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = engineTypeId;\nresult = 29 * result + point.hashCode();\nresult = 29 * result + principal.hashCode();\nresult = 29 * result + schedule.hashCode();\nreturn result;\n}\nprivate final ImPoint point;\nprivate final FreerailsPrincipal principal;\nprivate final ImmutableSchedule schedule;\npublic AddTrainPreMove(int e, ImInts wags, ImPoint p,\nFreerailsPrincipal fp, ImmutableSchedule s) {\nengineTypeId = e;\nwagons = wags;\npoint = p;\nprincipal = fp;\nschedule = s;\nif (null == wags) {\nthrow new NullPointerException();\n}\nif (null == p) {\nthrow new NullPointerException();\n}\nif (null == fp) {\nthrow new NullPointerException();\n}\nif (null == s) {\nthrow new NullPointerException();\n}\n}\nPathOnTiles initPositionStep1(ReadOnlyWorld w) {\nPositionOnTrack[] pp = FlatTrackExplorer.getPossiblePositions(w, point);\nFlatTrackExplorer fte = new FlatTrackExplorer(w, pp[0]);\nList<Step> steps = new ArrayList<Step>();\nint length = calTrainLength();\nint distanceTravelled = 0;\nPositionOnTrack p = new PositionOnTrack();\nwhile (distanceTravelled < length) {\nfte.nextEdge();\nfte.moveForward();\np.setValuesFromInt(fte.getPosition());\nStep v = p.cameFrom();\ndistanceTravelled += v.getLength();\nsteps.add(v);\n}\nreturn new PathOnTiles(point, steps);\n}\nprivate int calTrainLength() {\nTrainModel train = new TrainModel(engineTypeId, wagons, 0);\nint length = train.getLength();\nreturn length;\n}\nTrainMotion initPositionStep2(PathOnTiles path) {\n// TODO fix code.\nTrainMotion tm = new TrainMotion(path, path.steps(), calTrainLength(),\nConstAcc.STOPPED);\nreturn tm;\n}\n/**\n* Generates a move that does the following.\n* <ol>\n* <li>Adds the train</li>\n* <li>Adds a cargo bundle to represent the cargo the train is\n* carrying</li>\n* <li>Adds a schedule for the train</li>\n* <li>Adds transaction to pay for the train</li>\n* <li>Init. the trains position and motion</li>\n* </ol>\n*\n*\n*/\npublic Move generateMove(ReadOnlyWorld w) {\n// Add cargo bundle.\nint bundleId = w.size(principal, KEY.CARGO_BUNDLES);\nImmutableCargoBundle cargo = ImmutableCargoBundle.EMPTY_BUNDLE;\nAddItemToListMove addCargoBundle = new AddItemToListMove(\nKEY.CARGO_BUNDLES, bundleId, cargo, principal);\n// Add schedule\nfor (int i = 0; i < schedule.getNumOrders(); i++) {\nTrainOrdersModel order = schedule.getOrder(i);\nif (!w.boundsContain(principal, KEY.STATIONS, order.stationId)) {\nthrow new ArrayIndexOutOfBoundsException(String.format(\"%d\", order.stationId));\n}\n}\nint scheduleId = w.size(principal, KEY.TRAIN_SCHEDULES);\nAddItemToListMove addSchedule = new AddItemToListMove(\nKEY.TRAIN_SCHEDULES, scheduleId, schedule, principal);\n// Add train to train list.\nTrainModel train = new TrainModel(engineTypeId, wagons, scheduleId,\nbundleId);\nint trainId = w.size(principal, KEY.TRAINS);\nAddItemToListMove addTrain = new AddItemToListMove(KEY.TRAINS, trainId,\ntrain, principal);\n// Pay for train.\nint quantity = 1;\n/* Determine the price of the train. */\nEngineType engineType = (EngineType) w.get(SKEY.ENGINE_TYPES,\nengineTypeId);\nMoney price = engineType.getPrice();\nTransaction transaction = new AddItemTransaction(\nTransaction.Category.TRAIN, engineTypeId, quantity, new Money(\n-price.getAmount()));\nAddTransactionMove transactionMove = new AddTransactionMove(principal,\ntransaction);\n// Setup and add train position.\nPathOnTiles path = initPositionStep1(w);\nTrainMotion motion = initPositionStep2(path);\nMove addPosition = new AddActiveEntityMove(motion, trainId,\nprincipal);\nreturn new CompositeMove(addCargoBundle, addSchedule, addTrain,\ntransactionMove, addPosition);\n}\n}"}
{"className":"jfreerails.controller.OpenList","javaDoc":"/**\n* An OpenList for SimpleAStarPathFinder.\n*\n* @author Luke\n*\n*/","code":"/**\n* An OpenList for SimpleAStarPathFinder.\n*\n* @author Luke\n*\n*/\nclass OpenList implements Serializable {\nprivate static final long serialVersionUID = 3257282539419611442L;\nstatic class OpenListEntry implements Comparable<OpenListEntry>,\nSerializable {\nprivate static final long serialVersionUID = -4873508719707382681L;\nfinal int f;\nfinal int node;\nOpenListEntry(int _f, int _node) {\nthis.f = _f;\nthis.node = _node;\n}\npublic int compareTo(OpenListEntry o) {\n// XXX Work around for JDK Bug ID: 6207984\nif (f == o.f) {\nreturn node - o.node;\n}\nreturn f - o.f;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof OpenListEntry))\nreturn false;\nfinal OpenListEntry openListEntry = (OpenListEntry) o;\nif (f != openListEntry.f)\nreturn false;\nif (node != openListEntry.node)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = f;\nresult = 29 * result + node;\nreturn result;\n}\n@Override\npublic String toString() {\nreturn \"OpenListEntry{node=\" + node + \", f=\" + f + \"}\";\n}\n}\nprivate HashMap<Integer, OpenListEntry> map = new HashMap<Integer, OpenListEntry>();\nprivate PriorityQueue<OpenListEntry> queue = new PriorityQueue<OpenListEntry>();\npublic OpenList() {\n}\nvoid clear() {\nqueue.clear();\nmap.clear();\n}\nint getF(int node) {\nint f = map.get(node).f;\nreturn f;\n}\nvoid add(int node, int f) {\nif (map.containsKey(node)) {\nOpenListEntry old = map.get(node);\nqueue.remove(old);\nmap.remove(node);\n}\nOpenList.OpenListEntry entry = new OpenListEntry(f, node);\nqueue.offer(entry);\nmap.put(node, entry);\n}\nboolean contains(int node) {\nboolean containsKey = map.containsKey(node);\nreturn containsKey;\n}\nint smallestF() {\nOpenListEntry entry = queue.peek();\nreturn entry.f;\n}\nint popNodeWithSmallestF() {\nOpenListEntry entry = queue.remove();\nint node = entry.node;\nOpenListEntry removed = map.remove(node);\nif (null == removed) {\nSystem.out.println(\"Shizer, size =\" + queue.size());\n}\nreturn node;\n}\nint size() {\nreturn queue.size();\n}\n}"}
{"className":"jfreerails.controller.TrackPathFinder","javaDoc":"/**\n* Finds the best route to build track between two points.\n*\n* @author Luke\n*\n*/","code":"/**\n* Finds the best route to build track between two points.\n*\n* @author Luke\n*\n*/\npublic class TrackPathFinder implements IncrementalPathFinder {\nprivate static final Logger logger = Logger.getLogger(TrackPathFinder.class\n.getName());\nprivate SimpleAStarPathFinder pathFinder = new SimpleAStarPathFinder();\nprivate final ReadOnlyWorld world;\nprivate ImPoint startPoint;\nprivate final FreerailsPrincipal principal;\npublic TrackPathFinder(ReadOnlyWorld world, FreerailsPrincipal principal) {\nthis.world = world;\nthis.principal = principal;\n}\npublic void abandonSearch() {\npathFinder.abandonSearch();\n}\nprivate List<ImPoint> convertPath2Points(IntArray path) {\nPositionOnTrack progress = new PositionOnTrack();\nList<ImPoint> proposedTrack = new ArrayList<ImPoint>();\nImPoint p;\nfor (int i = 0; i < path.size(); i++) {\nprogress.setValuesFromInt(path.get(i));\np = new ImPoint(progress.getX(), progress.getY());\nproposedTrack.add(p);\nlogger.fine(\"Adding point \" + p);\n}\nreturn proposedTrack;\n}\nprivate int[] findTargets(ImPoint targetPoint) {\nFreerailsTile tile = (FreerailsTile) world.getTile(targetPoint.x,\ntargetPoint.y);\nTrackPiece trackPiece = tile.getTrackPiece();\nint ruleNumber = trackPiece.getTrackTypeID();\nint[] targetInts;\nif (tile.hasTrack()) {\n/*\n* If there is already track here, we need to check what directions\n* we can build in without creating an illegal track config.\n*/\nTrackRule trackRule = (TrackRule) world.get(SKEY.TRACK_RULES,\nruleNumber);\n/* Count number of possible directions. */\nArrayList<Step> possibleDirections = new ArrayList<Step>();\nfor (int i = 0; i < 8; i++) {\nStep direction = Step.getInstance(i);\nTrackConfiguration config = trackPiece.getTrackConfiguration();\nTrackConfiguration testConfig = TrackConfiguration.add(config,\ndirection);\nif (trackRule.trackPieceIsLegal(testConfig)) {\npossibleDirections.add(direction);\n}\n}\n/* Put them into an array. */\ntargetInts = new int[possibleDirections.size()];\nfor (int i = 0; i < targetInts.length; i++) {\nStep direction = possibleDirections.get(i);\nPositionOnTrack targetPot = PositionOnTrack.createFacing(\ntargetPoint.x, targetPoint.y, direction);\ntargetInts[i] = targetPot.toInt();\n}\n} else {\n/* If there is no track here, we can go in any direction. */\ntargetInts = new int[8];\nfor (int i = 0; i < 8; i++) {\nPositionOnTrack targetPot = PositionOnTrack.createComingFrom(\ntargetPoint.x, targetPoint.y, Step.getInstance(i));\ntargetInts[i] = targetPot.toInt();\n}\n}\nreturn targetInts;\n}\npublic List generatePath(ImPoint start, ImPoint targetPoint,\nBuildTrackStrategy bts) throws PathNotFoundException {\nsetupSearch(start, targetPoint, bts);\npathFinder.search(-1);\nIntArray path = pathFinder.retrievePath();\nList proposedTrack = convertPath2Points(path);\nreturn proposedTrack;\n}\npublic int getStatus() {\nreturn pathFinder.getStatus();\n}\npublic List<ImPoint> pathAsPoints() {\nIntArray path = pathFinder.retrievePath();\nreturn convertPath2Points(path);\n}\npublic Step[] pathAsVectors() {\nIntArray path = pathFinder.retrievePath();\nint size = path.size();\nStep[] vectors = new Step[size];\nPositionOnTrack progress = new PositionOnTrack();\nint x = startPoint.x;\nint y = startPoint.y;\nfor (int i = 0; i < size; i++) {\nprogress.setValuesFromInt(path.get(i));\nint x2 = progress.getX();\nint y2 = progress.getY();\nvectors[i] = Step.getInstance(x2 - x, y2 - y);\nx = x2;\ny = y2;\n}\nreturn vectors;\n}\npublic void search(long maxDuration) throws PathNotFoundException {\npathFinder.search(maxDuration);\n}\npublic void setupSearch(ImPoint startPoint, ImPoint targetPoint,\nBuildTrackStrategy bts) throws PathNotFoundException {\nlogger\n.fine(\"Find track path from \" + startPoint + \" to \"\n+ targetPoint);\nthis.startPoint = startPoint;\nint[] targetInts = findTargets(targetPoint);\nint[] startInts = findTargets(startPoint);\nBuildTrackExplorer explorer = new BuildTrackExplorer(world,\nprincipal, startPoint, targetPoint);\nexplorer.setBuildTrackStrategy(bts);\npathFinder.setupSearch(startInts, targetInts, explorer);\n}\n}"}
{"className":"jfreerails.controller.VerifyStationName","javaDoc":"/**\n* Class to verify that the chosen name for a station hasn't already been taken\n* by another station. If the name has been used, a minor alteration in the name\n* is required, by adding perhaps \"Junction\" or \"Siding\" to the name.\n*\n* @author Scott Bennett\n*\n* Date: 12th April 2003\n*\n*/","code":"/**\n* Class to verify that the chosen name for a station hasn't already been taken\n* by another station. If the name has been used, a minor alteration in the name\n* is required, by adding perhaps \"Junction\" or \"Siding\" to the name.\n*\n* @author Scott Bennett\n*\n* Date: 12th April 2003\n*\n*/\npublic class VerifyStationName {\nprivate final ReadOnlyWorld w;\nprivate final String nameToVerify;\nprivate final Vector<String> stationAlternatives;\npublic VerifyStationName(ReadOnlyWorld world, String name) {\nthis.w = world;\nthis.nameToVerify = name;\nthis.stationAlternatives = new Vector<String>();\nstationAlternatives.addElement(\"Junction\");\nstationAlternatives.addElement(\"Siding\");\nstationAlternatives.addElement(\"North\");\nstationAlternatives.addElement(\"East\");\nstationAlternatives.addElement(\"South\");\nstationAlternatives.addElement(\"West\");\n}\npublic String getName() {\nString appropriateName = nameToVerify;\nboolean found = false;\nString tempName = null;\n// if (w.size(KEY.STATIONS) <= 0) {\n// //if there are no stations, then obviously the name isn't taken\n// return appropriateName;\n// }\nfound = checkStationExists(appropriateName);\nif (!found) {\nreturn appropriateName;\n}\n// a station with that name already exists, so we need to find another\n// name\nfor (int i = 0; i < stationAlternatives.size(); i++) {\ntempName = appropriateName + \" \" + stationAlternatives.elementAt(i);\nfound = checkStationExists(tempName);\nif (!found) {\nreturn tempName;\n}\n}\nint j = 7; // for number of names that have already been used\nwhile (found) {\nj++;\ntempName = appropriateName + \"Station #\" + j;\nfound = checkStationExists(tempName);\n}\nreturn tempName;\n}\nprivate boolean checkStationExists(String name) {\nString testName = name;\nStationModel tempStation;\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nFreerailsPrincipal principal = w.getPlayer(i).getPrincipal();\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w, principal);\nwhile (wi.next()) { // loop over non null stations\ntempStation = (StationModel) wi.getElement();\nif ((testName).equals(tempStation.getStationName())) {\n// station already exists with that name\nreturn true;\n}\n}\n}\n// no stations exist with that name\nreturn false;\n}\n}"}
{"className":"jfreerails.controller.PathNotFoundException","javaDoc":"/**\n* Thrown when a path cannot be found.\n*\n* @author Luke\n*\n*/","code":"/**\n* Thrown when a path cannot be found.\n*\n* @author Luke\n*\n*/\npublic class PathNotFoundException extends Exception {\nprivate static final long serialVersionUID = 4121409601112717368L;\npublic PathNotFoundException(String arg0) {\nsuper(arg0);\n}\n}"}
{"className":"jfreerails.controller.Message2Server","javaDoc":"/**\n* Defines a command sent from a client to the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a command sent from a client to the server.\n*\n* @author Luke\n*\n*/\npublic interface Message2Server extends FreerailsSerializable {\nint getID();\nMessageStatus execute(ServerControlInterface server);\n}"}
{"className":"jfreerails.controller.StationBuilder","javaDoc":"/**\n* Class to build a station at a given point, names station after nearest city.\n* If that name is taken then a \"Junction\" or \"Siding\" is added to the name.\n*\n* @author Luke Lindsay 08-Nov-2002\n*\n* Updated 12th April 2003 by Scott Bennett to include nearest city names.\n*\n*/","code":"/**\n* Class to build a station at a given point, names station after nearest city.\n* If that name is taken then a \"Junction\" or \"Siding\" is added to the name.\n*\n* @author Luke Lindsay 08-Nov-2002\n*\n* Updated 12th April 2003 by Scott Bennett to include nearest city names.\n*\n*/\npublic class StationBuilder {\nprivate static final Logger logger = Logger.getLogger(StationBuilder.class\n.getName());\nprivate int ruleNumber;\nprivate final MoveExecutor executor;\npublic StationBuilder(MoveExecutor executor) {\nthis.executor = executor;\nTrackRule trackRule;\nint i = -1;\nReadOnlyWorld world = executor.getWorld();\ndo {\ni++;\ntrackRule = (TrackRule) world.get(SKEY.TRACK_RULES, i);\n} while (!trackRule.isStation());\nruleNumber = i;\n}\npublic MoveStatus tryBuildingStation(ImPoint p) {\nReadOnlyWorld world = executor.getWorld();\nFreerailsPrincipal principal = executor.getPrincipal();\nAddStationPreMove preMove = AddStationPreMove.newStation(p,\nthis.ruleNumber, principal);\nMove m = preMove.generateMove(world);\nMoveStatus ms = executor.tryDoMove(m);\nreturn ms;\n}\npublic MoveStatus buildStation(ImPoint p) {\n// Only build a station if there is track at the specified point.\nMoveStatus status = tryBuildingStation(p);\nif (status.ok) {\nFreerailsPrincipal principal = executor.getPrincipal();\nAddStationPreMove preMove = AddStationPreMove.newStation(p,\nthis.ruleNumber, principal);\nreturn executor.doPreMove(preMove);\n}\nlogger.fine(status.message);\nreturn status;\n}\npublic void setStationType(int ruleNumber) {\nthis.ruleNumber = ruleNumber;\n}\npublic int getTrackTypeID(String string) {\nReadOnlyWorld w = executor.getWorld();\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nTrackRule r = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nif (string.equals(r.getTypeName())) {\nreturn i;\n}\n}\nthrow new NoSuchElementException();\n}\n}"}
{"className":"jfreerails.controller.NetWorthCalculator","javaDoc":"/**\n* A TransactionAggregator that calculates the networth of a player by\n* totalling the value of their assets.\n*\n* @author Luke\n*\n*/","code":"/**\n* A TransactionAggregator that calculates the networth of a player by\n* totalling the value of their assets.\n*\n* @author Luke\n*\n*/\npublic class NetWorthCalculator extends TransactionAggregator {\npublic NetWorthCalculator(ReadOnlyWorld w, FreerailsPrincipal principal) {\nsuper(w, principal);\n}\n@Override\nprotected boolean condition(int transactionID) {\nTransaction t = super.w.getTransaction(super.principal,\ntransactionID);\nif (t instanceof AddItemTransaction) {\nif(t.getCategory().equals(Transaction.Category.ISSUE_STOCK)){\nreturn true;\n}\n// Since buying something is just converting one asset type to\n// another.\nreturn false;\n}\nreturn true;\n}\n}"}
{"className":"jfreerails.controller.FlatTrackExplorer","javaDoc":"/**\n* GraphExplorer that explorers track, the ints it returns are encoded\n* PositionOnTrack objects.\n*\n* @author Luke\n*/","code":"/**\n* GraphExplorer that explorers track, the ints it returns are encoded\n* PositionOnTrack objects.\n*\n* @author Luke\n*/\npublic class FlatTrackExplorer implements GraphExplorer, Serializable {\nprivate static final long serialVersionUID = 3834311713465185081L;\nprivate PositionOnTrack currentPosition = PositionOnTrack.createComingFrom(\n0, 0, Step.NORTH);\nfinal PositionOnTrack currentBranch = PositionOnTrack.createComingFrom(0,\n0, Step.NORTH);\nprivate boolean beforeFirst = true;\nprivate final ReadOnlyWorld w;\npublic ReadOnlyWorld getWorld() {\nreturn w;\n}\npublic void setPosition(int i) {\nbeforeFirst = true;\ncurrentPosition.setValuesFromInt(i);\n}\npublic int getPosition() {\nreturn this.currentPosition.toInt();\n}\npublic void moveForward() {\nif (beforeFirst) {\nthrow new IllegalStateException();\n}\nthis.setPosition(this.getVertexConnectedByEdge());\n}\npublic void nextEdge() {\nif (!hasNextEdge()) {\nthrow new NoSuchElementException();\n}\nStep v = this.getFirstVectorToTry();\nPoint p = new Point(currentPosition.getX(), currentPosition.getY());\nFreerailsTile ft = (FreerailsTile)w.getTile(p.x, p.y);\nTrackPiece tp = ft.getTrackPiece();\nTrackConfiguration conf = tp.getTrackConfiguration();\nStep[] vectors = Step.getList();\nint i = v.getID();\nint loopCounter = 0;\nwhile (!conf.contains(vectors[i].get9bitTemplate())) {\ni++;\ni = i % 8;\nloopCounter++;\nif (8 < loopCounter) {\nthrow new IllegalStateException();\n// This should never happen.. ..but it does happen when you\n// removed the track from under a train.\n}\n}\nStep branchDirection = Step.getInstance(i);\nthis.currentBranch.setCameFrom(branchDirection);\nint x = this.currentPosition.getX() + branchDirection.deltaX;\nint y = this.currentPosition.getY() + branchDirection.deltaY;\nthis.currentBranch.setX(x);\nthis.currentBranch.setY(y);\nbeforeFirst = false;\n}\npublic int getVertexConnectedByEdge() {\nreturn currentBranch.toInt();\n}\npublic int getEdgeCost() {\nreturn (int) Math.round(currentBranch.cameFrom().getLength());\n}\npublic boolean hasNextEdge() {\nif (beforeFirst) {\n// We can always go back the way we have come, so if we are before\n// the first\n// branch, there must be a branch: the one we used to get here.\nreturn true;\n}\n// Since we can always go back the way we have come, if the direction of\n// current branch is not equal to the opposite of the current direction,\n// there must be another branch.\nStep currentBranchDirection = this.currentBranch.cameFrom();\nStep oppositeToCurrentDirection = this.currentPosition.cameFrom()\n.getOpposite();\nif (oppositeToCurrentDirection.getID() == currentBranchDirection\n.getID()) {\nreturn false;\n}\nreturn true;\n}\npublic FlatTrackExplorer(ReadOnlyWorld world, PositionOnTrack p) {\nw = world;\nFreerailsTile tile = (FreerailsTile) world.getTile(p.getX(), p.getY());\nif (tile.getTrackPiece().getTrackTypeID() == NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\nthrow new IllegalArgumentException(p.toString());\n}\nthis.currentPosition = PositionOnTrack.createComingFrom(p.getX(), p\n.getY(), p.cameFrom());\n}\n/**\n* @return an array of PositionOnTrack objects describing the set of\n* possible orientations at this position (heading towards the\n* center of the tile)\n* @param p\n* location of track to consider.\n*/\npublic static PositionOnTrack[] getPossiblePositions(ReadOnlyWorld w,\nImPoint p) {\nTrackPiece tp = ((FreerailsTile) w.getTile(p.x, p.y)).getTrackPiece();\nTrackConfiguration conf = tp.getTrackConfiguration();\nStep[] vectors = Step.getList();\n// Count the number of possible positions.\nint n = 0;\nfor (int i = 0; i < vectors.length; i++) {\nif (conf.contains(vectors[i].get9bitTemplate())) {\nn++;\n}\n}\nPositionOnTrack[] possiblePositions = new PositionOnTrack[n];\nn = 0;\nfor (int i = 0; i < vectors.length; i++) {\nif (conf.contains(vectors[i].get9bitTemplate())) {\npossiblePositions[n] = PositionOnTrack.createComingFrom(p.x,\np.y, vectors[i].getOpposite());\nn++;\n}\n}\nreturn possiblePositions;\n}\nStep getFirstVectorToTry() {\nif (beforeFirst) {\n// Return the vector that is 45 degrees clockwise from the opposite\n// of the current position.\nStep v = this.currentPosition.cameFrom();\nv = v.getOpposite();\nint i = v.getID();\ni++;\ni = i % 8;\nv = Step.getInstance(i);\nreturn v;\n}\n// Return the vector that is 45 degrees clockwise from the direction\n// of the current branch.\nStep v = this.currentBranch.cameFrom();\nint i = v.getID();\ni++;\ni = i % 8;\nv = Step.getInstance(i);\nreturn v;\n}\npublic int getH() {\n// TODO Auto-generated method stub\nreturn 0;\n}\n}"}
{"className":"jfreerails.controller.ReportBugTextGenerator","javaDoc":null,"code":"public class ReportBugTextGenerator {\nprivate static final String TRACKER_URL = \"http://sourceforge.net/tracker/?group_id=9495&atid=109495\";\npublic static void main(String[] args) {\nException e = genException();\nSystem.out.println(genText());\nSystem.out.println(genText(e));\n}\nprivate static Exception genException() {\nException e = new Exception();\nreturn e;\n}\npublic static String genText() {\nStringBuffer sb = new StringBuffer();\nsb.append(\"How to report a bug\\n\");\nsb.append(\"\\n\");\nsb.append(\"Use the sourceforge.net bug tracker at the following url:\\n\");\nsb.append(TRACKER_URL);\nsb.append(\"\\n\");\nsb.append(\"\\n\");\nsb.append(\"Please include:\\n\");\nsb.append(\" 1. Steps to reproduce the bug (attach a save game if appropriate).\\n\");\nsb.append(\" 2. What you expected to see.\\n\");\nsb.append(\" 3. What you saw instead (attach a screenshot if appropriate).\\n\");\nsb.append(\" 4. The details below (copy and past them into the bug report).\\n\");\nappendBuildProps(sb);\nsb.append(\"\\n\");\nsb.append(\"\\n\");\nreturn sb.toString();\n}\npublic static String genText(Exception e) {\nStackTraceElement[] s = e.getStackTrace();\nStringBuffer sb = new StringBuffer();\nsb.append(\"Unexpected Exception\\n\");\nsb.append(\"\\n\");\nsb.append(\"Consider submitting a bug report using the sourceforge.net\" +\n\" bug tracker at the following url:\\n\");\nsb.append(TRACKER_URL);\nsb.append(\"\\n\");\nsb.append(\"\\n\");\nsb.append(\"Please:\\n\");\nsb.append(\" 1. Use the following as the title of the bug report:\\n\\t\");\nsb.append(\" Unexpected Exception: \");\nsb.append(s[0].getFileName());\nsb.append(\" line \");\nsb.append(s[0].getLineNumber());\nsb.append(\"\\n\");\nsb.append(\" 2. Include steps to reproduce the bug (attach a save game if appropriate).\\n\");\nsb.append(\" 3. Copy and paste the details below into the bug report:\\n\");\nappendBuildProps(sb);\nsb.append(\"\\n\");\nsb.append(\"\\n\\t\");\nsb.append(e.toString());\nfor (StackTraceElement ste : s) {\nsb.append(\"\\n\\t\\t at \");\nsb.append(ste);\n}\nreturn sb.toString();\n}\nprivate static void appendBuildProps(StringBuffer sb) {\nString version = null;\nString builtBy = null;;\ntry {\nProperties props = new Properties();\nInputStream in = ReportBugTextGenerator.class\n.getResourceAsStream(\"/build.properties\");\nprops.load(in);\nin.close();\nversion = props.getProperty(\"freerails.build\");\nbuiltBy = props.getProperty(\"freerails.built.by\");\n} catch (Exception e) {\n// ignore, there's nothing useful we can do.\n}\nversion = null == version ? \"not set\" : version;\nbuiltBy = null == builtBy ? \"not set\" : builtBy;\nsb.append(\"\\t\");\nsb.append(System.getProperty(\"os.name\"));\nsb.append(\" \");\nsb.append(System.getProperty(\"os.version\"));\nsb.append(\"\\n\\t\");\nsb.append(System.getProperty(\"java.vm.name\"));\nsb.append(\" \");\nsb.append(System.getProperty(\"java.version\"));\nsb.append(\"\\n\\t\");\nsb.append(\"Freerails build \");\nsb.append(version);\nsb.append(\" compiled by \");\nsb.append(builtBy);\n}\n@SuppressWarnings(\"deprecation\")\npublic static void unexpectedException(Exception e) {\nScreenHandler.exitFullScreenMode();\nString str = genText(e);\nSystem.err.print(str);\nUnexpectedExceptionForm unexpectedExceptionForm = new UnexpectedExceptionForm();\nunexpectedExceptionForm.setText(str);\nunexpectedExceptionForm.setVisible(true);\nif(!EventQueue.isDispatchThread()){\nThread.currentThread().stop();\n}\n}\n}"}
{"className":"jfreerails.controller.SharePriceCalculator","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class SharePriceCalculator {\npublic int totalShares;\npublic int treasuryStock;\npublic int otherRRStakes;\npublic long profitsLastYear;\npublic long networth;\npublic long stockholderEquity;\npublic long calculatePrice() {\nassert totalShares > 0;\nassert totalShares >= treasuryStock + otherRRStakes;\nassert stockholderEquity > 0;\nlong price;\nlong currentValue = networth + stockholderEquity;\nlong expectedIncrease = profitsLastYear * 5;\nint publicOwnedShares = totalShares - treasuryStock - otherRRStakes;\nprice = 2 * (currentValue + expectedIncrease)\n/ (2 * publicOwnedShares + otherRRStakes);\nreturn price;\n}\n}"}
{"className":"jfreerails.controller.CopyableTextJPanel","javaDoc":"/**\n* Displays text that can be selected with the mouse and copied to the clipboard.\n*\n* @author Luke\n*/","code":"/**\n* Displays text that can be selected with the mouse and copied to the clipboard.\n*\n* @author Luke\n*/\npublic class CopyableTextJPanel extends javax.swing.JPanel {\nprivate static final long serialVersionUID = 4076159955353400345L;\n/** Creates new form CopyableTextJPanel */\npublic CopyableTextJPanel() {\ninitComponents();\n}\npublic void setText(String s){\nthis.jTextArea1.setText(s);\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\njPopupMenu1 = new javax.swing.JPopupMenu();\ncopyItem = new javax.swing.JMenuItem();\nselectAllItem = new javax.swing.JMenuItem();\njScrollPane1 = new javax.swing.JScrollPane();\njTextArea1 = new javax.swing.JTextArea();\ncopyItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));\ncopyItem.setText(\"Copy\");\ncopyItem.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ncopyItemActionPerformed(evt);\n}\n});\njPopupMenu1.add(copyItem);\nselectAllItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.CTRL_MASK));\nselectAllItem.setText(\"Select All\");\nselectAllItem.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectAllItemActionPerformed(evt);\n}\n});\njPopupMenu1.add(selectAllItem);\nsetLayout(new java.awt.GridBagLayout());\nsetPreferredSize(new java.awt.Dimension(500, 300));\njTextArea1.setEditable(false);\njTextArea1.setText(\"dsfasd\\n\\nsad\\nf\\nasd\\nfa\\nsdf\\nas\\ndf\\nas\\ndf\\nads\\nf\\nasd\\nf\\nads\\nf\\ndsa\\nf\\ndsa\\nf\\ndasf\\na\\ndsf\\nads\\nf\\nasd\\nf\\nasd\\nf\\n\\nasdf\");\njTextArea1.setWrapStyleWord(true);\njTextArea1.setOpaque(false);\njTextArea1.addMouseListener(new java.awt.event.MouseAdapter() {\n@Override\npublic void mouseClicked(java.awt.event.MouseEvent evt) {\njTextArea1MouseClicked(evt);\n}\n});\njScrollPane1.setViewportView(jTextArea1);\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 0;\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\nadd(jScrollPane1, gridBagConstraints);\n}\n// </editor-fold>//GEN-END:initComponents\nprivate void selectAllItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectAllItemActionPerformed\njTextArea1.selectAll();\n}//GEN-LAST:event_selectAllItemActionPerformed\nprivate void copyItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_copyItemActionPerformed\njTextArea1.copy();\n}//GEN-LAST:event_copyItemActionPerformed\nprivate void jTextArea1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTextArea1MouseClicked\nif(SwingUtilities.isRightMouseButton(evt)){\njPopupMenu1.show(jTextArea1, evt.getX(), evt.getY());\n}\n}//GEN-LAST:event_jTextArea1MouseClicked\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JMenuItem copyItem;\njavax.swing.JPopupMenu jPopupMenu1;\njavax.swing.JScrollPane jScrollPane1;\njavax.swing.JTextArea jTextArea1;\njavax.swing.JMenuItem selectAllItem;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.controller.PathOnTrackFinder","javaDoc":"/**\n* Finds a path along existing track. Used for upgrading or removing track\n* between two points on the track.\n*\n* @author Luke\n*\n*/","code":"/**\n* Finds a path along existing track. Used for upgrading or removing track\n* between two points on the track.\n*\n* @author Luke\n*\n*/\npublic class PathOnTrackFinder implements IncrementalPathFinder {\nprivate static final Logger logger = Logger\n.getLogger(IncrementalPathFinder.class.getName());\nprivate SimpleAStarPathFinder pathFinder = new SimpleAStarPathFinder();\nprivate ImPoint startPoint;\nprivate final ReadOnlyWorld world;\npublic PathOnTrackFinder(ReadOnlyWorld world) {\nthis.world = world;\n}\npublic void abandonSearch() {\npathFinder.abandonSearch();\n}\npublic int getStatus() {\nreturn pathFinder.getStatus();\n}\npublic Step[] pathAsVectors() {\nint[] pathAsInts = pathFinder.retrievePath().toArray();\nStep[] vectors = new Step[pathAsInts.length];\nint x = startPoint.x;\nint y = startPoint.y;\nfor (int i = 0; i < pathAsInts.length; i++) {\nPositionOnTrack p2 = new PositionOnTrack(pathAsInts[i]);\nvectors[i] = Step.getInstance(p2.getX() - x, p2.getY() - y);\nx = p2.getX();\ny = p2.getY();\n}\nreturn vectors;\n}\npublic void search(long maxDuration) throws PathNotFoundException {\npathFinder.search(maxDuration);\n}\npublic void setupSearch(ImPoint from, ImPoint target) throws PathNotFoundException {\nstartPoint = from;\nlogger\n.fine(\"Find track path from \" + from + \" to \"\n+ target);\n/* Check there is track at both the points. */\nFreerailsTile tileA = (FreerailsTile) world.getTile(from.x,\nfrom.y);\nFreerailsTile tileB = (FreerailsTile) world.getTile(target.x,\ntarget.y);\nif (!tileA.hasTrack()) {\nthrow new PathNotFoundException(\"No track at \" + from.x\n+ \", \" + from.y + \".\");\n}\nif (!tileB.hasTrack()) {\nthrow new PathNotFoundException(\"No track at \" + target.x\n+ \", \" + target.y + \".\");\n}\nPositionOnTrack[] startPoints = FlatTrackExplorer.getPossiblePositions(\nworld, from);\nPositionOnTrack[] targetPoints = FlatTrackExplorer\n.getPossiblePositions(world, target);\nFlatTrackExplorer explorer = new FlatTrackExplorer(world,\nstartPoints[0]);\npathFinder.setupSearch(PositionOnTrack.toInts(startPoints),\nPositionOnTrack.toInts(targetPoints), explorer);\n}\n}"}
{"className":"jfreerails.controller.CalcNearestCity","javaDoc":"/**\n*\n*\n* Class to find the nearest city and return that name, so that a station can be\n* named appropriately. Date: 12th April 2003\n*\n* @author Scott Bennett\n*/","code":"/**\n*\n*\n* Class to find the nearest city and return that name, so that a station can be\n* named appropriately. Date: 12th April 2003\n*\n* @author Scott Bennett\n*/\npublic class CalcNearestCity {\nprivate final int x;\nprivate final int y;\nprivate final ReadOnlyWorld w;\npublic CalcNearestCity(ReadOnlyWorld world, int x, int y) {\nthis.w = world;\nthis.x = x;\nthis.y = y;\n}\npublic String findNearestCity() {\ndouble cityDistance;\nString cityName = null;\ndouble tempDistance;\nCityModel tempCity;\nif (w.size(SKEY.CITIES) > 0) {\ntempCity = (CityModel) w.get(SKEY.CITIES, 0);\ncityDistance = getDistance(tempCity.getCityX(), tempCity.getCityY());\ncityName = tempCity.getCityName();\nfor (int i = 1; i < w.size(SKEY.CITIES); i++) {\ntempCity = (CityModel) w.get(SKEY.CITIES, i);\ntempDistance = getDistance(tempCity.getCityX(), tempCity\n.getCityY());\nif (tempDistance < cityDistance) {\ncityDistance = tempDistance;\ncityName = tempCity.getCityName();\n}\n}\nreturn cityName;\n}\nthrow new NoSuchElementException();\n}\nprivate double getDistance(int cityX, int cityY) {\ndouble distance = 0;\ndouble a = (this.x - cityX) * (this.x - cityX);\ndouble b = (this.y - cityY) * (this.y - cityY);\ndistance = Math.sqrt(a + b);\nreturn distance;\n}\n}"}
{"className":"jfreerails.controller.BalanceSheetGenerator","javaDoc":"/**\n* Generates the balance sheet - note, its fields are read using reflection so\n* don't change their names.\n*\n* @author Luke\n*\n*/","code":"/**\n* Generates the balance sheet - note, its fields are read using reflection so\n* don't change their names.\n*\n* @author Luke\n*\n*/\npublic class BalanceSheetGenerator {\nGameTime from;\nGameTime to;\nfinal ReadOnlyWorld w;\nfinal FreerailsPrincipal principal;\nprivate GameCalendar cal;\npublic String year;\npublic Stats total;\npublic Stats ytd;\npublic BalanceSheetGenerator(ReadOnlyWorld w, FreerailsPrincipal principal) {\nthis.w = w;\nthis.principal = principal;\ncal = (GameCalendar) w.get(ITEM.CALENDAR);\n// Calculate totals\nGameTime time = w.currentTime();\nfinal int startyear = cal.getYear(time.getTicks());\nyear = String.valueOf(startyear);\nGameTime startOfYear = new GameTime(cal.getTicks(startyear));\nGameTime[] totalTimeInterval = new GameTime[] { GameTime.BIG_BANG,\nGameTime.END_OF_THE_WORLD };\ntotal = new Stats(w, principal, totalTimeInterval);\nGameTime[] ytdTimeInterval = new GameTime[] { startOfYear,\nGameTime.END_OF_THE_WORLD };\nytd = new Stats(w, principal, ytdTimeInterval);\n}\npublic static Money calTrackTotal(Transaction.Category category,\nReadOnlyWorld w, FreerailsPrincipal principal, GameTime startTime) {\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nw, principal);\naggregator.setCategory(TRACK);\nlong amount = 0;\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nlong trackValue = trackRule.getPrice().getAmount();\nGameTime[] times = new GameTime[] { startTime,\nGameTime.END_OF_THE_WORLD };\naggregator.setType(i);\naggregator.setTimes(times);\nItemsTransactionAggregator.QuantitiesAndValues qnv = aggregator\n.calculateQuantitiesAndValues();\nint quantity = qnv.quantities[0];\namount += trackValue * quantity\n/ TrackConfiguration.LENGTH_OF_STRAIGHT_TRACK_PIECE;\n}\nreturn new Money(amount);\n}\npublic static class Stats {\npublic Stats(ReadOnlyWorld w, FreerailsPrincipal principal, final GameTime[] totalTimeInterval){\nTransactionAggregator operatingFundsAggregator = new TransactionAggregator(w,\nprincipal) {\n@Override\nprotected boolean condition(int i) {\nint transactionTicks = w.getTransactionTimeStamp(\nprincipal, i).getTicks();\nint from = totalTimeInterval[0].getTicks();\nint to = totalTimeInterval[1].getTicks();\nreturn transactionTicks >= from && transactionTicks <=to;\n}\n};\noperatingFunds= operatingFundsAggregator.calculateValue();\ntrack = calTrackTotal(TRACK, w, principal, totalTimeInterval[0]);\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nw, principal);\naggregator.setTimes(totalTimeInterval);\naggregator.setCategory(STATIONS);\nstations = aggregator.calculateValue();\naggregator.setCategory(TRAIN);\nrollingStock = aggregator.calculateValue();\naggregator.setCategory(INDUSTRIES);\nindustries = aggregator.calculateValue();\naggregator.setCategory(BOND);\nloans = aggregator.calculateValue();\naggregator.setCategory(ISSUE_STOCK);\nequity= aggregator.calculateValue();\n//If we don't initialize this variable\n//we get a NPE when we don't own any stock in others RRs\notherRrStock = new Money(0);\nint thisPlayerId = w.getID(principal);\nStockPrice[] stockPrices = (new StockPriceCalculator(w)).calculate();\nfor (int playerId = 0; playerId < w.getNumberOfPlayers(); playerId++) {\naggregator.setCategory(TRANSFER_STOCK);\naggregator.setType(thisPlayerId);\nint quantity = aggregator.calculateQuantity();\nif (playerId == thisPlayerId) {\ntreasuryStock = new Money(quantity\n* stockPrices[playerId].currentPrice.getAmount());\n} else {\notherRrStock = new Money(quantity\n* stockPrices[playerId].currentPrice.getAmount()\n+ otherRrStock.getAmount());\n}\n}\ncalProfit();\n}\npublic Money operatingFunds;\npublic Money track;\npublic Money stations;\npublic Money rollingStock;\npublic Money industries;\npublic Money loans;\npublic Money equity;\npublic Money treasuryStock;\npublic Money otherRrStock;\npublic Money profit;\nprivate void calProfit(){\nlong profitValue = operatingFunds.getAmount() + track.getAmount()\n+ stations.getAmount() + rollingStock.getAmount()\n+ industries.getAmount() + loans.getAmount()\n+ equity.getAmount() + treasuryStock.getAmount()\n+ otherRrStock.getAmount();\nprofit= new Money(profitValue);\n}\n}\n}"}
{"className":"jfreerails.controller.ToAndFroPathIterator","javaDoc":"/**\n* Returns a path that goes forwards and backwards along the path passed to its\n* constructor.\n*\n* @author Luke Lindsay 30-Oct-2002\n*\n*/","code":"/**\n* Returns a path that goes forwards and backwards along the path passed to its\n* constructor.\n*\n* @author Luke Lindsay 30-Oct-2002\n*\n*/\npublic class ToAndFroPathIterator implements FreerailsPathIterator {\nprivate static final long serialVersionUID = 3256442525337202993L;\nprivate FreerailsPathIterator path;\nprivate boolean forwards = true;\nprivate final List<Point> list;\npublic ToAndFroPathIterator(List<Point> l) {\nlist = l;\nnextIterator();\n}\nprivate void nextIterator() {\npath = new FreerailsPathIteratorImpl(list, forwards);\n}\npublic boolean hasNext() {\nif (list.size() < 2) {\nreturn false;\n}\nreturn true;\n}\npublic void nextSegment(IntLine line) {\nif (this.hasNext()) {\nif (!path.hasNext()) {\nforwards = !forwards;\npath = new FreerailsPathIteratorImpl(list, forwards);\n}\npath.nextSegment(line);\n} else {\nthrow new NoSuchElementException();\n}\n}\n}"}
{"className":"jfreerails.controller.TrainStopsHandler","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class TrainStopsHandler implements Serializable {\nprivate static final Logger logger = Logger.getLogger(TrainStopsHandler.class.getName());\nprivate static final int NOT_AT_STATION = -1;\nprivate static final long serialVersionUID = 3257567287094882872L;\n/** If wagons are added to a train, we need to increase its length.*/\nstatic PathOnTiles lengthenPath(ReadOnlyWorld w, PathOnTiles path, int currentTrainLength) {\ndouble pathDistance = path.getTotalDistance();\ndouble extraDistanceNeeded = currentTrainLength - pathDistance;\nList<Step> steps = new ArrayList<Step>();\nImPoint start = path.getStart();\nStep firstStep = path.getStep(0);\nPositionOnTrack nextPot = PositionOnTrack.createComingFrom(start.x, start.y, firstStep);\nwhile( extraDistanceNeeded > 0){\nFlatTrackExplorer fte = new FlatTrackExplorer(w, nextPot);\nfte.nextEdge();\nnextPot.setValuesFromInt(fte.getVertexConnectedByEdge());\nStep cameFrom = nextPot.facing();\nsteps.add(0, cameFrom);\nextraDistanceNeeded -= cameFrom.getLength();\n}\n//Add existing steps\nfor (int i = 0; i < path.steps(); i++) {\nStep step = path.getStep(i);\nsteps.add(step);\n}\nImPoint newStart = new ImPoint(nextPot.getX(), nextPot.getY());\npath = new PathOnTiles(newStart, steps);\nreturn path;\n}\nprivate final FreerailsPrincipal principal;\nprivate GameTime timeLoadingFinished = new GameTime(0);\nprivate final int trainId;\nprivate final WorldDiffs worldDiffs;\npublic TrainStopsHandler(int id, FreerailsPrincipal p, WorldDiffs w) {\ntrainId = id;\nprincipal = p;\nworldDiffs = w;\n}\npublic ImPoint arrivesAtPoint(int x, int y) {\nTrainAccessor ta = new TrainAccessor(worldDiffs, principal, trainId);\nImPoint targetPoint = ta.getTarget();\nif (x == targetPoint.x && y == targetPoint.y) {\nupdateTarget();\ntargetPoint = ta.getTarget();\n} else {\nint stationNumber = getStationID(x, y);\nif (NOT_AT_STATION != stationNumber) {\nloadAndUnloadCargo(stationNumber, false, false);\n}\n}\nreturn targetPoint;\n}\npublic Move getMoves() {\nMove m = WorldDiffMove.generate(worldDiffs, WorldDiffMove.Cause.TrainArrives);\nworldDiffs.reset();\nreturn m;\n}\n/**\n* @return the number of the station the train is currently at, or -1 if no\n* current station.\n*/\npublic int getStationID(int x, int y) {\n// loop thru the station list to check if train is at the same Point\n// as\n// a station\nfor (int i = 0; i < worldDiffs.size(principal, KEY.STATIONS); i++) {\nStationModel tempPoint = (StationModel) worldDiffs.get(principal, KEY.STATIONS, i);\nif (null != tempPoint && (x == tempPoint.x) && (y == tempPoint.y)) {\nreturn i; // train is at the station at location tempPoint\n}\n}\nreturn -1;\n// there are no stations that exist where the train is currently\n}\npublic int getTrainLength() {\nTrainAccessor ta = new TrainAccessor(worldDiffs, principal, trainId);\nreturn ta.getTrain().getLength();\n}\npublic boolean isTrainFull() {\nTrainAccessor train = new TrainAccessor(worldDiffs, principal, trainId);\nImInts spaceAvailable = train.spaceAvailable();\nreturn spaceAvailable.sum() == 0;\n}\npublic boolean isTrainMoving() {\nif (refreshWaitingForFullLoad()) {\nreturn false;\n}\nGameTime time = worldDiffs.currentTime();\nreturn time.getTicks() > this.timeLoadingFinished.getTicks();\n}\npublic boolean isWaiting4FullLoad() {\nTrainModel train = (TrainModel) worldDiffs.get(principal, KEY.TRAINS, this.trainId);\nint scheduleID = train.getScheduleID();\nImmutableSchedule schedule = (ImmutableSchedule) worldDiffs.get(principal,\nKEY.TRAIN_SCHEDULES, scheduleID);\nif(schedule.getNumOrders() == 0){\nreturn false;\n}\nTrainOrdersModel order = schedule.getOrder(schedule.getOrderToGoto());\nreturn !isTrainFull() && order.waitUntilFull;\n}\nvoid loadAndUnloadCargo(int stationId, boolean waiting, boolean autoConsist) {\n// train is at a station so do the cargo processing\nDropOffAndPickupCargoMoveGenerator transfer = new DropOffAndPickupCargoMoveGenerator(\ntrainId, stationId, worldDiffs, principal, waiting, autoConsist);\nMove m = transfer.generateMove();\nif(null != m){\nMoveStatus ms = m.doMove(worldDiffs, principal);\nif (!ms.ok)\nthrow new IllegalStateException(ms.message);\n}\n}\nvoid makeTrainWait(int ticks) {\nGameTime currentTime = worldDiffs.currentTime();\ntimeLoadingFinished = new GameTime(currentTime.getTicks() + ticks);\n}\npublic boolean refreshWaitingForFullLoad() {\nTrainAccessor ta = new TrainAccessor(worldDiffs, principal, trainId);\nImmutableSchedule schedule = ta.getSchedule();\nint stationId = ta.getStationId(Double.MAX_VALUE);\nif(stationId<0) throw new IllegalStateException();\n//The train's orders may have changed...\nfinal int orderToGoto = schedule.getOrderToGoto();\nif(-1 == orderToGoto){\n//We end up here if all the orders are deleted.\nreturn false;\n}\nTrainOrdersModel order = schedule.getOrder(orderToGoto);\n//Should we go to another station?\nif(stationId != order.stationId){\nreturn false;\n}\n//Should we change the consist?\nImInts consist = ta.getTrain().getConsist();\nif(!consist.equals(order.consist)){\n// ..if so, we should change the consist.\nint oldLength = ta.getTrain().getLength();\nint engineType = ta.getTrain().getEngineType();\nTrainModel newTrain = ta.getTrain().getNewInstance(engineType, order.consist);\nworldDiffs.set(principal, KEY.TRAINS, trainId, newTrain);\nint newLength = newTrain.getLength();\n//has the trains length increased?\nif(newLength > oldLength){\nTrainMotion tm = ta.findCurrentMotion(Double.MAX_VALUE);\nPathOnTiles path = tm.getPath();\npath = lengthenPath(worldDiffs, path, oldLength);\nSpeedTimeAndStatus.TrainActivity status = isWaiting4FullLoad() ? WAITING_FOR_FULL_LOAD : STOPPED_AT_STATION;\nTrainMotion nextMotion = new TrainMotion(path, newLength,\n0, status);\n// Create a new Move object.\nMove trainMove = new NextActivityMove(nextMotion, trainId,\nprincipal);\nMoveStatus ms = trainMove.doMove(worldDiffs, Player.AUTHORITATIVE);\nif(!ms.ok) throw new IllegalStateException(ms.message);\n}\n}\n/* Add any cargo that is waiting. */\nloadAndUnloadCargo(schedule.getStationToGoto(), order.waitUntilFull, order.autoConsist);\n//Should we stop waiting?\nif(!order.waitUntilFull){\nupdateSchedule();\nreturn false;\n}\nif (isTrainFull()) {\nupdateSchedule();\nreturn false;\n}\nreturn true;\n}\nprivate void scheduledStop() {\nTrainModel train = (TrainModel) worldDiffs.get(principal, KEY.TRAINS, this.trainId);\nSchedule schedule = (ImmutableSchedule) worldDiffs.get(principal, KEY.TRAIN_SCHEDULES,\ntrain.getScheduleID());\nImInts wagonsToAdd = schedule.getWagonsToAdd();\n// Loading and unloading cargo takes time, so we make the train wait for\n// a few ticks.\nmakeTrainWait(50);\nboolean autoConsist = schedule.autoConsist();\nif (null != wagonsToAdd) {\nint engine = train.getEngineType();\nMove m = ChangeTrainMove.generateMove(this.trainId, train, engine, wagonsToAdd,\nprincipal);\nm.doMove(worldDiffs, principal);\n}\nupdateSchedule();\nint stationToGoto = schedule.getStationToGoto();\nloadAndUnloadCargo(stationToGoto, true, autoConsist);\n}\nvoid updateSchedule() {\nTrainModel train = (TrainModel) worldDiffs.get(principal, KEY.TRAINS, this.trainId);\nint scheduleID = train.getScheduleID();\nImmutableSchedule currentSchedule = (ImmutableSchedule) worldDiffs.get(principal,\nKEY.TRAIN_SCHEDULES, scheduleID);\nMutableSchedule schedule = new MutableSchedule(currentSchedule);\nStationModel station = null;\nTrainOrdersModel order = schedule.getOrder(schedule.getOrderToGoto());\nboolean waiting4FullLoad = order.waitUntilFull && !isTrainFull();\nif (!waiting4FullLoad) {\nschedule.gotoNextStation();\nImmutableSchedule newSchedule = schedule.toImmutableSchedule();\nworldDiffs.set(principal, KEY.TRAIN_SCHEDULES, scheduleID, newSchedule);\nint stationNumber = schedule.getStationToGoto();\nstation = (StationModel) worldDiffs.get(principal, KEY.STATIONS, stationNumber);\nif (null == station) {\nlogger.warning(\"null == station, train \" + trainId\n+ \" doesn't know where to go next!\");\n}\n}\n}\n/**\n* Issues a ChangeTrainScheduleMove to set the train to move to the next\n* station.\n*/\npublic void updateTarget() {\nscheduledStop();\n}\n}"}
{"className":"jfreerails.controller.AddStationPreMove","javaDoc":"/**\n* Generates a move that adds or upgrades a station.\n*\n* @author Luke\n*\n*/","code":"/**\n* Generates a move that adds or upgrades a station.\n*\n* @author Luke\n*\n*/\npublic class AddStationPreMove implements PreMove {\nprivate static final long serialVersionUID = 3258131349411148085L;\nprivate final ImPoint p;\nprivate final int ruleNumber;\nprivate final FreerailsPrincipal principal;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof AddStationPreMove))\nreturn false;\nfinal AddStationPreMove addStationPreMove = (AddStationPreMove) o;\nif (ruleNumber != addStationPreMove.ruleNumber)\nreturn false;\nif (!p.equals(addStationPreMove.p))\nreturn false;\nif (!principal.equals(addStationPreMove.principal))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = p.hashCode();\nresult = 29 * result + ruleNumber;\nresult = 29 * result + principal.hashCode();\nreturn result;\n}\nprivate AddStationPreMove(ImPoint p, int trackRule,\nFreerailsPrincipal principal) {\nthis.p = p;\nthis.ruleNumber = trackRule;\nthis.principal = principal;\n}\npublic static AddStationPreMove newStation(ImPoint p, int trackRule,\nFreerailsPrincipal principal) {\nreturn new AddStationPreMove(p, trackRule, principal);\n}\npublic static AddStationPreMove upgradeStation(ImPoint p, int trackRule,\nFreerailsPrincipal principal) {\nreturn new AddStationPreMove(p, trackRule, principal);\n}\npublic Move generateMove(ReadOnlyWorld world) {\nTrackMoveTransactionsGenerator transactionsGenerator = new TrackMoveTransactionsGenerator(\nworld, principal);\nFreerailsTile oldTile = (FreerailsTile) world.getTile(p.x, p.y);\nString cityName;\nString stationName;\nFreerailsTile ft = (FreerailsTile)world.getTile(p.x, p.y);\nTrackPiece before = ft.getTrackPiece();\nTrackRule trackRule = (TrackRule) world.get(SKEY.TRACK_RULES,\nthis.ruleNumber);\nint owner = ChangeTrackPieceCompositeMove.getOwner(principal, world);\nTrackPiece after = new TrackPieceImpl(before.getTrackConfiguration(),\ntrackRule, owner, ruleNumber);\nChangeTrackPieceMove upgradeTrackMove = new ChangeTrackPieceMove(\nbefore, after, p);\nCompositeMove move;\nif (!oldTile.getTrackPiece().getTrackRule().isStation()) {\n// There isn't already a station here, we need to pick a name and\n// add an entry\n// to the station list.\nCalcNearestCity cNC = new CalcNearestCity(world, p.x, p.y);\ntry {\ncityName = cNC.findNearestCity();\nVerifyStationName vSN = new VerifyStationName(world, cityName);\nstationName = vSN.getName();\n} catch (NoSuchElementException e) {\n// there are no cities, this should never happen during a proper\n// game. However\n// some of the unit tests create stations when there are no\n// cities.\nstationName = \"Central Station #\"\n+ world.size(principal, KEY.STATIONS);\n}\n// check the terrain to see if we can build a station on it...\nmove = AddStationMove.generateMove(world, stationName, p,\nupgradeTrackMove, principal);\nmove = addSupplyAndDemand(move, world);\nmove = transactionsGenerator.addTransactions(move);\n} else {\n// Upgrade an existing station.\nmove = AddStationMove.upgradeStation(upgradeTrackMove);\n}\nreturn move;\n}\nprivate CompositeMove addSupplyAndDemand(CompositeMove m, ReadOnlyWorld w) {\nImList<Move> moves2 = m.getMoves();\nMove[] moves = new Move[moves2.size()];\nfor (int i = 0; i < moves2.size(); i++) {\nmoves[i] = moves2.get(i);\n}\nfor (int i = 0; i < moves.length; i++) {\nif (moves[i] instanceof AddItemToListMove) {\nAddItemToListMove move = (AddItemToListMove) moves[i];\nif (move.getKey().equals(KEY.STATIONS)) {\nStationModel station = (StationModel) move.getAfter();\nCalcCargoSupplyRateAtStation supplyRate;\nsupplyRate = new CalcCargoSupplyRateAtStation(w, station.x,\nstation.y, ruleNumber);\nStationModel stationAfter = supplyRate\n.calculations(station);\nmoves[i] = new AddItemToListMove(move.getKey(), move\n.getIndex(), stationAfter, move.getPrincipal());\n}\n}\n}\nreturn new CompositeMove(moves);\n}\n}"}
{"className":"jfreerails.controller.TrainPathIntIterator","javaDoc":"/**\n* FlatTrackExplorer to FreerailsIntIterator adapter.\n*\n* @author Luke Lindsay 30-Nov-2002.\n*\n*/","code":"/**\n* FlatTrackExplorer to FreerailsIntIterator adapter.\n*\n* @author Luke Lindsay 30-Nov-2002.\n*\n*/\npublic class TrainPathIntIterator implements FreerailsIntIterator {\nprivate final FlatTrackExplorer trackExplorer;\npublic TrainPathIntIterator(FlatTrackExplorer t) {\ntrackExplorer = t;\n}\npublic boolean hasNextInt() {\nreturn trackExplorer.hasNextEdge();\n}\npublic int nextInt() {\ntrackExplorer.nextEdge();\ntrackExplorer.moveForward();\nreturn trackExplorer.getPosition();\n}\n}"}
{"className":"jfreerails.controller.FreerailsServerSerializable","javaDoc":"/**\n* Tags classes that the server may need to save but which won't be sent to\n* clients.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Tags classes that the server may need to save but which won't be sent to\n* clients.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface FreerailsServerSerializable extends Serializable {\n}"}
{"className":"jfreerails.controller.BuildTrackStrategy","javaDoc":"/**\n* A BuildTrackStrategy determines which track types to build (or upgrade to) on\n* different terrains.\n*\n* @author Luke\n*/","code":"/**\n* A BuildTrackStrategy determines which track types to build (or upgrade to) on\n* different terrains.\n*\n* @author Luke\n*/\npublic class BuildTrackStrategy {\nprivate final int[] rules;\npublic static BuildTrackStrategy getSingleRuleInstance(int trackTypeID,\nReadOnlyWorld w) {\nint noTerrainTypes = w.size(SKEY.TERRAIN_TYPES);\nint[] newRules = new int[noTerrainTypes];\nfor (int i = 0; i < noTerrainTypes; i++) {\nnewRules[i] = trackTypeID;\n}\nreturn new BuildTrackStrategy(newRules);\n}\npublic static BuildTrackStrategy getMultipleRuleInstance(\nArrayList<Integer> ruleIDs, ReadOnlyWorld w) {\nint[] rulesArray = generateRules(ruleIDs, w);\nreturn new BuildTrackStrategy(rulesArray);\n}\npublic static BuildTrackStrategy getDefault(ReadOnlyWorld w) {\nArrayList<Integer> allowable = new ArrayList<Integer>();\nallowable.add(getCheapest(TrackRule.TrackCategories.track, w));\nallowable.add(getCheapest(TrackRule.TrackCategories.bridge, w));\nallowable.add(getCheapest(TrackRule.TrackCategories.tunnel, w));\nreturn new BuildTrackStrategy(generateRules(allowable, w));\n}\nprivate static Integer getCheapest(TrackRule.TrackCategories category,\nReadOnlyWorld w) {\nTrackRule cheapest = null;\nInteger cheapestID = null;\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nTrackRule rule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nif (rule.getCategory().equals(category)) {\nif (null == cheapest\n|| cheapest.getPrice().getAmount() > rule.getPrice()\n.getAmount()) {\ncheapest = rule;\ncheapestID = new Integer(i);\n}\n}\n}\nreturn cheapestID;\n}\nprivate static int[] generateRules(ArrayList<Integer> allowable,\nReadOnlyWorld w) {\nint noTerrainTypes = w.size(SKEY.TERRAIN_TYPES);\nint[] newRules = new int[noTerrainTypes];\nfor (int i = 0; i < noTerrainTypes; i++) {\nTerrainType terrainType = (TerrainType) w\n.get(SKEY.TERRAIN_TYPES, i);\nnewRules[i] = -1; // the default value.\nfor (Integer rule : allowable) {\nif (null != rule) {\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES,\nrule.intValue());\nif (trackRule.canBuildOnThisTerrainType(terrainType\n.getCategory())) {\nnewRules[i] = rule.intValue();\nbreak;\n}\n}\n}\n}\nreturn newRules;\n}\n/** Creates a new instance of BuildTrackStrategy */\nprivate BuildTrackStrategy(int[] r) {\nrules = r;\n}\npublic int getRule(int terrainType) {\nreturn rules[terrainType];\n}\n}"}
{"className":"jfreerails.controller.MoveTrainPreMove","javaDoc":"/**\n* Generates moves for changes in train position and stops at stations.\n*\n* @author Luke\n*\n*/","code":"/**\n* Generates moves for changes in train position and stops at stations.\n*\n* @author Luke\n*\n*/\npublic class MoveTrainPreMove implements PreMove {\nprivate static final long serialVersionUID = 3545516188269491250L;\nprivate static final Logger logger = Logger.getLogger(MoveTrainPreMove.class\n.getName());\n/** Uses static method to make testing easier.*/\npublic static Step findNextStep(ReadOnlyWorld world,\nPositionOnTrack currentPosition, ImPoint target) {\nPathOnTrackFinder pathFinder = new PathOnTrackFinder(world);\ntry {\nImPoint location = new ImPoint(currentPosition.getX(),\ncurrentPosition.getY());\npathFinder.setupSearch(location, target);\npathFinder.search(-1);\nreturn pathFinder.pathAsVectors()[0];\n} catch (PathNotFoundException e) {\n// The pathfinder couldn't find a path so we\n// go in any legal direction.\nFlatTrackExplorer explorer = new FlatTrackExplorer(world,\ncurrentPosition);\nexplorer.nextEdge();\nint next = explorer.getVertexConnectedByEdge();\nPositionOnTrack nextPosition = new PositionOnTrack(next);\nreturn nextPosition.cameFrom();\n}\n}\nprivate final FreerailsPrincipal principal;\nprivate final int trainID;\npublic MoveTrainPreMove(int id, FreerailsPrincipal p) {\ntrainID = id;\nprincipal = p;\n}\ndouble acceleration(int wagons) {\nreturn 0.5d/(wagons + 1);\n}\n/**\n* Returns true iff an updated is due.\n*\n*/\npublic boolean isUpdateDue(ReadOnlyWorld w) {\nGameTime currentTime = w.currentTime();\nTrainAccessor ta = new TrainAccessor(w, principal, trainID);\nActivityIterator ai = w.getActivities(principal, trainID);\nai.gotoLastActivity();\ndouble finishTime = ai.getFinishTime();\ndouble ticks = currentTime.getTicks();\nboolean hasFinishedLastActivity = Math.floor(finishTime) <= ticks;\nTrainActivity trainActivity = ta.getStatus(finishTime);\nif(trainActivity == TrainActivity.WAITING_FOR_FULL_LOAD){\n//Check whether there is any cargo that can be added to the train.\nImInts spaceAvailable = ta.spaceAvailable();\nint stationId = ta.getStationId(ticks);\nif(stationId == -1)\nthrow new IllegalStateException();\nStationModel station = (StationModel)w.get(principal, KEY.STATIONS, stationId);\nCargoBundle cb = (CargoBundle)w.get(principal, KEY.CARGO_BUNDLES, station.getCargoBundleID());\nfor(int i = 0; i < spaceAvailable.size(); i++){\nint space = spaceAvailable.get(i);\nint atStation = cb.getAmount(i);\nif(space * atStation > 0){\nlogger.fine(\"There is cargo to transfer!\");\nreturn true;\n}\n}\nreturn !ta.keepWaiting();\n}\nreturn hasFinishedLastActivity;\n}\nprivate ImPoint currentTrainTarget(ReadOnlyWorld w) {\nTrainAccessor ta = new TrainAccessor(w, principal, trainID);\nreturn ta.getTarget();\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof MoveTrainPreMove))\nreturn false;\nfinal MoveTrainPreMove moveTrainPreMove = (MoveTrainPreMove) o;\nif (trainID != moveTrainPreMove.trainID)\nreturn false;\nif (!principal.equals(moveTrainPreMove.principal))\nreturn false;\nreturn true;\n}\npublic Move generateMove(ReadOnlyWorld w) {\n// Check that we can generate a move.\nif (!isUpdateDue(w))\nthrow new IllegalStateException();\nTrainAccessor ta = new TrainAccessor(w, principal, trainID);\nTrainMotion tm = ta.findCurrentMotion(Double.MAX_VALUE);\nSpeedTimeAndStatus.TrainActivity activity = tm.getActivity();\nswitch (activity) {\ncase STOPPED_AT_STATION:\nreturn moveTrain(w);\ncase READY:\n{\n// Are we at a station?\nTrainStopsHandler stopsHandler = new TrainStopsHandler(trainID,\nprincipal, new WorldDiffs(w));\nta.getStationId(Integer.MAX_VALUE);\nPositionOnTrack pot = tm.getFinalPosition();\nint x = pot.getX();\nint y = pot.getY();\nboolean atStation = stopsHandler.getStationID(x, y) >= 0;\nTrainMotion nextMotion;\nif (atStation) {\n// We have just arrived at a station.\ndouble durationOfStationStop = 10;\nstopsHandler.arrivesAtPoint(x, y);\nSpeedTimeAndStatus.TrainActivity status = stopsHandler.isWaiting4FullLoad() ? WAITING_FOR_FULL_LOAD : STOPPED_AT_STATION;\nPathOnTiles path = tm.getPath();\nint lastTrainLength = tm.getTrainLength();\nint currentTrainLength = stopsHandler.getTrainLength();\n//If we are adding wagons we may need to lengthen the path.\nif(lastTrainLength < currentTrainLength){\npath = TrainStopsHandler.lengthenPath(w, path, currentTrainLength);\n}\nnextMotion = new TrainMotion(path, currentTrainLength,\ndurationOfStationStop, status);\n// Create a new Move object.\nMove trainMove = new NextActivityMove(nextMotion, trainID,\nprincipal);\nMove cargoMove = stopsHandler.getMoves();\nreturn new CompositeMove(trainMove, cargoMove);\n}\nreturn moveTrain(w);\n}\ncase WAITING_FOR_FULL_LOAD:\n{\nTrainStopsHandler stopsHandler = new TrainStopsHandler(trainID,\nprincipal, new WorldDiffs(w));\nboolean waiting4fullLoad = stopsHandler.refreshWaitingForFullLoad();\nMove cargoMove = stopsHandler.getMoves();\nif(!waiting4fullLoad){\nMove trainMove = moveTrain(w);\nif(null != trainMove){\nreturn new CompositeMove(trainMove, cargoMove);\n}else{\nreturn cargoMove;\n}\n}\nstopsHandler.makeTrainWait(30);\nreturn cargoMove;\n}\ndefault:\nthrow new UnsupportedOperationException(activity.toString());\n}\n}\npublic SpeedTimeAndStatus.TrainActivity getActivity(ReadOnlyWorld w){\nTrainAccessor ta = new TrainAccessor(w, principal, trainID);\nTrainMotion tm = ta.findCurrentMotion(Integer.MAX_VALUE);\nreturn tm.getActivity();\n}\n@Override\npublic int hashCode() {\nint result;\nresult = trainID;\nresult = 29 * result + principal.hashCode();\nreturn result;\n}\nprivate TrainMotion lastMotion(ReadOnlyWorld w) {\nActivityIterator ai = w.getActivities(principal, trainID);\nai.gotoLastActivity();\nTrainMotion lastMotion = (TrainMotion) ai.getActivity();\nreturn lastMotion;\n}\nprivate Move moveTrain(ReadOnlyWorld w) {\n// Find the next vector.\nStep nextVector = nextStep(w);\nHashMap<TrackSection, Integer> occupiedTrackSections = occupiedTrackSections(w);\nTrainMotion motion = lastMotion(w);\nPositionOnTrack pot = motion.getFinalPosition();\nImPoint tile = new ImPoint(pot.getX(), pot.getY());\nTrackSection desiredTrackSection = new TrackSection(nextVector, tile);\n// Check whether the desired track section is single or double track.\nImPoint tileA = desiredTrackSection.tileA();\nImPoint tileB = desiredTrackSection.tileB();\nFreerailsTile fta = (FreerailsTile) w.getTile(tileA.x, tileA.y);\nFreerailsTile ftb = (FreerailsTile) w.getTile(tileB.x, tileB.y);\nTrackPiece tpa = fta.getTrackPiece();\nTrackPiece tpb = ftb.getTrackPiece();\nint tracks = 1;\nif (tpa.getTrackRule().isDouble() && tpb.getTrackRule().isDouble()) {\ntracks = 2;\n}\nif (occupiedTrackSections.containsKey(desiredTrackSection)) {\nint trains = occupiedTrackSections.get(desiredTrackSection);\nif (trains >= tracks) {\n// We need to wait for the track ahead to clear.\nreturn stopTrain(w);\n}\n}\n// Create a new train motion object.\nTrainMotion nextMotion = nextMotion(w, nextVector);\nreturn new NextActivityMove(nextMotion, trainID, principal);\n}\nprivate HashMap<TrackSection, Integer> occupiedTrackSections(ReadOnlyWorld w) {\nHashMap<TrackSection, Integer> occupiedTrackSections = new HashMap<TrackSection, Integer>();\nfor (int i = 0; i < w.size(principal, KEY.TRAINS); i++) {\nTrainModel train = (TrainModel) w.get(principal,\nKEY.TRAINS, i);\nif (null == train)\ncontinue;\nTrainAccessor ta = new TrainAccessor(w, principal, i);\nGameTime gt = w.currentTime();\nif(ta.isMoving(gt.getTicks())){\nHashSet<TrackSection> sections = ta.occupiedTrackSection(gt.getTicks());\nfor (TrackSection section : sections) {\nif(occupiedTrackSections.containsKey(section)){\nint count = occupiedTrackSections.get(section);\ncount++;\noccupiedTrackSections.put(section, count);\n}else{\noccupiedTrackSections.put(section, 1);\n}\n}\n}\n}\nreturn occupiedTrackSections;\n}\nTrainMotion nextMotion(ReadOnlyWorld w, Step v) {\nTrainMotion motion = lastMotion(w);\nSpeedAgainstTime speeds = nextSpeeds(w, v);\nPathOnTiles currentTiles = motion.getTiles(motion.duration());\nPathOnTiles pathOnTiles = currentTiles.addSteps(v);\nreturn new TrainMotion(pathOnTiles, currentTiles.steps(), motion\n.getTrainLength(), speeds);\n}\nSpeedAgainstTime nextSpeeds(ReadOnlyWorld w, Step v) {\nTrainAccessor ta = new TrainAccessor(w, principal, trainID);\nTrainMotion lastMotion = lastMotion(w);\ndouble u = lastMotion.getSpeedAtEnd();\ndouble s = v.getLength();\nint wagons = ta.getTrain().getNumberOfWagons();\ndouble a0 = acceleration(wagons);\ndouble topSpeed = topSpeed(wagons);\nSpeedAgainstTime newSpeeds;\nif (u < topSpeed) {\ndouble t = (topSpeed - u) / a0;\nSpeedAgainstTime a = ConstAcc.uat(u, a0, t);\nt = s / topSpeed + 1; // Slightly overestimate the time\nSpeedAgainstTime b = ConstAcc.uat(topSpeed, 0, t);\nnewSpeeds = new CompositeSpeedAgainstTime(a, b);\n} else {\ndouble t;\nt = s / topSpeed + 1; // Slightly overestimate the time\nnewSpeeds = ConstAcc.uat(topSpeed, 0, t);\n}\nreturn newSpeeds;\n}\nStep nextStep(ReadOnlyWorld w) {\n// Find current position.\nTrainMotion currentMotion = lastMotion(w);\nPositionOnTrack currentPosition = currentMotion.getFinalPosition();\n// Find targets\nImPoint targetPoint = currentTrainTarget(w);\nreturn findNextStep(w, currentPosition, targetPoint);\n}\npublic Move stopTrain(ReadOnlyWorld w) {\nTrainMotion motion = lastMotion(w);\nSpeedAgainstTime stopped = ConstAcc.STOPPED;\ndouble duration = motion.duration();\nint trainLength = motion.getTrainLength();\nPathOnTiles tiles = motion.getTiles(duration);\nint engineDist = tiles.steps();\nTrainMotion nextMotion = new TrainMotion(tiles, engineDist,\ntrainLength, stopped);\nreturn new NextActivityMove(nextMotion, trainID, principal);\n}\ndouble topSpeed(int wagons) {\nreturn 10 / (wagons + 1);\n}\n}"}
{"className":"jfreerails.controller.ClientControlInterface","javaDoc":"/**\n* Defines the methods that the server can call on a client using a\n* Message2Client.\n*\n* @see Message2Client\n* @author Luke\n*\n*/","code":"/**\n* Defines the methods that the server can call on a client using a\n* Message2Client.\n*\n* @see Message2Client\n* @author Luke\n*\n*/\npublic interface ClientControlInterface {\npublic enum ClientProperty {CONNECTED_CLIENTS, MAPS_AVAILABLE, SAVED_GAMES}\n/** Called when a new game is started or a game is loaded. */\nvoid setGameModel(FreerailsMutableSerializable world);\n/** Sets a property, for example, the list of saved games. */\nvoid setProperty(ClientProperty propertyName, Serializable value);\n}"}
{"className":"jfreerails.controller.Message2Client","javaDoc":"/**\n* Defines a command sent from the server to the client.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a command sent from the server to the client.\n*\n* @author Luke\n*\n*/\npublic interface Message2Client extends FreerailsSerializable {\n/** Executes this command on the specified ClientControlInterface. */\nMessageStatus execute(ClientControlInterface client);\n/** Returns the id of this command. */\nint getID();\n}"}
{"className":"jfreerails.controller.GraphExplorer","javaDoc":"/**\n* This interface lets the caller explorer a graph while hiding the way the\n* graph is stored. Vertices are packed into single ints to avoid the cost of\n* object creation and garbage collection.\n*\n* 24-Nov-2002\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This interface lets the caller explorer a graph while hiding the way the\n* graph is stored. Vertices are packed into single ints to avoid the cost of\n* object creation and garbage collection.\n*\n* 24-Nov-2002\n*\n* @author Luke Lindsay\n*/\npublic interface GraphExplorer {\nvoid setPosition(int vertex);\n/** Return the current edge. */\nint getPosition();\n/**\n* Sets the current edge to the current vertex's next edge. Throws a\n* NoSuchElementException if the vertex does not have another edge.\n*/\nvoid nextEdge();\n/**\n* Returns the vertex that is connected to the current vertex by the current\n* edge.\n*/\nint getVertexConnectedByEdge();\n/** Returns the cost of the current edge. */\nint getEdgeCost();\nboolean hasNextEdge();\n/**\n* Moves this GraphExplorer from the current vertex to the vertex that is\n* connected to the current vertex by the current edge.\n*/\nvoid moveForward();\nint getH();\n}"}
{"className":"jfreerails.controller.ModelRoot","javaDoc":"/**\n* Defines methods and constants that GUI classes can use to access shared data.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines methods and constants that GUI classes can use to access shared data.\n*\n* @author Luke\n*\n*/\npublic interface ModelRoot extends MoveExecutor {\npublic enum Property {\nCURSOR_POSITION, CURSOR_MODE, TRACK_BUILDER_MODE, PREVIOUS_CURSOR_MODE, CURSOR_MESSAGE, QUICK_MESSAGE, PERMANENT_MESSAGE, SHOW_STATION_NAMES, SHOW_CARGO_AT_STATIONS, SHOW_STATION_BORDERS, SERVER, PLAY_SOUNDS, BUILD_TRACK_STRATEGY, IGNORE_KEY_EVENTS, PROPOSED_TRACK, SAVED_GAMES_LIST, THINKING_POINT, TIME, SELECTED_TRAIN\n}\npublic enum Value {\nPLACE_STATION_CURSOR_MODE, BUILD_TRACK_CURSOR_MODE\n}\nvoid sendCommand(Message2Server c);\nvoid setProperty(Property property, Object newValue);\n/**\n* Tests whether the specified property has the specified value.\n*/\nboolean is(Property property, Object value);\nObject getProperty(Property property);\n}"}
{"className":"jfreerails.controller.StockPriceCalculator","javaDoc":"/**\n* Calculates the stock price for each of the players.\n* Stock price = [Net worth + 5 * profit last year] / [ shares owned by public +\n0.5 shares owned by other players]\nLet profit last year = 100,000 in the first year.\n* @author Luke\n*\n*/","code":"/**\n* Calculates the stock price for each of the players.\n* Stock price = [Net worth + 5 * profit last year] / [ shares owned by public +\n0.5 shares owned by other players]\nLet profit last year = 100,000 in the first year.\n* @author Luke\n*\n*/\npublic class StockPriceCalculator {\npublic static class StockPrice{\npublic StockPrice(long netWorth, long profitLastyear, int publicShares, int otherRRShares){\ncurrentPrice = calStockPrice(netWorth, profitLastyear, publicShares, otherRRShares);\nsellPrice = calStockPrice(netWorth, profitLastyear, publicShares + STOCK_BUNDLE_SIZE, otherRRShares - STOCK_BUNDLE_SIZE);\nbuyPrice = calStockPrice(netWorth, profitLastyear, publicShares - STOCK_BUNDLE_SIZE, otherRRShares + STOCK_BUNDLE_SIZE);\ntreasurySellPrice = calStockPrice(netWorth, profitLastyear, publicShares + STOCK_BUNDLE_SIZE, otherRRShares);\ntreasuryBuyPrice = calStockPrice(netWorth, profitLastyear, publicShares - STOCK_BUNDLE_SIZE, otherRRShares);\n}\npublic Money currentPrice;\npublic Money sellPrice;\npublic Money buyPrice;\npublic Money treasuryBuyPrice;\npublic Money treasurySellPrice;\n}\nprivate final ReadOnlyWorld w;\npublic StockPriceCalculator(ReadOnlyWorld w){\nthis.w = w;\n}\npublic StockPrice[] calculate() {\nStockPrice[] stockPrices = new StockPrice[w.getNumberOfPlayers()];\nfor (int playerId = 0; playerId < stockPrices.length; playerId++) {\nlong profitLastYear;\nif(isFirstYear(playerId)){\nprofitLastYear = 100000;\n}else{\nprofitLastYear = profitsLastYear(playerId);\n}\nlong netWorth = netWorth(playerId);\nint publicShares = sharesOwnedByPublic(playerId);\nint otherRRShares = sharesOwnedByOtherPlayers(playerId);\nstockPrices[playerId] = new StockPrice(netWorth, profitLastYear, publicShares, otherRRShares);\n}\nreturn stockPrices;\n}\n/** Returns true if the current time in the same year as the first transaction for the\n* specified player.\n*/\nboolean isFirstYear(int playerId){\nFreerailsPrincipal pr = w.getPlayer(playerId).getPrincipal();\nGameTime firstTransactionTime = w.getTransactionTimeStamp(pr, 0);\nGameCalendar calendar = (GameCalendar)w.get(ITEM.CALENDAR);\nint year = calendar.getYear(firstTransactionTime.getTicks());\nGameTime currentTime = w.currentTime();\nint currentYear = calendar.getYear(currentTime.getTicks());\nreturn year == currentYear;\n}\n/** Returns the players networth at the start of this year.*/\nlong netWorth(int playerId){\nFreerailsPrincipal pr = w.getPlayer(playerId).getPrincipal();\nNetWorthCalculator nwc = new NetWorthCalculator(w, pr);\n//Set the interval to beginning of time to start of this year.\nGameCalendar calendar = (GameCalendar)w.get(ITEM.CALENDAR);\nGameTime currentTime = w.currentTime();\nint currentYear = calendar.getYear(currentTime.getTicks());\nint ticksAtStartOfyear = calendar.getTicks(currentYear);\nGameTime[] times = {GameTime.BIG_BANG, new GameTime(ticksAtStartOfyear + 1)};\nnwc.setTimes(times);\nreturn nwc.calculateValue().getAmount();\n}\nlong profitsLastYear(int playerId){\nFreerailsPrincipal pr = w.getPlayer(playerId).getPrincipal();\nGameCalendar calendar = (GameCalendar)w.get(ITEM.CALENDAR);\nGameTime currentTime = w.currentTime();\nint currentYear = calendar.getYear(currentTime.getTicks());\nint lastyear = currentYear - 1;\nint ticksAtStartOfyear = calendar.getTicks(currentYear);\nint ticksAtStartOfLastYear = calendar.getTicks(lastyear);\nGameTime[] interval = {new GameTime(ticksAtStartOfLastYear), new GameTime(ticksAtStartOfyear)};\nTransactionAggregator aggregator = new TransactionAggregator(w, pr){\n@Override\nprotected boolean condition(int transactionID) {\nTransaction t = super.w.getTransaction(super.principal,\ntransactionID);\nif (t instanceof AddItemTransaction) {\n// Since buying something is just converting one asset type to\n// another.\nreturn false;\n}\nreturn true;\n}\n};\naggregator.setTimes(interval);\nreturn aggregator.calculateValue().getAmount();\n}\nint sharesOwnedByPublic(int playerId){\nFreerailsPrincipal pr = w.getPlayer(playerId).getPrincipal();\nFinancialDataGatherer gatherer = new FinancialDataGatherer(w, pr);\nreturn gatherer.sharesHeldByPublic();\n}\nint sharesOwnedByOtherPlayers(int playerId){\nFreerailsPrincipal pr = w.getPlayer(playerId).getPrincipal();\nFinancialDataGatherer gatherer = new FinancialDataGatherer(w, pr);\nint[] stakes = gatherer.getStockInThisRRs();\nint total = 0;\nfor (int i = 0; i < stakes.length; i++) {\nif(i != playerId){\ntotal+= stakes[i];\n}\n}\nreturn total;\n}\nstatic Money calStockPrice(long netWorth, long profitLastyear, int publicShares, int otherRRShares){\nif((publicShares + otherRRShares) == 0 ) return new Money(Long.MAX_VALUE);\nlong price = 2 * (5 * profitLastyear + netWorth) /(2 * publicShares + otherRRShares);\nreturn new Money(price);\n}\n}"}
{"className":"jfreerails.controller.ProcessCargoAtStationMoveGenerator","javaDoc":"/**\n* This class generates Moves that pay the player for delivering the cargo.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class generates Moves that pay the player for delivering the cargo.\n*\n* @author Luke Lindsay\n*\n*/\npublic class ProcessCargoAtStationMoveGenerator {\n/**\n* Determines how much the player gets for delivering cargo. Changed from\n* 100 to 75 to fix bug 910132 (Too easy to make money!)\n*/\nprivate final static int MAGIC_NUMBER = 75;\npublic static ArrayList<Move> processCargo(ReadOnlyWorld w,\nCargoBundle bundle, int stationID, FreerailsPrincipal p,\nint trainId) {\nStationModel thisStation = (StationModel) w.get(p,\nKEY.STATIONS, stationID);\nIterator<CargoBatch> batches = bundle.cargoBatchIterator();\nArrayList<Move> moves = new ArrayList<Move>();\nwhile (batches.hasNext()) {\nCargoBatch batch = batches.next();\ndouble distanceSquared = (batch.getSourceX() - thisStation.x)\n* (batch.getSourceX() - thisStation.x)\n+ (batch.getSourceY() - thisStation.y)\n* (batch.getSourceY() - thisStation.y);\ndouble dist = Math.sqrt(distanceSquared);\nint quantity = bundle.getAmount(batch);\ndouble amount = quantity * Math.log(dist) * MAGIC_NUMBER;\nMoney money = new Money((long) amount);\nDeliverCargoReceipt receipt = new DeliverCargoReceipt(money,\nquantity, stationID, batch, trainId);\nmoves.add(new AddTransactionMove(p, receipt));\n}\nreturn moves;\n}\n}"}
{"className":"jfreerails.controller.CalcCargoSupplyRateAtStation","javaDoc":"/**\n* This class probes the tiles adjacent to a station for what cargo they supply,\n* demand, and convert and then returns a vector of these rates.\n*\n* @author Scott Bennett\n* @author Luke Created: 9th May 2003\n*/","code":"/**\n* This class probes the tiles adjacent to a station for what cargo they supply,\n* demand, and convert and then returns a vector of these rates.\n*\n* @author Scott Bennett\n* @author Luke Created: 9th May 2003\n*/\npublic class CalcCargoSupplyRateAtStation {\nprivate static final Logger logger = Logger\n.getLogger(CalcCargoSupplyRateAtStation.class.getName());\n/**\n* The threshold that demand for a cargo must exceed before the station\n* demands the cargo.\n*/\nprivate static final int PREREQUISITE_FOR_DEMAND = 16;\nprivate final int[] converts;\nprivate final int[] demand;\nprivate final Vector<CargoElementObject> supplies;\nprivate final ReadOnlyWorld w;\nprivate int x;\nprivate int y;\nprivate int stationRadius;\n/**\n* Call this constructor if the station does not exist yet.\n*\n* @param trackRuleNo\n* the station type.\n*/\npublic CalcCargoSupplyRateAtStation(ReadOnlyWorld world, int X, int Y,\nint trackRuleNo) {\nthis.w = world;\nthis.x = X;\nthis.y = Y;\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, trackRuleNo);\nstationRadius = trackRule.getStationRadius();\nsupplies = new Vector<CargoElementObject>();\npopulateSuppliesVector();\nint numCargoTypes = w.size(SKEY.CARGO_TYPES);\ndemand = new int[numCargoTypes];\nconverts = ConvertedAtStation.emptyConversionArray(numCargoTypes);\n}\n/** Call this constructor if the station already exists. */\npublic CalcCargoSupplyRateAtStation(ReadOnlyWorld world, int X, int Y) {\nthis(world, X, Y, findTrackRule(X, Y, world));\n}\npublic ConvertedAtStation getConversion() {\nreturn new ConvertedAtStation(this.converts);\n}\npublic Demand4Cargo getDemand() {\nboolean[] demandboolean = new boolean[w.size(SKEY.CARGO_TYPES)];\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\nif (demand[i] >= PREREQUISITE_FOR_DEMAND) {\ndemandboolean[i] = true;\n}\n}\nreturn new Demand4Cargo(demandboolean);\n}\nprivate void incrementSupplyAndDemand(int i, int j) {\nint tileTypeNumber = ((FreerailsTile) w.getTile(i, j))\n.getTerrainTypeID();\nTerrainType terrainType = (TerrainType) w.get(SKEY.TERRAIN_TYPES,\ntileTypeNumber);\n// Calculate supply.\nImList<Production> production = terrainType.getProduction();\n// loop through the production array and increment\n// the supply rates for the station\nfor (int m = 0; m < production.size(); m++) {\nint type = production.get(m).getCargoType();\nint rate = production.get(m).getRate();\n// loop through supplies vector and increment the cargo values as\n// required\nupdateSupplyRate(type, rate);\n}\n// Now calculate demand.\nImList<Consumption> consumption = terrainType.getConsumption();\nfor (int m = 0; m < consumption.size(); m++) {\nint type = consumption.get(m).getCargoType();\nint prerequisite = consumption.get(m).getPrerequisite();\n// The prerequisite is the number tiles of this type that must\n// be within the station radius before the station demands the\n// cargo.\ndemand[type] += PREREQUISITE_FOR_DEMAND / prerequisite;\n}\nImList<Conversion> conversion = terrainType.getConversion();\nfor (int m = 0; m < conversion.size(); m++) {\nint type = conversion.get(m).getInput();\n// Only one tile that converts the cargo type is needed for the\n// station to demand the cargo type.\ndemand[type] += PREREQUISITE_FOR_DEMAND;\nconverts[type] = conversion.get(m).getOutput();\n}\n}\nprivate void populateSuppliesVector() {\n// fill supplies vector with 0 values for all cargo types\n// get the correct list of cargoes from the world object\nCargoElementObject tempCargoElement;\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\n// cT = (CargoType) w.get(SKEY.CARGO_TYPES, i);\ntempCargoElement = new CargoElementObject(0, i);\nsupplies.add(tempCargoElement);\n}\n}\npublic Vector<CargoElementObject> scanAdjacentTiles() {\nint stationDiameter = stationRadius * 2 + 1;\nRectangle stationRadiusRect = new Rectangle(x - stationRadius, y\n- stationRadius, stationDiameter, stationDiameter);\nRectangle mapRect = new Rectangle(0, 0, w.getMapWidth(), w\n.getMapHeight());\nRectangle tiles2scan = stationRadiusRect.intersection(mapRect);\nlogger.fine(\"stationRadiusRect=\" + stationRadiusRect);\nlogger.fine(\"mapRect=\" + mapRect);\nlogger.fine(\"tiles2scan=\" + tiles2scan);\n// Look at the terrain type of each tile and retrieve the cargo\n// supplied.\n// The station radius determines how many tiles each side we look at.\nfor (int i = tiles2scan.x; i < (tiles2scan.x + tiles2scan.width); i++) {\nfor (int j = tiles2scan.y; j < (tiles2scan.y + tiles2scan.height); j++) {\nincrementSupplyAndDemand(i, j);\n}\n}\n// return the supplied cargo rates\nreturn supplies;\n}\nprivate static int findTrackRule(int xx, int yy, ReadOnlyWorld w) {\nFreerailsTile tile = (FreerailsTile) w.getTile(xx, yy);\nint ruleNumber = tile.getTrackPiece().getTrackTypeID();\nreturn ruleNumber;\n}\nprivate void updateSupplyRate(int type, int rate) {\n// loop through supplies vector and increment the cargo values as\n// required\nfor (int n = 0; n < supplies.size(); n++) {\nCargoElementObject tempElement = supplies.elementAt(n);\nif (tempElement.getType() == type) {\n// cargo types are the same, so increment the rate in supply\n// with the rate.\ntempElement.setRate(tempElement.getRate() + rate);\nbreak; // no need to go through the rest if we've found a match\n}\n}\n}\n/**\n*\n* Process each existing station, updating what is supplied to it.\n*\n* @param station\n* A StationModel object to be processed\n*\n*/\npublic StationModel calculations(StationModel station) {\nint[] cargoSupplied = new int[w.size(SKEY.CARGO_TYPES)];\nVector<CargoElementObject> supply = scanAdjacentTiles();\n// grab the supply rates from the vector\nfor (int i = 0; i < supply.size(); i++) {\ncargoSupplied[i] = supply.get(i).getRate();\n}\n// set the supply rates for the current station\nSupplyAtStation supplyAtStation = new SupplyAtStation(cargoSupplied);\nstation = new StationModel(station, supplyAtStation);\nstation = new StationModel(station, getDemand());\nstation = new StationModel(station, getConversion());\nreturn station;\n}\n}"}
{"className":"jfreerails.controller.RandomPathFinder","javaDoc":"/**\n* Returns a random path along the track.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/","code":"/**\n* Returns a random path along the track.\n*\n* @author Luke Lindsay 13-Oct-2002\n*\n*/\npublic class RandomPathFinder implements FreerailsPathIterator {\nprivate static final long serialVersionUID = 3832906571880608313L;\nprivate final FlatTrackExplorer trackExplorer;\nprivate final PositionOnTrack p1 = new PositionOnTrack();\nprivate final PositionOnTrack p2 = new PositionOnTrack();\nprivate static final int tileSize = 30;\npublic RandomPathFinder(FlatTrackExplorer tx) {\ntrackExplorer = tx;\n}\npublic boolean hasNext() {\nreturn trackExplorer.hasNextEdge();\n}\npublic void nextSegment(IntLine line) {\np1.setValuesFromInt(trackExplorer.getPosition());\nline.x1 = p1.getX() * tileSize + tileSize / 2;\nline.y1 = p1.getY() * tileSize + tileSize / 2;\ntrackExplorer.nextEdge();\ntrackExplorer.moveForward();\np2.setValuesFromInt(trackExplorer.getPosition());\nline.x2 = p2.getX() * tileSize + tileSize / 2;\nline.y2 = p2.getY() * tileSize + tileSize / 2;\n}\n}"}
{"className":"jfreerails.controller.BuildTrackExplorer","javaDoc":"/**\n* GraphExplorer that explorers possible track placements, the ints it returns\n* are encoded PositionOnTrack objects.\n*\n* @author Luke\n*\n*/","code":"/**\n* GraphExplorer that explorers possible track placements, the ints it returns\n* are encoded PositionOnTrack objects.\n*\n* @author Luke\n*\n*/\npublic class BuildTrackExplorer implements GraphExplorer {\nprivate static final TrackConfiguration TILE_CENTER = TrackConfiguration\n.getFlatInstance(\"000010000\");\nprivate boolean beforeFirst = true;\nfinal PositionOnTrack currentBranch = PositionOnTrack.createComingFrom(0,\n0, Step.NORTH);\nfinal private PositionOnTrack currentPosition = PositionOnTrack\n.createComingFrom(0, 0, Step.NORTH);\nprivate int directionInt = 0;\nprivate final ImPoint target;\nprivate BuildTrackStrategy buildTrackStrategy;\nprivate boolean usingExistingTrack = false;\nprivate final ReadOnlyWorld world;\nprivate final FreerailsPrincipal principal;\npublic BuildTrackExplorer(ReadOnlyWorld w, FreerailsPrincipal principal) {\nthis(w, principal, null, new ImPoint(0, 0));\n}\npublic BuildTrackExplorer(ReadOnlyWorld w, FreerailsPrincipal principal,\nImPoint start, ImPoint target) {\nworld = w;\nthis.principal = principal;\nPositionOnTrack pos;\nif (null == start) {\npos = new PositionOnTrack();\n} else {\npos = PositionOnTrack\n.createComingFrom(start.x, start.y, Step.NORTH);\n}\ncurrentPosition.setValuesFromInt(pos.toInt());\ndirectionInt = 0;\nthis.target = target;\nbuildTrackStrategy = BuildTrackStrategy.getDefault(w);\n}\n/**\n* <p>\n* Tests whether we can build track in the direction specified by\n* m_direction.\n* </p>\n*\n* <p>\n* If we enter a tile from a given direction, the tiles we can build track\n* to depend on the following. (1) The terrain type of the surrounding tiles -\n* track can only be built on certain terrain types. (2) The direction we\n* entered the current tile from. (3) Any existing track on the current tile -\n* limits possible track configurations. (4) The terrain type of the current\n* tile - terrain type determines which track types and hence which track\n* configurations can be built.\n* </p>\n*\n*/\nprivate boolean canBuildTrack() {\n// Check that we are not doubling back on ourselves.\nStep opposite2current = currentPosition.cameFrom().getOpposite();\nint currentX = currentPosition.getX();\nint currentY = currentPosition.getY();\nint directionWeCameFrom = opposite2current.getID();\nint directionWeCameFromPlus = (directionWeCameFrom + 1) % 8;\nint directionWeCameFromMinus = (directionWeCameFrom + 7) % 8;\nif (directionInt == directionWeCameFrom\n|| directionInt == directionWeCameFromPlus\n|| directionInt == directionWeCameFromMinus) {\nreturn false;\n}\n// Check that we are not going off the map.\nStep directionOfNextTile = Step.getInstance(directionInt);\nint newX = currentX + directionOfNextTile.getDx();\nint newY = currentY + directionOfNextTile.getDy();\nif (!world.boundsContain(newX, newY)) {\nreturn false;\n}\nTrackRule rule4nextTile;\nTrackRule rule4lastTile;\n// Determine the track rule for the next tile.\nfinal FreerailsTile nextTile = (FreerailsTile) world.getTile(newX,\nnewY);\n// Check there is not another players track at nextTile.\nif (nextTile.hasTrack()) {\nif (nextTile.getTrackPiece().getOwnerID() != world.getID(principal)) {\nreturn false;\n}\n}\nrule4nextTile = getAppropriateTrackRule(newX, newY);\nif (null == rule4nextTile) {\nreturn false; // We can't build track on the tile.\n}\nrule4lastTile = getAppropriateTrackRule(currentX, currentY);\nif (null == rule4lastTile) {\nreturn false; // We can't build track on the tile.\n}\n// Determine the track rule for the current tile.\nFreerailsTile currentTile = (FreerailsTile) world.getTile(currentX,\ncurrentY);\n// Check for illegal track configurations.\nfinal TrackConfiguration trackAlreadyPresent1 = currentTile\n.getTrackPiece().getTrackConfiguration();\nfinal TrackConfiguration trackAlreadyPresent2 = nextTile\n.getTrackPiece().getTrackConfiguration();\nTrackConfiguration fromConfig = trackAlreadyPresent1;\nfromConfig = TrackConfiguration.add(fromConfig, opposite2current);\nfromConfig = TrackConfiguration.add(fromConfig, TILE_CENTER);\nStep goingTo = Step.getInstance(directionInt);\nfromConfig = TrackConfiguration.add(fromConfig, goingTo);\nif (!rule4lastTile.trackPieceIsLegal(fromConfig)) {\nreturn false;\n}\n// Check for diagonal conflicts.\nif (directionOfNextTile.isDiagonal()) {\nint x2check = currentX;\nint y2check = currentY + directionOfNextTile.deltaY;\n// We did a bounds check above.\nassert (world.boundsContain(x2check, y2check));\nFreerailsTile tile2Check = (FreerailsTile) world.getTile(x2check,\ny2check);\nTrackConfiguration config2check = tile2Check\n.getTrackPiece().getTrackConfiguration();\nStep vector2check = Step.getInstance(directionOfNextTile.deltaX,\n-directionOfNextTile.deltaY);\nif (config2check.contains(vector2check)) {\n// then we have a diagonal conflict.\nreturn false;\n}\n}\n// Check for illegal track configurations on the tile we are entering.\nTrackConfiguration fromConfig2 = trackAlreadyPresent2;\nfromConfig2 = TrackConfiguration.add(fromConfig2, TILE_CENTER);\nStep goingBack = Step.getInstance(directionInt).getOpposite();\nfromConfig2 = TrackConfiguration.add(fromConfig2, goingBack);\nif (!rule4nextTile.trackPieceIsLegal(fromConfig2)) {\nreturn false;\n}\n/*\n* Set the using existing track. We do this because a path that uses\n* existing track is cheaper to build.\n*/\nusingExistingTrack = trackAlreadyPresent1.contains(goingTo);\nreturn true;\n}\nprivate TrackRule getAppropriateTrackRule(int x, int y) {\nfinal FreerailsTile tile = (FreerailsTile) world.getTile(x, y);\nTrackRule rule;\nif (!tile.hasTrack()) {\nint terrainTypeID = tile.getTerrainTypeID();\nint trackRuleID = buildTrackStrategy.getRule(terrainTypeID);\nif (trackRuleID == -1) {\nreturn null; // Can't build on this terrain!\n}\nrule = (TrackRule) world.get(SKEY.TRACK_RULES, trackRuleID);\n} else {\nrule = tile.getTrackPiece().getTrackRule();\n}\nreturn rule;\n}\n/**\n* Calculates a cost figure incorporating the distance and the cost of any\n* new track.\n*/\npublic int getEdgeCost() {\nif (beforeFirst) {\nthrow new IllegalStateException();\n}\nStep edgeDirection = Step.getInstance(directionInt - 1);\ndouble length = edgeDirection.getLength();\nfinal int DISTANCE_COST = 10000; // Same as the cost of standard\n// track.\nint cost = (int) Math.round(DISTANCE_COST * length);\nif (!usingExistingTrack) {\nint[] x = { currentPosition.getX(),\ncurrentPosition.getX() + edgeDirection.deltaX };\nint[] y = { currentPosition.getY(),\ncurrentPosition.getY() + edgeDirection.deltaY };\nTrackRule ruleA = getAppropriateTrackRule(x[0], y[0]);\nTrackRule ruleB = getAppropriateTrackRule(x[1], y[1]);\n/*\n* If there is a station at either of the points, don't include its\n* price in the cost calculation since it has already been paid.\n* Otherwise, add the cost of building the track.\n*/\nlong priceA = ruleA.getPrice().getAmount();\nlong priceB = ruleB.getPrice().getAmount();\ncost += length * (priceA + priceB);\n// Add fixed cost if tile b does not have the desired track type.\nFreerailsTile a = (FreerailsTile) world.getTile(x[0], y[0]);\nTrackRule currentRuleA = a.getTrackPiece().getTrackRule();\nif (!currentRuleA.equals(ruleA)) {\nassert (!currentRuleA.isStation()); // We shouldn't be upgrading\n// a station.\ncost += ruleA.getFixedCost().getAmount() * Step.TILE_DIAMETER;\n}\n}\nreturn cost;\n}\npublic int getH() {\nint xDistance = (target.x - currentPosition.getX())\n* Step.TILE_DIAMETER;\nint yDistance = (target.y - currentPosition.getY())\n* Step.TILE_DIAMETER;\nint sumOfSquares = (xDistance * xDistance + yDistance * yDistance);\nreturn (int) Math.sqrt(sumOfSquares);\n}\npublic int getPosition() {\nreturn currentPosition.toInt();\n}\npublic int getVertexConnectedByEdge() {\nif (beforeFirst) {\nthrow new IllegalStateException();\n}\nreturn currentBranch.toInt();\n}\npublic boolean hasNextEdge() {\nwhile (directionInt < 8) {\nif (canBuildTrack()) {\nreturn true;\n}\ndirectionInt++;\n}\nreturn false;\n}\npublic void moveForward() {\nif (beforeFirst) {\nthrow new IllegalStateException();\n}\nsetPosition(this.getVertexConnectedByEdge());\n}\npublic void nextEdge() {\nif (!hasNextEdge()) {\nthrow new NoSuchElementException();\n}\n// The direction we are moving relative to the current position.\nStep direction = Step.getInstance(directionInt);\ncurrentBranch.setCameFrom(direction);\ncurrentBranch.setX(currentPosition.getX() + direction.getDx());\ncurrentBranch.setY(currentPosition.getY() + direction.getDy());\ndirectionInt++;\nbeforeFirst = false;\n}\npublic void setPosition(int vertex) {\ncurrentPosition.setValuesFromInt(vertex);\ndirectionInt = 0;\n}\npublic void setBuildTrackStrategy(BuildTrackStrategy trackStrategy) {\nif (null == trackStrategy)\nthrow new NullPointerException();\nbuildTrackStrategy = trackStrategy;\n}\n}"}
{"className":"jfreerails.controller.TrackMoveProducer","javaDoc":"/**\n* Provides methods that generate moves that build, upgrade, and remove track.\n*\n* @author Luke\n*/","code":"/**\n* Provides methods that generate moves that build, upgrade, and remove track.\n*\n* @author Luke\n*/\nfinal public class TrackMoveProducer {\nprivate final ModelRoot mr;\nprivate final MoveExecutor executor;\npublic enum BuildMode {\nBUILD_TRACK, REMOVE_TRACK, UPGRADE_TRACK, IGNORE_TRACK, BUILD_STATION\n}\nprivate final Stack<Move> moveStack = new Stack<Move>();\nprivate GameTime lastMoveTime = GameTime.BIG_BANG;\n/**\n* This generates the transactions - the charge - for the track being built.\n*/\nprivate final TrackMoveTransactionsGenerator transactionsGenerator;\npublic MoveStatus buildTrack(ImPoint from, Step[] path) {\nMoveStatus returnValue = MoveStatus.MOVE_OK;\nint x = from.x;\nint y = from.y;\nfor (int i = 0; i < path.length; i++) {\nreturnValue = buildTrack(new ImPoint(x, y), path[i]);\nx += path[i].deltaX;\ny += path[i].deltaY;\nif (!returnValue.ok) {\nreturn returnValue;\n}\n}\nreturn returnValue;\n}\npublic MoveStatus buildTrack(ImPoint from, Step trackVector) {\nReadOnlyWorld w = executor.getWorld();\nFreerailsPrincipal principal = executor.getPrincipal();\nswitch (getBuildMode()) {\ncase IGNORE_TRACK: {\nreturn MoveStatus.MOVE_OK;\n}\ncase REMOVE_TRACK: {\ntry {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateRemoveTrackMove(from, trackVector, w,\nprincipal);\nMove moveAndTransaction = transactionsGenerator\n.addTransactions(move);\nreturn sendMove(moveAndTransaction);\n} catch (Exception e) {\n// thrown when there is no track to remove.\n// Fix for bug [ 948670 ] Removing non-existent track\nreturn MoveStatus.moveFailed(\"No track to remove.\");\n}\n}\ncase BUILD_TRACK:\ncase UPGRADE_TRACK:\n/*\n* Do nothing yet since we need to work out what type of track to\n* build.\n*/\nbreak;\n}\nassert (getBuildMode() == BuildMode.BUILD_TRACK || getBuildMode() == BuildMode.UPGRADE_TRACK);\nint[] ruleIDs = new int[2];\nTrackRule[] rules = new TrackRule[2];\nint[] xs = { from.x, from.x + trackVector.deltaX };\nint[] ys = { from.y, from.y + trackVector.deltaY };\nfor (int i = 0; i < ruleIDs.length; i++) {\nint x = xs[i];\nint y = ys[i];\nFreerailsTile tile = (FreerailsTile) w.getTile(x, y);\nint tt = tile.getTerrainTypeID();\nruleIDs[i] = getBuildTrackStrategy().getRule(tt);\nif (ruleIDs[i] == -1) {\nTerrainType terrainType = (TerrainType) w.get(\nSKEY.TERRAIN_TYPES, tt);\nString message = \"Non of the selected track types can be built on \"\n+ terrainType.getDisplayName();\nreturn MoveStatus.moveFailed(message);\n}\nrules[i] = (TrackRule) w.get(SKEY.TRACK_RULES, ruleIDs[i]);\n}\nswitch (getBuildMode()) {\ncase UPGRADE_TRACK: {\n// upgrade the from tile if necessary.\nFreerailsTile tileA = (FreerailsTile) w.getTile(from.x, from.y);\nif (tileA.getTrackPiece().getTrackTypeID() != ruleIDs[0] && !isStationHere(from)) {\nMoveStatus ms = upgradeTrack(from, ruleIDs[0]);\nif (!ms.ok) {\nreturn ms;\n}\n}\nImPoint point = new ImPoint(from.x + trackVector.getDx(), from.y\n+ trackVector.getDy());\nFreerailsTile tileB = (FreerailsTile) w.getTile(point.x, point.y);\nif (tileB.getTrackPiece().getTrackTypeID() != ruleIDs[1] && !isStationHere(point)) {\nMoveStatus ms = upgradeTrack(point, ruleIDs[1]);\nif (!ms.ok) {\nreturn ms;\n}\n}\nreturn MoveStatus.MOVE_OK;\n}\ncase BUILD_TRACK: {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(from, trackVector, rules[0],\nrules[1], w, principal);\nMove moveAndTransaction = transactionsGenerator\n.addTransactions(move);\nreturn sendMove(moveAndTransaction);\n}\ndefault:\nthrow new IllegalArgumentException(String.valueOf(getBuildMode()));\n}\n}\npublic MoveStatus upgradeTrack(ImPoint point) {\nif (getBuildMode() == BuildMode.UPGRADE_TRACK) {\nReadOnlyWorld w = executor.getWorld();\nFreerailsTile tile = (FreerailsTile) w.getTile(point.x, point.y);\nint tt = tile.getTerrainTypeID();\nreturn upgradeTrack(point, getBuildTrackStrategy().getRule(tt));\n}\nthrow new IllegalStateException(\n\"Track builder not set to upgrade track!\");\n}\npublic void setTrackBuilderMode(BuildMode i) {\nsetBuildMode(i);\n}\npublic TrackMoveProducer(MoveExecutor executor, ReadOnlyWorld world, ModelRoot mr) {\nif(null == mr) throw new NullPointerException();\nthis.executor = executor;\nthis.mr = mr;\nFreerailsPrincipal principal = executor.getPrincipal();\ntransactionsGenerator = new TrackMoveTransactionsGenerator(world,\nprincipal);\nsetBuildTrackStrategy(BuildTrackStrategy.getDefault(world));\n}\npublic TrackMoveProducer(ModelRoot mr) {\nthis.executor = mr;\nif(null == mr) throw new NullPointerException();\nthis.mr = mr;\nReadOnlyWorld world = executor.getWorld();\nFreerailsPrincipal principal = executor.getPrincipal();\ntransactionsGenerator = new TrackMoveTransactionsGenerator(world,\nprincipal);\nsetBuildTrackStrategy(BuildTrackStrategy.getDefault(world));\n}\nprivate MoveStatus upgradeTrack(ImPoint point, int trackRuleID) {\nReadOnlyWorld w = executor.getWorld();\nTrackPiece before = ((FreerailsTile) w.getTile(point.x, point.y)).getTrackPiece();\n/* Check whether there is track here. */\nif (before.getTrackTypeID() == NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\nreturn MoveStatus.moveFailed(\"No track to upgrade.\");\n}\nFreerailsPrincipal principal = executor.getPrincipal();\nint owner = ChangeTrackPieceCompositeMove.getOwner(principal, w);\nTrackRule trackRule = (TrackRule) w.get(SKEY.TRACK_RULES, trackRuleID);\nTrackPiece after = new TrackPieceImpl(before.getTrackConfiguration(),\ntrackRule, owner, trackRuleID);\n/* We don't want to 'upgrade' a station to track. See bug 874416. */\nif (before.getTrackRule().isStation()) {\nreturn MoveStatus\n.moveFailed(\"No need to upgrade track at station.\");\n}\nMove move = UpgradeTrackMove.generateMove(before, after, point);\nMove move2 = transactionsGenerator.addTransactions(move);\nreturn sendMove(move2);\n}\npublic MoveStatus undoLastTrackMove() {\nclearStackIfStale();\nif (moveStack.size() > 0) {\nMove m = moveStack.pop();\nUndoMove undoMove = new UndoMove(m);\nMoveStatus ms = executor.doMove(undoMove);\nif (!ms.ok) {\nreturn MoveStatus.moveFailed(\"Can not undo building track!\");\n}\nreturn ms;\n}\nreturn MoveStatus.moveFailed(\"No track to undo building!\");\n}\n/**\n* Moves are only un-doable if no game time has passed since they they were\n* executed. This method clears the move stack if the moves were added to\n* the stack at a time other than the current time.\n*/\nprivate void clearStackIfStale() {\nReadOnlyWorld w = executor.getWorld();\nGameTime currentTime = w.currentTime();\nif (!currentTime.equals(lastMoveTime)) {\nmoveStack.clear();\nlastMoveTime = currentTime;\n}\n}\npublic BuildMode getTrackBuilderMode() {\nreturn getBuildMode();\n}\nprivate MoveStatus sendMove(Move m) {\nMoveStatus ms = executor.doMove(m);\nif (ms.isOk()) {\nclearStackIfStale();\nmoveStack.add(m);\n}\nreturn ms;\n}\n// public BuildTrackStrategy getBuildTrackStrategy() {\n// return buildTrackStrategy;\n// }\n//\n// public void setBuildTrackStrategy(BuildTrackStrategy buildTrackStrategy) {\n// this.buildTrackStrategy = buildTrackStrategy;\n// }\nprivate boolean isStationHere(ImPoint p) {\nReadOnlyWorld w = executor.getWorld();\nFreerailsTile tile = (FreerailsTile) w.getTile(p.x, p.y);\nreturn tile.getTrackPiece().getTrackRule().isStation();\n}\npublic void setBuildTrackStrategy(BuildTrackStrategy buildTrackStrategy) {\nmr.setProperty(Property.BUILD_TRACK_STRATEGY, buildTrackStrategy);\n}\npublic BuildTrackStrategy getBuildTrackStrategy() {\nreturn (BuildTrackStrategy) mr.getProperty(Property.BUILD_TRACK_STRATEGY);\n}\npublic void setBuildMode(BuildMode buildMode) {\nmr.setProperty(Property.TRACK_BUILDER_MODE, buildMode);\n}\npublic BuildMode getBuildMode() {\nreturn (BuildMode) mr.getProperty(Property.TRACK_BUILDER_MODE);\n}\n}"}
{"className":"jfreerails.controller.TimeTickPreMove","javaDoc":"/**\n* Generates a TimeTickMove.\n*\n* @author Luke\n*\n*/","code":"/**\n* Generates a TimeTickMove.\n*\n* @author Luke\n*\n*/\n@jfreerails.util.InstanceControlled\npublic class TimeTickPreMove implements PreMove {\nprivate static final long serialVersionUID = 3690479125647208760L;\npublic static final TimeTickPreMove INSTANCE = new TimeTickPreMove();\nprivate TimeTickPreMove() {\n}\npublic Move generateMove(ReadOnlyWorld w) {\nreturn TimeTickMove.getMove(w);\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn INSTANCE;\n}\n}"}
{"className":"jfreerails.controller.IncrementalPathFinder","javaDoc":"/**\n* Defines part of the contract for a pathfinder whose search can be completed\n* in several steps.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines part of the contract for a pathfinder whose search can be completed\n* in several steps.\n*\n* @author Luke\n*\n*/\npublic interface IncrementalPathFinder {\n// TODO replace with enum.\npublic static final int PATH_NOT_FOUND = Integer.MIN_VALUE;\npublic final int PATH_FOUND = Integer.MIN_VALUE + 1;\npublic static final int SEARCH_PAUSED = Integer.MIN_VALUE + 2;\npublic static final int SEARCH_NOT_STARTED = Integer.MIN_VALUE + 3;\npublic abstract int getStatus();\npublic abstract void search(long maxDuration) throws PathNotFoundException;\npublic abstract void abandonSearch();\n}"}
{"className":"jfreerails.controller.FinancialDataGatherer","javaDoc":"/**\n* Gathers the financial data for a company.\n*\n* @author Luke\n* @author smackay\n*/","code":"/**\n* Gathers the financial data for a company.\n*\n* @author Luke\n* @author smackay\n*/\npublic class FinancialDataGatherer extends TransactionAggregator {\nprivate int totalShares = 100000;\nprivate final int playerID;\nprivate int bonds;\nprivate int[] stockInRRs;\nprivate int[] stockInThisRRs;\n@Override\nprotected void incrementRunningTotal(int transactionID) {\nTransaction t = super.w.getTransaction(super.principal, transactionID);\nif (t instanceof AddItemTransaction) {\nAddItemTransaction ait = (AddItemTransaction) t;\nif (t instanceof StockTransaction\n&& ait.getCategory() == Transaction.Category.ISSUE_STOCK\n&& ait.getType() == -1) {\n// If it is a change in the total number of shares issued.\nStockTransaction ist = (StockTransaction) t;\ntotalShares += ist.getQuantity();\n} else if (t instanceof StockTransaction\n&& ait.getCategory() == Transaction.Category.TRANSFER_STOCK\n) {\n//\nstockInRRs[ait.getType()] += ait.getQuantity();\n} else if (t instanceof BondTransaction) {\nbonds += ait.getQuantity();\n}\n} else {\nsuper.incrementRunningTotal(transactionID);\n}\n}\n@Override\nprotected void setTotalsArrayLength(int length) {\n// TODO Auto-generated method stub\nsuper.setTotalsArrayLength(length);\n}\n@Override\nprotected void storeRunningTotal(int timeIndex) {\n// TODO Auto-generated method stub\nsuper.storeRunningTotal(timeIndex);\n}\npublic FinancialDataGatherer(ReadOnlyWorld w, FreerailsPrincipal principal) {\nsuper(w, principal);\nstockInRRs = new int [w.getNumberOfPlayers()];\ncalculateValues();\nthis.playerID = w.getID(principal);\n}\npublic void changeTreasuryStock(int deltaStock) {\n}\npublic void changeStake(int stakeHolder, int deltaStock) {\n}\npublic boolean canIssueBond() {\nreturn nextBondInterestRate() <= 7;\n}\npublic boolean canBuyStock() {\nreturn totalShares > 0;\n}\npublic int nextBondInterestRate() {\nEconomicClimate ec = (EconomicClimate) w.get(ITEM.ECONOMIC_CLIMATE);\nreturn bonds + ec.getBaseInterestRate();\n}\npublic int[] bondInterestRates() {\nreturn null;\n}\n/** Returns the number of stock in the Treasury */\npublic int treasuryStock() {\nreturn stockInRRs[playerID];\n}\n/** Returns The number of open Shares */\npublic int totalShares() {\nreturn totalShares;\n}\npublic int sharesHeldByPublic(){\nint[]stock = getStockInThisRRs();\nint returnValue = this.totalShares;\nfor (int i = 0; i < stock.length; i++) {\nreturnValue -= stock[i];\n}\nreturn returnValue;\n}\npublic boolean thisRRHasStakeIn(int otherReId){\nreturn stockInRRs[otherReId] > 0;\n}\npublic Money netWorth() {\nNetWorthCalculator nwc = new NetWorthCalculator(w, principal);\nGameTime[] times = {GameTime.BIG_BANG, GameTime.END_OF_THE_WORLD};\nnwc.setTimes(times);\nreturn nwc.calculateValue();\n}\n@Override\nprotected boolean condition(int transactionID) {\n// We'll do the work when incrementRunningTotal gets called.\nreturn true;\n}\npublic int[] getStockInThisRRs() {\nif(null == stockInThisRRs){\nstockInThisRRs = new int[w.getNumberOfPlayers()];\nfor(int i = 0; i < w.getNumberOfPlayers(); i++){\nPlayer p = w.getPlayer(i);\nFinancialDataGatherer temp = new FinancialDataGatherer(w, p.getPrincipal());\nstockInThisRRs[i] = temp.stockInRRs[this.playerID];\n}\n}\nreturn stockInThisRRs;\n}\npublic int[] getStockInRRs() {\nreturn stockInRRs;\n}\npublic int getBonds() {\nreturn bonds;\n}\n}"}
{"className":"jfreerails.controller.SimpleAStarPathFinder","javaDoc":"/**\n* A simple A* pathfinder implementation. It uses int's to avoid the cost of\n* object creation and garbage collection. 26-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* A simple A* pathfinder implementation. It uses int's to avoid the cost of\n* object creation and garbage collection. 26-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/\npublic class SimpleAStarPathFinder implements Serializable,\nIncrementalPathFinder {\nprivate static final long serialVersionUID = 3257565105200576310L;\nprivate static final Logger logger = Logger\n.getLogger(SimpleAStarPathFinder.class.getName());\nprivate OpenList openList = new OpenList();\nprivate final HashSet<Integer> startingPositions = new HashSet<Integer>();\nprivate final HashMap<Integer, Integer> closedList = new HashMap<Integer, Integer>();\nprivate final HashMap<Integer, Integer> shortestPath = new HashMap<Integer, Integer>();\nprivate int status = SEARCH_NOT_STARTED;\n/** Note, IntArray is not Serializable. */\nprivate transient IntArray path = null;\nprivate int bestPath;\nprivate int bestPathF;\nprivate GraphExplorer explorer;\nprivate long searchStartTime = 0;\npublic int getStatus() {\nreturn status;\n}\npublic IntArray retrievePath() {\nreturn path;\n}\npublic int findstep(int currentPosition, int[] targets,\nGraphExplorer tempExplorer) {\ntry {\nreturn findpath(new int[] { currentPosition }, targets,\ntempExplorer).get(0);\n} catch (PathNotFoundException e) {\nreturn PATH_NOT_FOUND;\n}\n}\npublic IntArray findpath(int[] currentPosition, int[] targets,\nGraphExplorer e) throws PathNotFoundException {\nlogger.fine(currentPosition.length + \" starting points; \"\n+ targets.length + \" targets.\");\nsetupSearch(currentPosition, targets, e);\nsearch(-1);\nreturn path;\n}\npublic void search(long maxDuration) throws PathNotFoundException {\nlong iterationStartTime = 0;\nboolean check4timeout = false;\nif (maxDuration > 0) {\ncheck4timeout = true;\niterationStartTime = System.currentTimeMillis();\nif (searchStartTime == 0) {\nsearchStartTime = iterationStartTime;\n}\n}\nint loopCounter = 0;\n// while the open list is not empty\nwhile (openList.size() > 0) {\n// find the node with the least f on the open list, call it \"q\"\n// pop q off the open list\nint f = openList.smallestF();\nint q = openList.popNodeWithSmallestF();\n// generate q's successors.\nexplorer.setPosition(q);\n// for each successor\nwhile (explorer.hasNextEdge()) {\nexplorer.nextEdge();\nint successor = explorer.getVertexConnectedByEdge();\nint successorF = f + explorer.getEdgeCost();\n// for now, let successor.h=0\n// successor.g = q.g + distance between successor and q\n// successor.h = distance from goal to successor\n// successor.f = successor.g + successor.h\nif (startingPositions.contains(successor)) {\n// if successor is the goal, we have found a path, but not\n// necessarily the shortest.\nif (bestPathF > successorF) {\nbestPath = q;\nbestPathF = successorF;\n}\n}\nif (openList.contains(successor)\n&& openList.getF(successor) < successorF) {\n// if a node with the same position as successor is in the\n// OPEN list \\\n// which has a lower f than successor, skip this successor\ncontinue;\n} else if (closedList.containsKey(successor)\n&& closedList.get(successor) < successorF) {\n// if a node with the same position as successor is in the\n// CLOSED list \\\n// which has a lower f than successor, skip this successor\ncontinue;\n} else {\n// otherwise, add the node to the open list\nopenList.add(successor, successorF);\nshortestPath.put(successor, q);\n}\n}\nif (PATH_NOT_FOUND != bestPath) {\nint SmallestFOnOpenList = openList.smallestF();\nif (bestPathF <= SmallestFOnOpenList) {\n// if the F value for the best path we have found so far is\n// less than that of the node with the smallest F value on\n// the open list, then the best path so far is the shortest\n// path.\nlogger.fine(\"Path successfully found after \" + loopCounter\n+ \" iterations.\");\npath.add(bestPath);\nint step = bestPath;\nwhile (shortestPath.containsKey(step)) {\nstep = shortestPath.get(step);\npath.add(step);\n}\nlogger.fine(\"Path found!\");\nstatus = PATH_FOUND;\nreturn;\n}\n}\n// push q on the closed list\n// PositionOnTrack p = new PositionOnTrack(q);\nclosedList.put(q, f);\nloopCounter++;\n// Check whether we have been searching too long.\nif (check4timeout && loopCounter % 50 == 0) {\nlong currentTime = System.currentTimeMillis();\nlong deltatime = currentTime - iterationStartTime;\nif (deltatime > maxDuration) {\nstatus = SEARCH_PAUSED;\nlong totalSearchTime = currentTime - searchStartTime;\nthrow new PathNotFoundException(\"No path found yet. \"\n+ totalSearchTime + \"ms.\");\n}\n}\n}\nstatus = PATH_NOT_FOUND;\nlogger.fine(\"No path found and open list empty after \" + loopCounter\n+ \" iterations.\");\nthrow new PathNotFoundException(\"Path not found.\");\n}\npublic void setupSearch(int[] currentPosition, int[] targets,\nGraphExplorer e) throws PathNotFoundException {\nabandonSearch();\nexplorer = e;\n// put the starting nodes on the open list (you can leave its f at zero)\nfor (int i = 0; i < targets.length; i++) {\nopenList.add(targets[i], 0);\nfor (int j = 0; j < currentPosition.length; j++) {\nif (targets[i] == currentPosition[j]) {\nstatus = PATH_NOT_FOUND;\nthrow new PathNotFoundException(\"Already at target!\");\n}\n}\n}\nfor (int j = 0; j < currentPosition.length; j++) {\nstartingPositions.add(currentPosition[j]);\n}\n}\npublic void abandonSearch() {\npath = new IntArray();\nsearchStartTime = 0;\nbestPath = PATH_NOT_FOUND;\nbestPathF = Integer.MAX_VALUE;\n// initialize the open list\nopenList.clear();\n// initialize the closed list\nclosedList.clear();\nshortestPath.clear();\nstartingPositions.clear();\nstatus = SEARCH_NOT_STARTED;\n}\n}"}
{"className":"jfreerails.controller.MyDisplayMode","javaDoc":"/**\n* Stores a DisplayMode and provides a customised implementation of toString\n* that can be used in menus.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Stores a DisplayMode and provides a customised implementation of toString\n* that can be used in menus.\n*\n* @author Luke Lindsay\n*/\npublic class MyDisplayMode {\npublic final DisplayMode displayMode;\npublic MyDisplayMode(DisplayMode displayMode) {\nthis.displayMode = displayMode;\n}\n@Override\npublic String toString() {\nreturn displayMode.getWidth() + \"x\" + displayMode.getHeight() + \" \"\n+ displayMode.getBitDepth() + \" bit \"\n+ displayMode.getRefreshRate() + \"Hz\";\n}\n@Override\npublic int hashCode() {\nreturn displayMode.hashCode();\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof MyDisplayMode) {\nMyDisplayMode test = (MyDisplayMode) o;\nreturn test.displayMode.equals(this.displayMode);\n}\nreturn false;\n}\n}"}
{"className":"jfreerails.controller.CargoElementObject","javaDoc":"/**\n* Small data object to store the rate of supply of a cargo.\n*\n* @author Scott Bennett Date: 14 May 2003\n*/","code":"/**\n* Small data object to store the rate of supply of a cargo.\n*\n* @author Scott Bennett Date: 14 May 2003\n*/\npublic class CargoElementObject {\nprivate int rate;\nprivate final int type;\npublic CargoElementObject(int rate, int type) {\nthis.rate = rate;\nthis.type = type;\n}\npublic int getRate() {\nreturn rate;\n}\npublic void setRate(int rate) {\nthis.rate = rate;\n}\npublic int getType() {\nreturn type;\n}\n}"}
{"className":"jfreerails.controller.UnexpectedExceptionForm","javaDoc":"/**\n*\n* @author Luke\n*/","code":"/**\n*\n* @author Luke\n*/\npublic class UnexpectedExceptionForm extends javax.swing.JFrame {\nprivate static final long serialVersionUID = -4348641764811196495L;\n/** Creates new form UnexpectedExceptionForm */\npublic UnexpectedExceptionForm() {\ninitComponents();\n}\npublic void setText(String s){\ncopyableTextJPanel1.setText(s);\n}\n/** This method is called from within the constructor to\n* initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is\n* always regenerated by the Form Editor.\n*/\n// <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\nprivate void initComponents() {\njava.awt.GridBagConstraints gridBagConstraints;\ncopyableTextJPanel1 = new jfreerails.controller.CopyableTextJPanel();\nclosebutton = new javax.swing.JButton();\ngetContentPane().setLayout(new java.awt.GridBagLayout());\nsetDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\nsetTitle(\"Unexpected Exception\");\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\ngridBagConstraints.weightx = 1.0;\ngridBagConstraints.weighty = 1.0;\ngetContentPane().add(copyableTextJPanel1, gridBagConstraints);\nclosebutton.setText(\"Close\");\nclosebutton.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nclosebuttonActionPerformed(evt);\n}\n});\ngridBagConstraints = new java.awt.GridBagConstraints();\ngridBagConstraints.gridx = 0;\ngridBagConstraints.gridy = 1;\ngridBagConstraints.insets = new java.awt.Insets(7, 7, 7, 7);\ngetContentPane().add(closebutton, gridBagConstraints);\npack();\n}\n// </editor-fold>//GEN-END:initComponents\nprivate void closebuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closebuttonActionPerformed\nSystem.exit(1);\n}//GEN-LAST:event_closebuttonActionPerformed\n/**\n* @param args the command line arguments\n*/\npublic static void main(String args[]) {\njava.awt.EventQueue.invokeLater(new Runnable() {\npublic void run() {\nUnexpectedExceptionForm unexpectedExceptionForm = new UnexpectedExceptionForm();\nException e = new Exception(\"Oh No..\");\nString str = ReportBugTextGenerator.genText(e);\nunexpectedExceptionForm.setText(str);\nunexpectedExceptionForm.setVisible(true);\ne.printStackTrace();\n}\n});\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JButton closebutton;\njfreerails.controller.CopyableTextJPanel copyableTextJPanel1;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"jfreerails.controller.PreMoveStatus","javaDoc":"/**\n* Records the success or failure of an attempt to execute a move.\n*\n* @author lindsal\n*/","code":"/**\n* Records the success or failure of an attempt to execute a move.\n*\n* @author lindsal\n*/\nfinal public class PreMoveStatus implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3978145456646009140L;\npublic static final PreMoveStatus PRE_MOVE_OK = new PreMoveStatus(\nMoveStatus.MOVE_OK);\npublic final MoveStatus ms;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof PreMoveStatus))\nreturn false;\nfinal PreMoveStatus preMoveStatus = (PreMoveStatus) o;\nif (!ms.equals(preMoveStatus.ms))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn ms.hashCode();\n}\n/**\n* Avoid creating a duplicate when deserializing.\n*/\nprivate Object readResolve() {\nif (ms.ok) {\nreturn PRE_MOVE_OK;\n}\nreturn this;\n}\nprivate PreMoveStatus(MoveStatus ms) {\nthis.ms = ms;\n}\npublic static PreMoveStatus failed(String reason) {\nreturn new PreMoveStatus(MoveStatus.moveFailed(reason));\n}\npublic static PreMoveStatus fromMoveStatus(MoveStatus ms) {\nif (ms.ok) {\nreturn PRE_MOVE_OK;\n}\nreturn new PreMoveStatus(ms);\n}\n}"}
{"className":"jfreerails.controller.PreMove","javaDoc":"/**\n* Defines a method that generates a move based on the state of the world\n* object. The state of a move is often a function of the state of the world\n* object and some other input.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a method that generates a move based on the state of the world\n* object. The state of a move is often a function of the state of the world\n* object and some other input.\n*\n* @author Luke\n*\n*/\npublic interface PreMove extends FreerailsSerializable {\nMove generateMove(ReadOnlyWorld w);\n}"}
{"className":"jfreerails.controller.DropOffAndPickupCargoMoveGenerator","javaDoc":"/**\n* This class generates moves that transfer cargo between train and the stations\n* it stops at - it also handles cargo conversions that occur when cargo is\n* dropped off.\n*\n* @author Scott Bennett\n* @author Luke Lindsay Date Created: 4 June 2003\n*/","code":"/**\n* This class generates moves that transfer cargo between train and the stations\n* it stops at - it also handles cargo conversions that occur when cargo is\n* dropped off.\n*\n* @author Scott Bennett\n* @author Luke Lindsay Date Created: 4 June 2003\n*/\npublic class DropOffAndPickupCargoMoveGenerator {\nprivate final ReadOnlyWorld w;\nprivate final TrainAccessor train;\nprivate final int trainId;\nprivate int trainBundleId;\nprivate final int stationId;\nprivate int stationBundleId;\nprivate MutableCargoBundle stationAfter;\nprivate MutableCargoBundle stationBefore;\nprivate MutableCargoBundle trainAfter;\nprivate MutableCargoBundle trainBefore;\nprivate ArrayList<Move> moves;\nprivate final FreerailsPrincipal principal;\nprivate boolean waitingForFullLoad;\nprivate boolean autoConsist;\nprivate ImInts consist = new ImInts();\n/**\n* Stores the type and quantity of cargo in a wagon.\n*\n* @author Luke\n*/\nprivate static class WagonLoad implements Comparable<WagonLoad> {\nfinal int quantity;\nfinal int cargoType;\npublic int compareTo(WagonLoad test) {\nreturn quantity - test.quantity;\n}\nWagonLoad(int q, int t) {\nquantity = q;\ncargoType = t;\n}\n}\n/**\n* Constructor.\n*\n* @param trainNo\n* ID of the train\n* @param stationNo\n* ID of the station\n* @param world\n* The world object\n*/\npublic DropOffAndPickupCargoMoveGenerator(int trainNo, int stationNo, ReadOnlyWorld world,\nFreerailsPrincipal p, boolean waiting, boolean autoConsist) {\nprincipal = p;\ntrainId = trainNo;\nstationId = stationNo;\nw = world;\nthis.autoConsist = autoConsist;\nthis.waitingForFullLoad = waiting;\ntrain = new TrainAccessor(w, principal, trainNo);\nconsist = train.getTrain().getConsist();\ngetBundles();\nprocessTrainBundle(); // ie. unload train / dropoff cargo\nif (autoConsist) {\nArrayList<WagonLoad> wagonsAvailable = new ArrayList<WagonLoad>();\nassert (train.equals(world.get(principal, KEY.TRAINS, this.trainId)));\nSchedule schedule = train.getSchedule();\nTrainOrdersModel order = schedule.getOrder(schedule.getOrderToGoto());\nint nextStationId = order.stationId;\nStationModel stationModel = (StationModel) w\n.get(principal, KEY.STATIONS, nextStationId);\nDemand4Cargo demand = stationModel.getDemand();\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\n// If this cargo is demanded at the next scheduled station.\nif (demand.isCargoDemanded(i)) {\nint amount = stationAfter.getAmount(i);\nwhile (amount > 0) {\nint amount2remove = Math.min(amount, WagonType.UNITS_OF_CARGO_PER_WAGON);\namount -= amount2remove;\n// Don't bother with less than half a wagon load.\nif (amount2remove * 2 > WagonType.UNITS_OF_CARGO_PER_WAGON) {\nwagonsAvailable.add(new WagonLoad(amount2remove, i));\n}\n}\n}\n}\nCollections.sort(wagonsAvailable);\nint numWagons2add = Math.min(wagonsAvailable.size(), 3);\nint[] temp = new int[numWagons2add];\nfor (int i = 0; i < numWagons2add; i++) {\nWagonLoad wagonload = wagonsAvailable.get(i);\ntemp[i] = wagonload.cargoType;\n}\nconsist = new ImInts(temp);\n}\nprocessStationBundle(); // ie. load train / pickup cargo\n}\npublic Move generateMove() {\n// The methods that calculate the before and after bundles could be\n// called from here.\nChangeCargoBundleMove changeAtStation = new ChangeCargoBundleMove(stationBefore\n.toImmutableCargoBundle(), stationAfter.toImmutableCargoBundle(), stationBundleId,\nprincipal);\nChangeCargoBundleMove changeOnTrain = new ChangeCargoBundleMove(trainBefore\n.toImmutableCargoBundle(), trainAfter.toImmutableCargoBundle(), trainBundleId,\nprincipal);\nmoves.add(TransferCargoAtStationMove.CHANGE_AT_STATION_INDEX, changeAtStation);\nmoves.add(TransferCargoAtStationMove.CHANGE_ON_TRAIN_INDEX, changeOnTrain);\nif (autoConsist) {\nint engine = train.getTrain().getEngineType();\nMove m = ChangeTrainMove.generateMove(this.trainId, train.getTrain(), engine, consist, principal);\nmoves.add(m);\n} else if (waitingForFullLoad) {\n// Only generate a move if there is some cargo to add..\nif (changeOnTrain.beforeEqualsAfter())\nreturn null;\n}\nTransferCargoAtStationMove move = new TransferCargoAtStationMove(moves, waitingForFullLoad);\nassert move.getChangeAtStation() == changeAtStation;\nassert move.getChangeOnTrain() == changeOnTrain;\nreturn move;\n}\nprivate void getBundles() {\nTrainModel trainModel = ((TrainModel) w.get(principal, KEY.TRAINS, trainId));\ntrainBundleId = trainModel.getCargoBundleID();\ntrainBefore = getCopyOfBundle(trainBundleId);\ntrainAfter = getCopyOfBundle(trainBundleId);\nStationModel stationModel = ((StationModel) w.get(principal, KEY.STATIONS, stationId));\nstationBundleId = stationModel.getCargoBundleID();\nstationAfter = getCopyOfBundle(stationBundleId);\nstationBefore = getCopyOfBundle(stationBundleId);\n}\nprivate MutableCargoBundle getCopyOfBundle(int id) {\nFreerailsSerializable fs = w.get(principal, KEY.CARGO_BUNDLES, id);\nImmutableCargoBundle ibundle = (ImmutableCargoBundle) fs;\nreturn new MutableCargoBundle(ibundle);\n}\nprivate void processTrainBundle() {\nIterator<CargoBatch> batches = trainAfter.toImmutableCargoBundle().cargoBatchIterator();\nStationModel station = (StationModel) w.get(principal, KEY.STATIONS, stationId);\nMutableCargoBundle cargoDroppedOff = new MutableCargoBundle();\n// Unload the cargo that the station demands\nwhile (batches.hasNext()) {\nCargoBatch cb = batches.next();\n// if the cargo is demanded and its not from this station\n// originally...\nDemand4Cargo demand = station.getDemand();\nint cargoType = cb.getCargoType();\nif ((demand.isCargoDemanded(cargoType)) && (stationId != cb.getStationOfOrigin())) {\nint amount = trainAfter.getAmount(cb);\ncargoDroppedOff.addCargo(cb, amount);\n// Now perform any conversions..\nConvertedAtStation converted = station.getConverted();\nif (converted.isCargoConverted(cargoType)) {\nint newCargoType = converted.getConversion(cargoType);\nCargoBatch newCargoBatch = new CargoBatch(newCargoType, station.x, station.y,\n0, stationId);\nstationAfter.addCargo(newCargoBatch, amount);\n}\ntrainAfter.setAmount(cb, 0);\n}\n}\nmoves = ProcessCargoAtStationMoveGenerator.processCargo(w, cargoDroppedOff, this.stationId,\nprincipal, trainId);\n// Unload the cargo that there isn't space for on the train regardless\n// of whether the station\n// demands it.\nImInts spaceAvailable = train.spaceAvailable();\nfor (int cargoType = 0; cargoType < spaceAvailable.size(); cargoType++) {\nint quantity = spaceAvailable.get(cargoType);\nif (quantity < 0) {\nint amount2transfer = -quantity;\ntransferCargo(cargoType, amount2transfer, trainAfter, stationAfter);\n}\n}\n}\n/** Transfer cargo from the station to the train subject to the space available on the train.\n*/\nprivate void processStationBundle() {\nImInts spaceAvailable = TrainAccessor.spaceAvailable2(w, trainAfter.toImmutableCargoBundle(), consist);\nfor (int cargoType = 0; cargoType < spaceAvailable.size(); cargoType++) {\nint quantity = spaceAvailable.get(cargoType);\nint amount2transfer = Math.min(quantity, stationAfter\n.getAmount(cargoType));\ntransferCargo(cargoType, amount2transfer, stationAfter, trainAfter);\n}\n}\npublic boolean isCargo2Transfer() {\nImInts spaceAvailable = train.spaceAvailable();\nint total = 0;\nfor (int cargoType = 0; cargoType < w.size(SKEY.CARGO_TYPES); cargoType++) {\nint quantity = spaceAvailable.get(cargoType);\nint amount2transfer = Math.min(quantity, stationAfter\n.getAmount(cargoType));\ntotal += amount2transfer;\n}\nreturn total > 0;\n}\n/**\n* Move the specified quantity of the specified cargotype from one bundle to\n* another.\n*/\nprivate static void transferCargo(int cargoTypeToTransfer, int amountToTransfer,\nMutableCargoBundle from, MutableCargoBundle to) {\nif (0 == amountToTransfer) {\nreturn;\n}\nIterator<CargoBatch> batches = from.toImmutableCargoBundle().cargoBatchIterator();\nint amountTransferredSoFar = 0;\nwhile (batches.hasNext() && amountTransferredSoFar < amountToTransfer) {\nCargoBatch cb = batches.next();\nif (cb.getCargoType() == cargoTypeToTransfer) {\nint amount = from.getAmount(cb);\nint amountOfThisBatchToTransfer;\nif (amount < amountToTransfer - amountTransferredSoFar) {\namountOfThisBatchToTransfer = amount;\nfrom.setAmount(cb, 0);\n} else {\namountOfThisBatchToTransfer = amountToTransfer - amountTransferredSoFar;\nfrom.addCargo(cb, -amountOfThisBatchToTransfer);\n}\nto.addCargo(cb, amountOfThisBatchToTransfer);\namountTransferredSoFar += amountOfThisBatchToTransfer;\n}\n}\n}\n}"}
{"className":"jfreerails.controller.MoveExecutor","javaDoc":"/**\n* Lets the caller try and execute Moves.\n*\n* @author Luke\n*\n*/","code":"/**\n* Lets the caller try and execute Moves.\n*\n* @author Luke\n*\n*/\npublic interface MoveExecutor {\nMoveStatus doMove(Move m);\nMoveStatus doPreMove(PreMove pm);\nMoveStatus tryDoMove(Move m);\nReadOnlyWorld getWorld();\nFreerailsPrincipal getPrincipal();\n}"}
{"className":"jfreerails.controller.MessageStatus","javaDoc":"/**\n* An instance of this class is returned to the client (the server) when a\n* Message2Server (Message2Client) is executed by the server (the client).\n*\n* @see Message2Client\n* @see Message2Server\n* @author Luke\n*\n*/","code":"/**\n* An instance of this class is returned to the client (the server) when a\n* Message2Server (Message2Client) is executed by the server (the client).\n*\n* @see Message2Client\n* @see Message2Server\n* @author Luke\n*\n*/\npublic class MessageStatus implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257285842216103987L;\nprivate final int id;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof MessageStatus))\nreturn false;\nfinal MessageStatus messageStatus = (MessageStatus) o;\nif (id != messageStatus.id)\nreturn false;\nif (successful != messageStatus.successful)\nreturn false;\nif (reason != null ? !reason.equals(messageStatus.reason)\n: messageStatus.reason != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = id;\nresult = 29 * result + (reason != null ? reason.hashCode() : 0);\nresult = 29 * result + (successful ? 1 : 0);\nreturn result;\n}\nprivate final String reason;\nprivate final boolean successful;\npublic MessageStatus(int id, boolean successful, String reason) {\nthis.id = id;\nthis.reason = reason;\nthis.successful = successful;\n}\npublic MessageStatus(int id, boolean successful) {\nthis.id = id;\nthis.reason = null;\nthis.successful = successful;\n}\n/** Returns the id of the command whose status this object stores. */\npublic int getId() {\nreturn id;\n}\n/** Returns the reason the command failed, may be null. */\npublic String getReason() {\nreturn reason;\n}\n/** True if the command was successfully executed. */\npublic boolean isSuccessful() {\nreturn successful;\n}\n}"}
{"className":"jfreerails.controller.ServerControlInterface","javaDoc":"/**\n* Defines the methods that a client can call on the server using a\n* Message2Server.\n*\n* @see Message2Server\n* @author Luke\n*\n*/","code":"/**\n* Defines the methods that a client can call on the server using a\n* Message2Server.\n*\n* @see Message2Server\n* @author Luke\n*\n*/\npublic interface ServerControlInterface {\npublic static final String FREERAILS_SAV = \"freerails.sav\";\npublic static final String VERSION = \"CVS\";\nvoid loadgame(String saveGameName) throws IOException;\nvoid savegame(String saveGameName);\nvoid stopGame();\nvoid refreshSavedGames();\nvoid newGame(String mapName);\n}"}
{"className":"jfreerails.controller.SimpleMoveExecutor","javaDoc":"/**\n* A MoveExecutor that executes moves on the world object passed to its\n* constructor.\n*\n* @author Luke\n*\n*/","code":"/**\n* A MoveExecutor that executes moves on the world object passed to its\n* constructor.\n*\n* @author Luke\n*\n*/\npublic class SimpleMoveExecutor implements MoveExecutor {\nprivate final World w;\nprivate final FreerailsPrincipal p;\npublic SimpleMoveExecutor(World world, int playerID) {\nw = world;\nPlayer player = w.getPlayer(playerID);\np = player.getPrincipal();\n}\npublic MoveStatus doMove(Move m) {\nreturn m.doMove(w, p);\n}\npublic MoveStatus doPreMove(PreMove pm) {\nMove m = pm.generateMove(w);\nreturn m.doMove(w, p);\n}\npublic MoveStatus tryDoMove(Move m) {\nreturn m.tryDoMove(w, p);\n}\npublic ReadOnlyWorld getWorld() {\nreturn w;\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn p;\n}\n}"}
{"className":"jfreerails.controller.TrainAccessor","javaDoc":"/**\n* Provides convenience methods to access the properties of a train from the\n* world object.\n*\n* @author Luke\n*\n*/","code":"/**\n* Provides convenience methods to access the properties of a train from the\n* world object.\n*\n* @author Luke\n*\n*/\npublic class TrainAccessor {\nprivate final ReadOnlyWorld w;\nprivate final FreerailsPrincipal p;\nprivate final int id;\npublic TrainAccessor(final ReadOnlyWorld w, final FreerailsPrincipal p,\nfinal int id) {\nthis.w = w;\nthis.p = p;\nthis.id = id;\n}\npublic int getId() {\nreturn id;\n}\npublic SpeedTimeAndStatus.TrainActivity getStatus(double time){\nTrainMotion tm = findCurrentMotion(time);\nreturn tm.getActivity();\n}\n/**\n* Checks the track under the train's final position still exists (i.e.\n* has not been bulldozed).\n*/\npublic boolean trackExists() {\nActivityIterator ai = w.getActivities(p, id);\nai.gotoLastActivity();\nTrainMotion tm = (TrainMotion) ai.getActivity();\nPositionOnTrack pot = tm.getFinalPosition();\nint x = pot.getX();\nint y = pot.getY();\nFreerailsTile tile = (FreerailsTile) w.getTile(x, y);\nTrackPiece trackPiece = tile.getTrackPiece();\nTrackConfiguration present = trackPiece.getTrackConfiguration();\nTrackConfiguration needed = TrackConfiguration.getFlatInstance(pot.cameFrom());\nreturn present.contains(needed);\n}\n/**\n* @return the id of the station the train is currently at, or -1 if no\n* current station.\n*\n*/\npublic int getStationId(double time){\nTrainMotion tm = findCurrentMotion(time);\nPositionOnTrack pot = tm.getFinalPosition();\nint x = pot.getX();\nint y = pot.getY();\n//loop thru the station list to check if train is at the same Point\n// as\n// a station\nfor (int i = 0; i < w.size(p, KEY.STATIONS); i++) {\nStationModel tempPoint = (StationModel) w.get(p, KEY.STATIONS, i);\nif (null != tempPoint && (x == tempPoint.x) && (y == tempPoint.y)) {\nreturn i; // train is at the station at location tempPoint\n}\n}\nreturn -1;\n}\npublic TrainPositionOnMap findPosition(double time) {\nActivityIterator ai = w.getActivities(p, id);\nai.gotoLastActivity();\nwhile (ai.getStartTime() > time && ai.hasPrevious()) {\nai.previousActivity();\n}\ndouble dt = time - ai.getStartTime();\ndt = Math.min(dt, ai.getDuration());\nTrainMotion tm = (TrainMotion) ai.getActivity();\nreturn tm.getState(dt);\n}\npublic TrainMotion findCurrentMotion(double time) {\nActivityIterator ai = w.getActivities(p, id);\nai.gotoLastActivity();\nwhile (ai.getStartTime() > time && ai.hasPrevious()) {\nai.previousActivity();\n}\nreturn (TrainMotion) ai.getActivity();\n}\npublic TrainModel getTrain() {\nreturn (TrainModel) w.get(p, KEY.TRAINS, id);\n}\npublic ImmutableSchedule getSchedule() {\nTrainModel train = getTrain();\nreturn (ImmutableSchedule) w.get(p, KEY.TRAIN_SCHEDULES, train\n.getScheduleID());\n}\npublic ImmutableCargoBundle getCargoBundle() {\nTrainModel train = getTrain();\nreturn (ImmutableCargoBundle) w.get(p, KEY.CARGO_BUNDLES, train\n.getCargoBundleID());\n}\n/**\n* Returns true iff all the following hold.\n* <ol>\n* <li>The train is waiting for a full load at some station X.</li>\n* <li>The current train order tells the train to goto station X.</li>\n* <li>The current train order tells the train to wait for a full load.</li>\n* <li>The current train order specifies a consist that matches the train's current consist.</li>\n* </ol>\n*\n*/\npublic boolean keepWaiting(){\ndouble time = w.currentTime().getTicks();\nint stationId = getStationId(time);\nif (stationId == -1)\nreturn false;\nSpeedTimeAndStatus.TrainActivity act = getStatus(time);\nif (act != TrainActivity.WAITING_FOR_FULL_LOAD)\nreturn false;\nImmutableSchedule schedule = getSchedule();\nif(schedule.getNumOrders() <1){\n//We end up here if all the train orders are deleted while a train\n//is waiting for a full load.\nreturn false;\n}\nTrainOrdersModel order = schedule.getOrder(schedule.getOrderToGoto());\nif (order.stationId != stationId)\nreturn false;\nif (!order.waitUntilFull)\nreturn false;\nTrainModel train = getTrain();\nreturn order.getConsist().equals(train.getConsist());\n}\n/**\n* @return the location of the station the train is currently heading\n* towards.\n*/\npublic ImPoint getTarget() {\nTrainModel train = (TrainModel) w.get(p, KEY.TRAINS, id);\nint scheduleID = train.getScheduleID();\nImmutableSchedule schedule = (ImmutableSchedule) w.get(\np, KEY.TRAIN_SCHEDULES, scheduleID);\nint stationNumber = schedule.getStationToGoto();\nif (-1 == stationNumber) {\n// There are no stations on the schedule.\nreturn new ImPoint(0, 0);\n}\nStationModel station = (StationModel) w.get(p,\nKEY.STATIONS, stationNumber);\nreturn new ImPoint(station.x, station.y);\n}\npublic HashSet<TrackSection> occupiedTrackSection(double time){\nTrainMotion tm = findCurrentMotion(time);\nPathOnTiles path = tm.getPath();\nHashSet<TrackSection> sections = new HashSet<TrackSection>();\nImPoint start = path.getStart();\nint x = start.x;\nint y = start.y;\nfor (int i = 0; i < path.steps(); i++) {\nStep s = path.getStep(i);\nImPoint tile = new ImPoint(x, y);\nx+=s.deltaX;\ny+=s.deltaY;\nsections.add(new TrackSection(s, tile));\n}\nreturn sections;\n}\npublic boolean isMoving(double time){\nTrainMotion tm = findCurrentMotion(time);\ndouble speed = tm.getSpeedAtEnd();\nreturn speed != 0;\n}\n/** The space available on the train measured in cargo units.*/\npublic ImInts spaceAvailable(){\nTrainModel train = (TrainModel) w.get(p, KEY.TRAINS, id);\nImmutableCargoBundle bundleOnTrain = (ImmutableCargoBundle) w.get(p,\nKEY.CARGO_BUNDLES, train.getCargoBundleID());\nreturn spaceAvailable2(w, bundleOnTrain, train.getConsist());\n}\npublic static ImInts spaceAvailable2(ReadOnlyWorld row, ImmutableCargoBundle onTrain, ImInts consist){\n// This array will store the amount of space available on the train for\n// each cargo type.\nfinal int NUM_CARGO_TYPES = row.size(SKEY.CARGO_TYPES);\nint[] spaceAvailable = new int[NUM_CARGO_TYPES];\n// First calculate the train's total capacity.\nfor (int j = 0; j < consist.size(); j++) {\nint cargoType = consist.get(j);\nspaceAvailable[cargoType] += WagonType.UNITS_OF_CARGO_PER_WAGON;\n}\nfor (int cargoType = 0; cargoType < NUM_CARGO_TYPES; cargoType++) {\nspaceAvailable[cargoType]= spaceAvailable[cargoType] - onTrain.getAmount(cargoType);\n}\nreturn new ImInts(spaceAvailable);\n}\n}"}
{"className":"jfreerails.controller.ScreenHandler","javaDoc":"/**\n* Handles going into fullscreen mode and setting buffer strategy etc.\n*\n* @author Luke\n*/","code":"/**\n* Handles going into fullscreen mode and setting buffer strategy etc.\n*\n* @author Luke\n*/\nfinal public class ScreenHandler {\nprivate static final Logger logger = Logger.getLogger(ScreenHandler.class\n.getName());\npublic static final int FULL_SCREEN = 0;\npublic static final int WINDOWED_MODE = 1;\npublic static final int FIXED_SIZE_WINDOWED_MODE = 2;\npublic final JFrame frame;\nprivate BufferStrategy bufferStrategy;\nprivate DisplayMode displayMode;\nprivate final int mode;\nprivate boolean isInUse = false;\n/** Whether the window is minimised. */\nprivate boolean isMinimised = false;\nstatic GraphicsDevice device = GraphicsEnvironment\n.getLocalGraphicsEnvironment().getDefaultScreenDevice();\npublic ScreenHandler(JFrame f, int mode, DisplayMode displayMode) {\nthis.displayMode = displayMode;\nframe = f;\nthis.mode = mode;\n}\npublic ScreenHandler(JFrame f, int mode) {\nframe = f;\nthis.mode = mode;\n}\nprivate static void goFullScreen(JFrame frame, DisplayMode displayMode) {\nsetRepaintOffAndDisableDoubleBuffering(frame);\n/*\n* We need to make the frame not displayable before calling\n* setUndecorated(true) otherwise a\n* java.awt.IllegalComponentStateException will get thrown.\n*/\nif (frame.isDisplayable()) {\nframe.dispose();\n}\nframe.setUndecorated(true);\ndevice.setFullScreenWindow(frame);\nif (device.isDisplayChangeSupported()) {\nif (null == displayMode) {\ndisplayMode = getBestDisplayMode();\n}\nlogger.info(\"Setting display mode to: \"\n+ (new MyDisplayMode(displayMode).toString()));\ndevice.setDisplayMode(displayMode);\n}\nframe.validate();\n}\npublic synchronized void apply() {\nswitch (mode) {\ncase FULL_SCREEN: {\ngoFullScreen(frame, displayMode);\nbreak;\n}\ncase WINDOWED_MODE: {\n// Some of the dialogue boxes do not get layed out properly if they\n// are smaller than their\n// minimum size. JFrameMinimumSizeEnforcer increases the size of the\n// Jframe when its size falls\n// below the specified size.\nframe.addComponentListener(new JFrameMinimumSizeEnforcer(640, 480));\nframe.setSize(640, 480);\nframe.setVisible(true);\nbreak;\n}\ncase FIXED_SIZE_WINDOWED_MODE: {\n/*\n* We need to make the frame not displayable before calling\n* setUndecorated(true) otherwise a\n* java.awt.IllegalComponentStateException will get thrown.\n*/\nif (frame.isDisplayable()) {\nframe.dispose();\n}\nframe.setUndecorated(true);\nframe.setResizable(false);\nframe.setSize(640, 480);\nframe.setVisible(true);\nbreak;\n}\ndefault:\nthrow new IllegalArgumentException(String.valueOf(mode));\n}\ncreateBufferStrategy();\nframe.addComponentListener(new java.awt.event.ComponentAdapter() {\n@Override\npublic void componentResized(java.awt.event.ComponentEvent evt) {\ncreateBufferStrategy();\n}\n});\nframe.addWindowListener(new WindowAdapter() {\n@Override\npublic void windowIconified(WindowEvent e) {\nisMinimised = true;\n}\n@Override\npublic void windowDeiconified(WindowEvent e) {\nisMinimised = false;\n}\n});\nisInUse = true;\n}\nprivate synchronized void createBufferStrategy() {\n// Use 2 backbuffers to avoid using too much VRAM.\nframe.createBufferStrategy(2);\nbufferStrategy = frame.getBufferStrategy();\nsetRepaintOffAndDisableDoubleBuffering(frame);\n}\npublic synchronized Graphics getDrawGraphics() {\nreturn bufferStrategy.getDrawGraphics();\n}\npublic synchronized void swapScreens() {\nif (!bufferStrategy.contentsLost()) {\nbufferStrategy.show();\n}\n}\nprivate static void setRepaintOffAndDisableDoubleBuffering(Component c) {\nc.setIgnoreRepaint(true);\n// Since we are using a buffer strategy we don't want Swing\n// to double buffer any JComponents.\nif (c instanceof JComponent) {\nJComponent jComponent = (JComponent) c;\njComponent.setDoubleBuffered(false);\n}\nif (c instanceof java.awt.Container) {\nComponent[] children = ((Container) c).getComponents();\nfor (int i = 0; i < children.length; i++) {\nsetRepaintOffAndDisableDoubleBuffering(children[i]);\n}\n}\n}\nprivate static DisplayMode getBestDisplayMode() {\nfor (int x = 0; x < BEST_DISPLAY_MODES.length; x++) {\nDisplayMode[] modes = device.getDisplayModes();\nfor (int i = 0; i < modes.length; i++) {\nif (modes[i].getWidth() == BEST_DISPLAY_MODES[x].getWidth()\n&& modes[i].getHeight() == BEST_DISPLAY_MODES[x]\n.getHeight()\n&& modes[i].getBitDepth() == BEST_DISPLAY_MODES[x]\n.getBitDepth()) {\nlogger.fine(\"Best display mode is \"\n+ (new MyDisplayMode(BEST_DISPLAY_MODES[x]))\n.toString());\nreturn BEST_DISPLAY_MODES[x];\n}\n}\n}\nreturn null;\n}\nprivate static final DisplayMode[] BEST_DISPLAY_MODES = new DisplayMode[] {\nnew DisplayMode(640, 400, 8, 60),\nnew DisplayMode(800, 600, 16, 60),\nnew DisplayMode(1024, 768, 8, 60),\nnew DisplayMode(1024, 768, 16, 60), };\npublic synchronized boolean isMinimised() {\nreturn isMinimised;\n}\npublic synchronized boolean isInUse() {\nreturn isInUse;\n}\npublic synchronized static void exitFullScreenMode(){\ndevice.setFullScreenWindow(null);\n}\npublic boolean contentsRestored() {\nreturn bufferStrategy.contentsRestored();\n}\n}"}
{"className":"jfreerails.controller.FinancialMoveProducer","javaDoc":"/**\n* Not yet implemented\n*\n* @author Luke\n*\n*/","code":"/**\n* Not yet implemented\n*\n* @author Luke\n*\n*/\npublic class FinancialMoveProducer {\npublic static final Money IPO_SHARE_PRICE = new Money(5);\npublic static final int SHARE_BUNDLE_SIZE = 10000;\npublic static final int IPO_SIZE = SHARE_BUNDLE_SIZE * 10;\nFinancialMoveProducer(ReadOnlyWorld row) {\n}\nEconomicClimate worsen() {\nreturn null;\n}\nEconomicClimate improve() {\nreturn null;\n}\n}"}
{"className":"experimental.TrackRenderer","javaDoc":"/**\n* Provides methods that render track pieces.\n*\n* @see experimental.TrackTilesGenerator\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Provides methods that render track pieces.\n*\n* @see experimental.TrackTilesGenerator\n* @author Luke Lindsay\n*\n*/\npublic class TrackRenderer {\nprivate final ImageManager imageManager = new ImageManagerImpl(\n\"/jfreerails/client/graphics/\");\nColor sleepersColor = new Color(118, 54, 36);\nColor railsColor = new Color(118, 118, 118);\ndouble sleeperLength = 6;\nfloat sleeperWidth = 2f;\nfloat targetSleeperGap = 2.5f;\nfloat tileWidth = 30f;\nfloat gauge = 3f;\nBasicStroke rail = new BasicStroke(1f);\nboolean doubleTrack = false;\nfloat doubleTrackGap = 4f;\nImage icon = null;\nboolean tunnel = false;\nvoid paintTrackConf(Graphics2D g2, TrackConfiguration conf) {\ng2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\nRenderingHints.VALUE_ANTIALIAS_ON);\n// Draw title\n// String title = BinaryNumberFormatter.formatWithLowBitOnLeft(conf\n// .get9bitTemplate(), 9);\n// g.setColor(Color.BLACK);\n// g.setFont(font);\n//\n// g.drawString(title, 10, 10);\nStep[] directions = Step.getList();\nList<CubicCurve2D.Double> sections = new ArrayList<CubicCurve2D.Double>();\nint matches = 0;\nfor (int i = 0; i < directions.length - 2; i++) {\nif (conf.contains(directions[i])) {\n// System.out.println(\"\\n\"+directions[i]+\" to ..\");\nint maxJ = Math.min(i + 7, directions.length);\nfor (int j = i + 2; j < maxJ; j++) {\n// System.out.println(directions[j]);\nif (conf.contains(directions[j])) {\nDouble toCurve = toCurve(directions[i], directions[j]);\nif (doubleTrack) {\nsections.add(createAdjacentCurve(toCurve,\ndoubleTrackGap, doubleTrackGap));\nsections.add(createAdjacentCurve(toCurve,\n-doubleTrackGap, -doubleTrackGap));\n} else {\nsections.add(toCurve);\n}\nmatches++;\n}\n}\n}\n}\nif (matches == 0) {\nfor (int i = 0; i < directions.length; i++) {\nif (conf.contains(directions[i])) {\nDouble toCurve = toCurve(directions[i]);\nif (doubleTrack) {\nsections.add(createAdjacentCurve(toCurve,\ndoubleTrackGap, doubleTrackGap));\nsections.add(createAdjacentCurve(toCurve,\n-doubleTrackGap, -doubleTrackGap));\n} else {\nsections.add(toCurve);\n}\n}\n}\n}\npaintTrack(g2, sections);\n}\nCubicCurve2D.Double toCurve(Step a) {\nfloat halfTile = tileWidth / 2;\nPoint2D.Double start, end, one;\nstart = new Point2D.Double();\nstart.x = tileWidth + (halfTile * a.deltaX);\nstart.y = tileWidth + (halfTile * a.deltaY);\none = controlPoint(start);\nend = new Point2D.Double(tileWidth, tileWidth);\nCubicCurve2D.Double returnValue = new CubicCurve2D.Double();\nreturnValue.setCurve(start, one, one, end);\nreturn returnValue;\n}\nCubicCurve2D.Double toCurve(Step a, Step b) {\nfloat halfTile = tileWidth / 2;\nPoint2D.Double start, end, one, two;\nstart = new Point2D.Double();\nstart.x = tileWidth + (halfTile * a.deltaX);\nstart.y = tileWidth + (halfTile * a.deltaY);\none = controlPoint(start);\nend = new Point2D.Double();\nend.x = tileWidth + (halfTile * b.deltaX);\nend.y = tileWidth + (halfTile * b.deltaY);\ntwo = controlPoint(end);\nCubicCurve2D.Double returnValue = new CubicCurve2D.Double();\nreturnValue.setCurve(start, one, two, end);\nreturn returnValue;\n}\nvoid paintTrack(Graphics2D g, List<CubicCurve2D.Double> sections) {\ng.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\nRenderingHints.VALUE_ANTIALIAS_ON);\nif (!tunnel) {\n// Draw sleepers\ng.setColor(sleepersColor);\nfor (CubicCurve2D.Double section : sections) {\nBasicStroke dashed = getStroke4Curve(section);\ng.setStroke(dashed);\ng.draw(section);\n}\ng.setColor(railsColor);\n} else {\ng.setColor(Color.BLACK);\n}\n// Draw rails\ng.setStroke(rail);\nfor (CubicCurve2D.Double section : sections) {\nfloat halfGauge = gauge / 2;\nCubicCurve2D.Double rail1 = createAdjacentCurve(section, halfGauge,\nhalfGauge);\nCubicCurve2D.Double rail2 = createAdjacentCurve(section,\n-halfGauge, -halfGauge);\ng.draw(rail1);\ng.draw(rail2);\n}\n}\n/**\n* Generates the Stroke used to draw the sleepers for track section\n* represented by the specified curve.\n*/\npublic BasicStroke getStroke4Curve(CubicCurve2D.Double curve) {\nPathIterator fpt = curve.getPathIterator(new AffineTransform(), 0.01);\ndouble length = 0;\ndouble[] coords = new double[6];\ndouble x, y;\nfpt.currentSegment(coords);\ndouble lastX = coords[0];\ndouble lastY = coords[1];\nfor (; !fpt.isDone(); fpt.next()) {\nfpt.currentSegment(coords);\nx = coords[0];\ny = coords[1];\ndouble dx = x - lastX;\ndouble dy = y - lastY;\nlength += Math.sqrt(dx * dx + dy * dy);\nlastX = x;\nlastY = y;\n}\nfloat sleepers = (float) length / (targetSleeperGap + sleeperWidth);\nfloat sleeperCount = (int) sleepers;\nfloat sleeperGap = (float) length / sleeperCount - sleeperWidth;\nfloat dash1[] = { sleeperWidth, sleeperGap };\nfloat phase = sleeperWidth + (sleeperGap / 2);\nreturn new BasicStroke((float) sleeperLength, BasicStroke.CAP_BUTT,\nBasicStroke.JOIN_MITER, 10.0f, dash1, phase);\n}\npublic static Line2D.Double createParallelLine(Line2D.Double line,\ndouble shift) {\nLine2D.Double returnValue = new Line2D.Double(line.getP1(), line\n.getP2());\ndouble distance = line.getP1().distance(line.getP2());\ndouble dRatio = shift / distance;\ndouble dx = (line.x1 - line.x2) * dRatio;\ndouble dy = (line.y1 - line.y2) * dRatio;\nreturnValue.x1 -= dy;\nreturnValue.y1 += dx;\nreturnValue.x2 -= dy;\nreturnValue.y2 += dx;\nreturn returnValue;\n}\npublic static CubicCurve2D.Double createAdjacentCurve(\nCubicCurve2D.Double c, double shift1, double shift2) {\nLine2D.Double line1 = new Line2D.Double(c.getX1(), c.getY1(), c\n.getCtrlX1(), c.getCtrlY1());\nLine2D.Double line2 = new Line2D.Double(c.getX2(), c.getY2(), c\n.getCtrlX2(), c.getCtrlY2());\nline1 = createParallelLine(line1, shift1);\nline2 = createParallelLine(line2, -shift2);\nreturn new CubicCurve2D.Double(line1.x1, line1.y1, line1.x2, line1.y2,\nline2.x2, line2.y2, line2.x1, line2.y1);\n}\nprivate Point2D.Double controlPoint(Point2D.Double from) {\ndouble weight = 0.3;\ndouble x = from.getX() * weight + tileWidth * (1 - weight);\ndouble y = from.getY() * weight + tileWidth * (1 - weight);\nreturn new Point2D.Double(x, y);\n}\nvoid setIcon(String typeName) {\ntry {\nString relativeFileName = \"icons\" + File.separator + typeName\n+ \".png\";\nrelativeFileName = relativeFileName.replace(' ', '_');\nImage im = imageManager.getImage(relativeFileName);\nicon = im;\n} catch (IOException e) {\ne.printStackTrace();\nthrow new IllegalStateException(e);\n}\n}\n}"}
{"className":"experimental.SimpleComponentFactoryImpl2","javaDoc":"/**\n* This GUIComponentFactory creates simple components that can be used to test\n* the layout of the client jFrame without running the whole game.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This GUIComponentFactory creates simple components that can be used to test\n* the layout of the client jFrame without running the whole game.\n*\n* @author Luke Lindsay\n*/\npublic class SimpleComponentFactoryImpl2 implements\njfreerails.client.top.GUIComponentFactory {\nprivate OverviewMapJComponent overviewMap;\nprivate JScrollPane mainMapScrollPane1;\nprivate MapViewJComponentConcrete mainMap;\nprivate MainMapAndOverviewMapMediator mediator;\nprivate Rectangle r = new Rectangle();\n/** Creates new SimpleComponentFactoryImpl */\npublic SimpleComponentFactoryImpl2() {\n}\npublic JMenu createBuildMenu() {\nreturn new JMenu(\"Build\");\n}\npublic JMenu createGameMenu() {\nreturn new JMenu(\"Game\");\n}\npublic JMenu createDisplayMenu() {\nJMenu displayMenu = new JMenu(\"Display\");\naddMainmapzoomMenuItem(displayMenu, 5);\naddMainmapzoomMenuItem(displayMenu, 10);\naddOverviewmapzoomMenuItem(displayMenu, 0.2F);\naddOverviewmapzoomMenuItem(displayMenu, 0.6F);\nreturn displayMenu;\n}\npublic JMenu createBrokerMenu() {\nJMenu brokerMenu = new JMenu(\"Broker\");\nreturn brokerMenu;\n}\nprivate void addOverviewmapzoomMenuItem(JMenu displayMenu, final float scale) {\nString menuItemName = \"Set overview map scale=\" + scale;\nJMenuItem menuItem = new JMenuItem(menuItemName);\nmenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\noverviewMap.setup(new BlankMapRenderer(scale));\n}\n});\ndisplayMenu.add(menuItem);\n}\nprivate void addMainmapzoomMenuItem(JMenu displayMenu, final float scale) {\nString menuItemName = \"Set main map scale=\" + scale;\nJMenuItem menuItem = new JMenuItem(menuItemName);\nmenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nRectangle visRect = mainMap.getVisibleRect();\nint oldWidth = mainMap.getWidth();\nmainMap.setup(new BlankMapRenderer(scale));\nint newWidth = mainMap.getPreferredSize().width;\nint oldCenterX = visRect.x + (visRect.width / 2);\nint newCenterX = oldCenterX * newWidth / oldWidth;\nvisRect.x = newCenterX - visRect.width / 2;\nint oldCenterY = visRect.y + (visRect.height / 2);\nint newCenterY = oldCenterY * newWidth / oldWidth;\nvisRect.y = newCenterY - visRect.height / 2;\n/*\n* LL: I'm not sure why the 'if' is necessary in the following,\n* but the view does not center on the right spot without it.\n*/\nif (oldWidth < newWidth) {\nmainMap.setSize(mainMap.getPreferredSize());\nmainMap.scrollRectToVisible(visRect);\n} else {\nmainMap.scrollRectToVisible(visRect);\nmainMap.setSize(mainMap.getPreferredSize());\n}\n}\n});\ndisplayMenu.add(menuItem);\n}\npublic JScrollPane createMainMap() {\nif (null == this.mainMap) {\n// this.mainMap = new MapJPanel();\nthis.mainMap = new MapViewJComponentConcrete();\nmainMapScrollPane1 = new JScrollPane();\nmainMapScrollPane1.setViewportView(this.mainMap);\naddMainMapAndOverviewMapMediatorIfNecessary();\n}\nreturn mainMapScrollPane1;\n}\npublic JPanel createOverviewMap() {\nif (null == this.overviewMap) {\n// this.overviewMap = new OverviewMapJPanel();\nthis.overviewMap = new OverviewMapJComponent(r);\nthis.overviewMap.setup(new BlankMapRenderer(0.4F));\naddMainMapAndOverviewMapMediatorIfNecessary();\n}\nreturn overviewMap;\n// return new TestPanel();\n}\nprivate void addMainMapAndOverviewMapMediatorIfNecessary() {\nif (this.mainMap != null && this.overviewMap != null\n&& null == this.mediator) {\n// Rectangle r = this.overviewMap.getMainMapVisibleRect();\nthis.mediator = new MainMapAndOverviewMapMediator(overviewMap,\nmainMapScrollPane1.getViewport(), mainMap, r);\n}\n}\npublic JLabel createCashJLabel() {\nreturn null;\n}\npublic JLabel createDateJLabel() {\nreturn null;\n}\npublic JMenu createHelpMenu() {\nreturn null;\n}\npublic JTabbedPane createTrainsJTabPane() {\nreturn null;\n}\npublic JMenu createReportsMenu() {\n// TODO Auto-generated method stub\nreturn null;\n}\n}"}
{"className":"experimental.DialogueBoxTester","javaDoc":"/**\n* This class lets you test dialogue boxes without running the whole game.\n*\n* @author lindsal8\n*\n*/","code":"/**\n* This class lets you test dialogue boxes without running the whole game.\n*\n* @author lindsal8\n*\n*/\npublic class DialogueBoxTester extends javax.swing.JFrame {\nprivate static final long serialVersionUID = 4050764909631780659L;\nprivate static final Player TEST_PLAYER = new Player(\"test player\", 0);\nprivate static final FreerailsPrincipal TEST_PRINCIPAL = TEST_PLAYER\n.getPrincipal();\nprivate final DialogueBoxController dialogueBoxController;\nprivate World w;\nprivate RenderersRoot vl;\nprivate ModelRootImpl modelRoot;\nprivate Action closeCurrentDialogue = new AbstractAction(\"Close\") {\nprivate static final long serialVersionUID = 1L;\npublic void actionPerformed(ActionEvent arg0) {\ndialogueBoxController.closeContent();\n}\n};\n;\nprivate TrainDialogueJPanel trainDialogueJPanel = new TrainDialogueJPanel();\n/** Creates new form TestGlassPanelMethod. */\nprivate DialogueBoxTester() {\nw = new WorldImpl(200, 200);\nUntriedMoveReceiver dummyReceiver = new SimpleMoveReceiver(w);\nmodelRoot = new ModelRootImpl();\nmodelRoot.setMoveFork(new MoveChainFork());\nmodelRoot.setMoveReceiver(dummyReceiver);\nWagonAndEngineTypesFactory wetf = new WagonAndEngineTypesFactory();\nTileSetFactory tileFactory = new TileSetFactoryImpl();\ntileFactory.addTerrainTileTypesList(w);\nwetf.addTypesToWorld(w);\nw.addPlayer(TEST_PLAYER);\ntry {\nvl = new RenderersRootImpl(w, FreerailsProgressMonitor.NULL_INSTANCE);\n} catch (IOException e) {\ne.printStackTrace();\n}\nmodelRoot.setup(w, TEST_PLAYER.getPrincipal());\nActionRoot actionRoot = new ActionRoot(modelRoot);\nactionRoot.setup(modelRoot, vl);\ndialogueBoxController = new DialogueBoxController(this, modelRoot);\nactionRoot.setDialogueBoxController(dialogueBoxController);\ndialogueBoxController.setDefaultFocusOwner(this);\nint numberOfCargoTypes = w.size(SKEY.CARGO_TYPES);\nStationModel bristol = new StationModel(10, 10, \"Bristol\",\nnumberOfCargoTypes, 0);\nboolean[] demandArray = new boolean[numberOfCargoTypes];\n// Make the stations demand all cargo..\nfor (int i = 0; i < demandArray.length; i++) {\ndemandArray[i] = true;\n}\nDemand4Cargo demand = new Demand4Cargo(demandArray);\nbristol = new StationModel(bristol, demand);\nw.add(TEST_PRINCIPAL, KEY.STATIONS, bristol);\nw.add(TEST_PRINCIPAL, KEY.STATIONS, new StationModel(50, 100, \"Bath\",\nnumberOfCargoTypes, 0));\nw.add(TEST_PRINCIPAL, KEY.STATIONS, new StationModel(40, 10, \"Cardiff\",\nnumberOfCargoTypes, 0));\nw.add(TEST_PRINCIPAL, KEY.STATIONS, new StationModel(100, 10, \"London\",\nnumberOfCargoTypes, 0));\nw.add(TEST_PRINCIPAL, KEY.STATIONS, new StationModel(90, 50, \"Swansea\",\nnumberOfCargoTypes, 0));\n// Set up cargo bundle, for the purpose of this test code all the trains\n// can share the\n// same one.\nMutableCargoBundle cb = new MutableCargoBundle();\ncb.setAmount(new CargoBatch(0, 10, 10, 8, 0), 80);\ncb.setAmount(new CargoBatch(0, 10, 10, 9, 0), 60);\ncb.setAmount(new CargoBatch(1, 10, 10, 9, 0), 140);\ncb.setAmount(new CargoBatch(3, 10, 10, 9, 0), 180);\ncb.setAmount(new CargoBatch(5, 10, 10, 9, 0), 10);\nw.add(TEST_PRINCIPAL, KEY.CARGO_BUNDLES, cb.toImmutableCargoBundle());\nMutableSchedule schedule = new MutableSchedule();\nTrainOrdersModel order = new TrainOrdersModel(0, new ImInts(0, 0, 0),\nfalse, false);\nTrainOrdersModel order2 = new TrainOrdersModel(1, new ImInts(1, 2, 0,\n0, 0), true, false);\nTrainOrdersModel order3 = new TrainOrdersModel(2, null, true, false);\nschedule.setOrder(0, order);\nschedule.setOrder(1, order2);\nint scheduleID = w.add(TEST_PRINCIPAL, KEY.TRAIN_SCHEDULES, schedule\n.toImmutableSchedule());\nw.add(TEST_PRINCIPAL, KEY.TRAINS,\nnew TrainModel(0, new ImInts(0, 0), scheduleID));\nschedule.setOrder(2, order2);\nschedule.setOrder(3, order3);\nscheduleID = w.add(TEST_PRINCIPAL, KEY.TRAIN_SCHEDULES,\nschedule.toImmutableSchedule());\nw.add(TEST_PRINCIPAL, KEY.TRAINS,\nnew TrainModel(1, new ImInts(1, 1), scheduleID));\nschedule.setOrder(4, order2);\nschedule.setOrderToGoto(3);\nschedule.setPriorityOrders(order);\nscheduleID = w.add(TEST_PRINCIPAL, KEY.TRAIN_SCHEDULES,\nschedule.toImmutableSchedule());\nw.add(TEST_PRINCIPAL, KEY.TRAINS,\nnew TrainModel(0, new ImInts(1, 2, 0), scheduleID));\nfinal MyGlassPanel glassPanel = new MyGlassPanel();\ndialogueBoxController.setup(modelRoot, vl);\ninitComponents();\nglassPanel.setSize(800, 600);\nthis.addComponentListener(new JFrameMinimumSizeEnforcer(640, 480));\nthis.setSize(640, 480);\n}\n/**\n* This method is called from within the constructor to initialize the form.\n* WARNING: Do NOT modify this code. The content of this method is always\n* regenerated by the FormEditor.\n*/\nprivate void initComponents() {// GEN-BEGIN:initComponents\njLabel1 = new javax.swing.JLabel();\njMenuBar1 = new javax.swing.JMenuBar();\nshow = new javax.swing.JMenu();\nshowBrokerScreen = new javax.swing.JMenuItem();\nselectEngine = new javax.swing.JMenuItem();\nselectWagons = new javax.swing.JMenuItem();\nselectTrainOrders = new javax.swing.JMenuItem();\nshowControls = new javax.swing.JMenuItem();\nshowTerrainInfo = new javax.swing.JMenuItem();\nshowStationInfo = new javax.swing.JMenuItem();\nshowTrainList = new javax.swing.JMenuItem();\nshowReportBug = new javax.swing.JMenuItem();\nthrowException = new javax.swing.JMenuItem();\nshowCargoWaitingAndDemand = new javax.swing.JMenuItem();\nshowJavaSystemProperties = new javax.swing.JMenuItem();\nshowNetworthGraph = new javax.swing.JMenuItem();\naddKeyListener(new java.awt.event.KeyAdapter() {\n@Override\npublic void keyPressed(java.awt.event.KeyEvent evt) {\nformKeyPressed(evt);\n}\n});\naddWindowListener(new java.awt.event.WindowAdapter() {\n@Override\npublic void windowClosing(java.awt.event.WindowEvent evt) {\nexitForm(evt);\n}\n});\njLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource(\n\"/jfreerails/data/south_america.png\")));\njLabel1.setText(\"Press Esc to close dialogue boxes\");\njLabel1.setMinimumSize(new java.awt.Dimension(640, 480));\njLabel1.setPreferredSize(new java.awt.Dimension(640, 480));\ngetContentPane().add(jLabel1, java.awt.BorderLayout.CENTER);\nshow.setText(\"Show\");\nshowBrokerScreen.setText(\"Broker Screen\");\nshowBrokerScreen.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nnewspaperActionPerformed(evt);\n}\n});\nshow.add(showBrokerScreen);\nselectEngine.setText(\"Select Engine\");\nselectEngine.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectEngineActionPerformed(evt);\n}\n});\nshow.add(selectEngine);\nselectWagons.setText(\"Select Wagons\");\nselectWagons.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectWagonsActionPerformed(evt);\n}\n});\nshow.add(selectWagons);\nselectTrainOrders.setText(\"Train Orders\");\nselectTrainOrders\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nselectTrainOrdersActionPerformed(evt);\n}\n});\nshow.add(selectTrainOrders);\nshowControls.setText(\"Show game controls\");\nshowControls.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowControlsActionPerformed(evt);\n}\n});\nshow.add(showControls);\nshowTerrainInfo.setText(\"Show Terrain Info\");\nshowTerrainInfo.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowTerrainInfoActionPerformed(evt);\n}\n});\nshow.add(showTerrainInfo);\nshowStationInfo.setText(\"Show Station Info\");\nshowStationInfo.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowStationInfoActionPerformed(evt);\n}\n});\nshow.add(showStationInfo);\nshowTrainList.setText(\"Train List\");\nshowTrainList.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowTrainListActionPerformed(evt);\n}\n});\nshow.add(showTrainList);\nshowCargoWaitingAndDemand.setText(\"Cargo waiting & demand\");\nshowCargoWaitingAndDemand\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowCargoWaitingAndDemandActionPerformed(evt);\n}\n});\nshow.add(showCargoWaitingAndDemand);\nshowJavaSystemProperties.setText(\"Java System Properties\");\nshowJavaSystemProperties\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowJavaSystemPropertiesActionPerformed(evt);\n}\n});\nthrowException.setText(\"Throw Exception\");\nthrowException.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nthrow new IllegalArgumentException();\n}\n});\nshow.add(showJavaSystemProperties);\nshowNetworthGraph.setText(\"Show networth graph\");\nshowNetworthGraph\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\nshowNetworthGraphActionPerformed(evt);\n}\n});\nshow.add(showNetworthGraph);\nshowReportBug.setText(\"Report Bug\");\nshowReportBug\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showReportBug();\n}\n});\nshow.add(showReportBug);\njMenuBar1.add(show);\nsetJMenuBar(jMenuBar1);\n}// GEN-END:initComponents\nprivate void showNetworthGraphActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showNetworthGraphActionPerformed\ndialogueBoxController.showNetworthGraph();\n}// GEN-LAST:event_showNetworthGraphActionPerformed\nprivate void showJavaSystemPropertiesActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_showJavaSystemPropertiesActionPerformed\n// Add your handling code here:\nString s = ShowJavaProperties.getPropertiesHtmlString();\nHtmlJPanel htmlPanel = new HtmlJPanel(s);\nhtmlPanel.setup(modelRoot, vl, closeCurrentDialogue);\ndialogueBoxController.showContent(htmlPanel);\n}// GEN-LAST:event_showJavaSystemPropertiesActionPerformed\nprivate void formKeyPressed(java.awt.event.KeyEvent evt) {// GEN-FIRST:event_formKeyPressed\nif (java.awt.event.KeyEvent.VK_ESCAPE == evt.getKeyCode()) {\ndialogueBoxController.closeContent();\n}\n}// GEN-LAST:event_formKeyPressed\nprivate void showCargoWaitingAndDemandActionPerformed(\njava.awt.event.ActionEvent evt) {// GEN-FIRST:event_showCargoWaitingAndDemandActionPerformed\n// Add your handling code here:\nCargoWaitingAndDemandedJPanel panel = new CargoWaitingAndDemandedJPanel();\npanel.setup(modelRoot, vl, closeCurrentDialogue);\nint newStationID = 0;\npanel.display(newStationID);\ndialogueBoxController.showContent(panel);\n}// GEN-LAST:event_showCargoWaitingAndDemandActionPerformed\nprivate void showTrainListActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showTrainListActionPerformed\n// Add your handling code here:\ndialogueBoxController.showTrainList();\n}// GEN-LAST:event_showTrainListActionPerformed\nprivate void showStationInfoActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showStationInfoActionPerformed\n// Add your handling code here:\nint stationNumber = 0;\ndialogueBoxController.showStationInfo(stationNumber);\n}// GEN-LAST:event_showStationInfoActionPerformed\nprivate void showTerrainInfoActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showTerrainInfoActionPerformed\n// Add your handling code here:\nint terrainType = 0;\ndialogueBoxController.showTerrainInfo(terrainType);\n}// GEN-LAST:event_showTerrainInfoActionPerformed\nprivate void showControlsActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_showControlsActionPerformed\n// Add your handling code here:\ndialogueBoxController.showGameControls();\n}// GEN-LAST:event_showControlsActionPerformed\nprivate void selectTrainOrdersActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_selectTrainOrdersActionPerformed\n// Add your handling code here:\ntrainDialogueJPanel.setup(modelRoot, vl, closeCurrentDialogue);\ntrainDialogueJPanel.display(0);\ndialogueBoxController.showContent(trainDialogueJPanel);\n}// GEN-LAST:event_selectTrainOrdersActionPerformed\nprivate void selectWagonsActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_selectWagonsActionPerformed\n// Add your handling code here:\ndialogueBoxController.showSelectWagons();\n}// GEN-LAST:event_selectWagonsActionPerformed\nprivate void selectEngineActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_selectEngineActionPerformed\n// Add your handling code here:\ndialogueBoxController.showSelectEngine();\n}// GEN-LAST:event_selectEngineActionPerformed\nprivate void newspaperActionPerformed(java.awt.event.ActionEvent evt) { // GEN-FIRST:event_newspaperActionPerformed\n// Add your handling code here:\ndialogueBoxController.showBrokerScreen();\n//dialogueBoxController.showNewspaper(\"New headline!\");\n}// GEN-LAST:event_newspaperActionPerformed\n/** Exit the Application. */\nprivate void exitForm(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_exitForm\nSystem.exit(0);\n}// GEN-LAST:event_exitForm\npublic static void main(String args[]) {\nDialogueBoxTester test = new DialogueBoxTester();\ntest.setVisible(true);\n}\n// Variables declaration - do not modify//GEN-BEGIN:variables\njavax.swing.JLabel jLabel1;\njavax.swing.JMenuBar jMenuBar1;\njavax.swing.JMenuItem showBrokerScreen;\njavax.swing.JMenuItem selectEngine;\njavax.swing.JMenuItem selectTrainOrders;\njavax.swing.JMenuItem selectWagons;\njavax.swing.JMenu show;\njavax.swing.JMenuItem showCargoWaitingAndDemand;\njavax.swing.JMenuItem showControls;\njavax.swing.JMenuItem showJavaSystemProperties;\njavax.swing.JMenuItem showNetworthGraph;\njavax.swing.JMenuItem showStationInfo;\njavax.swing.JMenuItem showTerrainInfo;\njavax.swing.JMenuItem showTrainList;\njavax.swing.JMenuItem showReportBug;\njavax.swing.JMenuItem throwException;\n// End of variables declaration//GEN-END:variables\n}"}
{"className":"experimental.ExptWriteToBuffer","javaDoc":"/**\n* Experiment to try out reading and writing to a buffer to test serialization\n* code.\n*\n* @author Luke\n*\n*/","code":"/**\n* Experiment to try out reading and writing to a buffer to test serialization\n* code.\n*\n* @author Luke\n*\n*/\npublic class ExptWriteToBuffer {\nprivate static final Logger logger = Logger\n.getLogger(ExptWriteToBuffer.class.getName());\npublic static void main(String[] args) {\ntry {\nPoint p = new Point(10, 10);\nByteArrayOutputStream out = new ByteArrayOutputStream();\nObjectOutputStream objectOut = new ObjectOutputStream(out);\nobjectOut.writeObject(p);\nobjectOut.flush();\nbyte[] bytes = out.toByteArray();\nByteArrayInputStream in = new ByteArrayInputStream(bytes);\nObjectInputStream objectIn = new ObjectInputStream(in);\nObject o = objectIn.readObject();\nPoint p2 = (Point) o;\nif (p.equals(p2)) {\nlogger.info(\"The two objects are equal!\");\n} else {\nlogger.info(\"The two objects are not equal!\");\n}\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}"}
{"className":"experimental.AnimationExpt","javaDoc":"/**\n* This class tests that the game loop and screen handler are working correctly.\n* All it does is display the current time in ms and display the number of\n* frames per second.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class tests that the game loop and screen handler are working correctly.\n* All it does is display the current time in ms and display the number of\n* frames per second.\n*\n* @author Luke Lindsay\n*\n*/\npublic class AnimationExpt extends JComponent {\nprivate static final long serialVersionUID = 3690191057862473264L;\n@Override\nprotected void paintComponent(Graphics g) {\nsuper.paintComponent(g);\nlong l = System.currentTimeMillis();\nString str = String.valueOf(l);\ng.drawString(str, 100, 100);\n}\npublic static void main(String[] args) {\nSystem.setProperty(\"SHOWFPS\", \"true\");\nJFrame f = new JFrame();\nf.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\nf.getContentPane().add(new AnimationExpt());\nScreenHandler screenHandler = new ScreenHandler(f,\nScreenHandler.WINDOWED_MODE);\nscreenHandler.apply();\nGameLoop gameLoop = new GameLoop(screenHandler);\nThread t = new Thread(gameLoop);\nt.start();\n}\n}"}
{"className":"experimental.GenerateDependenciesXmlAndHtml","javaDoc":"/**\n* This class generates an ant script that checks the dependencies between\n* packages and also generates an html page that illustrates the allowed\n* dependencies. The checkdep target on the generated ant script tests the\n* dependencies of packages. It does this by copying the contents of the package\n* in question together with the contents of the packages it is allowed to\n* depend on to a temporary directory, then compiling the contents of the\n* package. If the packaged depends on classes other than those contained in the\n* packages it is allowed to depend on, the compile will fail.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class generates an ant script that checks the dependencies between\n* packages and also generates an html page that illustrates the allowed\n* dependencies. The checkdep target on the generated ant script tests the\n* dependencies of packages. It does this by copying the contents of the package\n* in question together with the contents of the packages it is allowed to\n* depend on to a temporary directory, then compiling the contents of the\n* package. If the packaged depends on classes other than those contained in the\n* packages it is allowed to depend on, the compile will fail.\n*\n* @author Luke\n*\n*/\npublic class GenerateDependenciesXmlAndHtml {\nprivate static final Logger logger = Logger\n.getLogger(GenerateDependenciesXmlAndHtml.class.getName());\nprivate PrintWriter xmlWriter;\nprivate PrintWriter htmlWriter;\nprivate ArrayList<String> packages = new ArrayList<String>();\nprivate boolean started = false;\nprivate boolean startedBlock = false;\nprivate String sig;\npublic static void main(String[] args) {\ntry {\nnew GenerateDependenciesXmlAndHtml(\"checkdep.xml\", \"src\"\n+ File.separator + \"docs\" + File.separator\n+ \"dependencies.html\");\n} catch (FileNotFoundException e) {\ne.printStackTrace();\n}\n}\nprivate GenerateDependenciesXmlAndHtml(String xmlFilename,\nString htmlFilename) throws FileNotFoundException {\nDate d = new Date();\nsig = this.getClass().getName() + \" on \" + d;\n// Setup writers\nFile xmlFile = new File(xmlFilename);\nxmlWriter = new PrintWriter(new FileOutputStream(xmlFile));\nFile htmlFile = new File(htmlFilename);\nhtmlWriter = new PrintWriter(new FileOutputStream(htmlFilename));\nString[] basePackages = { \"jfreerails/util/*\" };\nstart();\nstartBlock(\"All\");\nadd(basePackages);\nadd(\"jfreerails/world/**/*\");\nadd(\"jfreerails/move/**/*\");\nadd(\"jfreerails/controller/*\");\nadd(\"jfreerails/network/*\");\nadd(new String[] { \"jfreerails/server/**/*\", \"jfreerails/client/**/*\" });\nadd(\"jfreerails/launcher/**/*\");\nadd(\"jfreerails/experimental/**/*\");\nendBlock();\nstartBlock(\"World\");\nadd(basePackages);\nadd(\"jfreerails/world/common/*\");\nadd(new String[] { \"jfreerails/world/terrain/*\",\n\"jfreerails/world/cargo/*\", \"jfreerails/world/train/*\",\n\"jfreerails/world/station/*\" });\nadd(\"jfreerails/world/track/*\");\nadd(\"jfreerails/world/accounts/*\");\nadd(\"jfreerails/world/player/*\");\nadd(\"jfreerails/world/top/*\");\nendBlock();\nstartBlock(\"Server\");\nadd(basePackages);\nadd(\"jfreerails/world/**/*\");\nadd(\"jfreerails/move/**/*\");\nadd(\"jfreerails/controller/*\");\nadd(\"jfreerails/network/*\");\nadd(\"jfreerails/server/common/*\");\nadd(\"jfreerails/server/parser/*\");\nadd(\"jfreerails/server/*\");\nendBlock();\nstartBlock(\"Client\");\nadd(basePackages);\nadd(\"jfreerails/world/**/*\");\nadd(\"jfreerails/move/**/*\");\nadd(\"jfreerails/controller/*\");\nadd(\"jfreerails/network/*\");\nadd(\"jfreerails/client/common/*\");\nadd(\"jfreerails/client/renderer/*\");\nadd(\"jfreerails/client/view/*\");\nadd(\"jfreerails/client/top/*\");\nendBlock();\nfinish();\nxmlWriter.flush();\nhtmlWriter.flush();\nlogger.info(sig);\nlogger.info(\"Wrote \" + xmlFile);\nlogger.info(\"Wrote \" + htmlFile);\n}\nprivate void start() {\nassert !started;\nstartXml();\nhtmlWriter.write(\"<html>\\n\");\nhtmlWriter.write(\"<title>Dependencies between packages</title>\\n\");\nhtmlWriter.write(\"<p><code>This file was generate by \" + sig\n+ \"</code></p>\\n\");\nhtmlWriter.write(\"<h1>Dependencies between packages</h1>\\n\");\nhtmlWriter\n.write(\"<p>The figures below show the dependencies: packages may only depend, i.e. import classes and interfaces, from packages below.</p>\\n\");\nstarted = true;\n}\nprivate void startBlock(String blockName) {\nassert started;\nassert !startedBlock;\nstartedBlock = true;\nhtmlWriter.write(\"<h2>\" + blockName + \"</h2>\");\nxmlWriter\n.write(\"\\n\\t\\t<!-- Setup the directory where the legal dependencies are stored -->\\n\");\nxmlWriter.write(\"\\t\\t<delete dir=\\\"dependencies\\\" />\\n\");\nxmlWriter.write(\"\\t\\t<mkdir dir=\\\"dependencies\\\" />\\n\");\n}\nprivate void endBlock() {\nassert started;\nassert startedBlock;\nhtmlWriter\n.write(\"<table width=\\\"100%\\\" border=\\\"1\\\" cellpadding=\\\"10\\\" cellspacing=\\\"10\\\" bordercolor=\\\"#333333\\\" bgcolor=\\\"#FFFFFF\\\">\\n\");\nfor (int i = packages.size() - 1; i >= 0; i--) {\nString packageName = packages.get(i);\nhtmlWriter.write(\"<tr bgcolor=\\\"#FFCCCC\\\"> \\n\");\nhtmlWriter.write(\"<td height=\\\"50\\\" bgcolor=\\\"#FFCC66\\\">\"\n+ packageName + \"</td>\\n\");\nhtmlWriter.write(\"</tr>\\n\");\n}\nhtmlWriter.write(\"</table>\\n\");\npackages.clear();\nxmlWriter.write(\"\\n\\t\\t<!-- End Block -->\\n\");\nxmlWriter.write(\"\\t\\t<echo message=\\\"End Block\\\"/>\\n\");\nstartedBlock = false;\n}\nprivate void startXml() {\n// Start the file.\nxmlWriter.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\nxmlWriter\n.write(\"<project basedir=\\\".\\\" default=\\\"checkdep\\\" name=\\\"checkdep\\\">\\n\");\nxmlWriter.write(\"\\t<description>This ant script was generated by \"\n+ sig\n+ \" to check the dependencies for jfreerails.</description>\\n\");\n// Set the properties.\n// Add the compile target.\nxmlWriter\n.write(\"\\n\\t<target description=\\\"Build everything except JUnit test-classes\\\" name=\\\"compile\\\">\\n\");\nxmlWriter.write(\"\\t\\t<mkdir dir=\\\"build\\\" />\\n\");\nxmlWriter\n.write(\"\\t\\t<javac destdir=\\\"build\\\" fork=\\\"true\\\" srcdir=\\\"src\\\" source=\\\"1.5\\\">\\n\");\nxmlWriter.write(\"\\t\\t\\t<exclude name=\\\"**/*Test.java\\\" />\\n\");\nxmlWriter.write(\"\\t\\t </javac>\\n\");\nxmlWriter.write(\"\\t</target>\\n\");\n// Start the check depend target.\nxmlWriter\n.write(\"\\n\\n\\t<target depends=\\\"compile\\\" description=\\\"Tests whether dependencies between packages conform to the rules defined in this target\\\" name=\\\"checkdep\\\">\\n\");\n}\nprivate void add(String packageName) {\nadd(new String[] { packageName });\n}\nprivate void add(String[] packageNames) {\nassert started;\nassert startedBlock;\nString packagesString = \"\";\nfor (int i = packageNames.length - 1; i > 0; i--) {\npackagesString += convertToPackageName(packageNames[i]) + \", \";\n}\npackagesString += \" \" + convertToPackageName(packageNames[0]);\n// The html writer will use this later.\npackages.add(packagesString);\nxmlWriter.write(\"\\n\\t\\t<!-- New row: \" + packagesString + \" -->\\n\");\nxmlWriter.write(\"\\t\\t<echo message=\\\"New row: \" + packagesString\n+ \"\\\"/>\\n\");\n// Include the source files we are going to compile.\nfor (String packageName : packageNames) {\nxmlWriter.write(\"\\t\\t<echo message=\\\"Check dependencies for \"\n+ packageName + \"\\\"/>\\n\");\nxmlWriter.write(\"\\t\\t<delete dir=\\\"temp\\\" />\\n\");\nxmlWriter.write(\"\\t\\t<mkdir dir=\\\"temp\\\" />\\n\");\n// First copy the files we are testing.\nxmlWriter.write(\"\\t\\t<copy todir=\\\"temp\\\">\\n\");\nxmlWriter.write(\"\\t\\t<fileset dir=\\\"src\\\">\\n\");\nxmlWriter.write(\"\\t\\t\\t<include name=\\\"\" + packageName\n+ \".java\\\" />\\n\");\n// Exclude unit tests.\nxmlWriter.write(\"\\t\\t\\t<exclude name=\\\"**/*Test.java\\\" />\\n\");\nxmlWriter.write(\"\\t\\t</fileset>\\n\");\nxmlWriter.write(\"\\t\\t</copy>\\n\");\nxmlWriter\n.write(\"\\t\\t<javac fork=\\\"true\\\" srcdir=\\\"temp\\\" source=\\\"1.5\\\" classpath=\\\"dependencies\\\">\\n\");\n// Include the files we are going to compile.\nxmlWriter.write(\"\\t\\t\\t<include name=\\\"\" + packageName\n+ \".java\\\" />\\n\");\nxmlWriter.write(\"\\t\\t</javac>\\n\");\nxmlWriter.write(\"\\t\\t<delete dir=\\\"temp\\\" />\\n\");\n}\n// Copy the files we have just tested to the dependencies directory.\nxmlWriter.write(\"\\t\\t<copy todir=\\\"dependencies\\\">\\n\");\nxmlWriter.write(\"\\t\\t<fileset dir=\\\"build\\\">\\n\");\nfor (int i = 0; i < packageNames.length; i++) {\nxmlWriter.write(\"\\t\\t\\t<include name=\\\"\" + packageNames[i]\n+ \".class\\\" />\\n\");\n}\nxmlWriter.write(\"\\t\\t\\t<exclude name=\\\"**/*Test.class\\\" />\\n\");\nxmlWriter.write(\"\\t\\t</fileset>\\n\");\nxmlWriter.write(\"\\t\\t</copy>\\n\");\n}\nprivate String convertToPackageName(String packagesString) {\nif (!isPackageNameOk(packagesString)) {\nthrow new IllegalArgumentException(packagesString);\n}\npackagesString = packagesString.replace('/', '.');\n/*\n* Remove the last two characters, so that jfreerails.world.**.* - >\n* jfreerails.world.** and jfreerails.util.* -> jfreerails.util\n*/\npackagesString = packagesString.substring(0,\npackagesString.length() - 2);\nreturn packagesString;\n}\nstatic boolean isPackageNameOk(String s) {\nreturn s.matches(\"(([a-zA-Z]*)/)*\\\\*\")\n|| s.matches(\"(([a-zA-Z]*)/)*\\\\*\\\\*/\\\\*\");\n}\nprivate void finish() {\nassert started;\nassert !startedBlock;\n// finish the file.\nxmlWriter.write(\"\\t\\t<delete dir=\\\"temp\\\" />\\n\");\nxmlWriter.write(\"\\t\\t<delete dir=\\\"dependencies\\\" />\\n\");\nxmlWriter.write(\"\\t</target>\\n\");\nxmlWriter.write(\"</project>\\n\");\nhtmlWriter.write(\"</html>\\n\");\nstarted = false;\n}\n}"}
{"className":"experimental.SimpleMoveReceiver","javaDoc":"/**\n* An UntriedMoveReceiver that executes moves on the world object passed to its\n* constructor.\n*\n* @author Luke\n*\n*/","code":"/**\n* An UntriedMoveReceiver that executes moves on the world object passed to its\n* constructor.\n*\n* @author Luke\n*\n*/\npublic final class SimpleMoveReceiver implements UntriedMoveReceiver {\nprivate final World w;\npublic SimpleMoveReceiver(World w) {\nthis.w = w;\nif (null == w)\nthrow new NullPointerException();\n}\npublic MoveStatus tryDoMove(Move move) {\nreturn move.tryDoMove(w, Player.AUTHORITATIVE);\n}\npublic void processMove(Move move) {\nmove.doMove(w, Player.AUTHORITATIVE);\n}\npublic void processPreMove(PreMove pm) {\nprocessMove(pm.generateMove(w));\n}\n}"}
{"className":"experimental.CheckFreerailsSerializableClasses","javaDoc":"/** Checks that all class that implement FreerailsSerializable are immutable and override equals and hashcode.\n*\n*\n*/","code":"/** Checks that all class that implement FreerailsSerializable are immutable and override equals and hashcode.\n*\n*\n*/\npublic class CheckFreerailsSerializableClasses {\nstatic final HashSet<Class> immutableTypes = new HashSet<Class>();\nstatic final HashSet<Class> mutableTypes = new HashSet<Class>();\nstatic Logger logger = Logger.getLogger(CheckFreerailsSerializableClasses.class\n.getName());\npublic static void main(String[] args) {\nimmutableTypes.clear();\nmutableTypes.clear();\nimmutableTypes.add(String.class);\n// Class clazz = StationModel.class;\n// System.err.println(overridesHashCodeAndEquals(clazz));\n// System.out.println(clazz.isAnnotationPresent(InstanceControlled.class));\n// Annotation[] ans = clazz.getAnnotations();\n// for (Annotation an : ans) {\n// System.err.println(an);\n// }\n// System.err.println(checkFields(clazz));\ntestAllClasses();\nfor (Class c : mutableTypes) {\nSystem.err.println(c.getName());\n}\n}\nstatic boolean checkFields(Class<?> clazz) {\nField[] fields = clazz.getDeclaredFields();\nboolean okSoFar = true;\nboolean assertImmutable = clazz.isAnnotationPresent(Immutable.class);\nfor (Field field : fields) {\nint modifiers = field.getModifiers();\nif (Modifier.isStatic(modifiers)) {\nlogger.fine(\"Skipping static field \" + field.getName());\ncontinue;\n}\nClass<?> type = field.getType();\nif (type.isPrimitive()) {\ncontinue;\n}\n// if(!Modifier.isPrivate(modifiers)){\n// System.err.println(clazz.getName()+field.getName()+\" should be\n// private!\");\n// okSoFar = false;\n// }\nif (!FreerailsSerializable.class.isAssignableFrom(type)\n&& !assertImmutable) {\nif (!immutableTypes.contains(type) && !type.isEnum()\n&& !type.isAnnotationPresent(Immutable.class)) {\nSystem.err.println(clazz.getName() + \".\" + field.getName()\n+ \" {\" + type.getName()\n+ \"} might not be immutable!\");\nokSoFar = false;\nif (!type.isArray())\nmutableTypes.add(type);\n}\n}\n}\nreturn okSoFar;\n}\n@SuppressWarnings(\"unchecked\")\nstatic void testAllClasses() {\nClassLocater locater = new ClassLocater();\nClass[] classes = locater.getSubclassesOf(FreerailsSerializable.class);\nint classesWithProblems = 0;\nfor (Class clazz : classes) {\nif (clazz.isInterface()) {\nlogger.fine(\"Skipping interface \" + clazz.getName());\ncontinue;\n}\nint mods = clazz.getModifiers();\nif ((mods & Modifier.ABSTRACT) != 0) {\nlogger.fine(\"Skipping abstract class \" + clazz.getName());\ncontinue;\n}\nif (clazz.isAnnotationPresent(InstanceControlled.class)) {\nlogger.fine(\"Skipping InstanceControlled class \"\n+ clazz.getName());\ncontinue;\n}\nboolean b = overridesHashCodeAndEquals(clazz);\nb = b && checkFields(clazz);\nif (!b) {\nclassesWithProblems++;\n}\n}\nSystem.err.println(classes.length + \" classes checked, \"\n+ classesWithProblems + \" have problems\");\n}\nstatic boolean overridesHashCodeAndEquals(Class clazz) {\ntry {\nboolean okSoFar = true;\nMethod equals = clazz.getMethod(\"equals\", Object.class);\nif (equals.getDeclaringClass().equals(Object.class)) {\nSystem.err.println(clazz.getName() + \" does not override \"\n+ equals.getName());\nokSoFar = false;\n}\nMethod hashCode = clazz.getMethod(\"hashCode\");\nif (hashCode.getDeclaringClass().equals(Object.class)) {\nSystem.err.println(clazz.getName() + \" does not override \"\n+ hashCode.getName());\nokSoFar = false;\n}\nreturn okSoFar;\n} catch (SecurityException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n} catch (NoSuchMethodException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\nreturn false;\n}\n}"}
{"className":"experimental.TrackTilesGenerator","javaDoc":"/**\n* Generates track graphic image files.\n*\n* @author Luke\n*/","code":"/**\n* Generates track graphic image files.\n*\n* @author Luke\n*/\npublic class TrackTilesGenerator extends JPanel {\nprivate static final long serialVersionUID = 3618982273966487859L;\npublic static void main(String[] args) {\nJFrame frame = new JFrame();\nJScrollPane scrollPane = new JScrollPane();\nframe.add(scrollPane);\nTrackTilesGenerator trackTilesGenerator = new TrackTilesGenerator();\ntrackTilesGenerator.setPreferredSize(trackTilesGenerator\n.getSize4Panel());\nscrollPane.setViewportView(trackTilesGenerator);\nframe.setSize(500, 500);\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setVisible(true);\n}\nprivate final ImageManager imageManager = new ImageManagerImpl(\n\"/experimental/\", \"/experimental/\");\nprivate List<TrackRule> rules;\nprivate TrackRenderer tr;\nCubicCurve2D.Double[] track;\npublic TrackTilesGenerator() {\nPoint2D.Double start, end, one, two;\ntrack = new CubicCurve2D.Double[3];\ntrack[0] = new CubicCurve2D.Double();\nstart = new Point2D.Double(150, 300);\nend = new Point2D.Double(450, 150);\none = controlPoint(start);\ntwo = controlPoint(end);\ntrack[0].setCurve(start, one, two, end);\ntrack[1] = TrackRenderer.createAdjacentCurve(track[0], 0, 0);\ntrack[2] = TrackRenderer.createAdjacentCurve(track[0], -60, -60);\ntr = new TrackRenderer();\nURL track_xml_url = OldWorldImpl.class\n.getResource(\"/jfreerails/data/track_tiles.xml\");\nTrack_TilesHandlerImpl trackSetFactory = new Track_TilesHandlerImpl(\ntrack_xml_url);\nrules = trackSetFactory.getRuleList();\ngenerateTiles();\n}\nprivate Point2D.Double controlPoint(Point2D.Double from) {\ndouble weight = 0.3;\ndouble x = from.getX() * weight + 300 * (1 - weight);\ndouble y = from.getY() * weight + 300 * (1 - weight);\nreturn new Point2D.Double(x, y);\n}\nprivate void generateTiles() {\nfor (TrackRule rule : rules) {\nTrackRule.TrackCategories category = rule.getCategory();\nImage icon;\nif (category.equals(TrackRule.TrackCategories.bridge)\n|| category.equals(TrackRule.TrackCategories.station)) {\ntr.setIcon(rule.getTypeName());\nicon = tr.icon;\n} else {\nicon = null;\n}\nif (category.equals(TrackRule.TrackCategories.tunnel)) {\ntr.tunnel = true;\n} else {\ntr.tunnel = false;\n}\ntr.doubleTrack = rule.isDouble();\nfor (int i = 0; i < 512; i++) {\nif (rule.testTrackPieceLegality(i)) {\nString fileName = TrackPieceRendererImpl.generateFilename(\ni, rule.getTypeName());\nTrackConfiguration conf = TrackConfiguration\n.from9bitTemplate(i);\nImage smallImage = imageManager.newBlankImage(60, 60);\nGraphics2D g2 = (Graphics2D) smallImage.getGraphics();\ntr.paintTrackConf(g2, conf);\n// Draw icon. Used for bridges and stations.\nif (null != icon) {\nint x = 30 - icon.getWidth(null) / 2;\nint y = 30 - icon.getHeight(null) / 2;\ng2.drawImage(icon, x, y, null);\n}\ng2.dispose();\nimageManager.setImage(fileName, smallImage);\n}\n}\n}\ntry {\nimageManager.writeAllImages();\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n}\nprivate Dimension getSize4Panel() {\nint height = 90 * rules.size();\nint width = 0;\nint lastWidth = 0;\nfor (TrackRule rule : rules) {\nwidth = Math.max(width, lastWidth);\nlastWidth = 0;\nIterator<TrackConfiguration> it = rule\n.getLegalConfigurationsIterator();\nwhile (it.hasNext()) {\nlastWidth += 60;\n}\n}\nreturn new Dimension(width, height);\n}\n@Override\nprotected void paintComponent(Graphics g) {\nsuper.paintComponent(g);\nfor (TrackRule rule : rules) {\nString typeName = rule.getTypeName();\ntypeName += rule.isDouble() ? \" (Double) \" : \" (Single)\";\ng.drawString(typeName, 10, 10);\ng.translate(0, 30);\nGraphics2D g2 = (Graphics2D) g.create();\nfor (int i = 0; i < 512; i++) {\nif (rule.testTrackPieceLegality(i)) {\nString fileName = TrackPieceRendererImpl.generateFilename(\ni, rule.getTypeName());\nImage tile;\ntry {\ntile = imageManager.getImage(fileName);\ng2.drawImage(tile, 0, 0, null);\ng2.translate(60, 0);\n} catch (IOException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n}\n}\ng.translate(0, 60);\n}\n}\n}"}
{"className":"experimental.LineDrawTrackPieceView","javaDoc":"/**\n* This TrackPieceRenderer renders track pieces by drawing lines so avoids the\n* need to load images.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This TrackPieceRenderer renders track pieces by drawing lines so avoids the\n* need to load images.\n*\n* @author Luke Lindsay\n*/\npublic class LineDrawTrackPieceView implements\njfreerails.client.renderer.TrackPieceRenderer {\nprivate int[] xx = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\nprivate int[] yy = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };\npublic java.awt.Image getTrackPieceIcon(int trackTemplate) {\nreturn null;\n}\npublic void drawTrackPieceIcon(int trackTemplate, java.awt.Graphics g,\nint x, int y, java.awt.Dimension tileSize) {\nGraphics2D g2 = (Graphics2D) g;\ng2.setStroke(new java.awt.BasicStroke(8.0f));\ng2.setColor(java.awt.Color.red);\nif (0 != trackTemplate) {\nint drawX = x * tileSize.width;\nint drawY = y * tileSize.height;\n// g.drawLine(drawX-10,drawY-10,drawX+10,drawY+10);\nfor (int i = 0; i < 9; i++) {\nif ((trackTemplate & (1 << i)) == (1 << i)) {\ng2.drawLine(drawX + 15, drawY + 15,\ndrawX + 15 + 15 * xx[i], drawY + 15 + 15 * yy[i]);\n}\n}\n}\n}\npublic void dumpImages(ImageManager imageManager) {\n// TODO Auto-generated method stub\n}\n}"}
{"className":"experimental.TestLogging","javaDoc":"/**\n* <p>\n* Used to test the logging configuration.\n* </p>\n* <p>\n* Usage:<code> java -Djava.util.logging.config.file=logging.properties experimental.TestLogging</code>\n* </p>\n* <p>\n* Make sure <code>logging.properties</code> is in the working directory.\n* </p>\n*\n* @author Luke\n*/","code":"/**\n* <p>\n* Used to test the logging configuration.\n* </p>\n* <p>\n* Usage:<code> java -Djava.util.logging.config.file=logging.properties experimental.TestLogging</code>\n* </p>\n* <p>\n* Make sure <code>logging.properties</code> is in the working directory.\n* </p>\n*\n* @author Luke\n*/\npublic class TestLogging {\npublic static void main(String[] args) {\nLogger logger1 = Logger.getLogger(TestLogging.class.getName());\nlogger1.info(\"Logging properties file: \"\n+ System.getProperty(\"java.util.logging.config.file\"));\nlogger1.severe(\"Hello severe logging\");\nlogger1.warning(\"Hello warning logging\");\nlogger1.info(\"Hello info logging\");\nlogger1.fine(\"Hello fine logging\");\nlogger1.finer(\"Hello finer logging\");\nlogger1.finest(\"Hello finest logging\");\n}\n}"}
{"className":"experimental.TrainMotionExpt","javaDoc":"/**\n* This class is a visual test for the train movement code.\n*\n* TODO: Update the trains position when necessary. Make the train stop at\n* intervals, and slowly accelerate.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class is a visual test for the train movement code.\n*\n* TODO: Update the trains position when necessary. Make the train stop at\n* intervals, and slowly accelerate.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrainMotionExpt extends JComponent {\nprivate static final long serialVersionUID = 3690191057862473264L;\nprivate final World world;\nprivate final FreerailsPrincipal principal;\nprivate double finishTime = 0;\nprivate long startTime;\n@Override\nprotected void paintComponent(Graphics g) {\nsuper.paintComponent(g);\n// Shade tiles with track..\ng.setColor(Color.GREEN);\nfor (int x = 0; x < world.getMapWidth(); x++) {\nfor (int y = 0; y < world.getMapHeight(); y++) {\nFreerailsTile tile = (FreerailsTile) world.getTile(x, y);\nif (tile.getTrackPiece().getTrackTypeID() != NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\nint w = Step.TILE_DIAMETER;\nint h = Step.TILE_DIAMETER;\ng.drawRect(x * Step.TILE_DIAMETER, y * Step.TILE_DIAMETER,\nw, h);\n}\n}\n}\nlong l = System.currentTimeMillis() - startTime;\ndouble ticks = (double) l / 1000;\nwhile (ticks > finishTime) {\nupdateTrainPosition();\n}\nActivityIterator ai = world.getActivities(principal, 0);\nwhile (ai.getFinishTime() < ticks && ai.hasNext()) {\nai.nextActivity();\n}\ndouble t = Math.min(ticks, ai.getFinishTime());\nt = t - ai.getStartTime();\nTrainMotion motion = (TrainMotion) ai.getActivity();\nTrainPositionOnMap pos = (TrainPositionOnMap) ai.getState(ticks);\nPathOnTiles pathOT = motion.getPath();\nIterator<ImPoint> it = pathOT.tiles();\nwhile (it.hasNext()) {\nImPoint tile = it.next();\nint x = tile.x * Step.TILE_DIAMETER;\nint y = tile.y * Step.TILE_DIAMETER;\nint w = Step.TILE_DIAMETER;\nint h = Step.TILE_DIAMETER;\ng.setColor(Color.WHITE);\ng.fillRect(x, y, w, h);\ng.setColor(Color.DARK_GRAY);\ng.drawRect(x, y, w, h);\n}\npathOT = motion.getTiles(t);\nit = pathOT.tiles();\nwhile (it.hasNext()) {\nImPoint tile = it.next();\nint x = tile.x * Step.TILE_DIAMETER;\nint y = tile.y * Step.TILE_DIAMETER;\nint w = Step.TILE_DIAMETER;\nint h = Step.TILE_DIAMETER;\ng.setColor(Color.LIGHT_GRAY);\ng.fillRect(x, y, w, h);\ng.setColor(Color.DARK_GRAY);\ng.drawRect(x, y, w, h);\n}\ng.setColor(Color.BLACK);\nIntLine line = new IntLine();\nFreerailsPathIterator path = pos.path();\nwhile (path.hasNext()) {\npath.nextSegment(line);\ng.drawLine(line.x1, line.y1, line.x2, line.y2);\n}\nint speed = (int) Math.round(pos.getSpeed());\ng.drawString(\"Speed: \" + speed, 260, 60);\n}\nprivate void updateTrainPosition() {\nRandom rand = new Random(System.currentTimeMillis());\nMoveTrainPreMove moveTrain = new MoveTrainPreMove(0, principal);\nMove m;\nif (rand.nextInt(10) == 0) {\nm = moveTrain.stopTrain(world);\n} else {\nm = moveTrain.generateMove(world);\n}\nMoveStatus ms = m.doMove(world, principal);\nif (!ms.ok)\nthrow new IllegalStateException(ms.message);\nActivityIterator ai = world.getActivities(principal, 0);\nwhile (ai.hasNext()) {\nai.nextActivity();\nfinishTime = ai.getFinishTime();\n}\n}\npublic TrainMotionExpt() {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\nTrackMoveProducer producer = new TrackMoveProducer(me, world, mr);\nStep[] trackPath = { EAST, SOUTH_EAST, SOUTH, SOUTH_WEST, WEST,\nNORTH_WEST, NORTH, NORTH_EAST };\nImPoint from = new ImPoint(5, 5);\nMoveStatus ms = producer.buildTrack(from, trackPath);\nif (!ms.ok)\nthrow new IllegalStateException(ms.message);\nTrainOrdersModel[] orders = {};\nImmutableSchedule is = new ImmutableSchedule(orders, -1, false);\nAddTrainPreMove addTrain = new AddTrainPreMove(0, new ImInts(), from,\nprincipal, is);\nMove m = addTrain.generateMove(world);\nms = m.doMove(world, principal);\nif (!ms.ok)\nthrow new IllegalStateException(ms.message);\nstartTime = System.currentTimeMillis();\n}\npublic static void main(String[] args) {\nSystem.setProperty(\"SHOWFPS\", \"true\");\nJFrame f = new JFrame();\nf.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\nf.getContentPane().add(new TrainMotionExpt());\nScreenHandler screenHandler = new ScreenHandler(f,\nScreenHandler.WINDOWED_MODE);\nscreenHandler.apply();\nGameLoop gameLoop = new GameLoop(screenHandler);\nThread t = new Thread(gameLoop);\nt.start();\n}\n}"}
{"className":"experimental.RunMe","javaDoc":"/**\n* Tests that ClientJFrame and ScreenHandler work together.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Tests that ClientJFrame and ScreenHandler work together.\n*\n* @author Luke Lindsay\n*/\npublic class RunMe {\npublic static void main(String[] args) {\nJFrame jFrame = new jfreerails.client.top.ClientJFrame(\nnew SimpleComponentFactoryImpl2());\n// jFrame.show();\nScreenHandler screenHandler = new ScreenHandler(jFrame,\nScreenHandler.WINDOWED_MODE);\nGameLoop gameLoop = new GameLoop(screenHandler);\nThread t = new Thread(gameLoop);\nt.start();\n}\n}"}
{"className":"experimental.GenerateTrainHighlights","javaDoc":"/**\n* Generates image files that can be used to indicate that a train has focus or\n* is selected. The image files are semi transparent and are intended to be\n* rendered 'under' the images of the train's engine and wagons.\n*\n*\n* @author Luke\n*/","code":"/**\n* Generates image files that can be used to indicate that a train has focus or\n* is selected. The image files are semi transparent and are intended to be\n* rendered 'under' the images of the train's engine and wagons.\n*\n*\n* @author Luke\n*/\npublic class GenerateTrainHighlights {\n/**\n* @param args the command line arguments\n*/\npublic static void main(String[] args) {\nImageManager imageManager = new ImageManagerImpl(\n\"/experimental/\", \"/experimental/\");\nUIDefaults lookAndFeelDefaults = UIManager.getLookAndFeelDefaults();\nColor selection = (Color) lookAndFeelDefaults.get(\"List.selectionBackground\");\nselection = makeTransparent(selection, 128);\nString filename = \"selected_%s.png\";\ngen(imageManager, selection, filename);\nColor focus = (Color) lookAndFeelDefaults.get(\"TabbedPane.focus\");\nfocus = makeTransparent(focus, 128);\nfilename = \"focused_%s.png\";\ngen(imageManager, focus, filename);\ntry {\nimageManager.writeAllImages();\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\npublic static void gen(ImageManager imageManager, Color selection, String filename) {\nfor (Step step : Step.getList()) {\nint tileSize = 30;\nImage smallImage = imageManager.newBlankImage(tileSize, tileSize);\nGraphics2D g2 = (Graphics2D) smallImage.getGraphics();\ng2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\nRenderingHints.VALUE_ANTIALIAS_ON);\ng2.setStroke(new BasicStroke(3));\ndouble arcRadius = 5;\ng2.rotate(step.getDirection(), tileSize/2, tileSize/2);\nRoundRectangle2D roundedRectangle = new RoundRectangle2D.Double(7, 3, 16, 26, arcRadius, arcRadius);\ng2.setColor(selection);\ng2.fill(roundedRectangle);\ng2.dispose();\nString name = String.format(filename, step.toAbrvString());\nimageManager.setImage(name, smallImage);\n}\n}\nstatic Color makeTransparent(Color before, int alpha){\nreturn new Color(before.getRed(), before.getGreen(), before.getBlue(), alpha);\n}\n}"}
{"className":"experimental.ConnectAllCities","javaDoc":"/**\n*\n* @author Luke\n*/","code":"/**\n*\n* @author Luke\n*/\npublic class ConnectAllCities {\nstatic class DistanceComparator implements Comparator<CityModel> {\nfinal int targetX, targetY;\npublic DistanceComparator(int targetX, int targetY) {\nthis.targetX = targetX;\nthis.targetY = targetY;\n}\nint distSquared(CityModel a) {\nint xDist = a.getCityX() - targetX;\nint yDist = a.getCityY() - targetY;\nreturn xDist * xDist + yDist * yDist;\n}\n@Override\npublic int compare(CityModel a, CityModel b) {\nreturn distSquared(a) - distSquared(b);\n}\n}\n/**\n* @param args the command line arguments\n*/\npublic static void main(String[] args) throws IOException, PathNotFoundException {\nSavedGamesManager gamesManager = new SavedGamesManagerImpl();\nString[] newMapNames = gamesManager.getNewMapNames();\nWorld w = (World) gamesManager.newMap(newMapNames[0]);\nSystem.out.println(w.getClass());\nServerGameModel gameModel = new ServerGameModelImpl();\nString name = \"Tester\";\nPlayer p = new Player(name, 0);\nMove addPlayerMove = AddPlayerMove.generateMove(w, p);\nMoveStatus ms = addPlayerMove.doMove(w, Player.AUTHORITATIVE);\nw.set(ITEM.CALENDAR, new GameCalendar(1200, 1840));\nw.setTime(new GameTime(0));\nw.set(ITEM.GAME_SPEED, new GameSpeed(10));\nw.set(ITEM.GAME_RULES, GameRules.DEFAULT_RULES);\nTransaction t = new AddItemTransaction(Transaction.Category.BOND, 0, 1, new Money(50000000));\nw.addTransaction(p.getPrincipal(), t);\nList<CityModel> citiesUnconnected = new ArrayList<>();\nList<CityModel> citiesConnected = new ArrayList<>();\nint nCities = w.size(SKEY.CITIES);\nSystem.out.format(\"There are %d cities.%n\", nCities);\nfor (int i = 0; i < nCities; i++) {\ncitiesUnconnected.add((CityModel) w.get(SKEY.CITIES, i));\n}\nCityModel cityA = citiesUnconnected.remove(0);\ncitiesConnected.add(cityA);\nDistanceComparator distanceComparator = new DistanceComparator(cityA.getCityX(), cityA.getCityY());\nCollections.sort(citiesUnconnected, distanceComparator);\nMapCustomizer mc = new MapCustomizer(w);\nint n = citiesUnconnected.size();\nfor (int i = 0; i < n; i++) {\nCityModel cityB = citiesUnconnected.remove(0);\nSystem.out.format(\"build track to %s%n\", cityB.getCityName());\ndistanceComparator = new DistanceComparator(cityB.getCityX(), cityB.getCityY());\nCollections.sort(citiesConnected, distanceComparator);\nImPoint b = cityB.getLocation();\nfor (int j = 0; j < Math.min(3, citiesConnected.size()); j++) {\ncityA = citiesConnected.get(j);\nImPoint a = cityA.getLocation();\nmc.buildTrack(a, b);\ntry {\nif (j == 0) {\nif (i == 0) {\nmc.buildStation(a);\n}\nmc.buildStation(b);\n}\n} catch (java.lang.IllegalStateException e) {\n//sometimes it is not possible to build the\n//stations, e.g. another one is too close.\nbreak;\n}\nint stationA = mc.getStationId(a);\nint stationB = mc.getStationId(b);\nif (stationA >= 0 && stationB >= 0) {\n//the stations exist.\nmc.buildTrain(b, stationA, stationB);\n}\n}\nSystem.out.format(\"There are %d stations%n\", w.size(p.getPrincipal(), KEY.STATIONS));\ncitiesConnected.add(cityB);\n}\nSystem.out.println(ms);\nString[] passwords = {\"password\"};\ngameModel.setWorld(w, passwords);\ngamesManager.saveGame(gameModel, \"generated.sav\");\n}\n}"}
{"className":"jfreerails.JavaDocPlaceholder","javaDoc":"/**\n* This class does nothing and is only here so that javadoc gets generated\n* correctly.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class does nothing and is only here so that javadoc gets generated\n* correctly.\n*\n* @author Luke\n*\n*/\npublic class JavaDocPlaceholder {\n}"}
{"className":"jfreerails.move.AddActiveEntityMoveTest","javaDoc":null,"code":"public class AddActiveEntityMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nFreerailsPrincipal p = getPrincipal();\nActivity a = new WorldImplTest.TestActivity(50);\nAddActiveEntityMove move = new AddActiveEntityMove(a, 0,\np);\nassertSurvivesSerialisation(move);\nassertOkButNotRepeatable(move);\nAddActiveEntityMove move2 = new AddActiveEntityMove(a, 2,\np);\nassertTryMoveFails(move2);\n}\n}"}
{"className":"jfreerails.move.ListMove","javaDoc":"/**\n* This interface provides information about changes to the lists in the World\n* database.\n*\n* @author rob?\n*/","code":"/**\n* This interface provides information about changes to the lists in the World\n* database.\n*\n* @author rob?\n*/\npublic interface ListMove extends Move {\n/**\n* @return the type of object which was changed\n*/\nKEY getKey();\n/**\n* @return the old item or null if not any.\n*/\nFreerailsSerializable getBefore();\n/**\n* @return the new item or null if not any.\n*/\nFreerailsSerializable getAfter();\n/**\n* @return the index of the item which changed.\n*/\nint getIndex();\nFreerailsPrincipal getPrincipal();\n}"}
{"className":"jfreerails.move.NextActivityMoveTest","javaDoc":null,"code":"public class NextActivityMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nWorld w = getWorld();\nFreerailsPrincipal principal = getPrincipal();\nActivity act = new WorldImplTest.TestActivity(50);\nw.addActiveEntity(principal, act);\nActivity act2 = new WorldImplTest.TestActivity(60);\nMove move = new NextActivityMove(act2, 0,\nprincipal);\nassertSurvivesSerialisation(move);\nassertOkAndRepeatable(move);\n}\npublic void testMove2() {\nWorld w = getWorld();\nFreerailsPrincipal principal = getPrincipal();\nActivity act = new WorldImplTest.TestActivity(50);\nw.addActiveEntity(principal, act);\nActivity act2 = new WorldImplTest.TestActivity(60);\nMove move = new NextActivityMove(act2, 0,\nprincipal);\nassertDoThenUndoLeavesWorldUnchanged(move);\n}\npublic void testStackingOfActivities() {\nWorld w = getWorld();\nFreerailsPrincipal principal = getPrincipal();\nActivity act = new WorldImplTest.TestActivity(50);\nw.addActiveEntity(principal, act);\nActivity act2 = new WorldImplTest.TestActivity(60);\nMove move = new NextActivityMove(act2, 0,\nprincipal);\nassertDoMoveIsOk(move);\nGameTime currentTime = new GameTime(0);\nassertEquals(currentTime, w.currentTime());\nActivityIterator it = w.getActivities(principal, 0);\nassertEquals(it.getActivity(), act);\nassertEquals(it.getStartTime(), currentTime.getTicks(), 0.00001);\nassertEquals(50d, it.getDuration(), 0.00001);\nassertEquals(50d, it.getFinishTime(), 0.00001);\nassertTrue(it.hasNext());\nit.nextActivity();\nassertEquals(it.getActivity(), act2);\nassertEquals(50, it.getStartTime(), 0.00001);\nassertEquals(60, it.getDuration(), 0.0001d);\nassertEquals(110, it.getFinishTime(), 0.00001);\n}\n}"}
{"className":"jfreerails.move.ChangeCargoBundleMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class ChangeCargoBundleMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nMutableCargoBundle before;\nMutableCargoBundle after;\nbefore = new MutableCargoBundle();\nafter = new MutableCargoBundle();\nbefore.setAmount(new CargoBatch(1, 2, 3, 4, 0), 5);\nafter.setAmount(new CargoBatch(1, 2, 3, 4, 0), 8);\nMove m = new ChangeCargoBundleMove(before.toImmutableCargoBundle(),\nafter.toImmutableCargoBundle(), 0,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertSurvivesSerialisation(m);\nassertTryMoveFails(m);\nassertTryUndoMoveFails(m);\ngetWorld().add(MapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES,\nbefore.toImmutableCargoBundle());\n}\n}"}
{"className":"jfreerails.move.ChangeTrackPieceCompositeMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class ChangeTrackPieceCompositeMoveTest extends AbstractMoveTestCase {\nfinal Step southeast = Step.SOUTH_EAST;\nfinal Step east = Step.EAST;\nfinal Step northeast = Step.NORTH_EAST;\nfinal Step south = Step.SOUTH;\nfinal Step west = Step.WEST;\nTrackMoveTransactionsGenerator transactionsGenerator;\npublic ChangeTrackPieceCompositeMoveTest(java.lang.String testName) {\nsuper(testName);\n}\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\npublic static Test suite() {\nTestSuite testSuite = new TestSuite(\nChangeTrackPieceCompositeMoveTest.class);\nreturn testSuite;\n}\n@Override\nprotected void setUp() {\nsuper.setHasSetupBeenCalled(true);\nsetWorld(new WorldImpl(10, 10));\ngetWorld().set(ITEM.GAME_RULES, GameRules.DEFAULT_RULES);\ngetWorld().addPlayer(MapFixtureFactory.TEST_PLAYER);\nMapFixtureFactory.generateTrackRuleList(getWorld());\ntransactionsGenerator = new TrackMoveTransactionsGenerator(getWorld(),\nMapFixtureFactory.TEST_PRINCIPAL);\n}\npublic void testRemoveTrack() {\ngetWorld().set(ITEM.GAME_RULES, GameRules.NO_RESTRICTIONS);\nTrackRule trackRule = (TrackRule) getWorld().get(SKEY.TRACK_RULES, 0);\nassertBuildTrackSucceeds(new ImPoint(0, 5), east, trackRule);\nassertBuildTrackSucceeds(new ImPoint(0, 6), east, trackRule);\nassertBuildTrackSucceeds(new ImPoint(1, 6), east, trackRule);\nassertBuildTrackSucceeds(new ImPoint(0, 7), east, trackRule);\nassertBuildTrackSucceeds(new ImPoint(1, 7), east, trackRule);\nassertBuildTrackSucceeds(new ImPoint(2, 7), east, trackRule);\n// Remove only track piece built.\nassertRemoveTrackSucceeds(new ImPoint(0, 5), east);\nTrackConfiguration trackConfiguration = ((FreerailsTile) getWorld().getTile(0, 5))\n.getTrackPiece().getTrackConfiguration();\nTrackConfiguration expected = NullTrackPiece.getInstance().getTrackConfiguration();\nassertEquals(expected,\ntrackConfiguration);\nTrackConfiguration trackConfiguration2 = ((FreerailsTile) getWorld().getTile(1, 5))\n.getTrackPiece().getTrackConfiguration();\nassertEquals(expected,\ntrackConfiguration2);\n}\n/**\n* All track except the first piece built should be connected to existing\n* track.\n*/\npublic void testMustConnect2ExistingTrack() {\nTrackRule trackRule = (TrackRule) world.get(SKEY.TRACK_RULES, 0);\nint numberOfTransactions = world\n.getNumberOfTransactions(MapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(0, numberOfTransactions);\nboolean hasTrackBeenBuilt = ChangeTrackPieceCompositeMove\n.hasAnyTrackBeenBuilt(world, MapFixtureFactory.TEST_PRINCIPAL);\nassertFalse(\"No track has been built yet.\", hasTrackBeenBuilt);\nassertBuildTrackSucceeds(new ImPoint(0, 5), east, trackRule);\n// Building the track should have added a transaction.\nnumberOfTransactions = world\n.getNumberOfTransactions(MapFixtureFactory.TEST_PRINCIPAL);\nassertTrue(0 < numberOfTransactions);\nhasTrackBeenBuilt = ChangeTrackPieceCompositeMove.hasAnyTrackBeenBuilt(\nworld, MapFixtureFactory.TEST_PRINCIPAL);\nassertTrue(\"One track piece has been built.\", hasTrackBeenBuilt);\nassertBuildTrackSucceeds(new ImPoint(1, 5), east, trackRule);\nassertBuildTrackFails(new ImPoint(4, 8), east, trackRule);\n}\npublic void testCannotConnect2OtherRRsTrack() {\nassertFalse(ChangeTrackPieceMove.canConnect2OtherRRsTrack(world));\nfinal int TRACK_RULE_ID = 0;\nTrackRule trackRule = (TrackRule) getWorld().get(SKEY.TRACK_RULES,\nTRACK_RULE_ID);\nassertBuildTrackSucceeds(new ImPoint(0, 6), east, trackRule);\n// Now change the owner of the track piece at (1, 6);\nint anotherPlayer = 999;\nFreerailsTile oldTile = (FreerailsTile) world.getTile(1, 6);\nTrackPiece tp = oldTile.getTrackPiece();\nTrackPiece newTrackPiece = new TrackPieceImpl(tp\n.getTrackConfiguration(), tp.getTrackRule(), anotherPlayer,\nTRACK_RULE_ID);\nFreerailsTile newTile = FreerailsTile.getInstance(oldTile\n.getTerrainTypeID(), newTrackPiece);\nworld.setTile(1, 6, newTile);\nassertBuildTrackFails(new ImPoint(1, 6), east, trackRule);\nworld.setTile(1, 6, oldTile);\nassertBuildTrackSucceeds(new ImPoint(1, 6), east, trackRule);\n}\npublic void testBuildTrack() {\nImPoint pointA = new ImPoint(0, 0);\nImPoint pointB = new ImPoint(1, 1);\nImPoint pointC = new ImPoint(1, 0);\nTrackRule trackRule = (TrackRule) getWorld().get(SKEY.TRACK_RULES, 0);\n// First track piece built\nassertBuildTrackSucceeds(pointA, southeast, trackRule);\n// Track connected from one existing track piece\nassertBuildTrackSucceeds(pointB, northeast, trackRule);\n// Track connected to one existing track piece\n// This is not going through for some reason, not sure why.\n// assertBuildTrackSucceeds(pointC, west, trackRule);\n// Track connecting two existing track pieces.\nassertBuildTrackSucceeds(pointA, east, trackRule);\n// Track off map.. should fail.\nassertBuildTrackFails(pointA, northeast, trackRule);\n// Track already there.\nassertBuildTrackFails(pointA, southeast, trackRule);\n// Illegal config. connecting from one existing track piece\nassertBuildTrackFails(pointA, south, trackRule);\n// Illegal config. connecting to one existing track piece\nassertBuildTrackFails(new ImPoint(0, 1), northeast, trackRule);\n// Illegal config. connecting between two existing track pieces\nassertBuildTrackFails(pointC, south, trackRule);\n// Not allowed on this terrain type, from existing track.\nassertBuildTrackFails(new ImPoint(2, 0), northeast,\n(TrackRule) getWorld().get(SKEY.TRACK_RULES, 1));\n}\nprivate void assertBuildTrackFails(ImPoint p, Step v, TrackRule rule) {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(p, v, rule, rule, getWorld(),\nMapFixtureFactory.TEST_PRINCIPAL);\nMoveStatus status = move.doMove(getWorld(), Player.AUTHORITATIVE);\nassertEquals(false, status.isOk());\n}\nprivate void assertBuildTrackSucceeds(ImPoint p, Step v, TrackRule rule) {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(p, v, rule, rule, getWorld(),\nMapFixtureFactory.TEST_PRINCIPAL);\nMove moveAndTransaction = transactionsGenerator.addTransactions(move);\nMoveStatus status = moveAndTransaction.doMove(getWorld(),\nPlayer.AUTHORITATIVE);\nassertEquals(true, status.isOk());\n}\nprivate void assertRemoveTrackSucceeds(ImPoint p, Step v) {\ntry {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateRemoveTrackMove(p, v, getWorld(),\nMapFixtureFactory.TEST_PRINCIPAL);\nMoveStatus status = move.doMove(getWorld(), Player.AUTHORITATIVE);\nassertEquals(true, status.isOk());\n} catch (Exception e) {\nfail();\n}\n}\n@Override\npublic void testMove() {\nImPoint pointA = new ImPoint(0, 0);\nTrackRule trackRule = (TrackRule) getWorld().get(SKEY.TRACK_RULES, 0);\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(pointA, southeast, trackRule,\ntrackRule, getWorld(), MapFixtureFactory.TEST_PRINCIPAL);\nassertSurvivesSerialisation(move);\nassertOkButNotRepeatable(move);\nsetUp();\nassertDoThenUndoLeavesWorldUnchanged(move);\n}\n}"}
{"className":"jfreerails.move.AddPlayerMoveTest","javaDoc":null,"code":"public class AddPlayerMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nPlayer newPlayer = new Player(\"New Player\");\nassertTrue(\"Check reflexivity of Player.equals(.)\", Utils\n.equalsBySerialization(newPlayer, newPlayer));\nAddPlayerMove move = AddPlayerMove.generateMove(getWorld(), newPlayer);\nassertSurvivesSerialisation(move);\nassertDoThenUndoLeavesWorldUnchanged(move);\n}\npublic void testMove2() {\nPlayer newPlayer = new Player(\"New Player\");\nAddPlayerMove move = AddPlayerMove.generateMove(getWorld(), newPlayer);\nassertOkButNotRepeatable(move);\n}\n}"}
{"className":"jfreerails.move.TrackMoveTransactionsGeneratorTest","javaDoc":"/**\n* JUnit test case for TrackMoveTransactionsGenerator.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* JUnit test case for TrackMoveTransactionsGenerator.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrackMoveTransactionsGeneratorTest extends TestCase {\nprivate World world;\nprivate TrackMoveTransactionsGenerator transactionGenerator;\nprivate Player player;\n@Override\nprotected void setUp() throws Exception {\nworld = new WorldImpl(20, 20);\nMapFixtureFactory.generateTrackRuleList(world);\nplayer = new Player(\"test player\", 0);\nworld.addPlayer(player);\ntransactionGenerator = new TrackMoveTransactionsGenerator(world, player\n.getPrincipal());\n}\npublic void testAddTrackMove() {\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nTrackConfiguration newConfig;\nTrackMove move;\n// Try building the simplest piece of track.\nnewConfig = TrackConfiguration.getFlatInstance(\"000010000\");\noldTrackPiece = ((FreerailsTile) world.getTile(0, 0)).getTrackPiece();\nTrackRule r = (TrackRule) world.get(SKEY.TRACK_RULES, 0);\nint owner = ChangeTrackPieceCompositeMove.getOwner(\nMapFixtureFactory.TEST_PRINCIPAL, world);\nnewTrackPiece = new TrackPieceImpl(newConfig, r, owner, 0);\nmove = new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece,\nnew ImPoint(0, 0));\nMove m = transactionGenerator.addTransactions(move);\nassertNotNull(m);\n}\n}"}
{"className":"jfreerails.move.NextActivityMove","javaDoc":null,"code":"public class NextActivityMove implements Move {\nprivate static final long serialVersionUID = -1783556069173689661L;\nprivate final Activity activity;\nprivate final FreerailsPrincipal principal;\nprivate final int index;\npublic NextActivityMove(Activity activity, int index,\nFreerailsPrincipal principal) {\nthis.activity = activity;\nthis.index = index;\nthis.principal = principal;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof NextActivityMove))\nreturn false;\nfinal NextActivityMove nextActivityMove = (NextActivityMove) o;\nif (index != nextActivityMove.index)\nreturn false;\nif (!activity.equals(nextActivityMove.activity))\nreturn false;\nif (!principal.equals(nextActivityMove.principal))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = activity.hashCode();\nresult = 29 * result + principal.hashCode();\nresult = 29 * result + index;\nreturn result;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\n// Check that active entity exists.\nif (w.size(principal) <= index)\nreturn MoveStatus.moveFailed(\"Index out of range. \"+w.size(principal)+\"<= \"+index);\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nActivityIterator ai = w.getActivities(principal, index);\nai.gotoLastActivity();\nActivity act = ai.getActivity();\nif (act.equals(activity))\nreturn MoveStatus.MOVE_OK;\nreturn MoveStatus.moveFailed(\"Expected \" + activity + \" but found \"\n+ act);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.ok)\nw.add(principal, index, activity);\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.ok)\nw.removeLastActivity(principal, index);\nreturn ms;\n}\n}"}
{"className":"jfreerails.move.MapDiffMoveTest","javaDoc":"/**\n* JUnit test for MapDiffMove.\n*\n* @author Luke\n*/","code":"/**\n* JUnit test for MapDiffMove.\n*\n* @author Luke\n*/\npublic class MapDiffMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nWorld world2 = this.getWorld();\nWorldDiffs worldDiff = new WorldDiffs(world2);\nFreerailsTile tile = (FreerailsTile) world2.getTile(2, 2);\nassertNotNull(tile);\nassertEquals(tile, worldDiff.getTile(2, 2));\nFreerailsTile newTile = FreerailsTile.getInstance(999);\nworldDiff.setTile(3, 5, newTile);\nassertEquals(newTile, worldDiff.getTile(3, 5));\nMove m = new WorldDiffMove(world2, worldDiff, WorldDiffMove.Cause.Other);\nthis.assertDoMoveIsOk(m);\nthis.assertUndoMoveIsOk(m);\nthis.assertDoThenUndoLeavesWorldUnchanged(m);\nthis.assertSurvivesSerialisation(m);\n}\n}"}
{"className":"jfreerails.move.TrackMoveTransactionsGenerator","javaDoc":"/**\n* This class calculates the cost of a series of track moves. The motivation for\n* separating this code from the code that generates track moves is that the\n* transactions will be generated by the server whereas the track moves will be\n* generated by a client.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This class calculates the cost of a series of track moves. The motivation for\n* separating this code from the code that generates track moves is that the\n* transactions will be generated by the server whereas the track moves will be\n* generated by a client.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrackMoveTransactionsGenerator {\n/** Number of each of the track types added. */\nprivate int[] trackAdded;\nprivate long fixedCostsStations = 0;\nprivate long fixedCostsBridges = 0;\n/** Number of each of the track types removed. */\nprivate int[] trackRemoved;\nprivate final FreerailsPrincipal principal;\n/*\n* Note, trackAdded and trackRemoved cannot be combined, since it may cost\n* more to added a unit of track than is refunded when you removed it.\n*/\nprivate final ArrayList<Transaction> transactions = new ArrayList<Transaction>();\nprivate final ReadOnlyWorld w;\n/**\n* @param p\n* the Principal on behalf of which this object generates\n* transactions for\n*/\npublic TrackMoveTransactionsGenerator(ReadOnlyWorld world,\nFreerailsPrincipal p) {\nw = world;\nprincipal = p;\n}\npublic CompositeMove addTransactions(Move move) {\nint numberOfTrackTypes = w.size(SKEY.TRACK_RULES);\ntrackAdded = new int[numberOfTrackTypes];\ntrackRemoved = new int[numberOfTrackTypes];\nfixedCostsStations = 0;\nfixedCostsBridges = 0;\nunpackMove(move);\ngenerateTransactions();\nint numberOfMoves = 1 + transactions.size();\nMove[] moves = new Move[numberOfMoves];\nmoves[0] = move;\nfor (int i = 0; i < transactions.size(); i++) {\nTransaction t = transactions.get(i);\nmoves[i + 1] = new AddTransactionMove(principal, t, true);\n}\nreturn new CompositeMove(moves);\n}\nprivate void unpackMove(Move move) {\nif (move instanceof ChangeTrackPieceMove) {\nChangeTrackPieceMove tm = (ChangeTrackPieceMove) move;\nprocessMove(tm);\n} else if (move instanceof CompositeMove) {\nCompositeMove cm = (CompositeMove) move;\ncm.getMoves();\nImList<Move> moves = cm.getMoves();\nfor (int i = 0; i < moves.size(); i++) {\nunpackMove(moves.get(i));\n}\n}\n}\nprivate void processMove(ChangeTrackPieceMove move) {\nTrackPiece newTrackPiece = move.getNewTrackPiece();\nTrackRule newTrackRule = newTrackPiece.getTrackRule();\nfinal int ruleAfter = newTrackPiece.getTrackTypeID();\nTrackPiece oldTrackPiece = move.getOldTrackPiece();\nfinal int ruleBefore = oldTrackPiece.getTrackTypeID();\nfinal int oldLength = oldTrackPiece.getTrackConfiguration().getLength();\nfinal int newLength = newTrackPiece.getTrackConfiguration().getLength();\nif (ruleAfter != ruleBefore) {\nTrackRule.TrackCategories category = newTrackRule.getCategory();\nswitch (category) {\ncase station: {\nfixedCostsStations -= newTrackRule.getFixedCost().getAmount();\nbreak;\n}\ncase bridge: {\nfixedCostsBridges -= newTrackRule.getFixedCost().getAmount();\nbreak;\n}\ndefault: {\n// Do nothing.\n}\n}\n}\nif (ruleAfter == ruleBefore) {\nif (oldLength < newLength) {\ntrackAdded[ruleAfter] += (newLength - oldLength);\n} else if (oldLength > newLength) {\ntrackRemoved[ruleAfter] += (oldLength - newLength);\n}\nreturn;\n}\nif (ruleAfter != NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\ntrackAdded[ruleAfter] += newLength;\n}\nif (ruleBefore != NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\ntrackRemoved[ruleBefore] += oldLength;\n}\n}\nprivate void generateTransactions() {\ntransactions.clear();\n// For each track type, generate a transaction if any pieces of the type\n// have been added or removed.\nfor (int i = 0; i < trackAdded.length; i++) {\nint numberAdded = trackAdded[i];\nif (0 != numberAdded) {\nTrackRule rule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nMoney m = rule.getPrice();\nMoney total = new Money(-m.getAmount() * numberAdded\n/ TrackConfiguration.LENGTH_OF_STRAIGHT_TRACK_PIECE);\nTransaction t = new AddItemTransaction(TRACK, i, numberAdded,\ntotal);\ntransactions.add(t);\n}\nint numberRemoved = trackRemoved[i];\nif (0 != numberRemoved) {\nTrackRule rule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nMoney m = rule.getPrice();\nMoney total = new Money((m.getAmount() * numberRemoved)\n/ TrackConfiguration.LENGTH_OF_STRAIGHT_TRACK_PIECE);\n// You only get half the money back.\ntotal = new Money(total.getAmount() / 2);\nTransaction t = new AddItemTransaction(TRACK, i,\n-numberRemoved, total);\ntransactions.add(t);\n}\n}\nif (0 != fixedCostsStations) {\nTransaction t = new AddItemTransaction(STATIONS, -1, -1, new Money(\nfixedCostsStations));\ntransactions.add(t);\n}\nif (0 != fixedCostsBridges) {\nTransaction t = new AddItemTransaction(BRIDGES, -1, -1, new Money(\nfixedCostsBridges));\ntransactions.add(t);\n}\n}\n}"}
{"className":"jfreerails.move.CompositeMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class CompositeMoveTest extends AbstractMoveTestCase {\nfinal StationModel station1 = new StationModel(1, 1, \"station1\", 10, 0);\nfinal StationModel station2 = new StationModel(2, 3, \"station2\", 10, 0);\nfinal StationModel station3 = new StationModel(3, 3, \"station3\", 10, 0);\nfinal StationModel station4 = new StationModel(4, 4, \"station4\", 10, 0);\n@Override\npublic void testMove() {\nMove[] moves = new Move[4];\nmoves[0] = new AddItemToListMove(KEY.STATIONS, 0, station1,\nMapFixtureFactory.TEST_PRINCIPAL);\nmoves[1] = new AddItemToListMove(KEY.STATIONS, 1, station2,\nMapFixtureFactory.TEST_PRINCIPAL);\nmoves[2] = new AddItemToListMove(KEY.STATIONS, 2, station3,\nMapFixtureFactory.TEST_PRINCIPAL);\nmoves[3] = new AddItemToListMove(KEY.STATIONS, 3, station4,\nMapFixtureFactory.TEST_PRINCIPAL);\nMove compositeMove = new CompositeMove(moves);\nassertSurvivesSerialisation(compositeMove);\nassertTryMoveIsOk(compositeMove);\nassertEquals(\"The stations should not have been add yet.\", 0,\ngetWorld().size(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS));\nassertDoMoveIsOk(compositeMove);\nassertEquals(\"The stations should have been add now.\", 4, getWorld()\n.size(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS));\nassertTryUndoMoveIsOk(compositeMove);\nassertUndoMoveIsOk(compositeMove);\nassertOkButNotRepeatable(compositeMove);\n}\n}"}
{"className":"jfreerails.move.TimeTickMove","javaDoc":"/**\n*\n* Changes the time item on the world object.\n*\n* @author rob\n*/","code":"/**\n*\n* Changes the time item on the world object.\n*\n* @author rob\n*/\npublic class TimeTickMove implements Move {\nprivate static final long serialVersionUID = 3257290240212153393L;\nprivate final GameTime oldTime;\nprivate final GameTime newTime;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TimeTickMove))\nreturn false;\nfinal TimeTickMove timeTickMove = (TimeTickMove) o;\nif (!newTime.equals(timeTickMove.newTime))\nreturn false;\nif (!oldTime.equals(timeTickMove.oldTime))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = oldTime.hashCode();\nresult = 29 * result + newTime.hashCode();\nreturn result;\n}\npublic static TimeTickMove getMove(ReadOnlyWorld w) {\nGameTime oldTime = w.currentTime();\nGameTime newTime = new GameTime(oldTime.getTicks() + 1);\nreturn new TimeTickMove(oldTime, newTime);\n}\npublic TimeTickMove(GameTime oldTime, GameTime newTime) {\nthis.oldTime = oldTime;\nthis.newTime = newTime;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.currentTime().equals(oldTime)) {\nreturn MoveStatus.MOVE_OK;\n}\nString string = \"oldTime = \" + oldTime.getTicks() + \" <=> \"\n+ \"currentTime \" + (w.currentTime()).getTicks();\nreturn MoveStatus.moveFailed(string);\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nGameTime time = w.currentTime();\nif (time.equals(newTime)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected \" + newTime + \", found \" + time);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryDoMove(w, p);\nif (status.ok) {\nw.setTime(newTime);\n}\nreturn status;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryUndoMove(w, p);\nif (status.isOk()) {\nw.setTime(oldTime);\n}\nreturn status;\n}\n@Override\npublic String toString() {\nreturn \"TimeTickMove: \" + oldTime + \"=>\" + newTime;\n}\n}"}
{"className":"jfreerails.move.ChangeTrackPieceMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class ChangeTrackPieceMoveTest extends AbstractMoveTestCase {\npublic ChangeTrackPieceMoveTest(String testName) {\nsuper(testName);\n}\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\npublic static junit.framework.Test suite() {\njunit.framework.TestSuite testSuite = new junit.framework.TestSuite(\nChangeTrackPieceMoveTest.class);\nreturn testSuite;\n}\n@Override\nprotected void setUp() {\nsetHasSetupBeenCalled(true);\nsetWorld(new WorldImpl(20, 20));\ngetWorld().set(ITEM.GAME_RULES, GameRules.NO_RESTRICTIONS);\nMapFixtureFactory.generateTrackRuleList(getWorld());\n}\npublic void testTryDoMove() {\nsetUp();\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nTrackConfiguration newConfig;\nTrackMove move;\nMoveStatus moveStatus;\n// Try building the simplest piece of track.\nnewConfig = TrackConfiguration.getFlatInstance(\"000010000\");\noldTrackPiece = ((FreerailsTile) getWorld().getTile(0, 0)).getTrackPiece();\nfinal int trackRuleID = 0;\nfinal TrackRule r = (TrackRule) getWorld().get(SKEY.TRACK_RULES,\ntrackRuleID);\nnewTrackPiece = new TrackPieceImpl(newConfig, r, 0, trackRuleID);\nmove = new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece,\nnew ImPoint(0, 0));\nmoveStatus = move.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(moveStatus);\nassertEquals(true, moveStatus.isOk());\n// As above but with newTrackPiece and oldTrackPiece in the wrong order,\n// should fail.\nmove = new ChangeTrackPieceMove(newTrackPiece, oldTrackPiece,\nnew ImPoint(0, 0));\nmoveStatus = move.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(moveStatus);\nassertEquals(false, moveStatus.isOk());\n// Try a move that does nothing, i.e. oldTrackPiece==newTrackPiece,\n// should fail.\nmove = new ChangeTrackPieceMove(oldTrackPiece, oldTrackPiece,\nnew ImPoint(0, 0));\nmoveStatus = move.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(moveStatus);\nassertEquals(false, moveStatus.isOk());\n// Try buildingtrack outside the map.\nmove = new ChangeTrackPieceMove(newTrackPiece, oldTrackPiece,\nnew ImPoint(100, 0));\nmoveStatus = move.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(moveStatus);\nassertEquals(false, moveStatus.isOk());\n// Try building an illegal track configuration.\nnewConfig = TrackConfiguration.getFlatInstance(\"000011111\");\nnewTrackPiece = new TrackPieceImpl(newConfig, r, 0, trackRuleID);\nmove = new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece,\nnew ImPoint(0, 0));\nmoveStatus = move.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertEquals(false, moveStatus.isOk());\n}\npublic void testTryUndoMove() {\nsetUp();\n}\npublic void testDoMove() {\nsetUp();\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nTrackConfiguration newConfig;\n// Try building the simplest piece of track.\nnewConfig = TrackConfiguration.getFlatInstance(\"000010000\");\noldTrackPiece = ((FreerailsTile) getWorld().getTile(0, 0)).getTrackPiece();\nTrackRule r = (TrackRule) getWorld().get(SKEY.TRACK_RULES, 0);\nnewTrackPiece = new TrackPieceImpl(newConfig, r, 0, 0);\nassertMoveDoMoveIsOk(oldTrackPiece, newTrackPiece);\n}\nprotected void assertMoveDoMoveIsOk(TrackPiece oldTrackPiece,\nTrackPiece newTrackPiece) {\nTrackMove move;\nMoveStatus moveStatus;\nmove = new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece,\nnew ImPoint(0, 0));\nmoveStatus = move.doMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(moveStatus);\nassertEquals(true, moveStatus.isOk());\nTrackConfiguration actual = ((FreerailsTile)getWorld().getTile(0, 0)).getTrackPiece().getTrackConfiguration();\nassertEquals(newTrackPiece.getTrackConfiguration(),\nactual);\n}\n@Override\npublic void testMove() {\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nTrackConfiguration newConfig;\nnewConfig = TrackConfiguration.getFlatInstance(\"000010000\");\noldTrackPiece = ((FreerailsTile) getWorld().getTile(0, 0)).getTrackPiece();\nTrackRule r = (TrackRule) getWorld().get(SKEY.TRACK_RULES, 0);\nnewTrackPiece = new TrackPieceImpl(newConfig, r, 0, 0);\nMove move = new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece,\nnew ImPoint(0, 0));\nassertSurvivesSerialisation(move);\nassertOkButNotRepeatable(move);\n}\n}"}
{"className":"jfreerails.move.WorldDiffMove","javaDoc":"/**\n* A move that makes a number of changes to the map and to the lists.\n*\n* WARNING: This class currently only handles the most common cases. A\n* UnsupportedOperationException is thrown if an appropriate move\n* cannot be generated.\n*\n*\n* @author Luke\n*/","code":"/**\n* A move that makes a number of changes to the map and to the lists.\n*\n* WARNING: This class currently only handles the most common cases. A\n* UnsupportedOperationException is thrown if an appropriate move\n* cannot be generated.\n*\n*\n* @author Luke\n*/\npublic class WorldDiffMove implements Move, MapUpdateMove {\npublic enum Cause{TrainArrives, Other, YearEnd};\nprivate final Cause cause;\nprivate static final Logger logger = Logger.getLogger(WorldDiffMove.class\n.getName());\nstatic class MapDiff implements FreerailsSerializable {\nprivate static final long serialVersionUID = -5935670372745313360L;\nfinal FreerailsSerializable before, after;\nfinal int x, y;\nMapDiff(FreerailsSerializable before, FreerailsSerializable after,\nImPoint p) {\nthis.after = after;\nthis.before = before;\nthis.x = p.x;\nthis.y = p.y;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof MapDiff))\nreturn false;\nfinal MapDiff diff = (MapDiff) o;\nif (x != diff.x)\nreturn false;\nif (y != diff.y)\nreturn false;\nif (!after.equals(diff.after))\nreturn false;\nif (!before.equals(diff.before))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = x;\nresult = 29 * result + y;\nresult = 29 * result + before.hashCode();\nresult = 29 * result + after.hashCode();\nreturn result;\n}\n}\nprivate static final long serialVersionUID = 3905245632406239544L;\npublic static WorldDiffMove generate(WorldDiffs diffs, Cause cause) {\nreturn new WorldDiffMove(diffs.getUnderlying(), diffs, cause);\n}\nprivate final ImList<MapDiff> diffs;\nprivate final CompositeMove listChanges;\nprivate final int x, y, w, h;\npublic WorldDiffMove(ReadOnlyWorld world, WorldDiffs worldDiffs, Cause cause) throws UnsupportedOperationException {\nthis.cause = cause;\nIterator<ImPoint> mit = worldDiffs.getMapDiffs();\nArrayList<MapDiff> diffsArrayList = new ArrayList<MapDiff>();\nwhile (mit.hasNext()) {\nImPoint p = mit.next();\nFreerailsSerializable oldTile = world.getTile(p.x, p.y);\nFreerailsSerializable newTile = worldDiffs.getTile(p.x, p.y);\ndiffsArrayList.add(new MapDiff(oldTile, newTile, p));\n}\ndiffs = new ImList<MapDiff>(diffsArrayList);\nx = 0;\ny = 0;\nw = world.getMapWidth();\nh = world.getMapHeight();\nList<Move> tempList = new ArrayList<Move>();\nIterator<ListKey> lit = worldDiffs.getListDiffs();\nwhile (lit.hasNext()) {\nListKey lkey = lit.next();\nWorldDiffs.LISTID listId = (LISTID) lkey.getListID();\nswitch (listId) {\ncase LISTS: {\nint playerId = lkey.getIndex()[0];\nFreerailsPrincipal fp = worldDiffs.getPlayer(playerId)\n.getPrincipal();\nKEY k = KEY.getKey(lkey.getIndex()[1]);\nif (lkey.getType() == Element) {\nMove m;\nint elementId = lkey.getIndex()[2];\n// Are we changing an element?\nif (elementId < world.size(fp, k)) {\nFreerailsSerializable before = world.get(fp, k,\nelementId);\nFreerailsSerializable after = worldDiffs.get(fp, k,\nelementId);\nm = new ChangeItemInListMove(k, elementId, before,\nafter, fp);\n} else {\nFreerailsSerializable element = worldDiffs.get(fp, k,\nelementId);\nm = new AddItemToListMove(k, elementId, element, fp);\n}\ntempList.add(m);\n} else {\nassert (lkey.getType() == EndPoint);\nInteger newSize = (Integer) worldDiffs.getDiff(lkey);\nint oldSize = world.size(fp, k);\nif (newSize < oldSize) {\nthrow new UnsupportedOperationException();\n}\n}\nbreak;\n}\ncase CURRENT_BALANCE:\n// Do nothing. The transaction moves should take care of changing\n// the values of current balance.\nbreak;\ncase BANK_ACCOUNTS: {\nint playerId = lkey.getIndex()[0];\nFreerailsPrincipal fp = worldDiffs.getPlayer(playerId)\n.getPrincipal();\nif (lkey.getType() == Element) {\nMove m;\nint elementId = lkey.getIndex()[1];\n// Are we changing an element?\nif (elementId < world.getNumberOfTransactions(fp)) {\nthrow new UnsupportedOperationException();\n}\nTransaction t = worldDiffs.getTransaction(fp, elementId);\nm = new AddTransactionMove(fp, t );\ntempList.add(m);\n} else {\nassert (lkey.getType() == EndPoint);\nInteger newSize = (Integer) worldDiffs.getDiff(lkey);\nint oldSize = world.getNumberOfTransactions(fp);\nif (newSize < oldSize) {\nthrow new UnsupportedOperationException();\n}\n}\nbreak;\n}\ncase ACTIVITY_LISTS:{\nint playerId = lkey.getIndex()[0];\nFreerailsPrincipal fp = worldDiffs.getPlayer(playerId)\n.getPrincipal();\nObject o = worldDiffs.getDiff(lkey);\nlogger.fine(lkey.toString() + \" --> \"+ o.toString());\nswitch (lkey.getIndex().length){\ncase 1:{\nassert (lkey.getType() == EndPoint);\n//Do nothing. Adding the activities will increase the\n//size of the list.\nbreak;\n}\ncase 2:\nassert (lkey.getType() == EndPoint);\n//Do nothing. Adding the activities will increase the\n//size of the list.\nbreak;\ncase 3:{\nMove m;\n//Do we need to add a new active entity?\nint entityId = lkey.getIndex()[1];\nActivityAndTime aat = (ActivityAndTime) worldDiffs.getDiff(lkey);\nActivity act = aat.act;\nint activityID = lkey.getIndex()[2];\nif(entityId >= world.getNumberOfActiveEntities(fp) && 0 == activityID){\nlogger.fine(\"AddActiveEntityMove: \"+act+\" entityId=\"+entityId);\nm = new AddActiveEntityMove(act, entityId, fp );\n}else{\nlogger.fine(\"NextActivityMove: \"+act+\" entityId=\"+entityId);\nm = new NextActivityMove(act,entityId, fp);\n}\ntempList.add(m);\nbreak;\n}default:\nthrow new UnsupportedOperationException(listId.toString());\n}\nbreak;\n}\ndefault:\nthrow new UnsupportedOperationException(listId.toString());\n}\n}\nlistChanges = new CompositeMove(tempList);\n}\nprivate void doMove(World world, boolean undo) {\nfor (int i = 0; i < diffs.size(); i++) {\nMapDiff diff = diffs.get(i);\nFreerailsSerializable tile = undo ? diff.before : diff.after;\nworld.setTile(diff.x, diff.y, tile);\n}\n}\npublic MoveStatus doMove(World world, FreerailsPrincipal p) {\nMoveStatus ms = tryMapChanges(world, false);\nif (!ms.ok)\nreturn ms;\nms = listChanges.doMove(world, p);\nif (ms.isOk()) {\ndoMove(world, false);\n}\nreturn ms;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof WorldDiffMove))\nreturn false;\nfinal WorldDiffMove mapDiffMove = (WorldDiffMove) o;\nif (h != mapDiffMove.h)\nreturn false;\nif (w != mapDiffMove.w)\nreturn false;\nif (x != mapDiffMove.x)\nreturn false;\nif (y != mapDiffMove.y)\nreturn false;\nif (!diffs.equals(mapDiffMove.diffs))\nreturn false;\nreturn true;\n}\npublic Rectangle getUpdatedTiles() {\nreturn new Rectangle(x, y, w, h);\n}\n@Override\npublic int hashCode() {\nint result;\nresult = diffs.hashCode();\nresult = 29 * result + x;\nresult = 29 * result + y;\nresult = 29 * result + w;\nresult = 29 * result + h;\nreturn result;\n}\npublic MoveStatus tryDoMove(World world, FreerailsPrincipal p) {\nMoveStatus ms = tryMapChanges(world, false);\nif (!ms.ok)\nreturn ms;\nreturn ms = listChanges.tryDoMove(world, p);\n}\nprivate MoveStatus tryMapChanges(World world, boolean undo) {\nfor (int i = 0; i < diffs.size(); i++) {\nMapDiff diff = diffs.get(i);\nFreerailsSerializable actual = world.getTile(diff.x, diff.y);\nFreerailsSerializable expected = undo ? diff.after : diff.before;\nif (!actual.equals(expected)) {\nreturn MoveStatus.moveFailed(\"expected =\" + expected\n+ \", actual = \" + actual);\n}\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World world, FreerailsPrincipal p) {\nMoveStatus ms = tryMapChanges(world, true);\nif (!ms.ok)\nreturn ms;\nreturn ms = listChanges.tryUndoMove(world, p);\n}\npublic int listDiffs() {\nreturn listChanges.size();\n}\npublic MoveStatus undoMove(World world, FreerailsPrincipal p) {\nMoveStatus ms = tryMapChanges(world, true);\nif (!ms.ok)\nreturn ms;\nms = listChanges.undoMove(world, p);\nif (ms.isOk()) {\ndoMove(world, true);\n}\nreturn ms;\n}\npublic Cause getCause() {\nreturn cause;\n}\npublic CompositeMove getListChanges() {\nreturn listChanges;\n}\n}"}
{"className":"jfreerails.move.RemoveCargoBundleMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class RemoveCargoBundleMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nMutableCargoBundle bundleA;\nMutableCargoBundle bundleB;\nbundleA = new MutableCargoBundle();\nbundleB = new MutableCargoBundle();\nbundleA.setAmount(new CargoBatch(1, 2, 3, 4, 0), 5);\nbundleB.setAmount(new CargoBatch(1, 2, 3, 4, 0), 5);\nassertEquals(bundleA, bundleB);\nMove m = new RemoveCargoBundleMove(0, bundleB.toImmutableCargoBundle(),\nMapFixtureFactory.TEST_PRINCIPAL);\nassertSurvivesSerialisation(m);\nassertTryMoveFails(m);\nassertTryUndoMoveFails(m);\ngetWorld().add(MapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES,\nbundleA.toImmutableCargoBundle());\nassertTryMoveIsOk(m);\nassertOkButNotRepeatable(m);\n}\n}"}
{"className":"jfreerails.move.Move","javaDoc":"/**\n* All moves should implement this interface and obey the contract described\n* below.\n* <p>\n* (1) They should be immutable.\n* </P>\n* <p>\n* (2) They should override <code>Object.equals()</code> to test for logical\n* equality.\n* </P>\n* <p>\n* (3) They should store 'before' and 'after' values for all properties of the\n* world object that they change.\n* <p>\n* (4) The changes they encapsulate should be stored in an address space\n* independent way, so that a move generated on a client can be serialised, sent\n* over a network, and then deserialized and executed on a server. To achieve\n* this, they should refer to items in the game world via either their\n* coordinates, e.g. tile 10,50, or their position in a list, e.g. train #4.\n* </p>\n* <p>\n* (5) They should be undoable. To achieve this, they need to store the\n* information necessary to undo the change. E.g. a change-terrain-type move\n* might store the tile coordinates, the terrain type before the change and the\n* terrain type after the change.\n* </p>\n* <p>\n* (6) The tryDoMove and tryUndoMove methods should test whether the move is\n* valid but leave the gameworld unchanged\n* </p>\n*\n* @see MoveStatus\n* @see jfreerails.world.top.World\n* @see jfreerails.controller.PreMove\n* @author lindsal\n*/","code":"/**\n* All moves should implement this interface and obey the contract described\n* below.\n* <p>\n* (1) They should be immutable.\n* </P>\n* <p>\n* (2) They should override <code>Object.equals()</code> to test for logical\n* equality.\n* </P>\n* <p>\n* (3) They should store 'before' and 'after' values for all properties of the\n* world object that they change.\n* <p>\n* (4) The changes they encapsulate should be stored in an address space\n* independent way, so that a move generated on a client can be serialised, sent\n* over a network, and then deserialized and executed on a server. To achieve\n* this, they should refer to items in the game world via either their\n* coordinates, e.g. tile 10,50, or their position in a list, e.g. train #4.\n* </p>\n* <p>\n* (5) They should be undoable. To achieve this, they need to store the\n* information necessary to undo the change. E.g. a change-terrain-type move\n* might store the tile coordinates, the terrain type before the change and the\n* terrain type after the change.\n* </p>\n* <p>\n* (6) The tryDoMove and tryUndoMove methods should test whether the move is\n* valid but leave the gameworld unchanged\n* </p>\n*\n* @see MoveStatus\n* @see jfreerails.world.top.World\n* @see jfreerails.controller.PreMove\n* @author lindsal\n*/\npublic interface Move extends FreerailsSerializable {\n/**\n* Tests whether this Move can be executed on the specified world object,\n* this method should leave the world object unchanged.\n*/\nMoveStatus tryDoMove(World w, FreerailsPrincipal p);\n/**\n* Tests whether this Move can be undone on the specified world object, this\n* method should leave the world object unchanged.\n*/\nMoveStatus tryUndoMove(World w, FreerailsPrincipal p);\n/**\n* Executes this move on the specified world object.\n*/\nMoveStatus doMove(World w, FreerailsPrincipal p);\n/**\n* If <code>doMove</code> has just been executed on the specified world\n* object, calling this method changes the state of the world object back to\n* how it was before <code>doMove</code> was called.\n*/\nMoveStatus undoMove(World w, FreerailsPrincipal p);\n}"}
{"className":"jfreerails.move.ChangeTileMoveTest","javaDoc":null,"code":"public class ChangeTileMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nPoint p = new Point(10, 10);\nTerrainTile tile = (TerrainTile) world.getTile(10, 10);\nassertTrue(tile.getTerrainTypeID() != 5);\nChangeTileMove move = new ChangeTileMove(world, p, 5);\nMoveStatus ms = move.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.message, ms.ok);\ntile = (TerrainTile) world.getTile(10, 10);\nassertTrue(tile.getTerrainTypeID() == 5);\n}\npublic void testMove2() {\nPoint p = new Point(10, 10);\nChangeTileMove move = new ChangeTileMove(world, p, 5);\nassertSurvivesSerialisation(move);\n}\n@Override\nprotected void setupWorld() {\nworld = MapFixtureFactory2.getCopy();\n}\n}"}
{"className":"jfreerails.move.RemoveStationMove","javaDoc":"/**\n* This Move removes a station from the station list and from the map.\n*\n* @author Luke\n*\n*/","code":"/**\n* This Move removes a station from the station list and from the map.\n*\n* @author Luke\n*\n*/\npublic class RemoveStationMove extends CompositeMove implements TrackMove {\nprivate static final long serialVersionUID = 3760847865429702969L;\nprivate RemoveStationMove(ArrayList<Move> moves) {\nsuper(moves);\n}\nstatic RemoveStationMove getInstance(ReadOnlyWorld w,\nChangeTrackPieceMove removeTrackMove, FreerailsPrincipal principal) {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w, principal);\nint stationIndex = -1;\nwhile (wi.next()) {\nStationModel station = (StationModel) wi.getElement();\nif (station.x == removeTrackMove.getLocation().x\n&& station.y == removeTrackMove.getLocation().y) {\n// We have found the station!\nstationIndex = wi.getIndex();\nbreak;\n}\n}\nif (-1 == stationIndex) {\nthrow new IllegalArgumentException(\"Could find a station at \"\n+ removeTrackMove.getLocation().x + \", \"\n+ removeTrackMove.getLocation().y);\n}\nStationModel station2remove = (StationModel) w.get(principal,\nKEY.STATIONS, stationIndex);\nArrayList<Move> moves = new ArrayList<Move>();\nmoves.add(removeTrackMove);\nmoves.add(new RemoveItemFromListMove(KEY.STATIONS, stationIndex,\nstation2remove, principal));\n// Now update any train schedules that include this station.\nWorldIterator schedules = new NonNullElements(KEY.TRAIN_SCHEDULES, w,\nprincipal);\nwhile (schedules.next()) {\nImmutableSchedule schedule = (ImmutableSchedule) schedules\n.getElement();\nif (schedule.stopsAtStation(stationIndex)) {\nMutableSchedule mutableSchedule = new MutableSchedule(schedule);\nmutableSchedule.removeAllStopsAtStation(stationIndex);\nMove changeScheduleMove = new ChangeTrainScheduleMove(schedules\n.getIndex(), schedule, mutableSchedule\n.toImmutableSchedule(), principal);\nmoves.add(changeScheduleMove);\n}\n}\nreturn new RemoveStationMove(moves);\n}\npublic Rectangle getUpdatedTiles() {\nTrackMove tm = (TrackMove) getMove(0);\nreturn tm.getUpdatedTiles();\n}\n}"}
{"className":"jfreerails.move.AbstractMoveTestCase","javaDoc":"/**\n* All TestCases for moves should extend this class.\n*\n* @author Luke\n*\n*/","code":"/**\n* All TestCases for moves should extend this class.\n*\n* @author Luke\n*\n*/\npublic abstract class AbstractMoveTestCase extends TestCase {\nprivate boolean hasSetupBeenCalled = false;\nprotected World world;\nprotected AbstractMoveTestCase() {\n}\npublic AbstractMoveTestCase(String str) {\nsuper(str);\n}\nprotected void assertDoMoveFails(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.doMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertTrue(\"Move went through when it should have failed\", !ms.ok);\n}\nprotected void assertDoMoveIsOk(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.doMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(MoveStatus.MOVE_OK, ms);\n}\nprotected void assertDoThenUndoLeavesWorldUnchanged(Move m) {\ntry {\nWorld w = getWorld();\nWorld before = (World) Utils.cloneBySerialisation(w);\nassertEquals(before, w);\nassertTrue(m.doMove(w, Player.AUTHORITATIVE).ok);\nWorld after = (World) Utils.cloneBySerialisation(w);\nassertFalse(after.equals(before));\nboolean b = m.undoMove(w, Player.AUTHORITATIVE).ok;\nassertTrue(b);\nassertEquals(before, w);\n} catch (Exception e) {\ne.printStackTrace();\nassertTrue(false);\n}\n}\n/**\n* This method asserts that if we serialise then deserialize the specified\n* move, the specified move is equal to the deserialized move. The assertion\n* depends on the move being serializable and the equals method being\n* implemented correctly. Also checks that the hashcode does not change.\n*\n* @param m\n*/\nprotected void assertSurvivesSerialisation(FreerailsSerializable m) {\nassertEquals(\"Reflexivity violated: the move does not equal itself\", m,\nm);\ntry {\nObject o = Utils.cloneBySerialisation(m);\nassertEquals(m, o);\nassertEquals(\"The hashcodes should be the same!\", m.hashCode(), o\n.hashCode());\n} catch (Exception e) {\ne.printStackTrace();\nassertTrue(false);\n}\n}\nprotected void assertOkAndRepeatable(Move m) {\nassertSetupHasBeenCalled();\n// Do move\nassertTryMoveIsOk(m);\nassertDoMoveIsOk(m);\nassertTryMoveIsOk(m);\nassertDoMoveIsOk(m);\n// Since it leaves the world unchanged it should also be\n// possible to undo it repeatably\nassertTryUndoMoveIsOk(m);\nassertUndoMoveIsOk(m);\nassertTryUndoMoveIsOk(m);\nassertUndoMoveIsOk(m);\n}\n/**\n* Generally moves should not be repeatable. For example, if we have just\n* removed a piece of track, that piece of track is gone, so we cannot\n* remove it again.\n*/\nprotected void assertOkButNotRepeatable(Move m) {\nassertSetupHasBeenCalled();\nassertTryMoveIsOk(m);\nassertDoMoveIsOk(m);\nassertTryMoveFails(m);\nassertDoMoveFails(m);\nassertTryUndoMoveIsOk(m);\nassertUndoMoveIsOk(m);\nassertTryUndoMoveFails(m);\nassertTryMoveIsOk(m);\nassertDoMoveIsOk(m);\n}\nprivate void assertSetupHasBeenCalled() {\nassertTrue(\"AbstractMoveTestCase.setUp has not been called!\",\nhasSetupBeenCalled());\n}\nprotected void assertTryMoveFails(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertTrue(\"Move went through when it should have failed\", !ms.ok);\n}\nprotected void assertTryMoveIsOk(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(\"First try failed\", MoveStatus.MOVE_OK, ms);\nms = m.tryDoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(\n\"Second try failed, this suggests that the tryDoMove method failed to leave the world unchanged!\",\nMoveStatus.MOVE_OK, ms);\n}\nprotected void assertTryUndoMoveFails(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.tryUndoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertTrue(\"Move went through when it should have failed\", !ms.ok);\n}\nprotected void assertTryUndoMoveIsOk(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.tryUndoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(\"First try failed\", MoveStatus.MOVE_OK, ms);\nms = m.tryUndoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(\n\"Second try failed, this suggests that the tryDoMove method failed to leave the world unchanged!\",\nMoveStatus.MOVE_OK, ms);\n}\nprotected void assertUndoMoveFails(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.tryUndoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertTrue(\"Move went through when it should have failed\", !ms.ok);\n}\nprotected void assertUndoMoveIsOk(Move m) {\nassertSetupHasBeenCalled();\nMoveStatus ms = m.undoMove(getWorld(), Player.AUTHORITATIVE);\nassertNotNull(ms);\nassertEquals(MoveStatus.MOVE_OK, ms);\n}\nFreerailsPrincipal getPrincipal() {\nreturn world.getPlayer(0).getPrincipal();\n}\nWorld getWorld() {\nreturn world;\n}\nprotected boolean hasSetupBeenCalled() {\nreturn hasSetupBeenCalled;\n}\nprotected void setHasSetupBeenCalled(boolean hasSetupBeenCalled) {\nthis.hasSetupBeenCalled = hasSetupBeenCalled;\n}\n@Override\nprotected void setUp() throws Exception {\nsetHasSetupBeenCalled(true);\nsetupWorld();\n}\nprotected void setupWorld() {\nsetWorld(new WorldImpl(10, 10));\n// Set the time..\ngetWorld().set(ITEM.CALENDAR, new GameCalendar(12000, 1840));\ngetWorld().addPlayer(MapFixtureFactory.TEST_PLAYER);\n}\nvoid setWorld(World world) {\nthis.world = world;\n}\npublic void testMove(){}\nprotected void assertTrackHere(int x, int y) {\nFreerailsTile tile = (FreerailsTile) world.getTile(x, y);\nassertTrue(tile.hasTrack());\n}\nprotected void assertTrackHere(PathOnTiles path) {\nImPoint start = path.getStart();\nint x = start.x;\nint y = start.y;\nfor (int i = 0; i < path.steps(); i++) {\nassertTrackHere(x, y);\nStep step = path.getStep(i);\nx += step.deltaX;\ny += step.deltaY;\nassertTrackHere(x, y);\n}\n}\n}"}
{"className":"jfreerails.move.AddTransactionMove","javaDoc":"/**\n* This {@link Move} adds a {@link Transaction} to a players bank account on the\n* {@link World} object.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This {@link Move} adds a {@link Transaction} to a players bank account on the\n* {@link World} object.\n*\n* @author Luke Lindsay\n*\n*/\npublic class AddTransactionMove implements Move {\nprivate static final long serialVersionUID = 3976738055925019701L;\nprivate final Transaction transaction;\nprivate final FreerailsPrincipal principal;\n/** Whether the move fails if there is not enough cash. */\nprivate final boolean constrained;\npublic Transaction getTransaction() {\nreturn transaction;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = transaction.hashCode();\nresult = 29 * result + principal.hashCode();\nresult = 29 * result + (constrained ? 1 : 0);\nreturn result;\n}\npublic AddTransactionMove(FreerailsPrincipal account, Transaction t) {\nif (null == t) {\nthrow new NullPointerException();\n}\nprincipal = account;\ntransaction = t;\nconstrained = false;\n}\npublic AddTransactionMove(FreerailsPrincipal account, Transaction t,\nboolean constrain) {\nprincipal = account;\ntransaction = t;\nconstrained = constrain;\nif (null == t) {\nthrow new NullPointerException();\n}\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.isPlayer(principal)) {\nif (this.constrained) {\nlong bankBalance = w.getCurrentBalance(principal).getAmount();\nlong transactionAmount = this.transaction.deltaCash()\n.getAmount();\nlong balanceAfter = bankBalance + transactionAmount;\nif (transactionAmount < 0 && balanceAfter < 0) {\nreturn MoveStatus.moveFailed(\"You can't afford that!\");\n}\n}\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(p.getName()\n+ \" does not have a bank account.\");\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nint size = w.getNumberOfTransactions(this.principal);\nif (0 == size) {\nreturn MoveStatus.moveFailed(\"No transactions to remove!\");\n}\nTransaction lastTransaction = w\n.getTransaction(this.principal, size - 1);\nif (lastTransaction.equals(this.transaction)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected \" + this.transaction\n+ \"but found \" + lastTransaction);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.ok) {\nw.addTransaction(this.principal, this.transaction);\n}\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.ok) {\nw.removeLastTransaction(this.principal);\n}\nreturn ms;\n}\n@Override\npublic boolean equals(Object obj) {\nif (obj instanceof AddTransactionMove) {\nAddTransactionMove test = (AddTransactionMove) obj;\nreturn test.principal.equals(this.principal)\n&& test.transaction.equals(this.transaction);\n}\nreturn false;\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn principal;\n}\n}"}
{"className":"jfreerails.move.WorldDiffsMoveTest","javaDoc":null,"code":"public class WorldDiffsMoveTest extends TestCase {\nWorld world;\nWorldDiffs diffs;\nFreerailsPrincipal fp1;\nCityModel city1 = new CityModel(\"City 1\", 8, 4);\nCityModel city2 = new CityModel(\"City 2\", 9, 4);\n@Override\nprotected void setUp() throws Exception {\nworld = new WorldImpl(10, 10);\n// Set the time..\nworld.set(ITEM.CALENDAR, new GameCalendar(12000, 1840));\nworld.addPlayer(MapFixtureFactory.TEST_PLAYER);\nfp1 = world.getPlayer(0).getPrincipal();\ndiffs = new WorldDiffs(world);\n}\npublic void testChangingMap() {\ndiffs.setTile(4, 0, city1);\ndiffs.setTile(8, 5, city2);\nrunTests();\n}\npublic void testChangingElementInList1() {\nworld.add(fp1, KEY.STATIONS, city1);\nworld.add(fp1, KEY.STATIONS, city1);\ndiffs.set(fp1, KEY.STATIONS, 0, city2);\ndiffs.set(fp1, KEY.STATIONS, 1, city2);\nrunTests();\n}\npublic void testChangingElementInList2() {\nworld.add(fp1, KEY.STATIONS, city1);\nworld.add(fp1, KEY.STATIONS, city1);\ndiffs.set(fp1, KEY.STATIONS, 0, city2);\ndiffs.set(fp1, KEY.STATIONS, 1, city2);\nassertEquals(2, diffs.listDiffs());\nWorldDiffMove move = WorldDiffMove.generate(diffs, WorldDiffMove.Cause.Other);\nassertEquals(2, move.listDiffs());\n}\npublic void testAddingElementToList() {\nworld.add(fp1, KEY.STATIONS, city1);\ndiffs.add(fp1, KEY.STATIONS, city2);\ndiffs.add(fp1, KEY.STATIONS, city2);\ndiffs.add(fp1, KEY.STATIONS, city2);\nrunTests();\n}\npublic void testAddingTransaction() {\nTransaction t1 = new AddItemTransaction(Category.BOND, 1, 1, new Money(\n100));\nTransaction t2 = new AddItemTransaction(Category.BOND, 2, 2, new Money(\n1000));\nTransaction t3 = new AddItemTransaction(Category.BOND, 3, 3, new Money(\n10000));\nworld.addTransaction(fp1, t1);\ndiffs.addTransaction(fp1, t2);\ndiffs.addTransaction(fp1, t3);\nrunTests();\n}\npublic void testAddingActivity(){\nActivity act = new TestActivity(30);\nint row = world.addActiveEntity(fp1, act);\nact = new TestActivity(40);\nworld.add(fp1, row, act);\nact = new TestActivity(50);\ndiffs.add(fp1, row, act);\nrunTests();\n}\npublic void testAddingActivateEntity() {\nActivity act = new TestActivity(30);\nint row = world.addActiveEntity(fp1, act);\nact = new TestActivity(40);\nworld.add(fp1, row, act);\nact = new TestActivity(50);\ndiffs.add(fp1, row, act);\nact = new TestActivity(60);\nrow = diffs.addActiveEntity(fp1, act);\nact = new TestActivity(70);\ndiffs.add(fp1, row, act);\nact = new TestActivity(80);\nrow = diffs.addActiveEntity(fp1, act);\nact = new TestActivity(90);\ndiffs.add(fp1, row, act);\nrunTests();\n}\nvoid runTests() {\nassertFalse(diffs.equals(world));\nWorldDiffMove move = WorldDiffMove.generate(diffs, WorldDiffMove.Cause.Other);\n// Doing the move on the world should also succeed.\nWorld worldCopy = (World) Utils.cloneBySerialisation(world);\nassertEquals(worldCopy, world);\nMoveStatus ms = move.tryDoMove(worldCopy, fp1);\nif(!ms.ok)\nms.printStackTrack();\nassertTrue(ms.message, ms.ok);\nms = move.doMove(worldCopy, fp1);\nassertTrue(ms.ok);\nassertEquals(worldCopy, diffs);\n// Undoing the move on the diffs should succeed.\nWorldDiffs diffsCopy = (WorldDiffs) Utils.cloneBySerialisation(diffs);\nassertEquals(diffsCopy, diffs);\nms = move.tryUndoMove(diffsCopy, fp1);\nassertTrue(ms.message, ms.ok);\nassertFalse(diffsCopy.equals(world));\nms = move.undoMove(diffsCopy, fp1);\nassertTrue(ms.ok);\nassertEquals(diffsCopy, world);\n// The move should survive serialisation.\nObject moveCopy = Utils.cloneBySerialisation(move);\nassertEquals(moveCopy, move);\nassertEquals(moveCopy.hashCode(), move.hashCode());\n}\n}"}
{"className":"jfreerails.move.CompositeMove","javaDoc":"/**\n*\n* This Move may be subclassed to create a move composed of a number of\n* component Moves where atomicity of the move is required. This class defines a\n* number of methods which may not be subclassed - all changes must be\n* encapsulated as sub-moves of this move.\n*\n* @author Luke\n*/","code":"/**\n*\n* This Move may be subclassed to create a move composed of a number of\n* component Moves where atomicity of the move is required. This class defines a\n* number of methods which may not be subclassed - all changes must be\n* encapsulated as sub-moves of this move.\n*\n* @author Luke\n*/\npublic class CompositeMove implements Move {\nprivate static final long serialVersionUID = 3257289149391517489L;\nprivate final ImList<Move> moves;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof CompositeMove))\nreturn false;\nfinal CompositeMove compositeMove = (CompositeMove) o;\nif (!moves.equals(compositeMove.moves))\nreturn false;\nreturn true;\n}\n/**\n* This method lets sub classes look at the moves.\n*/\nfinal Move getMove(int i) {\nreturn moves.get(i);\n}\n@Override\npublic int hashCode() {\n// This will do for now.\nreturn moves.size();\n}\npublic final ImList<Move> getMoves() {\nreturn moves;\n}\npublic CompositeMove(List<Move> movesArrayList) {\nmoves = new ImList<Move>(movesArrayList);\n}\npublic CompositeMove(Move... moves) {\nthis.moves = new ImList<Move>(moves);\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\n// Since whether a move later in the list goes through could\n// depend on whether an earlier move has been executed, we need\n// actually execute moves, then undo them to test whether the\n// array of moves can be executed ok.\nMoveStatus ms = doMove(w, p);\nif (ms.ok) {\n// We just wanted to see if we could do them so we undo them again.\nundoMoves(w, moves.size() - 1, p);\n}\n// If its not ok, then doMove would have undone the moves so we don't\n// need to undo them.\nreturn ms;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = undoMove(w, p);\nif (ms.isOk()) {\nredoMoves(w, 0, p);\n}\nreturn ms;\n}\npublic final MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = compositeTest(w, p);\nif (!ms.ok) {\nreturn ms;\n}\nfor (int i = 0; i < moves.size(); i++) {\nms = moves.get(i).doMove(w, p);\nif (!ms.ok) {\n// Undo any moves we have already done.\nundoMoves(w, i - 1, p);\nreturn ms;\n}\n}\nreturn ms;\n}\npublic final MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = MoveStatus.MOVE_OK;\nfor (int i = moves.size() - 1; i >= 0; i--) {\nms = moves.get(i).undoMove(w, p);\nif (!ms.ok) {\n// Redo any moves we have already undone.\nredoMoves(w, i + 1, p);\nreturn ms;\n}\n}\nreturn ms;\n}\nprivate void undoMoves(World w, int number, FreerailsPrincipal p) {\nfor (int i = number; i >= 0; i--) {\nMoveStatus ms = moves.get(i).undoMove(w, p);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\n}\n}\nprivate void redoMoves(World w, int number, FreerailsPrincipal p) {\nfor (int i = number; i < moves.size(); i++) {\nMoveStatus ms = moves.get(i).doMove(w, p);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\n}\n}\n/**\n* Subclasses may override this method to perform tests which pass or fail\n* depending on the combination of moves making up this composite move.\n*/\nMoveStatus compositeTest(World w, FreerailsPrincipal p) {\nreturn MoveStatus.MOVE_OK;\n}\npublic int size(){\nreturn moves.size();\n}\n@Override\npublic final String toString() {\nString s = \"\";\nfor (int i = 0; i < moves.size(); i++) {\ns += moves.get(i).toString() + ((i > 0) ? \", \" : \"\");\n}\nreturn s;\n}\n}"}
{"className":"jfreerails.move.AddTransactionMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke Lindsay\n*\n*/\npublic class AddTransactionMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nMoney currentBalance = getWorld().getCurrentBalance(\nMapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(new Money(0), currentBalance);\nTransaction t = new Receipt(new Money(100),\nTransaction.Category.MISC_INCOME);\nMove m = new AddTransactionMove(MapFixtureFactory.TEST_PRINCIPAL, t);\nassertTryMoveIsOk(m);\nassertTryUndoMoveFails(m);\nassertDoMoveIsOk(m);\ncurrentBalance = getWorld().getCurrentBalance(\nMapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(new Money(100), currentBalance);\nfinal Player PLAYER_WITHOUT_ACCOUNT = new Player(\n\"PLAYER_WITHOUT_ACCOUNT\", 4);\nassertSurvivesSerialisation(m);\nMove m2 = new AddTransactionMove(PLAYER_WITHOUT_ACCOUNT.getPrincipal(),\nt);\nassertTryMoveFails(m2);\nassertOkAndRepeatable(m);\n}\npublic void testConstrainedMove() {\nMoney currentBalance = getWorld().getCurrentBalance(\nMapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(new Money(0), currentBalance);\nTransaction t = new Bill(new Money(100),\nTransaction.Category.MISC_INCOME);\nMove m = new AddTransactionMove(MapFixtureFactory.TEST_PRINCIPAL, t,\ntrue);\n// This move should fail since there is no money in the account and\n// it is constrained is set to true.\nassertTryMoveFails(m);\n}\n}"}
{"className":"jfreerails.move.TrackMove","javaDoc":"/**\n* This interface tags Moves that change the track.\n*\n* @author luke\n*/","code":"/**\n* This interface tags Moves that change the track.\n*\n* @author luke\n*/\npublic interface TrackMove extends MapUpdateMove {\n}"}
{"className":"jfreerails.move.ChangeProductionAtEngineShopMoveTest","javaDoc":"/**\n* Junit TestCase for ChangeProductionAtEngineShopMove.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit TestCase for ChangeProductionAtEngineShopMove.\n*\n* @author Luke\n*\n*/\npublic class ChangeProductionAtEngineShopMoveTest extends AbstractMoveTestCase {\nprivate ImList<PlannedTrain> before;\nprivate ImList<PlannedTrain> after;\nprivate int engineType;\nprivate int wagonType;\nprivate int[] wagons;\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\ngetWorld().add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\nnew StationModel());\ngetWorld().add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\nnew StationModel());\ngetWorld().add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\nnew StationModel());\nWagonAndEngineTypesFactory wetf = new WagonAndEngineTypesFactory();\nwetf.addTypesToWorld(getWorld());\nengineType = 0;\nwagonType = 0;\nwagons = new int[] { wagonType, wagonType };\nafter = new ImList<PlannedTrain>(new PlannedTrain(\nengineType, wagons));\n}\n@Override\npublic void testMove() {\nbefore = new ImList<PlannedTrain>();\nChangeProductionAtEngineShopMove m;\n// Should fail because current production at station 0 is null;\nm = new ChangeProductionAtEngineShopMove(after, before, 0,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertTryMoveFails(m);\nassertDoMoveFails(m);\n// Should fail because station 6 does not exist.\nm = new ChangeProductionAtEngineShopMove(before, after, 6,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertTryMoveFails(m);\nassertDoMoveFails(m);\n// Should go through\nm = new ChangeProductionAtEngineShopMove(before, after, 0,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertTryMoveIsOk(m);\nassertDoMoveIsOk(m);\nassertTryUndoMoveIsOk(m);\nassertUndoMoveIsOk(m);\n// It should not be repeatable.\nassertOkButNotRepeatable(m);\nassertSurvivesSerialisation(m);\n}\npublic void testProductionAtEngineShopEquals() {\nPlannedTrain b;\nPlannedTrain c;\nb = new PlannedTrain(engineType, wagons);\nc = new PlannedTrain(engineType, wagons);\nassertEquals(c, b);\nassertEquals(b, c);\n}\n}"}
{"className":"jfreerails.move.ChangeGameSpeedMove","javaDoc":"/**\n*\n* Changes the game speed item on the world object.\n*\n* @author Jan Tozicka\n*\n*/","code":"/**\n*\n* Changes the game speed item on the world object.\n*\n* @author Jan Tozicka\n*\n*/\npublic class ChangeGameSpeedMove implements Move {\nprivate static final long serialVersionUID = 3545794368956086071L;\nprivate final GameSpeed oldSpeed;\nprivate final GameSpeed newSpeed;\npublic static ChangeGameSpeedMove getMove(ReadOnlyWorld w,\nGameSpeed newGameSpeed) {\nreturn new ChangeGameSpeedMove((GameSpeed) w.get(ITEM.GAME_SPEED),\nnewGameSpeed);\n}\nprivate ChangeGameSpeedMove(GameSpeed before, GameSpeed after) {\noldSpeed = before;\nnewSpeed = after;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.get(ITEM.GAME_SPEED).equals(oldSpeed)) {\nreturn MoveStatus.MOVE_OK;\n}\nString string = \"oldSpeed = \" + oldSpeed.getSpeed() + \" <=> \"\n+ \"currentSpeed \"\n+ ((GameSpeed) w.get(ITEM.GAME_SPEED)).getSpeed();\nreturn MoveStatus.moveFailed(string);\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nGameSpeed speed = ((GameSpeed) w.get(ITEM.GAME_SPEED));\nif (speed.equals(newSpeed)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected \" + newSpeed + \", found \"\n+ speed);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryDoMove(w, p);\nif (status.ok) {\nw.set(ITEM.GAME_SPEED, newSpeed);\n}\nreturn status;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryUndoMove(w, p);\nif (status.isOk()) {\nw.set(ITEM.GAME_SPEED, oldSpeed);\n}\nreturn status;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ChangeGameSpeedMove))\nreturn false;\nfinal ChangeGameSpeedMove changeGameSpeedMove = (ChangeGameSpeedMove) o;\nif (!newSpeed.equals(changeGameSpeedMove.newSpeed))\nreturn false;\nif (!oldSpeed.equals(changeGameSpeedMove.oldSpeed))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = oldSpeed.hashCode();\nresult = 29 * result + newSpeed.hashCode();\nreturn result;\n}\npublic int getNewSpeed() {\nreturn newSpeed.getSpeed();\n}\n@Override\npublic String toString() {\nreturn \"ChangeGameSpeedMove: \" + oldSpeed + \"=>\" + newSpeed;\n}\n}"}
{"className":"jfreerails.move.AddCargoBundleMoveTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class AddCargoBundleMoveTest extends AbstractMoveTestCase {\n@Override\npublic void testMove() {\nMutableCargoBundle bundleA;\nMutableCargoBundle bundleB;\nbundleA = new MutableCargoBundle();\nbundleB = new MutableCargoBundle();\nbundleA.setAmount(new CargoBatch(1, 2, 3, 4, 0), 5);\nbundleB.setAmount(new CargoBatch(1, 2, 3, 4, 0), 5);\nassertEquals(bundleA, bundleB);\nMove m = new AddCargoBundleMove(0, bundleA.toImmutableCargoBundle(),\nMapFixtureFactory.TEST_PRINCIPAL);\nassertDoMoveIsOk(m);\nassertEquals(getWorld().size(MapFixtureFactory.TEST_PRINCIPAL,\nKEY.CARGO_BUNDLES), 1);\nassertUndoMoveIsOk(m);\nassertSurvivesSerialisation(m);\nassertOkButNotRepeatable(m);\n}\n}"}
{"className":"jfreerails.move.ChangeStationMove","javaDoc":"/**\n*\n* This Move changes the properties of a station.\n*\n* @author lindsal\n*/","code":"/**\n*\n* This Move changes the properties of a station.\n*\n* @author lindsal\n*/\nfinal public class ChangeStationMove extends ChangeItemInListMove {\nprivate static final long serialVersionUID = 3833469496064160307L;\npublic ChangeStationMove(int index, StationModel before,\nStationModel after, FreerailsPrincipal p) {\nsuper(KEY.STATIONS, index, before, after, p);\n}\n}"}
{"className":"jfreerails.move.ChangeProductionAtEngineShopMove","javaDoc":"/**\n* This Move changes what is being built at an engine shop - when a client wants\n* to build a train, it should send an instance of this class to the server.\n*\n* @author Luke\n*\n*/","code":"/**\n* This Move changes what is being built at an engine shop - when a client wants\n* to build a train, it should send an instance of this class to the server.\n*\n* @author Luke\n*\n*/\npublic class ChangeProductionAtEngineShopMove implements Move {\nprivate static final long serialVersionUID = 3905519384997737520L;\nprivate final ImList<PlannedTrain> before;\nprivate final ImList<PlannedTrain> after;\nprivate final int stationNumber;\nprivate final FreerailsPrincipal principal;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ChangeProductionAtEngineShopMove))\nreturn false;\nfinal ChangeProductionAtEngineShopMove changeProductionAtEngineShopMove = (ChangeProductionAtEngineShopMove) o;\nif (stationNumber != changeProductionAtEngineShopMove.stationNumber)\nreturn false;\nif (after != null ? !after\n.equals(changeProductionAtEngineShopMove.after)\n: changeProductionAtEngineShopMove.after != null)\nreturn false;\nif (before != null ? !before\n.equals(changeProductionAtEngineShopMove.before)\n: changeProductionAtEngineShopMove.before != null)\nreturn false;\nif (!principal.equals(changeProductionAtEngineShopMove.principal))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (before != null ? before.hashCode() : 0);\nresult = 29 * result + (after != null ? after.hashCode() : 0);\nresult = 29 * result + stationNumber;\nresult = 29 * result + principal.hashCode();\nreturn result;\n}\npublic ChangeProductionAtEngineShopMove(ImList<PlannedTrain> b,\nImList<PlannedTrain> a, int station, FreerailsPrincipal p) {\nthis.before = b;\nthis.after = a;\nthis.stationNumber = station;\nthis.principal = p;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(w, before);\n}\nprivate MoveStatus tryMove(World w, ImList<PlannedTrain> stateA) {\n// Check that the specified station exists.\nif (!w.boundsContain(principal, KEY.STATIONS, this.stationNumber)) {\nreturn MoveStatus.moveFailed(this.stationNumber + \" \" + principal);\n}\nStationModel station = (StationModel) w.get(principal, KEY.STATIONS,\nstationNumber);\nif (null == station) {\nreturn MoveStatus.moveFailed(this.stationNumber + \" \" + principal\n+ \" is does null\");\n}\n// Check that the station is building what we expect.\nif (null == station.getProduction()) {\nif (null == stateA) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(this.stationNumber + \" \" + principal);\n}\nif (station.getProduction().equals(stateA)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(this.stationNumber + \" \" + principal);\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(w, after);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryDoMove(w, p);\nif (status.isOk()) {\nStationModel station = (StationModel) w.get(principal,\nKEY.STATIONS, stationNumber);\nstation = new StationModel(station, this.after);\nw.set(principal, KEY.STATIONS, stationNumber, station);\n}\nreturn status;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus status = tryUndoMove(w, p);\nif (status.isOk()) {\nStationModel station = (StationModel) w.get(principal,\nKEY.STATIONS, stationNumber);\nstation = new StationModel(station, this.before);\nw.set(principal, KEY.STATIONS, stationNumber, station);\n}\nreturn status;\n}\n}"}
{"className":"jfreerails.move.ChangeItemInListMove","javaDoc":"/**\n* All Moves that replace an item in a list with another should extend this\n* class.\n*\n* @author Luke\n*\n*/","code":"/**\n* All Moves that replace an item in a list with another should extend this\n* class.\n*\n* @author Luke\n*\n*/\npublic class ChangeItemInListMove implements ListMove {\nprivate static final long serialVersionUID = -4457694821370844051L;\nprivate final KEY listKey;\nprivate final int index;\nprivate final FreerailsSerializable before;\nprivate final FreerailsSerializable after;\nprivate final FreerailsPrincipal principal;\npublic ChangeItemInListMove(KEY k, int index, FreerailsSerializable before,\nFreerailsSerializable after, FreerailsPrincipal p) {\nthis.before = before;\nthis.after = after;\nthis.index = index;\nthis.listKey = k;\nthis.principal = p;\n}\npublic boolean beforeEqualsAfter(){\nreturn Utils.equal(this.before, this.after);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nreturn move(after, before, w);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof ChangeItemInListMove) {\nChangeItemInListMove test = (ChangeItemInListMove) o;\nif (!before.equals(test.getBefore())) {\nreturn false;\n}\nif (!after.equals(test.getAfter())) {\nreturn false;\n}\nif (index != test.index) {\nreturn false;\n}\nif (listKey != test.listKey) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\npublic FreerailsSerializable getAfter() {\nreturn after;\n}\npublic FreerailsSerializable getBefore() {\nreturn before;\n}\npublic int getIndex() {\nreturn index;\n}\npublic KEY getKey() {\nreturn listKey;\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn principal;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = listKey.hashCode();\nresult = 29 * result + index;\nresult = 29 * result + (before != null ? before.hashCode() : 0);\nresult = 29 * result + (after != null ? after.hashCode() : 0);\nresult = 29 * result + principal.hashCode();\nreturn result;\n}\nprotected MoveStatus move(FreerailsSerializable to,\nFreerailsSerializable from, World w) {\nMoveStatus ms = tryMove(to, from, w);\nif (ms.ok) {\nw.set(principal, listKey, index, to);\n}\nreturn ms;\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(getClass().getName());\nsb.append(\" before: \");\nsb.append(before.toString());\nsb.append(\" after: \");\nsb.append(after.toString());\nreturn sb.toString();\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(after, before, w);\n}\nprotected MoveStatus tryMove(FreerailsSerializable to,\nFreerailsSerializable from, World w) {\nif (index >= w.size(principal, listKey)) {\nreturn MoveStatus.moveFailed(\"w.size(listKey) is \"\n+ w.size(principal, listKey) + \" but index is \" + index);\n}\nFreerailsSerializable item2change = w.get(principal, listKey, index);\nif (null == item2change) {\nif (null == from) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected null but found \" + from);\n}\nif (!from.equals(item2change)) {\nString message = \"Expected \" + from.toString() + \" but found \"\n+ to.toString();\nreturn MoveStatus.moveFailed(message);\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(before, after, w);\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nreturn move(before, after, w);\n}\n}"}
{"className":"jfreerails.move.ChangeTrackPieceCompositeMove","javaDoc":"/**\n* This Move changes adds, removes, or upgrades the track between two tiles.\n*\n* @author lindsal\n*\n*/","code":"/**\n* This Move changes adds, removes, or upgrades the track between two tiles.\n*\n* @author lindsal\n*\n*/\npublic final class ChangeTrackPieceCompositeMove extends CompositeMove\nimplements TrackMove, MapUpdateMove {\nprivate static final long serialVersionUID = 3616443518780978743L;\nprivate final int x, y, w, h;\nprivate final FreerailsPrincipal builder;\nprivate ChangeTrackPieceCompositeMove(TrackMove a, TrackMove b,\nFreerailsPrincipal fp) {\nsuper(a, b);\nRectangle r = a.getUpdatedTiles().union(b.getUpdatedTiles());\nx = r.x;\ny = r.y;\nw = r.width;\nh = r.height;\nbuilder = fp;\n}\npublic static ChangeTrackPieceCompositeMove generateBuildTrackMove(\nImPoint from, Step direction, TrackRule ruleA, TrackRule ruleB,\nReadOnlyWorld w, FreerailsPrincipal principal) {\nChangeTrackPieceMove a;\nChangeTrackPieceMove b;\na = getBuildTrackChangeTrackPieceMove(from, direction, ruleA, w,\nprincipal);\nb = getBuildTrackChangeTrackPieceMove(direction\n.createRelocatedPoint(from), direction.getOpposite(), ruleB, w,\nprincipal);\nreturn new ChangeTrackPieceCompositeMove(a, b, principal);\n}\npublic static ChangeTrackPieceCompositeMove generateRemoveTrackMove(\nImPoint from, Step direction, ReadOnlyWorld w,\nFreerailsPrincipal principal) throws Exception {\nTrackMove a;\nTrackMove b;\na = getRemoveTrackChangeTrackPieceMove(from, direction, w, principal);\nb = getRemoveTrackChangeTrackPieceMove(direction\n.createRelocatedPoint(from), direction.getOpposite(), w,\nprincipal);\nreturn new ChangeTrackPieceCompositeMove(a, b, principal);\n}\n// utility method.\nprivate static ChangeTrackPieceMove getBuildTrackChangeTrackPieceMove(\nImPoint p, Step direction, TrackRule trackRule, ReadOnlyWorld w,\nFreerailsPrincipal principal) {\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nint owner = getOwner(principal, w);\nif (w.boundsContain(p.x, p.y)) {\noldTrackPiece = ((FreerailsTile) w.getTile(p.x, p.y))\n.getTrackPiece();\nif (oldTrackPiece.getTrackRule() != NullTrackType.getInstance()) {\nTrackConfiguration trackConfiguration = TrackConfiguration.add(\noldTrackPiece.getTrackConfiguration(), direction);\nnewTrackPiece = new TrackPieceImpl(trackConfiguration,\noldTrackPiece.getTrackRule(), owner, oldTrackPiece\n.getTrackTypeID());\n} else {\nnewTrackPiece = getTrackPieceWhenOldTrackPieceIsNull(direction,\ntrackRule, owner, findRuleID(trackRule, w));\n}\n} else {\nnewTrackPiece = getTrackPieceWhenOldTrackPieceIsNull(direction,\ntrackRule, owner, findRuleID(trackRule, w));\noldTrackPiece = NullTrackPiece.getInstance();\n}\nreturn new ChangeTrackPieceMove(oldTrackPiece, newTrackPiece, p);\n}\n// utility method.\nprivate static TrackMove getRemoveTrackChangeTrackPieceMove(ImPoint p,\nStep direction, ReadOnlyWorld w, FreerailsPrincipal principal)\nthrows Exception {\nTrackPiece oldTrackPiece;\nTrackPiece newTrackPiece;\nif (w.boundsContain(p.x, p.y)) {\noldTrackPiece = ((FreerailsTile) w.getTile(p.x, p.y)).getTrackPiece();\nif (oldTrackPiece.getTrackRule() != NullTrackType.getInstance()) {\nTrackConfiguration trackConfiguration = TrackConfiguration\n.subtract(oldTrackPiece.getTrackConfiguration(),\ndirection);\nif (trackConfiguration != TrackConfiguration\n.getFlatInstance(\"000010000\")) {\nint owner = getOwner(principal, w);\nnewTrackPiece = new TrackPieceImpl(trackConfiguration,\noldTrackPiece.getTrackRule(), owner, oldTrackPiece\n.getTrackTypeID());\n} else {\nnewTrackPiece = NullTrackPiece.getInstance();\n}\n} else {\n// There is no track to remove.\n// Fix for bug [ 948670 ] Removing non-existent track\nthrow new Exception();\n}\n} else {\nnewTrackPiece = NullTrackPiece.getInstance();\noldTrackPiece = NullTrackPiece.getInstance();\n}\nChangeTrackPieceMove m = new ChangeTrackPieceMove(oldTrackPiece,\nnewTrackPiece, p);\n// If we are removing a station, we also need to remove the station from\n// the station list.\nif (oldTrackPiece.getTrackRule().isStation()\n&& !newTrackPiece.getTrackRule().isStation()) {\nreturn RemoveStationMove.getInstance(w, m, principal);\n}\nreturn m;\n}\nprivate static TrackPiece getTrackPieceWhenOldTrackPieceIsNull(\nStep direction, TrackRule trackRule, int owner, int ruleNumber) {\nTrackConfiguration simplestConfig = TrackConfiguration\n.getFlatInstance(\"000010000\");\nTrackConfiguration trackConfiguration = TrackConfiguration.add(\nsimplestConfig, direction);\nreturn new TrackPieceImpl(trackConfiguration, trackRule, owner,\nruleNumber);\n}\npublic Rectangle getUpdatedTiles() {\nreturn new Rectangle(x, y, w, h);\n}\npublic static int getOwner(FreerailsPrincipal p, ReadOnlyWorld w) {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nif (w.getPlayer(i).getPrincipal().equals(p)) {\nreturn i;\n}\n}\nthrow new IllegalStateException();\n}\n/** Returns true if some track has been built. */\nstatic boolean hasAnyTrackBeenBuilt(ReadOnlyWorld world,\nFreerailsPrincipal principal) {\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nworld, principal);\naggregator.setCategory(Transaction.Category.TRACK);\nreturn aggregator.calculateQuantity() > 0;\n}\nprivate static boolean mustConnectToExistingTrack(ReadOnlyWorld world) {\nGameRules rules = (GameRules) world.get(ITEM.GAME_RULES);\nreturn rules.isMustConnect2ExistingTrack();\n}\n@Override\nprotected MoveStatus compositeTest(World world, FreerailsPrincipal p) {\nif (mustConnectToExistingTrack(world)) {\nif (hasAnyTrackBeenBuilt(world, this.builder)) {\ntry {\nChangeTrackPieceMove a = (ChangeTrackPieceMove) super\n.getMove(0);\nChangeTrackPieceMove b = (ChangeTrackPieceMove) super\n.getMove(1);\nint ruleBeforeA = a.trackPieceBefore.getTrackTypeID();\nint ruleBeforeB = b.trackPieceBefore.getTrackTypeID();\nif (ruleBeforeA == NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER\n&& ruleBeforeB == NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER) {\nreturn MoveStatus\n.moveFailed(\"Must connect to existing track\");\n}\n} catch (ClassCastException e) {\n// It was not the type of move we expected.\n// We end up here when we are removing a station.\nreturn MoveStatus.MOVE_OK;\n}\n}\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic static int findRuleID(TrackRule r, ReadOnlyWorld w) {\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nObject o = w.get(SKEY.TRACK_RULES, i);\nif (r.equals(o)) {\nreturn i;\n}\n}\nthrow new IllegalStateException();\n}\n}"}
{"className":"jfreerails.move.RemoveCargoBundleMove","javaDoc":"/**\n* This move removes a cargo bundle from the cargo bundle list.\n*\n* @author Luke\n*\n*/","code":"/**\n* This move removes a cargo bundle from the cargo bundle list.\n*\n* @author Luke\n*\n*/\npublic class RemoveCargoBundleMove extends RemoveItemFromListMove {\nprivate static final long serialVersionUID = 3762247522239723316L;\npublic RemoveCargoBundleMove(int i, ImmutableCargoBundle item,\nFreerailsPrincipal p) {\nsuper(KEY.CARGO_BUNDLES, i, item, p);\n}\n}"}
{"className":"jfreerails.move.AddCargoBundleMove","javaDoc":"/**\n* This Move adds a cargo bundle to the cargo bundle list.\n*\n* @author Luke\n*\n*/","code":"/**\n* This Move adds a cargo bundle to the cargo bundle list.\n*\n* @author Luke\n*\n*/\npublic class AddCargoBundleMove extends AddItemToListMove {\nprivate static final long serialVersionUID = 3257288049795674934L;\npublic AddCargoBundleMove(int i, ImmutableCargoBundle item,\nFreerailsPrincipal p) {\nsuper(KEY.CARGO_BUNDLES, i, item, p);\n}\n}"}
{"className":"jfreerails.move.PreMoveException","javaDoc":"/**\n* Thrown when there is a problem generating a move.\n*\n* @author Luke Lindsay\n*\n*\n*/","code":"/**\n* Thrown when there is a problem generating a move.\n*\n* @author Luke Lindsay\n*\n*\n*/\npublic class PreMoveException extends Exception {\nprivate static final long serialVersionUID = 3257007635675755061L;\npublic PreMoveException(String s) {\nsuper(s);\n}\n}"}
{"className":"jfreerails.move.ChangeTileMove","javaDoc":"/**\n* Move that changes a single tile.\n*\n* @author Luke\n*\n*/","code":"/**\n* Move that changes a single tile.\n*\n* @author Luke\n*\n*/\npublic class ChangeTileMove implements Move, MapUpdateMove {\nprivate static final long serialVersionUID = 3256726169272662320L;\nprivate final int x;\nprivate final int y;\nprivate final FreerailsTile before;\nprivate final FreerailsTile after;\npublic ChangeTileMove(ReadOnlyWorld w, Point p, int terrainTypeAfter) {\nthis.x = p.x;\nthis.y = p.y;\nthis.before = (FreerailsTile) w.getTile(x, y);\nthis.after = FreerailsTile.getInstance(terrainTypeAfter, before\n.getTrackPiece());\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ChangeTileMove))\nreturn false;\nfinal ChangeTileMove changeTileMove = (ChangeTileMove) o;\nif (x != changeTileMove.x)\nreturn false;\nif (y != changeTileMove.y)\nreturn false;\nif (!after.equals(changeTileMove.after))\nreturn false;\nif (!before.equals(changeTileMove.before))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = x;\nresult = 29 * result + y;\nresult = 29 * result + before.hashCode();\nresult = 29 * result + after.hashCode();\nreturn result;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nFreerailsTile actual = (FreerailsTile) w.getTile(x, y);\nTerrainType type = (TerrainType) w.get(SKEY.TERRAIN_TYPES, actual\n.getTerrainTypeID());\nif (!type.getCategory().equals(TerrainType.Category.Country)) {\nreturn MoveStatus.moveFailed(\"Can only build on clear terrain.\");\n}\nif (actual.equals(before)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected \" + before + \" but found \"\n+ actual);\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nFreerailsTile actual = (FreerailsTile) w.getTile(x, y);\nif (actual.equals(after)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"Expected \" + after + \" but found \"\n+ actual);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.isOk()) {\nw.setTile(x, y, after);\n}\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.isOk()) {\nw.setTile(x, y, before);\n}\nreturn ms;\n}\npublic Rectangle getUpdatedTiles() {\nRectangle r = new Rectangle(x, y, 1, 1);\nreturn r;\n}\n}"}
{"className":"jfreerails.move.AddItemToListMove","javaDoc":"/**\n* All moves that add an item to a list should extend this class.\n*\n* @author Luke\n*\n*/","code":"/**\n* All moves that add an item to a list should extend this class.\n*\n* @author Luke\n*\n*/\npublic class AddItemToListMove implements ListMove {\nprivate static final long serialVersionUID = 3256721779916747824L;\nprivate final KEY listKey;\nprivate final int index;\nprivate final FreerailsPrincipal principal;\nprivate final FreerailsSerializable item;\npublic int getIndex() {\nreturn index;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = listKey.hashCode();\nresult = 29 * result + index;\nresult = 29 * result + principal.hashCode();\nresult = 29 * result + (item != null ? item.hashCode() : 0);\nreturn result;\n}\npublic KEY getKey() {\nreturn listKey;\n}\npublic AddItemToListMove(KEY key, int i, FreerailsSerializable item,\nFreerailsPrincipal p) {\nthis.listKey = key;\nthis.index = i;\nthis.item = item;\nthis.principal = p;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.size(this.principal, listKey) != index) {\nreturn MoveStatus.moveFailed(\"Expected size of \"\n+ listKey.toString() + \" list is \" + index\n+ \" but actual size is \" + w.size(this.principal, listKey));\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nint expectListSize = index + 1;\nif (w.size(this.principal, listKey) != expectListSize) {\nreturn MoveStatus.moveFailed(\"Expected size of \"\n+ listKey.toString() + \" list is \" + expectListSize\n+ \" but actual size is \" + w.size(this.principal, listKey));\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.isOk()) {\nw.add(this.principal, listKey, this.item);\n}\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.isOk()) {\nw.removeLast(this.principal, listKey);\n}\nreturn ms;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof AddItemToListMove) {\nAddItemToListMove test = (AddItemToListMove) o;\nif (null == this.item) {\nif (null != test.item) {\nreturn false;\n}\n} else if (!this.item.equals(test.getAfter())) {\nreturn false;\n}\nif (this.index != test.index) {\nreturn false;\n}\nif (this.listKey != test.listKey) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\npublic FreerailsSerializable getBefore() {\nreturn null;\n}\npublic FreerailsSerializable getAfter() {\nreturn item;\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer(this.getClass().getName());\nsb.append(\"\\n list=\");\nsb.append(listKey.toString());\nsb.append(\"\\n index =\");\nsb.append(index);\nsb.append(\"\\n item =\");\nsb.append(item);\nreturn sb.toString();\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn principal;\n}\n}"}
{"className":"jfreerails.move.RemoveItemFromListMove","javaDoc":"/**\n* All moves that remove an item from a list should extend this class.\n*\n* @author Luke\n*\n*/","code":"/**\n* All moves that remove an item from a list should extend this class.\n*\n* @author Luke\n*\n*/\npublic class RemoveItemFromListMove implements ListMove {\nprivate static final long serialVersionUID = 3906091169698953521L;\nprivate final FreerailsSerializable item;\nprivate final KEY listKey;\nprivate final int index;\nprivate final FreerailsPrincipal principal;\npublic int getIndex() {\nreturn index;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (item != null ? item.hashCode() : 0);\nresult = 29 * result + listKey.hashCode();\nresult = 29 * result + index;\nresult = 29 * result + principal.hashCode();\nreturn result;\n}\npublic KEY getKey() {\nreturn listKey;\n}\nRemoveItemFromListMove(KEY k, int i, FreerailsSerializable item,\nFreerailsPrincipal p) {\nthis.item = item;\nthis.listKey = k;\nthis.index = i;\nthis.principal = p;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.size(principal, listKey) < (index + 1)) {\nreturn MoveStatus.moveFailed(\"w.size(listKey)=\"\n+ w.size(principal, listKey) + \" but index =\" + index);\n}\nFreerailsSerializable item2remove = w.get(principal, listKey, index);\nif (null == item2remove) {\nreturn MoveStatus.moveFailed(\"The item at position \" + index\n+ \" has already been removed.\");\n}\nif (!item.equals(item2remove)) {\nString reason = \"The item at position \" + index + \" in the list (\"\n+ item2remove.toString() + \") is not the expected item (\"\n+ item.toString() + \").\";\nreturn MoveStatus.moveFailed(reason);\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nif (w.size(principal, listKey) < (index + 1)) {\nreturn MoveStatus.moveFailed(\"w.size(listKey)=\"\n+ w.size(principal, listKey) + \" but index =\" + index);\n}\nif (null != w.get(principal, listKey, index)) {\nString reason = \"The item at position \" + index + \" in the list (\"\n+ w.get(principal, listKey, index).toString()\n+ \") is not the expected item (null).\";\nreturn MoveStatus.moveFailed(reason);\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.isOk()) {\nw.set(principal, listKey, index, null);\n}\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.isOk()) {\nw.set(principal, listKey, index, this.item);\n}\nreturn ms;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof RemoveItemFromListMove) {\nRemoveItemFromListMove test = (RemoveItemFromListMove) o;\nif (!this.item.equals(test.getBefore())) {\nreturn false;\n}\nif (this.index != test.index) {\nreturn false;\n}\nif (this.listKey != test.listKey) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\npublic FreerailsSerializable getBefore() {\nreturn item;\n}\npublic FreerailsSerializable getAfter() {\nreturn null;\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn principal;\n}\n}"}
{"className":"jfreerails.move.RemoveTrainMove","javaDoc":"/**\n* This Move removes a train from the list of trains, and the corresponding\n* CargoBundle and Schedule.\n*\n* @author Luke\n*\n*/","code":"/**\n* This Move removes a train from the list of trains, and the corresponding\n* CargoBundle and Schedule.\n*\n* @author Luke\n*\n*/\npublic class RemoveTrainMove extends CompositeMove {\nprivate static final long serialVersionUID = 3979265867567544114L;\nprivate RemoveTrainMove(Move[] moves) {\nsuper(moves);\n}\npublic static RemoveTrainMove getInstance(int index, FreerailsPrincipal p,\nReadOnlyWorld world) {\nTrainModel train = (TrainModel) world.get(p, KEY.TRAINS, index);\nint scheduleId = train.getScheduleID();\nImmutableSchedule schedule = (ImmutableSchedule) world.get(\np, KEY.TRAIN_SCHEDULES, scheduleId);\nint cargoBundleId = train.getCargoBundleID();\nImmutableCargoBundle cargoBundle = (ImmutableCargoBundle) world.get(\np, KEY.CARGO_BUNDLES, cargoBundleId);\n// TrainPositionOnMap position =\n// (TrainPositionOnMap)world.get(KEY.TRAIN_POSITIONS, index, p);\nMove removeTrain = new RemoveItemFromListMove(KEY.TRAINS, index, train,\np);\nMove removeCargobundle = new RemoveItemFromListMove(KEY.CARGO_BUNDLES,\ncargoBundleId, cargoBundle, p);\nMove removeSchedule = new RemoveItemFromListMove(KEY.TRAIN_SCHEDULES,\nscheduleId, schedule, p);\n// Move removePosition = new RemoveItemFromListMove(KEY.TRAIN_POSITIONS,\n// index, position, p);\nreturn new RemoveTrainMove(new Move[] { removeTrain, removeCargobundle,\nremoveSchedule /* , removePosition */\n});\n}\n}"}
{"className":"jfreerails.move.MapUpdateMove","javaDoc":"/**\n* This interface tags Moves that change items on the map and tells the caller\n* which tiles have been updated. It is used by the map-view classes to\n* determine which tiles need repainting.\n*\n* @author Luke\n*\n*/","code":"/**\n* This interface tags Moves that change items on the map and tells the caller\n* which tiles have been updated. It is used by the map-view classes to\n* determine which tiles need repainting.\n*\n* @author Luke\n*\n*/\npublic interface MapUpdateMove extends Move {\nRectangle getUpdatedTiles();\n}"}
{"className":"jfreerails.move.AddActiveEntityMove","javaDoc":"/**\n* A move that adds an active entity. An active entity is something whose state\n* may be continually changing. An example is a train - it is an active entity\n* since while it is moving its position is continually changing.\n*\n* @author Luke\n* @see NextActivityMove\n*/","code":"/**\n* A move that adds an active entity. An active entity is something whose state\n* may be continually changing. An example is a train - it is an active entity\n* since while it is moving its position is continually changing.\n*\n* @author Luke\n* @see NextActivityMove\n*/\npublic class AddActiveEntityMove implements Move {\nprivate static final long serialVersionUID = 8732702087937675013L;\nprivate final Activity activity;\nprivate final FreerailsPrincipal principal;\nprivate final int index;\npublic AddActiveEntityMove(Activity activity, int index,\nFreerailsPrincipal principal) {\nthis.activity = activity;\nthis.index = index;\nthis.principal = principal;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof AddActiveEntityMove))\nreturn false;\nfinal AddActiveEntityMove addActiveEntityMove = (AddActiveEntityMove) o;\nif (index != addActiveEntityMove.index)\nreturn false;\nif (!activity.equals(addActiveEntityMove.activity))\nreturn false;\nif (!principal.equals(addActiveEntityMove.principal))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = activity.hashCode();\nresult = 29 * result + principal.hashCode();\nresult = 29 * result + index;\nreturn result;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (index != w.size(principal))\nreturn MoveStatus.moveFailed(\"index != w.size(listKey, p)\");\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nint expectedSize = index + 1;\nif (expectedSize != w.size(principal))\nreturn MoveStatus\n.moveFailed(\"(index + 1) != w.size(listKey, principal)\");\nActivityIterator ai = w.getActivities(principal, index);\nif (ai.hasNext())\nreturn MoveStatus\n.moveFailed(\"There should be exactly one activity!\");\nActivity act = ai.getActivity();\nif (!act.equals(activity))\nreturn MoveStatus.moveFailed(\"Expected \" + activity.toString()\n+ \" but found \" + act.toString());\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.ok)\nw.addActiveEntity(principal, activity);\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.ok)\nw.removeLastActiveEntity(principal);\nreturn ms;\n}\n}"}
{"className":"jfreerails.move.UndoMove","javaDoc":"/**\n* Undoes the Move passed to its constructor.\n*\n* @author luke\n*/","code":"/**\n* Undoes the Move passed to its constructor.\n*\n* @author luke\n*/\npublic class UndoMove implements Move {\nprivate static final long serialVersionUID = 3977582498051929144L;\nprivate Move move2undo;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof UndoMove))\nreturn false;\nfinal UndoMove undoMove = (UndoMove) o;\nif (!move2undo.equals(undoMove.move2undo))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn move2undo.hashCode();\n}\n/**\n* @param move\n* The move that was undone\n*/\npublic UndoMove(Move move) {\nif (move instanceof UndoMove) {\nthrow new IllegalArgumentException();\n}\nmove2undo = move;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nreturn move2undo.tryUndoMove(w, p);\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nreturn move2undo.tryDoMove(w, p);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nreturn move2undo.undoMove(w, p);\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nreturn move2undo.undoMove(w, p);\n}\npublic Move getUndoneMove() {\nreturn move2undo;\n}\n}"}
{"className":"jfreerails.move.AddItemToSharedListMove","javaDoc":"/**\n* All moves that add an item to a shared list should extend this class.\n*\n* @author Luke\n*\n*/","code":"/**\n* All moves that add an item to a shared list should extend this class.\n*\n* @author Luke\n*\n*/\npublic class AddItemToSharedListMove implements Move {\nprivate static final long serialVersionUID = 3762256352759722807L;\nprivate final SKEY listKey;\nprivate final int index;\nprivate final FreerailsSerializable item;\npublic int getIndex() {\nreturn index;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = listKey.hashCode();\nresult = 29 * result + index;\nresult = 29 * result + (item != null ? item.hashCode() : 0);\nreturn result;\n}\npublic SKEY getKey() {\nreturn listKey;\n}\nprotected AddItemToSharedListMove(SKEY key, int i,\nFreerailsSerializable item) {\nthis.listKey = key;\nthis.index = i;\nthis.item = item;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (w.size(listKey) != index) {\nreturn MoveStatus.moveFailed(\"Expected size of \"\n+ listKey.toString() + \" list is \" + index\n+ \" but actual size is \" + w.size(listKey));\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nint expectListSize = index + 1;\nif (w.size(listKey) != expectListSize) {\nreturn MoveStatus.moveFailed(\"Expected size of \"\n+ listKey.toString() + \" list is \" + expectListSize\n+ \" but actual size is \" + w.size(listKey));\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (ms.isOk()) {\nw.add(listKey, this.item);\n}\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (ms.isOk()) {\nw.removeLast(listKey);\n}\nreturn ms;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof AddItemToSharedListMove) {\nAddItemToSharedListMove test = (AddItemToSharedListMove) o;\nif (!this.item.equals(test.getAfter())) {\nreturn false;\n}\nif (this.index != test.index) {\nreturn false;\n}\nif (this.listKey != test.listKey) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\npublic FreerailsSerializable getBefore() {\nreturn null;\n}\npublic FreerailsSerializable getAfter() {\nreturn item;\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer(this.getClass().getName());\nsb.append(\"\\nlist=\");\nsb.append(listKey.toString());\nsb.append(\"\\n index =\");\nsb.append(this.index);\nsb.append(\"\\n item =\");\nsb.append(this.item.toString());\nreturn sb.toString();\n}\n}"}
{"className":"jfreerails.move.ChangeTrainMove","javaDoc":"/**\n* This Move can change a train's engine and wagons.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This Move can change a train's engine and wagons.\n*\n* @author Luke Lindsay\n*\n*/\npublic class ChangeTrainMove extends ChangeItemInListMove {\nprivate static final long serialVersionUID = 3257854272514242873L;\nprivate ChangeTrainMove(int index, FreerailsSerializable before,\nFreerailsSerializable after, FreerailsPrincipal p) {\nsuper(KEY.TRAINS, index, before, after, p);\n}\npublic static ChangeTrainMove generateMove(int id, TrainModel before,\nint newEngine, ImInts newWagons, FreerailsPrincipal p) {\nTrainModel after = before.getNewInstance(newEngine, newWagons);\nreturn new ChangeTrainMove(id, before, after, p);\n}\n}"}
{"className":"jfreerails.move.AddStationMove","javaDoc":"/**\n* This {@link CompositeMove}adds a station to the station list and adds a\n* cargo bundle (to store the cargo waiting at the station) to the cargo bundle\n* list.\n*\n* @author Luke\n*\n*/","code":"/**\n* This {@link CompositeMove}adds a station to the station list and adds a\n* cargo bundle (to store the cargo waiting at the station) to the cargo bundle\n* list.\n*\n* @author Luke\n*\n*/\npublic class AddStationMove extends CompositeMove {\nprivate static final long serialVersionUID = 3256728398461089080L;\nprivate AddStationMove(Move[] moves) {\nsuper(moves);\n}\npublic StationModel getNewStation() {\nAddItemToListMove addStation = (AddItemToListMove) super.getMove(2);\nreturn (StationModel) addStation.getAfter();\n}\npublic static AddStationMove generateMove(ReadOnlyWorld w,\nString stationName, ImPoint p,\nChangeTrackPieceMove upgradeTrackMove, FreerailsPrincipal principal) {\nint cargoBundleNumber = w.size(principal, KEY.CARGO_BUNDLES);\nMove addCargoBundleMove = new AddCargoBundleMove(cargoBundleNumber,\nImmutableCargoBundle.EMPTY_BUNDLE, principal);\nint stationNumber = w.size(principal, KEY.STATIONS);\nStationModel station = new StationModel(p.x, p.y, stationName, w\n.size(SKEY.CARGO_TYPES), cargoBundleNumber);\nMove addStation = new AddItemToListMove(KEY.STATIONS, stationNumber,\nstation, principal);\nreturn new AddStationMove(new Move[] { upgradeTrackMove,\naddCargoBundleMove, addStation });\n}\npublic static AddStationMove upgradeStation(\nChangeTrackPieceMove upgradeTrackMove) {\nreturn new AddStationMove(new Move[] { upgradeTrackMove });\n}\n}"}
{"className":"jfreerails.move.TrainCrashException","javaDoc":"/**\n*\n* @author mduarte-leon\n*/","code":"/**\n*\n* @author mduarte-leon\n*/\npublic class TrainCrashException extends Exception {\nprivate static final long serialVersionUID = 3978710596948342065L;\nprivate int trainA;\nprivate int trainB;\npublic TrainCrashException() {\n}\npublic TrainCrashException(int aTrain, int bTrain) {\ntrainA = aTrain;\ntrainB = bTrain;\n}\npublic int getTrainA() {\nreturn trainA;\n}\npublic int getTrainB() {\nreturn trainB;\n}\n}"}
{"className":"jfreerails.move.AddPlayerMove","javaDoc":"/**\n* Adds a player to the world.\n*\n* @author Luke\n*/","code":"/**\n* Adds a player to the world.\n*\n* @author Luke\n*/\npublic class AddPlayerMove implements Move, ServerMove {\nprivate static final long serialVersionUID = 3977580277537322804L;\nprivate final Player player2add;\nprivate AddPlayerMove(Player p) {\nplayer2add = p;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof AddPlayerMove))\nreturn false;\nfinal AddPlayerMove addPlayerMove = (AddPlayerMove) o;\nif (!player2add.equals(addPlayerMove.player2add))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn player2add.hashCode();\n}\npublic static AddPlayerMove generateMove(ReadOnlyWorld w, Player player) {\n/**\n* create a new player with a corresponding Principal\n*/\nPlayer player2add = new Player(player.getName(), w.getNumberOfPlayers());\nreturn new AddPlayerMove(player2add);\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nif (isAlreadyASimilarPlayer(w))\nreturn MoveStatus\n.moveFailed(\"There is already a player with the same name.\");\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nint numPlayers = w.getNumberOfPlayers();\nPlayer pp = w.getPlayer(numPlayers - 1);\nif (pp.equals(player2add)) {\nreturn MoveStatus.MOVE_OK;\n}\nreturn MoveStatus.moveFailed(\"The last player is \" + pp.getName()\n+ \"not \" + player2add.getName());\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryDoMove(w, p);\nif (!ms.ok)\nreturn ms;\nint playerId = w.addPlayer(this.player2add);\n// Sell the player 2 $500,000 bonds at 5% interest.\nFreerailsPrincipal principal = player2add.getPrincipal();\nw.addTransaction(principal, BondTransaction.issueBond(5));\n//Issue stock\nMoney initialStockPrice = new Money(5);\nTransaction t = StockTransaction.issueStock(playerId, 100000,\ninitialStockPrice);\nw.addTransaction(principal, t);\nreturn ms;\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus ms = tryUndoMove(w, p);\nif (!ms.ok)\nreturn ms;\nw.removeLastTransaction(player2add.getPrincipal());\nw.removeLastTransaction(player2add.getPrincipal());\nw.removeLastPlayer();\nreturn ms;\n}\nprivate boolean isAlreadyASimilarPlayer(World w) {\nfor (int i = 0; i < w.getNumberOfPlayers(); i++) {\nPlayer pp = w.getPlayer(i);\nif (pp.getName().equalsIgnoreCase(this.player2add.getName())) {\nreturn true;\n}\n}\nreturn false;\n}\n}"}
{"className":"jfreerails.move.ServerMove","javaDoc":"/**\n* Indicates a move which can only be submitted by the server.\n*\n* @author rob\n*/","code":"/**\n* Indicates a move which can only be submitted by the server.\n*\n* @author rob\n*/\npublic interface ServerMove {\n}"}
{"className":"jfreerails.move.UpgradeTrackMove","javaDoc":"/**\n* This CompositeMove changes the track type at a point on the map and charges\n* the players account for the cost of the change.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This CompositeMove changes the track type at a point on the map and charges\n* the players account for the cost of the change.\n*\n* @author Luke Lindsay\n*\n*/\npublic class UpgradeTrackMove extends CompositeMove implements TrackMove {\nprivate static final long serialVersionUID = 3907215961470875442L;\nprivate UpgradeTrackMove(ChangeTrackPieceMove trackMove) {\nsuper(trackMove);\n}\npublic static UpgradeTrackMove generateMove(TrackPiece before,\nTrackPiece after, ImPoint p) {\nChangeTrackPieceMove m = new ChangeTrackPieceMove(before, after, p);\nreturn new UpgradeTrackMove(m);\n}\npublic Rectangle getUpdatedTiles() {\nChangeTrackPieceMove m = (ChangeTrackPieceMove) this.getMove(0);\nreturn m.getUpdatedTiles();\n}\n}"}
{"className":"jfreerails.move.ChangeTrainScheduleMove","javaDoc":"/**\n* This Move changes a train's schedule.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This Move changes a train's schedule.\n*\n* @author Luke Lindsay\n*\n*/\npublic class ChangeTrainScheduleMove extends ChangeItemInListMove {\nprivate static final long serialVersionUID = 3691043187930052149L;\npublic ChangeTrainScheduleMove(int id, ImmutableSchedule before,\nImmutableSchedule after, FreerailsPrincipal p) {\nsuper(KEY.TRAIN_SCHEDULES, id, before, after, p);\n}\n}"}
{"className":"jfreerails.move.ChangeTrackPieceMove","javaDoc":"/**\n* This Move adds, removes, or upgrades the track on a single tile.\n*\n* @author Luke\n*\n*/","code":"/**\n* This Move adds, removes, or upgrades the track on a single tile.\n*\n* @author Luke\n*\n*/\nfinal public class ChangeTrackPieceMove implements TrackMove, MapUpdateMove {\nprivate static final long serialVersionUID = 4120849958418591801L;\nfinal TrackPiece trackPieceBefore;\nprivate final TrackPiece trackPieceAfter;\nprivate final ImPoint location;\npublic ImPoint getLocation() {\nreturn location;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (trackPieceBefore != null ? trackPieceBefore.hashCode() : 0);\nresult = 29 * result\n+ (trackPieceAfter != null ? trackPieceAfter.hashCode() : 0);\nresult = 29 * result + location.hashCode();\nreturn result;\n}\npublic TrackPiece getOldTrackPiece() {\nreturn trackPieceBefore;\n}\npublic TrackPiece getNewTrackPiece() {\nreturn trackPieceAfter;\n}\npublic ChangeTrackPieceMove(TrackPiece before, TrackPiece after, ImPoint p) {\ntrackPieceBefore = before;\ntrackPieceAfter = after;\nlocation = p;\n}\npublic MoveStatus tryDoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(w, this.trackPieceBefore, this.trackPieceAfter);\n}\nprivate MoveStatus tryMove(World w, TrackPiece oldTrackPiece,\nTrackPiece newTrackPiece) {\n// Check that location is on the map.\nif (!w.boundsContain(location.x, location.y)) {\nreturn MoveStatus\n.moveFailed(\"Tried to build track outside the map.\");\n}\n// Check that we are not changing another players track if this is not\n// allowed.\nif (!canConnect2OtherRRsTrack(w)) {\n// If either the new or old track piece is null, we are ok.\nint oldRuleNumber = oldTrackPiece.getTrackTypeID();\nint newRuleNumber = newTrackPiece.getTrackTypeID();\nif (NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER != oldRuleNumber\n&& NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER != newRuleNumber) {\nint oldOwner = oldTrackPiece.getOwnerID();\nint newOwner = newTrackPiece.getOwnerID();\nif (oldOwner != newOwner) {\nreturn MoveStatus\n.moveFailed(\"Not allowed to connect to other RR\");\n}\n}\n}\n// Check that the current track piece at this.location is\n// the same as this.oldTrackPiece.\nTrackPiece currentTrackPieceAtLocation = ((FreerailsTile) w.getTile(\nlocation.x, location.y)).getTrackPiece();\nTrackRule expectedTrackRule = oldTrackPiece.getTrackRule();\nTrackRule actualTrackRule = currentTrackPieceAtLocation.getTrackRule();\nif (!expectedTrackRule.equals(actualTrackRule)) {\nreturn MoveStatus.moveFailed(\"Expected '\"\n+ expectedTrackRule.getTypeName() + \"' but found '\"\n+ actualTrackRule.getTypeName() + \"' at \" + location.x\n+ \" ,\" + location.y);\n}\nif (currentTrackPieceAtLocation.getTrackConfiguration() != oldTrackPiece\n.getTrackConfiguration()) {\nreturn MoveStatus\n.moveFailed(\"Unexpected track piece found at location: \"\n+ location.x + \" ,\" + location.y);\n}\n// Check that oldTrackPiece is not the same as newTrackPiece\nif ((oldTrackPiece.getTrackConfiguration() == newTrackPiece\n.getTrackConfiguration())\n&& (oldTrackPiece.getTrackRule() == newTrackPiece\n.getTrackRule())) {\nreturn MoveStatus.moveFailed(\"Already track here!\");\n}\n// Check for illegal track configurations.\nif (!(oldTrackPiece.getTrackRule().trackPieceIsLegal(\noldTrackPiece.getTrackConfiguration()) && newTrackPiece\n.getTrackRule().trackPieceIsLegal(\nnewTrackPiece.getTrackConfiguration()))) {\nreturn MoveStatus.moveFailed(\"Illegal track configuration.\");\n}\n// Check for diagonal conflicts.\nif (!(noDiagonalTrackConflicts(location, oldTrackPiece\n.getTrackGraphicID(), w) && noDiagonalTrackConflicts(location,\nnewTrackPiece.getTrackGraphicID(), w))) {\nreturn MoveStatus\n.moveFailed(\"Illegal track configuration - diagonal conflict\");\n}\nint terrainType = ((FreerailsTile) w.getTile(location.x, location.y))\n.getTerrainTypeID();\nTerrainType tt = (TerrainType) w.get(SKEY.TERRAIN_TYPES, terrainType);\nif (!newTrackPiece.getTrackRule().canBuildOnThisTerrainType(\ntt.getCategory())) {\nString thisTrackType = newTrackPiece.getTrackRule().getTypeName();\nString terrainCategory = tt.getCategory().toString().toLowerCase();\nreturn MoveStatus.moveFailed(\"Can't build \" + thisTrackType\n+ \" on \" + terrainCategory);\n}\n// Check 4 overlapping stations.\nif (newTrackPiece.getTrackRule().isStation()) {\nMoveStatus ms = ChangeTrackPieceMove.check4overlap(w, location,\nnewTrackPiece);\nif (!ms.ok)\nreturn ms;\n}\nreturn MoveStatus.MOVE_OK;\n}\npublic MoveStatus tryUndoMove(World w, FreerailsPrincipal p) {\nreturn tryMove(w, this.trackPieceAfter, this.trackPieceBefore);\n}\npublic MoveStatus doMove(World w, FreerailsPrincipal p) {\nMoveStatus moveStatus = tryDoMove(w, p);\nif (!moveStatus.isOk()) {\nreturn moveStatus;\n}\nmove(w, this.trackPieceBefore, this.trackPieceAfter);\nreturn moveStatus;\n}\nprivate void move(World w, TrackPiece oldTrackPiece,\nTrackPiece newTrackPiece) {\n// FIXME why is oldTrackPiece not used???\nFreerailsTile oldTile = (FreerailsTile) w.getTile(location.x,\nlocation.y);\nint terrain = oldTile.getTerrainTypeID();\nFreerailsTile newTile = FreerailsTile.getInstance(terrain,\nnewTrackPiece);\nw.setTile(location.x, location.y, newTile);\n}\npublic MoveStatus undoMove(World w, FreerailsPrincipal p) {\nMoveStatus moveStatus = tryUndoMove(w, p);\nif (!moveStatus.isOk()) {\nreturn moveStatus;\n}\nmove(w, this.trackPieceAfter, this.trackPieceBefore);\nreturn moveStatus;\n}\nprivate boolean noDiagonalTrackConflicts(ImPoint point, int trackTemplate,\nWorld w) {\n/*\n* This method is needs replacing. It only deals with flat track pieces,\n* and is rather hard to make sense of. LL\n*/\n// int trackTemplate = (1 << (3 * (1 + tv.getY()) + (1 + tv.getX())));\nint trackTemplateAbove;\nint trackTemplateBelow;\nint cornersTemplate = TrackConfiguration\n.stringTemplate2Int(\"101000101\");\ntrackTemplate = trackTemplate & cornersTemplate;\nDimension mapSize = new Dimension(w.getMapWidth(), w.getMapHeight());\n// Avoid array-out-of-bounds exceptions.\nif (point.y > 0) {\nFreerailsTile ft = (FreerailsTile)w.getTile(point.x, point.y - 1);\nTrackPiece tp = ft.getTrackPiece();\ntrackTemplateAbove = tp.getTrackGraphicID();\n} else {\ntrackTemplateAbove = 0;\n}\nif ((point.y + 1) < mapSize.height) {\nFreerailsTile ft = (FreerailsTile)w.getTile(point.x, point.y + 1);\nTrackPiece tp = ft.getTrackPiece();\ntrackTemplateBelow = tp.getTrackGraphicID();\n} else {\ntrackTemplateBelow = 0;\n}\ntrackTemplateAbove = trackTemplateAbove >> 6;\ntrackTemplateBelow = trackTemplateBelow << 6;\ntrackTemplate = trackTemplate\n& (trackTemplateAbove | trackTemplateBelow);\nif (trackTemplate != 0) {\nreturn false;\n// There is a clash.\n}\nreturn true;\n// Things are ok.\n}\npublic Rectangle getUpdatedTiles() {\n// If we are building or removing a station,\n// we need to repaint/remove the station radius\n// that appears on the map.\nint radius = 1;\nTrackRule trackRuleAfter = this.trackPieceAfter.getTrackRule();\nif (trackRuleAfter.isStation()) {\nradius = Math.max(radius, trackRuleAfter.getStationRadius());\n}\nTrackRule trackRuleBefore = this.trackPieceBefore.getTrackRule();\nif (trackRuleBefore.isStation()) {\nradius = Math.max(radius, trackRuleBefore.getStationRadius());\n}\n// Just to be safe.\nradius++;\nint x;\nint y;\nint width;\nint height;\nx = location.x - radius;\ny = location.y - radius;\nwidth = radius * 2 + 1;\nheight = radius * 2 + 1;\nreturn new Rectangle(x, y, width, height);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof ChangeTrackPieceMove) {\nChangeTrackPieceMove m = (ChangeTrackPieceMove) o;\nboolean fieldPointEqual = this.location.equals(m.location);\nboolean fieldoldTrackPieceEqual = this.trackPieceBefore\n.equals(m.trackPieceBefore);\nboolean fieldnewTrackPieceEqual = this.trackPieceAfter\n.equals(m.trackPieceAfter);\nif (fieldPointEqual && fieldoldTrackPieceEqual\n&& fieldnewTrackPieceEqual) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\nprotected static boolean canConnect2OtherRRsTrack(ReadOnlyWorld world) {\nGameRules rules = (GameRules) world.get(ITEM.GAME_RULES);\nreturn rules.isCanConnect2OtherRRTrack();\n}\n/**\n* This method may be called under 3 possible conditions: (1) when a station\n* is getting built, (2) when a station is getting upgraded, (3) when a\n* station is getting removed.\n*/\nprotected static MoveStatus check4overlap(World w, ImPoint location,\nTrackPiece trackPiece) {\n/*\n* Fix for 915945 (Stations should not overlap) Check that there is not\n* another station whose radius overlaps with the one we are building.\n*/\nTrackRule thisStationType = trackPiece.getTrackRule();\nassert thisStationType.isStation();\nfor (int player = 0; player < w.getNumberOfPlayers(); player++) {\nFreerailsPrincipal principal = w.getPlayer(player).getPrincipal();\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w, principal);\nwhile (wi.next()) {\nStationModel station = (StationModel) wi.getElement();\n/*\n* Fix for bug 948675 - Can't upgrade station types If locations\n* are the same, then we are upgrading a station so it doesn't\n* matter if the radii overlap.\n*/\nif (location.x == station.x && location.y == station.y) {\ncontinue;\n}\nFreerailsTile tile = (FreerailsTile) w.getTile(station.x,\nstation.y);\nTrackRule otherStationType = tile.getTrackPiece().getTrackRule();\nassert otherStationType.isStation();\nint sumOfRadii = otherStationType.getStationRadius()\n+ thisStationType.getStationRadius();\nint sumOfRadiiSquared = sumOfRadii * sumOfRadii;\nint xDistance = station.x - location.x;\nint yDistance = station.y - location.y;\n// Do radii overlap?\nboolean xOverlap = sumOfRadiiSquared >= (xDistance * xDistance);\nboolean yOverlap = sumOfRadiiSquared >= (yDistance * yDistance);\nif (xOverlap && yOverlap) {\nString message = \"Too close to \" + station.getStationName();\nreturn MoveStatus.moveFailed(message);\n}\n}\n}\nreturn MoveStatus.MOVE_OK;\n}\n}"}
{"className":"jfreerails.move.MoveStatus","javaDoc":"/**\n* Records the success or failure of an attempt to execute a move.\n*\n* @author lindsal\n*/","code":"/**\n* Records the success or failure of an attempt to execute a move.\n*\n* @author lindsal\n*/\n@Immutable\nfinal public class MoveStatus implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3258129171879309624L;\npublic static final MoveStatus MOVE_OK = new MoveStatus(true,\n\"Move accepted\");\npublic final boolean ok;\npublic final String message;\nprivate final Throwable t;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof MoveStatus))\nreturn false;\nfinal MoveStatus moveStatus = (MoveStatus) o;\nif (ok != moveStatus.ok)\nreturn false;\nif (message != null ? !message.equals(moveStatus.message)\n: moveStatus.message != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (ok ? 1 : 0);\nresult = 29 * result + (message != null ? message.hashCode() : 0);\nreturn result;\n}\n/**\n* Avoid creating a duplicate when deserializing.\n*/\nprivate Object readResolve() {\nif (ok) {\nreturn MOVE_OK;\n}\nreturn this;\n}\nprivate MoveStatus(boolean ok, String mess) {\nif(ok){\nt = null;\n}else{\nt = new Throwable();\nt.fillInStackTrace();\n}\nthis.ok = ok;\nthis.message = mess;\n}\npublic static MoveStatus moveFailed(String reason) {\nreturn new MoveStatus(false, reason);\n}\npublic boolean isOk() {\nreturn ok;\n}\npublic void printStackTrack(){\nif(null != t)\nt.printStackTrace();\n}\n@Override\npublic String toString() {\nreturn message;\n}\n}"}
{"className":"jfreerails.move.TransferCargoAtStationMove","javaDoc":"/**\n* This {@link CompositeMove} transfers cargo from a train to a station and\n* vice-versa.\n*\n* @author Luke Lindsay\n*\n*\n*/","code":"/**\n* This {@link CompositeMove} transfers cargo from a train to a station and\n* vice-versa.\n*\n* @author Luke Lindsay\n*\n*\n*/\npublic class TransferCargoAtStationMove extends CompositeMove {\nprivate static final long serialVersionUID = 3257291318215456563L;\npublic static final int CHANGE_ON_TRAIN_INDEX = 1;\npublic static final int CHANGE_AT_STATION_INDEX = 0;\nprivate final boolean waitingForFullLoad;\nprivate TransferCargoAtStationMove(Move[] moves, boolean waiting) {\nsuper(moves);\nwaitingForFullLoad = waiting;\n}\npublic static TransferCargoAtStationMove generateMove(\nChangeCargoBundleMove changeAtStation,\nChangeCargoBundleMove changeOnTrain, CompositeMove payment,\nboolean waiting) {\nreturn new TransferCargoAtStationMove(new Move[] { changeAtStation,\nchangeOnTrain, payment }, waiting);\n}\npublic ChangeCargoBundleMove getChangeAtStation() {\nreturn (ChangeCargoBundleMove) super.getMoves().get(\nCHANGE_AT_STATION_INDEX);\n}\npublic ChangeCargoBundleMove getChangeOnTrain() {\nreturn (ChangeCargoBundleMove) super.getMoves().get(\nCHANGE_ON_TRAIN_INDEX);\n}\npublic Money getRevenue() {\nImList<Move> moves = super.getMoves();\nlong amount = CHANGE_AT_STATION_INDEX;\nfor (int i = CHANGE_AT_STATION_INDEX; i < moves.size(); i++) {\nif (moves.get(i) instanceof AddTransactionMove) {\nAddTransactionMove move = (AddTransactionMove) moves.get(i);\nDeliverCargoReceipt receipt = (DeliverCargoReceipt) move\n.getTransaction();\namount += receipt.deltaCash().getAmount();\n}\n}\nreturn new Money(amount);\n}\npublic int getQuantityOfCargo(int cargoType) {\nImList<Move> moves = super.getMoves();\nint quantity = CHANGE_AT_STATION_INDEX;\nfor (int i = CHANGE_AT_STATION_INDEX; i < moves.size(); i++) {\nif (moves.get(i) instanceof AddTransactionMove) {\nAddTransactionMove move = (AddTransactionMove) moves.get(i);\nDeliverCargoReceipt receipt = (DeliverCargoReceipt) move\n.getTransaction();\nCargoBatch cb = receipt.getCb();\nif (cb.getCargoType() == cargoType) {\nquantity += receipt.getQuantity();\n}\n}\n}\nreturn quantity;\n}\n/** The player who is getting paid for the delivery. */\npublic FreerailsPrincipal getPrincipal() {\nImList<Move> moves = super.getMoves();\nfor (int i = CHANGE_AT_STATION_INDEX; i < moves.size(); i++) {\nif (moves.get(i) instanceof AddTransactionMove) {\nAddTransactionMove move = (AddTransactionMove) moves.get(i);\nreturn move.getPrincipal();\n}\n}\nreturn Player.NOBODY;\n}\npublic TransferCargoAtStationMove(ArrayList<Move> movesArrayList,\nboolean waiting) {\nsuper(movesArrayList);\nthis.waitingForFullLoad = waiting;\n}\npublic boolean isWaitingForFullLoad() {\nreturn waitingForFullLoad;\n}\n}"}
{"className":"jfreerails.move.ChangeCargoBundleMove","javaDoc":"/**\n* This {@link Move} changes a cargo bundle (cargo bundles are used to represent\n* the cargo carried by trains and the cargo waiting at stations).\n*\n* @author Luke\n*\n*/","code":"/**\n* This {@link Move} changes a cargo bundle (cargo bundles are used to represent\n* the cargo carried by trains and the cargo waiting at stations).\n*\n* @author Luke\n*\n*/\npublic class ChangeCargoBundleMove extends ChangeItemInListMove {\nprivate static final long serialVersionUID = 3258126960072143408L;\npublic ChangeCargoBundleMove(ImmutableCargoBundle before,\nImmutableCargoBundle after, int bundleNumber, FreerailsPrincipal p) {\nsuper(KEY.CARGO_BUNDLES, bundleNumber, before, after, p);\n}\n}"}
{"className":"jfreerails.util.ListXDDiffsTest","javaDoc":null,"code":"public class ListXDDiffsTest extends ListXDTest {\nprivate SortedMap<ListKey, Object> map;\nenum listid{list1, list2, list3}\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\nmap = new TreeMap<ListKey, Object>();\nlist1d = new List1DDiff<Object>(map, list1d, listid.list1);\nlist2d = new List2DDiff<Object>(map, list2d, listid.list2);\nlist3d = new List3DDiff<Object>(map, list3d, listid.list3);\n}\n}"}
{"className":"jfreerails.util.UtilsTest","javaDoc":null,"code":"public class UtilsTest extends TestCase {\npublic void testEqualsBySerialization() {\nSerializable a = new Point(10, 10);\nSerializable b = new Point(10, 10);\nSerializable c = new Point(30, 10);\nassertTrue(Utils.equalsBySerialization(a, b));\nassertTrue(Utils.equalsBySerialization(a, a));\nassertTrue(Utils.equalsBySerialization(b, b));\nassertTrue(Utils.equalsBySerialization(c, c));\nassertFalse(Utils.equalsBySerialization(a, c));\n}\n}"}
{"className":"jfreerails.util.List2DDiffTest","javaDoc":null,"code":"public class List2DDiffTest extends TestCase {\nList2D<Object> underlying;\nList2DDiff<Object> diffs;\nSortedMap<ListKey, Object> map;\nenum listid{test}\n@Override\nprotected void setUp() throws Exception {\nunderlying = new List2DImpl<Object>(0);\nmap = new TreeMap<ListKey, Object>();\ndiffs = new List2DDiff<Object>(map, underlying, listid.test);\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.sizeD1()'\n*/\npublic void testSizeD1() {\nassertEquals(0, diffs.sizeD1());\nunderlying.addD1();\nassertEquals(1, diffs.sizeD1());\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.sizeD2(int)'\n*/\npublic void testSizeD2() {\nunderlying.addD1();\nassertEquals(1, diffs.sizeD1());\nassertEquals(0, diffs.sizeD2(0));\nunderlying.addD2(0, String.valueOf(1));\nassertEquals(1, diffs.sizeD2(0));\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.get(int, int)'\n*/\npublic void testGetIntInt() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nassertEquals(String.valueOf(1), underlying.get(0, 0));\nassertEquals(String.valueOf(1), diffs.get(0, 0));\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.removeLastD2(int)'\n*/\npublic void testRemoveLastD2() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\nObject removed = diffs.removeLastD2(0);\nassertEquals(String.valueOf(2), removed);\nassertEquals(2, underlying.sizeD2(0));\nassertEquals(2, diffs.getUnderlyingSize(0));\nassertEquals(1, map.size());\nassertEquals(1, diffs.sizeD2(0));\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.removeLastD1()'\n*/\npublic void testRemoveLastD1() {\nunderlying.addD1();\nunderlying.addD1();\nassertEquals(2, diffs.sizeD1());\nint i = diffs.removeLastD1();\nassertEquals(1, i);\nassertEquals(1, diffs.sizeD1());\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.addD1()'\n*/\npublic void testAddD1() {\nunderlying.addD1();\nassertEquals(1, diffs.sizeD1());\nassertEquals(1, diffs.getUnderlyingSize());\nassertEquals(1, diffs.size());\ndiffs.addD1();\nListKey sizeKey = new ListKey(EndPoint, listid.test);\nassertEquals(2, map.size());\nassertTrue(map.containsKey(sizeKey));\nassertEquals(new Integer(2), map.get(sizeKey));\nassertEquals(2, diffs.sizeD1());\ndiffs.addD1();\nassertEquals(3, diffs.sizeD1());\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.addD2(int, T)'\n*/\npublic void testAddD2() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\nassertEquals(2, diffs.sizeD2(0));\nint i = diffs.addD2(0, String.valueOf(3));\nassertEquals(2, i);\nassertEquals(3, diffs.sizeD2(0));\ni = diffs.addD2(0, String.valueOf(4));\nassertEquals(3, i);\nassertEquals(4, diffs.sizeD2(0));\nassertEquals(String.valueOf(3), diffs.get(0, 2));\nassertEquals(String.valueOf(4), diffs.get(0, 3));\n}\n/*\n* Test method for 'jfreerails.util.List2DDiff.set(int, int, T)'\n*/\npublic void testSetIntIntT() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\nassertEquals(String.valueOf(2), diffs.get(0, 1));\ndiffs.set(0, 1, String.valueOf(22));\nassertEquals(String.valueOf(22), diffs.get(0, 1));\ndiffs.addD2(0, String.valueOf(3));\nassertEquals(String.valueOf(3), diffs.get(0, 2));\ndiffs.set(0, 2, String.valueOf(33));\nassertEquals(String.valueOf(33), diffs.get(0, 2));\n}\n/*\n* Test method for 'jfreerails.util.ListXDDiffs.add(int...)'\n*/\npublic void testAddIntArray() {\nassertEquals(0, diffs.sizeD1());\ndiffs.addDimension();\nListKey sizeKey = new ListKey(EndPoint, listid.test);\nassertEquals(\"There should be two values: EndPoint = 0 and EndPoint[0] = 0\", 2, map.size());\nassertTrue(map.containsKey(sizeKey));\nassertEquals(new Integer(1), map.get(sizeKey));\nassertEquals(1, diffs.sizeD1());\nassertEquals(0, diffs.sizeD2(0));\ndiffs.addDimension(0);\nassertEquals(1, diffs.sizeD2(0));\n}\npublic void testBoundsOnSet1() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\ntry {\nassertEquals(2, diffs.size(0));\ndiffs.set(0, 2, String.valueOf(3));\nfail();\n} catch (Exception e) {\n}\n}\npublic void testBoundsOnSet2() {\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\nunderlying.addD2(0, String.valueOf(3));\ndiffs.removeLastD2(0);\ndiffs.removeLastD2(0);\ntry {\nassertEquals(1, diffs.size(0));\ndiffs.set(0, 2, String.valueOf(3));\nfail();\n} catch (Exception e) {\n}\n}\npublic void testBoundsOnGet(){\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\nunderlying.addD2(0, String.valueOf(3));\ndiffs.removeLastD2(0);\ndiffs.removeLastD2(0);\ntry {\nassertEquals(1, diffs.size(0));\ndiffs.get(0, 2);\nfail();\n} catch (Exception e) {\n}\n}\npublic void testReverting2OriginalState1(){\nunderlying.addD1();\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\ndiffs.addD1();\nassertEquals(3, diffs.sizeD1());\nassertEquals(0, diffs.sizeD2(2));\ndiffs.removeLastD1();\nassertEquals(2, diffs.sizeD1());\nassertEquals(2, underlying.sizeD1());\nassertEquals(0, map.size());\n}\npublic void testReverting2OriginalState2(){\nunderlying.addD1();\nunderlying.addD1();\nunderlying.addD2(0, String.valueOf(1));\nunderlying.addD2(0, String.valueOf(2));\ndiffs.addD1();\ndiffs.addD2(2, String.valueOf(3));\ndiffs.addD2(2, String.valueOf(33));\nassertEquals(2, diffs.sizeD2(2));\nassertEquals(String.valueOf(3), diffs.get(2, 0));\nassertEquals(String.valueOf(33), diffs.get(2, 1));\nObject removed = diffs.removeLastD2(2);\nassertEquals(String.valueOf(33), removed);\nremoved = diffs.removeLastD2(2);\nassertEquals(String.valueOf(3), removed);\nassertEquals(0, diffs.sizeD2(2));\nassertEquals(3, diffs.sizeD1());\nassertEquals(0, diffs.sizeD2(2));\ndiffs.removeLastD1();\nassertEquals(2, diffs.sizeD1());\nassertEquals(2, underlying.sizeD1());\nassertEquals(0, map.size());\n}\npublic void testAddingElementAlreadyPresent(){\nunderlying.addD1();\nunderlying.addD2(0, new Integer(1));\ndiffs.removeLastD2(0);\ndiffs.addD2(0, new Integer(1));\nassertEquals(0, map.size());\n}\npublic void testAddingNullElement(){\nunderlying.addD1();\nunderlying.addD2(0, null);\ndiffs.removeLastD2(0);\ndiffs.addD2(0, new Integer(1));\nassertEquals(1, map.size());\ndiffs.removeLastD2(0);\ndiffs.addD2(0, null);\nassertEquals(0, map.size());\ndiffs.addD2(0, null);\n}\npublic void testSettingNullElement(){\nunderlying.addD1();\nunderlying.addD2(0, null);\nunderlying.addD2(0, new Integer(1));\nassertEquals(null, diffs.get(0,0));\ndiffs.set(0, 0, new Integer(0));\nassertEquals(new Integer(0), diffs.get(0,0));\nassertEquals(new Integer(1), diffs.get(0,1));\ndiffs.set(0, 1, null);\nassertEquals(null, diffs.get(0,1));\n}\n}"}
{"className":"jfreerails.util.List3DDiffTest","javaDoc":null,"code":"public class List3DDiffTest extends TestCase {\nList3DDiff<Object> diffs;\nSortedMap<ListKey, Object> map;\nList3D<Object> underlying;\nenum listid{test}\n@Override\nprotected void setUp() throws Exception {\nunderlying = new List3DImpl<Object>(0, 0);\nmap = new TreeMap<ListKey, Object>();\ndiffs = new List3DDiff<Object>(map, underlying, listid.test);\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.addD1()'\n*/\npublic void testAddD1() {\ndiffs.addD1();\nassertEquals(1, diffs.sizeD1());\ndiffs.addD1();\nassertEquals(2, diffs.sizeD1());\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.addD2(int)'\n*/\npublic void testAddD2() {\nunderlying.addD1();\nunderlying.addD1();\ndiffs.addD2(0);\nassertEquals(1, diffs.sizeD2(0));\ndiffs.addD2(0);\nassertEquals(2, diffs.sizeD2(0));\ndiffs.addD2(1);\nassertEquals(1, diffs.sizeD2(1));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.addD3(int, int, T)'\n*/\npublic void testAddD3() {\nunderlying.addD1();\nunderlying.addD1();\nunderlying.addD2(1);\nunderlying.addD2(1);\ndiffs.addD3(1, 0, new Integer(5));\nassertEquals(1, diffs.sizeD3(1, 0));\ndiffs.addD3(1, 1, new Integer(5));\nassertEquals(1, diffs.sizeD3(1, 1));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.get(int, int, int)'\n*/\npublic void testGetIntIntInt() {\nunderlying.addD1();\nunderlying.addD1();\nunderlying.addD2(1);\nunderlying.addD2(1);\nunderlying.addD3(1, 1, new Integer(1));\nassertEquals(new Integer(1), diffs.get(1,1,0));\ndiffs.addD3(1, 1, new Integer(2));\ndiffs.addD3(1, 1, new Integer(3));\nassertEquals(new Integer(2), diffs.get(1,1,1));\nassertEquals(new Integer(3), diffs.get(1,1,2));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.getUnderlyingSize(int...)'\n*/\npublic void testGetUnderlyingSize() {\nassertEquals(-1, diffs.getUnderlyingSize(0,0));\nassertEquals(-1, diffs.getUnderlyingSize(0));\nassertEquals(0, diffs.getUnderlyingSize());\nassertEquals(-1, diffs.getUnderlyingSize(1, 0));\nassertEquals(-1, diffs.getUnderlyingSize(0, 1));\nunderlying.addD1();\nunderlying.addD1();\nassertEquals(2, diffs.getUnderlyingSize());\nassertEquals(0, diffs.getUnderlyingSize(1));\nassertEquals(0, diffs.getUnderlyingSize(0));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.removeLastD1()'\n*/\npublic void testRemoveLastD1() {\nunderlying.addD1();\nunderlying.addD1();\nassertEquals(2, diffs.sizeD1());\ndiffs.removeLastD1();\nassertEquals(1, diffs.sizeD1());\ndiffs.removeLastD1();\nassertEquals(0, diffs.sizeD1());\ntry{\ndiffs.removeLastD1();\nfail();\n}catch (Exception e) {\n}\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.removeLastD2(int)'\n*/\npublic void testRemoveLastD2() {\nunderlying.addD1();\nunderlying.addD2(0);\nunderlying.addD2(0);\nunderlying.addD2(0);\nassertEquals(3, diffs.sizeD2(0));\ndiffs.removeLastD2(0);\nassertEquals(2, diffs.sizeD2(0));\ndiffs.removeLastD2(0);\ndiffs.removeLastD2(0);\nassertEquals(0, diffs.sizeD2(0));\ntry{\ndiffs.removeLastD2(0);\nfail();\n}catch (Exception e) {\n}\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.removeLastD3(int, int)'\n*/\npublic void testRemoveLastD3() {\nunderlying.addD1();\nunderlying.addD2(0);\nunderlying.addD3(0,0, new Integer(1));\nunderlying.addD3(0,0, new Integer(2));\nunderlying.addD3(0,0, new Integer(3));\nassertEquals(3, diffs.sizeD3(0,0));\ndiffs.removeLastD3(0, 0);\nassertEquals(2, diffs.sizeD3(0,0));\ndiffs.removeLastD3(0, 0);\nassertEquals(1, diffs.sizeD3(0,0));\ndiffs.removeLastD3(0, 0);\nassertEquals(0, diffs.sizeD3(0,0));\ntry{\ndiffs.removeLastD3(0, 0);\nfail();\n}catch (Exception e) {\n}\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.set(int, int, int, T)'\n*/\npublic void testSetIntIntIntT() {\nunderlying.addD1();\nunderlying.addD2(0);\nunderlying.addD3(0,0, new Integer(1));\nassertEquals(new Integer(1), diffs.get(0, 0, 0));\ndiffs.addD3(0,0, new Integer(2));\nassertEquals(new Integer(2), diffs.get(0, 0, 1));\ndiffs.set(0,0,0, new Integer(11));\nassertEquals(new Integer(11), diffs.get(0, 0, 0));\ndiffs.set(0,0,1, new Integer(22));\nassertEquals(new Integer(22), diffs.get(0, 0, 1));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.sizeD1()'\n*/\npublic void testSizeDx() {\nassertEquals(0, diffs.sizeD1());\nunderlying.addD1();\nassertEquals(1, diffs.sizeD1());\nassertEquals(0, diffs.sizeD2(0));\nunderlying.addD2(0);\nassertEquals(1, diffs.sizeD2(0));\nassertEquals(0, diffs.sizeD3(0,0));\nunderlying.addD3(0,0, new Integer(4));\nunderlying.addD3(0,0, new Integer(4));\nassertEquals(2, diffs.sizeD3(0,0));\n}\n/*\n* Test method for 'jfreerails.util.List3DDiff.uGet(int...)'\n*/\npublic void testUGet() {\nunderlying.addD1();\nunderlying.addD2(0);\nunderlying.addD3(0,0, new Integer(1));\nassertEquals(new Integer(1), diffs.uGet(0,0,0));\n}\n}"}
{"className":"jfreerails.util.ListXDTest","javaDoc":null,"code":"public class ListXDTest extends TestCase {\nList1D<Object> list1d;\nList2D<Object> list2d;\nList3D<Object> list3d;\n@Override\nprotected void setUp() throws Exception {\nlist1d = new List1DImpl<Object>();\nlist2d = new List2DImpl<Object>(5);\nlist3d = new List3DImpl<Object>(3, 2);\n}\npublic void testAdd(){\n//Test initial size.\nassertEquals(0, list1d.size());\nassertEquals(5, list2d.sizeD1());\nassertEquals(0, list2d.sizeD2(0));\n//Add an object\nInteger i = new Integer(4);\nassertEquals(0, list1d.add(i));\nassertEquals(0, list2d.addD2(2, i));\nassertEquals(1, list1d.size());\nassertEquals(5, list2d.sizeD1());\nassertEquals(1, list2d.sizeD2(2));\nassertEquals(0, list2d.sizeD2(0));\n}\npublic void testRemove(){\nInteger i = new Integer(4);\nlist2d.addD2(4, i);\ntry{\nlist2d.removeLastD1();\nfail();\n}catch (Exception e) {\n//An exception should be thrown since the list we are trying to remove is not empty.\n}\nlist3d.addD3(2,1,i);\n//We now should be able to remove the last\ntry{\nlist3d.removeLastD1();\nfail();\n}catch (Exception e) {\n//An exception should be thrown since the list we are trying to remove is not empty.\n}\ntry{\nlist3d.removeLastD2(3);\nfail();\n}catch (Exception e) {\n//An exception should be thrown since the list we are trying to remove is not empty.\n}\n}\npublic void testHashCodeAndEquals(){\nInteger i = new Integer(5);\nInteger ii = new Integer(53);\n//1d\nlist1d.add(i);\nObject copy = Utils.cloneBySerialisation(list1d);\nassertEquals(copy, list1d);\nassertEquals(copy.hashCode(), list1d.hashCode());\nlist1d.add(ii);\nassertFalse(copy.equals(list1d));\n//2d\nlist2d.addD2(0, i);\ncopy = Utils.cloneBySerialisation(list2d);\nassertEquals(copy, list2d);\nassertEquals(copy.hashCode(), list2d.hashCode());\nlist2d.addD2(0, ii);\nassertFalse(copy.equals(list2d));\n//3d\nlist3d.addD3(0, 1, i);\ncopy = Utils.cloneBySerialisation(list3d);\nassertEquals(copy, list3d);\nassertEquals(copy.hashCode(), list3d.hashCode());\nlist3d.addD3(0, 1, ii);\nassertFalse(copy.equals(list3d));\n}\npublic void test3DList(){\nlist3d = new List3DImpl<Object>(0, 0);\n//Add a player\nint playerId = list3d.addD1();\nlist3d.addD2(playerId);\nlist3d.addD2(playerId);\nlist3d.addD2(playerId);\n//Then remove them\nwhile(list3d.sizeD2(playerId)>0){\nlist3d.removeLastD2(playerId);\n}\n}\n}"}
{"className":"jfreerails.util.List1DDiffsTest","javaDoc":null,"code":"public class List1DDiffsTest extends TestCase {\nprivate List1D<Object> list;\nprivate List1DDiff<Object> diffs;\nprivate SortedMap<ListKey, Object> map;\nenum test{test}\n@Override\nprotected void setUp() throws Exception {\nlist = new List1DImpl<Object>();\nmap = new TreeMap<ListKey, Object>();\ndiffs = new List1DDiff<Object>(map, list, test.test);\n}\npublic void testChangingValues(){\nlist.add(String.valueOf(1));\nassertEquals(diffs.get(0), String.valueOf(1));\nassertEquals(diffs.size(), list.size());\ndiffs.set(String.valueOf(2), 0);\nassertEquals(diffs.get(0), String.valueOf(2));\nassertEquals(1, map.size());\ndiffs.set(String.valueOf(1),0);\nassertEquals(0, map.size());\n}\npublic void testAdd(){\nPlayer player0 = new Player(\"player0\", 0);\nPlayer player1 = new Player(\"player1\", 1);\nint i = diffs.add(player0);\nassertEquals(0, i);\nassertEquals(1, diffs.size());\nassertEquals(player0, diffs.get(0));\ni = diffs.add(player1);\nassertEquals(1, i);\nassertEquals(2, diffs.size());\nassertEquals(player1, diffs.get(1));\n}\npublic void testAddAndRemove(){\nlist.add(String.valueOf(1));\nassertEquals( String.valueOf(1), diffs.get(0));\nint i = diffs.add(String.valueOf(2));\nassertEquals(1, i);\nassertEquals( String.valueOf(1), diffs.get(0));\nassertEquals(diffs.get(1), String.valueOf(2));\nassertEquals(2, diffs.size());\nassertEquals(2, map.size());\nObject removed = diffs.removeLast();\nassertEquals(String.valueOf(2), removed);\nassertEquals(1, diffs.size());\nassertEquals(0, map.size());\nremoved = diffs.removeLast();\nassertEquals(String.valueOf(1), removed);\nassertEquals(0, diffs.size());\nassertEquals(1, map.size());\n}\npublic void testAddAndRemove2(){\nlist.add(String.valueOf(1));\nlist.add(String.valueOf(1));\nlist.add(String.valueOf(1));\ndiffs.removeLast();\ndiffs.removeLast();\nassertEquals(1, diffs.size());\nassertEquals(1, map.size());\ndiffs.add(String.valueOf(2));\ndiffs.add(String.valueOf(2));\ndiffs.add(String.valueOf(2));\ndiffs.add(String.valueOf(2));\nassertEquals(5, diffs.size());\nassertEquals(\"4 elements + end=5\", 5, map.size());\nassertEquals(String.valueOf(1), diffs.get(0));\nassertEquals(String.valueOf(2), diffs.get(1));\nassertEquals(String.valueOf(2), diffs.get(2));\nassertEquals(String.valueOf(2), diffs.get(3));\nassertEquals(String.valueOf(2), diffs.get(3));\ndiffs.set(String.valueOf(3), 2);\nassertEquals(5, diffs.size());\nassertEquals(5, map.size());\nassertEquals(String.valueOf(3), diffs.get(2));\ndiffs.set(String.valueOf(4), 4);\nassertEquals(String.valueOf(4), diffs.get(4));\ndiffs.removeLast();\ndiffs.removeLast();\ndiffs.removeLast();\ndiffs.removeLast();\nassertEquals(1, diffs.size());\nassertEquals(\"fork=1\", 1, map.size());\n}\npublic void testSortedMap(){\nListKey elementKey1 = new ListKey(ListKey.Type.Element, test.test, 0);\nListKey elementKey2 = new ListKey(ListKey.Type.Element, test.test, 1);\nListKey elementKey3 = new ListKey(ListKey.Type.Element, test.test, 0);\nmap.put(elementKey1, String.valueOf(1));\nassertFalse(map.containsKey(elementKey2));\nassertTrue(map.containsKey(elementKey1));\nassertTrue(map.containsKey(elementKey3));\n}\n}"}
{"className":"jfreerails.util.List2DDiff","javaDoc":null,"code":"public class List2DDiff<T> extends ListXDDiffs<T> implements List2D<T> {\nprivate final List2D<T> underlyingList;\npublic List2DDiff(SortedMap<ListKey, Object> diffs, List2D<T> list,\nEnum listID) {\nsuper(diffs, listID);\nunderlyingList = list;\n}\nprivate static final long serialVersionUID = 4323585276281406244L;\npublic int sizeD1() {\nreturn super.size();\n}\npublic int sizeD2(int d1) {\nreturn super.size(d1);\n}\npublic T get(int d1, int d2) {\nreturn super.get(d1, d2);\n}\npublic T removeLastD2(int d1) {\nreturn super.removeLast(d1);\n}\npublic int removeLastD1() {\nreturn super.removeLastList();\n}\npublic int addD1() {\nreturn super.addDimension();\n}\npublic int addD2(int d1, T element) {\nreturn super.addElement(element, d1);\n}\npublic void set(int d1, int d2, T element) {\nsuper.set(element, d1, d2);\n}\n@Override\nObject getUnderlyingList() {\nreturn underlyingList;\n}\n@Override\nT uGet(int... i) {\nif (i.length != 2)\nthrow new IllegalArgumentException(String.valueOf(i.length));\nreturn underlyingList.get(i[0], i[1]);\n}\n@Override\nint getUnderlyingSize(int... dim) {\nif(dim.length == 0)\nreturn underlyingList.sizeD1();\nif(dim.length == 1){\nif (underlyingList.sizeD1() <= dim[0])\nreturn -1;\nreturn underlyingList.sizeD2(dim[0]);\n}\nthrow new IllegalArgumentException(String.valueOf(dim.length));\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List2D))\nreturn false;\nreturn Lists.equals(this, (List2D)obj);\n}\n@Override\npublic int hashCode() {\nreturn sizeD1();\n}\n}"}
{"className":"jfreerails.util.List1D","javaDoc":null,"code":"public interface List1D<T> extends Serializable {\nint size();\nT get(int i);\nT removeLast();\nint add(T element);\nvoid set(int i, T element);\n}"}
{"className":"jfreerails.util.Utils","javaDoc":"/**\n* A bunch of static methods.\n*\n* @author Luke\n*\n*/","code":"/**\n* A bunch of static methods.\n*\n* @author Luke\n*\n*/\nstrictfp public class Utils {\npublic static boolean equalsBySerialization(Serializable a, Serializable b) {\nbyte[] bytesA = write2ByteArray(a);\nbyte[] bytesB = write2ByteArray(b);\nif (bytesA.length != bytesB.length)\nreturn false;\nfor (int i = 0; i < bytesA.length; i++) {\nif (bytesA[i] != bytesB[i])\nreturn false;\n}\nreturn true;\n}\n/** Used when debugging. */\npublic static void write(Serializable m, String fileName) {\ntry {\nFile f = new File(fileName);\nOutputStream out = new FileOutputStream(f);\nObjectOutputStream objectOut = new ObjectOutputStream(out);\nobjectOut.writeObject(m);\nobjectOut.flush();\nobjectOut.close();\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\npublic static Serializable cloneBySerialisation(Serializable m) {\ntry {\nbyte[] bytes = write2ByteArray(m);\nByteArrayInputStream in = new ByteArrayInputStream(bytes);\nObjectInputStream objectIn = new ObjectInputStream(in);\nSerializable o;\no = (Serializable) objectIn.readObject();\nreturn o;\n} catch (ClassNotFoundException e) {\n// Should never happen.\nthrow new IllegalStateException();\n} catch (IOException e) {\n// Should never happen.\ne.printStackTrace();\nthrow new IllegalStateException();\n}\n}\nprivate static byte[] write2ByteArray(Serializable m) {\nByteArrayOutputStream out = new ByteArrayOutputStream();\ntry {\nObjectOutputStream objectOut = new ObjectOutputStream(out);\nobjectOut.writeObject(m);\nobjectOut.flush();\n} catch (IOException e) {\n// Should never happen.\ne.printStackTrace();\nthrow new IllegalStateException();\n}\nbyte[] bytes = out.toByteArray();\nreturn bytes;\n}\npublic static String capitalizeEveryWord(String str) {\nStringBuffer result = new StringBuffer();\nStringTokenizer tok = new StringTokenizer(str);\nwhile (tok.hasMoreTokens()) {\nString token = tok.nextToken().toLowerCase();\nresult.append(Character.toUpperCase(token.charAt(0))\n+ token.substring(1) + \" \");\n}\nreturn result.toString().trim();\n}\npublic static String findConstantFieldName(Object o) {\nField[] fields = o.getClass().getFields();\nfor (int i = 0; i < fields.length; i++) {\nint modifiers = fields[i].getModifiers();\ntry {\nif (Modifier.isStatic(modifiers)\n&& Modifier.isPublic(modifiers)) {\nObject o2 = fields[i].get(null);\nif (o2.equals(o)) {\nreturn fields[i].getName();\n}\n}\n} catch (IllegalAccessException e) {\nthrow new IllegalStateException();\n}\n}\nreturn null;\n}\n/**\n* Returns the largest solution of the quadratic equation ax<sup><font\n* size=\"-1\">2</font></sup> + bx + c = 0.\n*\n* @throws IllegalArgumentException\n* if <code>a == 0</code>\n* @throws IllegalArgumentException\n* if <code>(b * b - 4 * a * c) < 0</code>\n*/\npublic static double solveQuadratic(double a, double b, double c)\nthrows IllegalArgumentException {\nif (a == 0) {\nthrow new IllegalArgumentException(\"a == 0\");\n}\ndouble disc = b * b - 4 * a * c;\nif (disc < 0)\nthrow new IllegalArgumentException(\"(b * b - 4 * a * c) < 0\");\nreturn (-b + StrictMath.sqrt(disc)) / (2 * a);\n}\npublic static int hypotenuse(int a, int b) {\ndouble d = Math.hypot(a, b);\nreturn (int) Math.round(d);\n}\n/**\n* Returns true if the objects are equal or both null, otherwise returns\n* false. Does not throw null pointer exceptions when either of the objects\n* is null.\n*/\npublic static boolean equal(Object a, Object b) {\nif (null == a || null == b) {\nreturn null == a && null == b;\n}\nreturn a.equals(b);\n}\n}"}
{"className":"jfreerails.util.CompressedInputStream","javaDoc":"/**\n* A FilterInputStream for reading compressed data from a network connection.\n*\n* @author Patrice Espie Licensing: LGPL\n* @see CompressedOutputStream\n*/","code":"/**\n* A FilterInputStream for reading compressed data from a network connection.\n*\n* @author Patrice Espie Licensing: LGPL\n* @see CompressedOutputStream\n*/\npublic class CompressedInputStream extends FilterInputStream {\npublic CompressedInputStream(InputStream in) {\nsuper(in);\nbuffer = new byte[0x7d000];\ncompBuffer = new byte[(int) (buffer.length * 1.2D)];\nreadIndex = 0;\nmaxReadIndex = 0;\ninflater = new Inflater();\n}\n@Override\npublic boolean markSupported() {\nreturn false;\n}\n@Override\npublic int available() throws IOException {\nif (maxReadIndex - readIndex == 0 && super.in.available() > 0\n&& !readNextBuffer()) {\nreturn -1;\n}\nreturn maxReadIndex - readIndex;\n}\n@Override\npublic int read() throws IOException {\nif (maxReadIndex - readIndex == 0 && !readNextBuffer()) {\nreturn -1;\n}\nbyte b = buffer[readIndex++];\nif (b < 0) {\nreturn 256 + b;\n}\nreturn b;\n}\n@Override\npublic int read(byte[] b) throws IOException {\nreturn read(b, 0, b.length);\n}\n@Override\npublic int read(byte[] b, int off, int len) throws IOException {\nif (maxReadIndex - readIndex == 0 && !readNextBuffer()) {\nreturn -1;\n}\nint read = 0;\nfor (int i = 0; i < len && available() > 0;) {\nb[off + i] = (byte) read();\ni++;\nread++;\n}\nreturn read;\n}\nprivate boolean readNextBuffer() throws IOException {\nbyte compressionFlag = -1;\ncompressionFlag = (byte) super.in.read();\nif (compressionFlag == -1) {\nreturn false;\n}\nmaxReadIndex = super.in.read() & 0xff;\nmaxReadIndex = maxReadIndex << 8 | super.in.read() & 0xff;\nmaxReadIndex = maxReadIndex << 8 | super.in.read() & 0xff;\nmaxReadIndex = maxReadIndex << 8 | super.in.read() & 0xff;\nif (buffer.length < maxReadIndex) {\nbuffer = new byte[maxReadIndex + 40960];\n}\nif (compressionFlag == 1) {\nint compSize = super.in.read() & 0xff;\ncompSize = compSize << 8 | super.in.read() & 0xff;\ncompSize = compSize << 8 | super.in.read() & 0xff;\ncompSize = compSize << 8 | super.in.read() & 0xff;\nif (compBuffer.length < compSize) {\ncompBuffer = new byte[compSize + 40960];\n}\nfor (int read = 0; read < compSize; read += super.in.read(\ncompBuffer, read, compSize - read)) {\n}\ninflater.reset();\ninflater.setInput(compBuffer, 0, compSize);\ntry {\ninflater.inflate(buffer);\n} catch (DataFormatException ex) {\nthrow new IOException(\"Data format exception\");\n}\n} else if (compressionFlag == 0) {\nfor (int read = 0; read < maxReadIndex; read += super.in.read(\nbuffer, read, maxReadIndex - read)) {\n}\n}\nreadIndex = 0;\nreturn true;\n}\nprivate byte[] buffer;\nprivate byte[] compBuffer;\nprivate int readIndex;\nprivate int maxReadIndex;\nprivate Inflater inflater;\n}"}
{"className":"jfreerails.util.FreerailsProgressMonitor","javaDoc":"/**\n* This interface defines callbacks that can be used to let the user know how a\n* slow task is progressing.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This interface defines callbacks that can be used to let the user know how a\n* slow task is progressing.\n*\n* @author Luke Lindsay\n*/\npublic interface FreerailsProgressMonitor {\npublic static final FreerailsProgressMonitor NULL_INSTANCE = new FreerailsProgressMonitor() {\npublic void setValue(int i) {\n}\npublic void nextStep(int max) {\n}\npublic void finished() {\n}\n};\nvoid setValue(int i);\nvoid nextStep(int max);\nvoid finished();\n}"}
{"className":"jfreerails.util.ListXDDiffs","javaDoc":null,"code":"public abstract class ListXDDiffs<T> implements Serializable {\nprivate static final long serialVersionUID = 127789045793369316L;\nstatic int[] add2Array(int[] dim, int last) {\nint[] array = new int[dim.length + 1];\nfor (int i = 0; i < dim.length; i++) {\narray[i] = dim[i];\n}\narray[array.length - 1] = last;\nreturn array;\n}\nstatic int[] removeFromArray(int[] dim) {\nint[] array = new int[dim.length - 1];\nfor (int i = 0; i < dim.length - 1; i++) {\narray[i] = dim[i];\n}\nreturn array;\n}\nprivate final SortedMap<ListKey, Object> diffs;\nprivate final Enum listID;\npublic ListXDDiffs(SortedMap<ListKey, Object> diffs, Enum listID) {\nthis.diffs = diffs;\nthis.listID = listID;\n}\npublic int addDimension(int... dim) {\nint i = size(dim);\nListKey sizeKeyA = new ListKey(ListKey.Type.EndPoint, listID, dim);\nint[] subArray = add2Array(dim, i);\nListKey sizeKeyB = new ListKey(ListKey.Type.EndPoint, listID, subArray);\ndiffs.put(sizeKeyA, new Integer(i + 1));\ndiffs.put(sizeKeyB, new Integer(0));\nreturn i;\n}\npublic int addElement(T element, int... dim) {\nint sizeBefore = size(dim);\nint[] index = add2Array(dim, sizeBefore);\nsetElementDiff: {\nif (getUnderlyingSize(dim) > sizeBefore) {\nT uElement = uGet(index);\nif (Utils.equal(uElement, element)) {\n// We are reading an element that was removed, in which\n// case we don't store a diff.\nbreak setElementDiff;\n}\n}\nListKey elementKey = new ListKey(ListKey.Type.Element, listID,\nindex);\ndiffs.put(elementKey, element);\n}\nsetSize(sizeBefore + 1, dim);\nreturn sizeBefore;\n}\n@SuppressWarnings(\"unchecked\")\npublic T get(int... i) {\ncheckBounds(i);\nListKey elementKey = new ListKey(ListKey.Type.Element, listID, i);\nif (diffs.containsKey(elementKey)) {\nreturn (T) diffs.get(elementKey);\n}\nreturn uGet(i);\n}\nabstract Object getUnderlyingList();\n/**\n* Returns the size of the underlying list at the specified dimension or -1\n* if the underlying list does not have the specified dimension.\n*/\nabstract int getUnderlyingSize(int... dim);\n@SuppressWarnings(\"unchecked\")\npublic T removeLast(int... dim) {\nT toRemove;\nint last = size(dim) - 1;\nint[] array = add2Array(dim, last);\nListKey elementKey = new ListKey(ListKey.Type.Element, listID, array);\nif (diffs.containsKey(elementKey)) {\ntoRemove = (T) diffs.remove(elementKey);\n} else {\ntoRemove = uGet(array);\n}\nsetSize(last, dim);\nreturn toRemove;\n}\nint removeLastList(int... dim) {\nint last = size(dim) - 1;\n// Check that the list we are removing is empty.\nint[] array = add2Array(dim, last);\nif (0 != size(array))\nthrow new IllegalStateException();\nListKey sizeKeyB = new ListKey(ListKey.Type.EndPoint, listID, array);\ndiffs.remove(sizeKeyB);\nsetSize(last, dim);\nreturn last;\n}\npublic void set(T element, int... i) {\n// Check bounds..\ncheckBounds(i);\nint last = i[i.length - 1];\nint[] dim = checkBounds(i);\nListKey elementKey = new ListKey(ListKey.Type.Element, listID, i);\nboolean b = getUnderlyingSize(dim) > last;\nif (b && Utils.equal(uGet(i), element)) {\nif (diffs.containsKey(elementKey))\ndiffs.remove(elementKey);\n} else {\ndiffs.put(elementKey, element);\n}\n}\nprivate int[] checkBounds(int... i) {\nint[] dim = removeFromArray(i);\nint last = i[i.length - 1];\nif (last >= size(dim))\nthrow new IndexOutOfBoundsException(String.valueOf(last));\nreturn dim;\n}\nprivate void setSize(int size, int... dim) {\nListKey sizeKey = new ListKey(ListKey.Type.EndPoint, listID, dim);\nif (getUnderlyingSize(dim) == size) {\ndiffs.remove(sizeKey);\n} else {\ndiffs.put(sizeKey, new Integer(size));\n}\n}\npublic int size(int... i) {\nListKey sizeKey = new ListKey(ListKey.Type.EndPoint, listID, i);\nif (diffs.containsKey(sizeKey)) {\nInteger size = (Integer) diffs.get(sizeKey);\nreturn size.intValue();\n}\nreturn getUnderlyingSize(i);\n}\nabstract T uGet(int... i);\n// abstract int uSize(int... i);\n}"}
{"className":"jfreerails.util.List3DImpl","javaDoc":null,"code":"public class List3DImpl<T> implements List3D<T> {\nprivate static final long serialVersionUID = 1353309875727204066L;\nprivate ArrayList<ArrayList<ArrayList<T>>> elementData= new ArrayList<ArrayList<ArrayList<T>>>();\npublic List3DImpl(int d1, int d2){\nfor (int i = 0; i < d1; i++) {\nArrayList<ArrayList<T>> dim2 = new ArrayList<ArrayList<T>>();\nelementData.add(dim2);\nfor (int j = 0; j < d2; j++) {\ndim2.add(new ArrayList<T>() );\n}\n}\n}\npublic int sizeD1() {\nreturn elementData.size();\n}\npublic int sizeD2(int d1) {\nreturn elementData.get(d1).size();\n}\npublic int sizeD3(int d1, int d2) {\nreturn elementData.get(d1).get(d2).size();\n}\npublic T get(int d1, int d2, int d3) {\nreturn elementData.get(d1).get(d2).get(d3);\n}\npublic T removeLastD3(int d1, int d2) {\nArrayList<T> dim3 = elementData.get(d1).get(d2);\nint last = dim3.size()-1;\nT element = dim3.get(last);\ndim3.remove(last);\nreturn element;\n}\npublic void removeLastD1() {\nint last = elementData.size()-1;\nif(elementData.get(last).size() > 0)\nthrow new IllegalStateException(String.valueOf(last));\nelementData.remove(last);\n}\npublic void removeLastD2(int d1) {\nArrayList<ArrayList<T>> dim2 = elementData.get(d1);\nint last = dim2.size()-1;\nArrayList<T> dim3 = dim2.get(last);\nif(dim3.size() > 0)\nthrow new IllegalStateException(String.valueOf(d1));\ndim2.remove(last);\n}\npublic int addD1() {\nArrayList<ArrayList<T>> dim2 = new ArrayList<ArrayList<T>>();\nelementData.add(dim2);\nreturn elementData.size() -1;\n}\npublic int addD2(int d1) {\nArrayList<ArrayList<T>> dim2 = elementData.get(d1);\ndim2.add(new ArrayList<T>() );\nreturn dim2.size()-1;\n}\npublic int addD3(int d1, int d2, T element) {\nArrayList<T> dim3 = elementData.get(d1).get(d2);\ndim3.add(element);\nreturn dim3.size()-1;\n}\npublic void set(int d1, int d2, int d3, T element) {\nArrayList<T> dim3 = elementData.get(d1).get(d2);\ndim3.set(d3, element);\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List3D))\nreturn false;\nreturn Lists.equals(this, (List3D)obj);\n}\n@Override\npublic int hashCode() {\nreturn sizeD1();\n}\npublic List<T> get(int d1, int d2) {\nreturn elementData.get(d1).get(d2);\n}\n}"}
{"className":"jfreerails.util.LRUCache","javaDoc":"/**\n* An LRU cache, based on <code>LinkedHashMap</code>.<br>\n* This cache has a fixed maximum number of elements (<code>cacheSize</code>).\n* If the cache is full and another entry is added, the LRU (least recently\n* used) entry is dropped.\n* <p>\n* This class is thread-safe. All methods of this class are synchronized.<br>\n* Author: Christian d'Heureuse (<a\n* href=\"http://www.source-code.biz\">www.source-code.biz</a>)<br>\n* License: <a href=\"http://www.gnu.org/licenses/lgpl.html\">LGPL</a>.\n*/","code":"/**\n* An LRU cache, based on <code>LinkedHashMap</code>.<br>\n* This cache has a fixed maximum number of elements (<code>cacheSize</code>).\n* If the cache is full and another entry is added, the LRU (least recently\n* used) entry is dropped.\n* <p>\n* This class is thread-safe. All methods of this class are synchronized.<br>\n* Author: Christian d'Heureuse (<a\n* href=\"http://www.source-code.biz\">www.source-code.biz</a>)<br>\n* License: <a href=\"http://www.gnu.org/licenses/lgpl.html\">LGPL</a>.\n*/\npublic class LRUCache<K, V> {\nprivate static final float hashTableLoadFactor = 0.75f;\nprivate LinkedHashMap<K, V> map;\nprivate int cacheSize;\n/**\n* Creates a new LRU cache.\n*\n* @param cacheSize\n* the maximum number of entries that will be kept in this cache.\n*/\npublic LRUCache(int cacheSize) {\nthis.cacheSize = cacheSize;\nint hashTableCapacity = (int) Math\n.ceil(cacheSize / hashTableLoadFactor) + 1;\nmap = new LinkedHashMap<K, V>(hashTableCapacity, hashTableLoadFactor,\ntrue) {\n// (an anonymous inner class)\nprivate static final long serialVersionUID = 1;\n@Override\nprotected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\nreturn size() > LRUCache.this.cacheSize;\n}\n};\n}\n/**\n* Retrieves an entry from the cache.<br>\n* The retrieved entry becomes the MRU (most recently used) entry.\n*\n* @param key\n* the key whose associated value is to be returned.\n* @return the value associated to this key, or null if no value with this\n* key exists in the cache.\n*/\npublic synchronized V get(K key) {\nreturn map.get(key);\n}\n/**\n* Adds an entry to this cache. If the cache is full, the LRU (least\n* recently used) entry is dropped.\n*\n* @param key\n* the key with which the specified value is to be associated.\n* @param value\n* a value to be associated with the specified key.\n*/\npublic synchronized void put(K key, V value) {\nmap.put(key, value);\n}\n/**\n* Clears the cache.\n*/\npublic synchronized void clear() {\nmap.clear();\n}\n/**\n* Returns the number of used entries in the cache.\n*\n* @return the number of entries currently in the cache.\n*/\npublic synchronized int usedEntries() {\nreturn map.size();\n}\n/**\n* Returns a <code>Collection</code> that contains a copy of all cache\n* entries.\n*\n* @return a <code>Collection</code> with a copy of the cache content.\n*/\npublic synchronized Collection<Map.Entry<K, V>> getAll() {\nreturn new ArrayList<Map.Entry<K, V>>(map.entrySet());\n}\n} // end class LRUCache"}
{"className":"jfreerails.util.FlowRateInputStream","javaDoc":"/**\n* A FilterInputStream that measures flow rate.\n*\n* @author Patrice Espie Licensing: LGPL\n*/","code":"/**\n* A FilterInputStream that measures flow rate.\n*\n* @author Patrice Espie Licensing: LGPL\n*/\npublic class FlowRateInputStream extends FilterInputStream implements Runnable {\nprivate static final Logger logger = Logger\n.getLogger(FlowRateInputStream.class.getName());\npublic FlowRateInputStream(InputStream in, String streamName) {\nthis(in, streamName, 60, 1000);\n}\npublic FlowRateInputStream(InputStream in, String streamName,\nint measureDuration, int measureInterval) {\nsuper(in);\nbyteReceivedCumul = 0L;\ntotalByteReceived = 0L;\npreviousTotalByteReceived = 0L;\nopenTimeMillis = System.currentTimeMillis();\nnextFree = 0;\nnbUsed = 0;\nrunning = false;\ncloseRequested = false;\nbyteReceived = new long[measureDuration];\nthis.measureInterval = measureInterval;\nthis.streamName = streamName;\nif (this.measureInterval == 0) {\nshowTrace = false;\nthis.measureInterval = 1000L;\n} else {\nshowTrace = true;\n}\n(new Thread(this)).start();\n}\npublic FlowRateInputStream(InputStream in) {\nthis(in, \"FlowRateInputStream\", 60, 1000);\n}\n@Override\npublic void close() throws IOException {\ncloseRequested = true;\nsuper.close();\ndo {\ntry {\nThread.currentThread();\nThread.sleep(50L);\n} catch (InterruptedException interruptedexception) {\n}\n} while (running);\nlogger.info(String.valueOf(String.valueOf((new StringBuffer(\"Stream \"))\n.append(streamName).append(\": Open duration = \").append(\n(System.currentTimeMillis() - openTimeMillis) / 1000D)\n.append(\", Byte received = \").append(totalByteReceived).append(\n\" (\").append((int) (totalByteReceived / 1024D)).append(\n\" Ko), overall flow rate = \").append(overallRate())\n.append(\" Ko/s\"))));\n}\n@Override\npublic int read() throws IOException {\nint r = super.in.read();\ntotalByteReceived += r;\nreturn r;\n}\n@Override\npublic int read(byte[] b) throws IOException {\nint r = super.in.read(b);\ntotalByteReceived += r;\nreturn r;\n}\n@Override\npublic int read(byte[] b, int off, int len) throws IOException {\nint r = super.in.read(b, off, len);\ntotalByteReceived += r;\nreturn r;\n}\npublic int currentRate() {\nreturn (int) (byteReceivedCumul / 1024D / (nbUsed * (measureInterval / 1000D)));\n}\npublic String currentRateString() {\ndouble d = (byteReceivedCumul / 1024D / (nbUsed * (measureInterval / 1000D)));\nreturn decimalFormat.format(d);\n}\npublic int overallRate() {\nreturn (int) (totalByteReceived / 1024D / ((System.currentTimeMillis() - openTimeMillis) / 1000D));\n}\npublic void run() {\nif (running || measureInterval == 0x7fffffffffffffffL) {\nreturn;\n}\nrunning = true;\ntry {\ndo {\ntry {\nThread.currentThread();\nThread.sleep(measureInterval);\n} catch (InterruptedException interruptedexception) {\n}\nif (!closeRequested) {\nlong totalByteReceivedCopy = totalByteReceived;\nlong byteSentThisTime = totalByteReceivedCopy\n- previousTotalByteReceived;\npreviousTotalByteReceived = totalByteReceivedCopy;\nbyteReceivedCumul -= byteReceived[nextFree];\nbyteReceived[nextFree] = byteSentThisTime;\nbyteReceivedCumul += byteSentThisTime;\nnextFree = (nextFree + 1) % byteReceived.length;\nnbUsed = Math.min(byteReceived.length, nbUsed + 1);\nif (showTrace) {\nlogger\n.info(String\n.valueOf(String\n.valueOf((new StringBuffer(\n\"Stream \"))\n.append(streamName)\n.append(\n\": Open duration = \")\n.append(\n(System\n.currentTimeMillis() - openTimeMillis) / 1000D)\n.append(\n\", Byte sent = \")\n.append(\ntotalByteReceived)\n.append(\" (\")\n.append(\n(int) (totalByteReceived / 1024D))\n.append(\n\" Ko), current flow rate = \")\n.append(\ncurrentRateString())\n.append(\" Ko/s\"))));\n}\n}\n} while (!closeRequested);\n} finally {\nrunning = false;\n}\n}\nprivate long[] byteReceived;\nprivate long byteReceivedCumul;\nprivate long totalByteReceived;\nprivate long previousTotalByteReceived;\nprivate long openTimeMillis;\nprivate long measureInterval;\nprivate int nextFree;\nprivate int nbUsed;\nprivate boolean running;\nprivate boolean closeRequested;\nprivate String streamName;\nprivate boolean showTrace;\nprivate DecimalFormat decimalFormat = new DecimalFormat(\"0.00\");\n}"}
{"className":"jfreerails.util.GrowableBase","javaDoc":"/**\n* Base class for various types of collections based on type-specific growable\n* arrays. The underlying array used for storage of items doubles in size each\n* time more space is required, up to an optional maximum growth increment\n* specified by the user.\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/","code":"/**\n* Base class for various types of collections based on type-specific growable\n* arrays. The underlying array used for storage of items doubles in size each\n* time more space is required, up to an optional maximum growth increment\n* specified by the user.\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/\npublic abstract class GrowableBase implements Serializable {\n/** Default initial array size. */\npublic static final int DEFAULT_SIZE = 8;\n/** Size of the current array. */\nprotected int countLimit;\n/** Maximum size increment for growing array. */\nprotected int maximumGrowth;\n/**\n* Constructor with full specification.\n*\n* @param size\n* number of elements in initial array\n* @param growth\n* maximum size increment for growing array\n* @param type\n* array element type\n*/\npublic GrowableBase(int size, int growth, Class type) {\nObject array = Array.newInstance(type, size);\ncountLimit = size;\nmaximumGrowth = growth;\nsetArray(array);\n}\n/**\n* Constructor with partial specification.\n*\n* @param size\n* number of elements initially allowed in array\n* @param type\n* array element type\n*/\npublic GrowableBase(int size, Class type) {\nthis(size, Integer.MAX_VALUE, type);\n}\n/**\n* Copy (clone) constructor.\n*\n* @param base\n* instance being copied\n*/\npublic GrowableBase(GrowableBase base) {\nthis(base.countLimit, base.maximumGrowth, base.getArray().getClass()\n.getComponentType());\n}\n/**\n* Get the backing array. This method is used by the type-agnostic base\n* class code to access the array used for type-specific storage by the\n* child class.\n*\n* @return backing array object\n*/\nprotected abstract Object getArray();\n/**\n* Set the backing array. This method is used by the type-agnostic base\n* class code to set the array used for type-specific storage by the child\n* class.\n*\n*/\nprotected abstract void setArray(Object array);\n/**\n* Copy data after array resize. This default implementation just copies the\n* entire contents of the old array to the start of the new array. It should\n* be overridden in cases where data needs to be rearranged in the array\n* after a resize.\n*\n* @param base\n* original array containing data\n* @param grown\n* resized array for data\n*/\nprotected void resizeCopy(Object base, Object grown) {\nSystem.arraycopy(base, 0, grown, 0, Array.getLength(base));\n}\n/**\n* Discards values for a range of indices in the array. Checks if the values\n* stored in the array are object references, and if so clears them. If the\n* values are primitives, this method does nothing.\n*\n* @param from\n* index of first value to be discarded\n* @param to\n* index past last value to be discarded\n*/\nprotected void discardValues(int from, int to) {\nObject values = getArray();\nif (!values.getClass().getComponentType().isPrimitive()) {\nObject[] objects = (Object[]) values;\nfor (int i = from; i < to; i++) {\nobjects[i] = null;\n}\n}\n}\n/**\n* Increase the size of the array to at least a specified size. The array\n* will normally be at least doubled in size, but if a maximum size\n* increment was specified in the constructor and the value is less than the\n* current size of the array, the maximum increment will be used instead. If\n* the requested size requires more than the default growth, the requested\n* size overrides the normal growth and determines the size of the\n* replacement array.\n*\n* @param required\n* new minimum size required\n*/\nprotected void growArray(int required) {\nObject base = getArray();\nint size = Math.max(required, countLimit\n+ Math.min(countLimit, maximumGrowth));\nClass type = base.getClass().getComponentType();\nObject grown = Array.newInstance(type, size);\nresizeCopy(base, grown);\ncountLimit = size;\nsetArray(grown);\n}\n/**\n* Ensure that the array has the capacity for at least the specified number\n* of values.\n*\n* @param min\n* minimum capacity to be guaranteed\n*/\npublic final void ensureCapacity(int min) {\nif (min > countLimit) {\ngrowArray(min);\n}\n}\n/**\n* Constructs and returns a simple array containing the same data as held in\n* a portion of this growable array.\n*\n* @param type\n* element type for constructed array\n* @param offset\n* start offset in array\n* @param length\n* number of characters to use\n* @return array containing a copy of the data\n*/\nprotected Object buildArray(Class type, int offset, int length) {\nObject copy = Array.newInstance(type, length);\nSystem.arraycopy(getArray(), offset, copy, 0, length);\nreturn copy;\n}\n}"}
{"className":"jfreerails.util.Lists","javaDoc":null,"code":"public class Lists {\n@SuppressWarnings(\"unchecked\")\npublic static boolean equals(List1D a, List1D b) {\nif (a.size() != b.size())\nreturn false;\nfor (int i = 0; i < a.size(); i++) {\nif (!Utils.equal(a.get(i), b.get(i)))\nreturn false;\n}\nreturn true;\n}\n@SuppressWarnings(\"unchecked\")\npublic static boolean equals(List2D a, List2D b) {\nif (a.sizeD1() != b.sizeD1())\nreturn false;\nfor (int d1 = 0; d1 < a.sizeD1(); d1++) {\nif (a.sizeD2(d1) != b.sizeD2(d1))\nreturn false;\nfor (int d2 = 0; d2 < a.sizeD2(d1); d2++) {\nif (!Utils.equal(a.get(d1, d2), b.get(d1, d2)))\nreturn false;\n}\n}\nreturn true;\n}\n@SuppressWarnings(\"unchecked\")\npublic static boolean equals(List3D a, List3D b) {\nif (a.sizeD1() != b.sizeD1())\nreturn false;\nfor (int d1 = 0; d1 < a.sizeD1(); d1++) {\nif (a.sizeD2(d1) != b.sizeD2(d1))\nreturn false;\nfor (int d2 = 0; d2 < a.sizeD2(d1); d2++) {\nif (a.sizeD3(d1, d2) != b.sizeD3(d1, d2))\nreturn false;\nfor (int d3 = 0; d3 < a.sizeD3(d1, d2); d3++) {\nif (!Utils.equal(a.get(d1, d2, d3), b.get(d1, d2, d3)))\nreturn false;\n}\n}\n}\nreturn true;\n}\n}"}
{"className":"jfreerails.util.Pair","javaDoc":null,"code":"public class Pair<A, B> {\nprivate A e1;\nprivate B e2;\npublic Pair(A e1, B e2) {\nthis.e1 = e1;\nthis.e2 = e2;\n}\npublic boolean equals(Pair<A, B> other) {\nif (this == other)\nreturn true;\nif (null == other)\nreturn false;\nreturn (e1.equals(other.e1) && e2.equals(other.e2));\n}\npublic String toString() {\nreturn \"(\" + e1.toString() + \", \" + e2.toString() + \")\";\n}\npublic A getA() {\nreturn e1;\n}\npublic B getB() {\nreturn e2;\n}\n}"}
{"className":"jfreerails.util.Immutable","javaDoc":"/**\n* @author Luke 04-Jul-2005\n*/","code":"/**\n* @author Luke 04-Jul-2005\n*/\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Immutable {\n}"}
{"className":"jfreerails.util.GameModel","javaDoc":"/**\n* Defines a standard method to update the game world.\n*\n* @author Luke\n*\n*/","code":"/**\n* Defines a standard method to update the game world.\n*\n* @author Luke\n*\n*/\npublic interface GameModel {\nvoid update();\n}"}
{"className":"jfreerails.util.List1DImpl","javaDoc":null,"code":"public class List1DImpl<T> implements List1D<T> {\nprivate static final long serialVersionUID = 8285123045287237133L;\nprivate final ArrayList<T> elementData;\npublic List1DImpl() {\nelementData = new ArrayList<T>();\n}\npublic List1DImpl(int initialSize) {\nelementData = new ArrayList<T>();\nfor (int i = 0; i < initialSize; i++) {\nelementData.add(null);\n}\n}\npublic int size() {\nreturn elementData.size();\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List1D))\nreturn false;\nreturn Lists.equals(this, (List1D) obj);\n}\n@Override\npublic int hashCode() {\nreturn size();\n}\npublic T get(int i) {\nreturn elementData.get(i);\n}\npublic T removeLast() {\nint last = elementData.size() - 1;\nreturn elementData.remove(last);\n}\npublic int add(T element) {\nelementData.add(element);\nreturn elementData.size() - 1;\n}\npublic void set(int i, T element) {\nelementData.set(i, element);\n}\n}"}
{"className":"jfreerails.util.FlowRateOutputStream","javaDoc":"/**\n* A FilterOutputStream that measures flow rate.\n*\n* @author Patrice Espie Licensing: LGPL\n*/","code":"/**\n* A FilterOutputStream that measures flow rate.\n*\n* @author Patrice Espie Licensing: LGPL\n*/\npublic class FlowRateOutputStream extends FilterOutputStream implements\nRunnable {\nprivate static final Logger logger = Logger\n.getLogger(FlowRateOutputStream.class.getName());\npublic FlowRateOutputStream(OutputStream out, String streamName) {\nthis(out, streamName, 60, 1000);\n}\npublic FlowRateOutputStream(OutputStream out, String streamName,\nint measureDuration, int measureInterval) {\nsuper(out);\nbyteSentCumul = 0L;\ntotalByteSent = 0L;\npreviousTotalByteSent = 0L;\nopenTimeMillis = System.currentTimeMillis();\nnextFree = 0;\nnbUsed = 0;\nrunning = false;\ncloseRequested = false;\nbyteSent = new long[measureDuration];\nthis.measureInterval = measureInterval;\nthis.streamName = streamName;\nif (this.measureInterval == 0) {\nshowTrace = false;\nthis.measureInterval = 1000L;\n} else {\nshowTrace = true;\n}\n(new Thread(this)).start();\n}\npublic FlowRateOutputStream(OutputStream out) {\nthis(out, \"FlowRateOutputStream\", 60, 1000);\n}\n@Override\npublic void close() throws IOException {\ncloseRequested = true;\nsuper.close();\ndo {\ntry {\nThread.currentThread();\nThread.sleep(50L);\n} catch (InterruptedException interruptedexception) {\n}\n} while (running);\nlogger.info(String.valueOf(String.valueOf((new StringBuffer(\"Stream \"))\n.append(streamName).append(\": Open duration = \").append(\n(System.currentTimeMillis() - openTimeMillis) / 1000D)\n.append(\", Byte sent = \").append(totalByteSent).append(\" (\")\n.append((int) (totalByteSent / 1024D)).append(\n\" Ko), overall flow rate = \").append(\noverallRateString()).append(\" Ko/s\"))));\n}\n@Override\npublic void write(byte[] b) throws IOException {\nsuper.out.write(b, 0, b.length);\ntotalByteSent += b.length;\n}\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\nsuper.out.write(b, off, len);\ntotalByteSent += len;\n}\n@Override\npublic void write(int b) throws IOException {\nsuper.out.write(b);\ntotalByteSent++;\n}\npublic int currentRate() throws IOException {\nreturn (int) (byteSentCumul / 1024D / (nbUsed * (measureInterval / 1000D)));\n}\npublic int overallRate() throws IOException {\nreturn (int) (totalByteSent / 1024D / ((System.currentTimeMillis() - openTimeMillis) / 1000D));\n}\npublic String overallRateString() throws IOException {\ndouble d = totalByteSent / 1024D\n/ ((System.currentTimeMillis() - openTimeMillis) / 1000D);\nreturn decimalFormat.format(d);\n}\npublic String currentRateString() {\ndouble d = (byteSentCumul / 1024D / (nbUsed * (measureInterval / 1000D)));\nreturn decimalFormat.format(d);\n}\npublic void run() {\nif (running) {\nthrow new Error(\"Starting thread task on an already-started object\");\n}\nif (measureInterval == 0x7fffffffffffffffL) {\nreturn;\n}\nrunning = true;\ntry {\ndo {\ntry {\nThread.currentThread();\nThread.sleep(measureInterval);\n} catch (InterruptedException interruptedexception) {\n}\nif (!closeRequested) {\nlong totalByteSentCopy = totalByteSent;\nlong byteSentThisTime = totalByteSentCopy\n- previousTotalByteSent;\npreviousTotalByteSent = totalByteSentCopy;\nbyteSentCumul -= byteSent[nextFree];\nbyteSent[nextFree] = byteSentThisTime;\nbyteSentCumul += byteSentThisTime;\nnextFree = (nextFree + 1) % byteSent.length;\nnbUsed = Math.min(byteSent.length, nbUsed + 1);\nif (showTrace) {\nlogger\n.info(String\n.valueOf(String\n.valueOf((new StringBuffer(\n\"Stream \"))\n.append(streamName)\n.append(\n\": Open duration = \")\n.append(\n(System\n.currentTimeMillis() - openTimeMillis) / 1000D)\n.append(\n\", Byte sent = \")\n.append(totalByteSent)\n.append(\" (\")\n.append(\n(int) (totalByteSent / 1024D))\n.append(\n\" Ko), current flow rate = \")\n.append(\ncurrentRateString())\n.append(\" Ko/s\"))));\n}\n}\n} while (!closeRequested);\n// } catch (IOException ioexception) {\n} finally {\nrunning = false;\n}\n}\nprivate long[] byteSent;\nprivate long byteSentCumul;\nprivate long totalByteSent;\nprivate long previousTotalByteSent;\nprivate long openTimeMillis;\nprivate long measureInterval;\nprivate int nextFree;\nprivate int nbUsed;\nprivate boolean running;\nprivate boolean closeRequested;\nprivate String streamName;\nprivate boolean showTrace;\nprivate DecimalFormat decimalFormat = new DecimalFormat(\"0.00\");\n}"}
{"className":"jfreerails.util.List2D","javaDoc":null,"code":"public interface List2D<T> extends Serializable {\nint sizeD1();\nint sizeD2(int d1);\nT get(int d1, int d2);\nT removeLastD2(int d1);\nint removeLastD1();\nint addD1();\nint addD2(int d1, T element);\nvoid set(int d1, int d2, T element);\n}"}
{"className":"jfreerails.util.CompressedOutputStream","javaDoc":"/**\n* A FilterOutputStream for sending compressed data over a network connection.\n* Note that standard ZipOutputStream and java.util.zip.GZipOutputStream don't\n* guarantee that flush sends out all the data written so far, which leads to\n* deadlocks in request-response-based protocols.\n*\n* @author Patrice Espie Licensing: LGPL\n*/","code":"/**\n* A FilterOutputStream for sending compressed data over a network connection.\n* Note that standard ZipOutputStream and java.util.zip.GZipOutputStream don't\n* guarantee that flush sends out all the data written so far, which leads to\n* deadlocks in request-response-based protocols.\n*\n* @author Patrice Espie Licensing: LGPL\n*/\npublic class CompressedOutputStream extends FilterOutputStream {\npublic CompressedOutputStream(OutputStream out) {\nsuper(out);\nbuffer = new byte[0x7d000];\ncompBuffer = new byte[(int) (buffer.length * 1.2D)];\nwriteIndex = 0;\ndeflater = new Deflater(9);\n}\n@Override\npublic void write(byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\nint written = 0;\ndo {\nif (written >= len) {\nbreak;\n}\nint toWrite = Math.min(len - written, buffer.length - writeIndex);\nSystem.arraycopy(b, off + written, buffer, writeIndex, toWrite);\nwritten += toWrite;\nwriteIndex += toWrite;\nif (writeIndex >= buffer.length * 0.80000000000000004D) {\nflush();\n}\n} while (true);\n}\n@Override\npublic void write(int b) throws IOException {\nif (writeIndex >= buffer.length * 0.80000000000000004D) {\nflush();\n}\nbuffer[writeIndex++] = (byte) b;\n}\n@Override\npublic void flush() throws IOException {\nint compSize = 0;\nboolean sendCompressed;\nif (writeIndex > 150) {\ndeflater.reset();\ndeflater.setInput(buffer, 0, writeIndex);\ndeflater.finish();\nif (compBuffer.length < writeIndex * 2 + 40960) {\ncompBuffer = new byte[writeIndex * 2 + 40960];\n}\ncompSize = deflater.deflate(compBuffer);\nif (compSize <= 0) {\nthrow new IOException(\"Compression exception\");\n}\nsendCompressed = compSize < writeIndex;\n} else {\nsendCompressed = false;\n}\nif (sendCompressed) {\nsuper.out.write(1);\nsuper.out.write(writeIndex >> 24 & 0xff);\nsuper.out.write(writeIndex >> 16 & 0xff);\nsuper.out.write(writeIndex >> 8 & 0xff);\nsuper.out.write(writeIndex & 0xff);\nsuper.out.write(compSize >> 24 & 0xff);\nsuper.out.write(compSize >> 16 & 0xff);\nsuper.out.write(compSize >> 8 & 0xff);\nsuper.out.write(compSize & 0xff);\nsuper.out.write(compBuffer, 0, compSize);\nsuper.out.flush();\nwriteIndex = 0;\n} else if (writeIndex > 0) {\nsuper.out.write(0);\nsuper.out.write(writeIndex >> 24 & 0xff);\nsuper.out.write(writeIndex >> 16 & 0xff);\nsuper.out.write(writeIndex >> 8 & 0xff);\nsuper.out.write(writeIndex & 0xff);\nsuper.out.write(buffer, 0, writeIndex);\nsuper.out.flush();\nwriteIndex = 0;\n}\n}\nprivate byte[] buffer;\nprivate byte[] compBuffer;\nprivate int writeIndex;\nprivate Deflater deflater;\n}"}
{"className":"jfreerails.util.InstanceControlled","javaDoc":"/**\n* @author Luke 04-Jul-2005\n*/","code":"/**\n* @author Luke 04-Jul-2005\n*/\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface InstanceControlled {\n}"}
{"className":"jfreerails.util.List2DImpl","javaDoc":null,"code":"public class List2DImpl<T> implements List2D<T> {\nprivate static final long serialVersionUID = 7614246212629595959L;\nprivate final ArrayList<ArrayList<T>> elementData = new ArrayList<ArrayList<T>>();\npublic List2DImpl(int d1){\nfor(int i = 0; i < d1; i++){\nelementData.add(new ArrayList<T>());\n}\n}\npublic int sizeD1() {\nreturn elementData.size();\n}\npublic int sizeD2(int d1) {\nreturn elementData.get(d1).size();\n}\npublic T get(int d1, int d2) {\nreturn elementData.get(d1).get(d2);\n}\npublic T removeLastD2(int d1) {\nint last = elementData.get(d1).size() -1;\nT element = elementData.get(d1).get(last);\nelementData.get(d1).remove(last);\nreturn element;\n}\npublic int removeLastD1() {\nint last = elementData.size() -1;\nif(sizeD2(last) != 0)\nthrow new IllegalStateException(String.valueOf(last));\nelementData.remove(last);\nreturn last;\n}\npublic int addD1() {\nelementData.add(new ArrayList<T>());\nreturn elementData.size() -1;\n}\npublic int addD2(int d1, T element) {\nArrayList<T> d2 = elementData.get(d1);\nint index = d2.size();\nd2.add(element);\nreturn index;\n}\npublic void set(int d1, int d2, T element) {\nelementData.get(d1).set(d2, element);\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List2D)) {\nreturn false;\n}\nreturn Lists.equals(this, (List2D)obj);\n}\n@Override\npublic int hashCode() {\nreturn sizeD1();\n}\n}"}
{"className":"jfreerails.util.ListKey","javaDoc":null,"code":"public class ListKey implements Comparable<ListKey>, Serializable{\nprivate static final long serialVersionUID = -4939641035786937927L;\npublic enum Type {\nElement, EndPoint\n}\nprivate final Type type;\nprivate final int[] index;\nprivate final Enum listID;\npublic ListKey(Type t, Enum listID, int... i){\ntype = t;\nindex = i.clone();\nthis.listID = listID;\n}\npublic int[] getIndex() {\nreturn index.clone();\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ListKey))\nreturn false;\nfinal ListKey listKey = (ListKey) o;\nif (!Arrays.equals(index, listKey.index))\nreturn false;\nif (!listID.equals(listKey.listID))\nreturn false;\nif (!type.equals(listKey.type))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = type.hashCode();\nresult = 29 * result + listID.hashCode();\nreturn result;\n}\npublic Type getType() {\nreturn type;\n}\npublic int compareTo(ListKey o) {\nif(o.listID != listID)\nreturn o.listID.ordinal() - listID.ordinal();\nif(index.length != o.index.length)\nreturn index.length -o.index.length;\nfor (int i = 0; i < index.length; i++) {\nif(index[i] != o.index[i])\nreturn index[i] -o.index[i];\n}\nif(o.type != type)\nreturn o.type.ordinal() - type.ordinal();\nreturn 0;\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(listID);\nsb.append(\" \");\nsb.append(type);\nsb.append(\" index \");\nfor (int i = 0; i < index.length; i++) {\nsb.append(\"[\");\nsb.append(index[i]);\nsb.append(\"]\");\n}\nreturn sb.toString();\n}\npublic Enum getListID() {\nreturn listID;\n}\n}"}
{"className":"jfreerails.util.List1DDiff","javaDoc":null,"code":"public class List1DDiff<T> extends ListXDDiffs<T> implements List1D<T> {\nprivate static final long serialVersionUID = -6058018396890452219L;\nprivate final List1D<T> underlyingList;\npublic List1DDiff(SortedMap<ListKey, Object> diffs, List1D<T> list,\nEnum listID) {\nsuper(diffs, listID);\nunderlyingList = list;\n}\npublic T get(int i) {\nreturn get(new int[] { i });\n}\n@Override\nObject getUnderlyingList() {\nreturn underlyingList;\n}\npublic int size() {\nreturn super.size(new int[0]);\n}\n@Override\nT uGet(int... i) {\nif (i.length != 1)\nthrow new IllegalArgumentException();\nreturn underlyingList.get(i[0]);\n}\npublic int add(T element) {\nreturn super.addElement(element);\n}\npublic T removeLast() {\nreturn super.removeLast();\n}\npublic void set(int i, T element) {\nsuper.set(element, i);\n}\n@Override\nint getUnderlyingSize(int... dim) {\nif (dim.length != 0)\nthrow new IllegalArgumentException(String.valueOf(dim.length));\nreturn underlyingList.size();\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List1D))\nreturn false;\nreturn Lists.equals(this, (List1D) obj);\n}\n@Override\npublic int hashCode() {\nreturn size();\n}\n}"}
{"className":"jfreerails.util.IntArray","javaDoc":"/**\n* Growable <code>int</code> array with type specific access methods. This\n* implementation is unsynchronized in order to provide the best possible\n* performance for typical usage scenarios, so explicit synchronization must be\n* implemented by a wrapper class or directly by the application in cases where\n* instances are modified in a multithreaded environment. See the base classes\n* for other details of the implementation.\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/","code":"/**\n* Growable <code>int</code> array with type specific access methods. This\n* implementation is unsynchronized in order to provide the best possible\n* performance for typical usage scenarios, so explicit synchronization must be\n* implemented by a wrapper class or directly by the application in cases where\n* instances are modified in a multithreaded environment. See the base classes\n* for other details of the implementation.\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/\npublic class IntArray extends ArrayBase implements Serializable {\nprivate static final long serialVersionUID = 3258408426391418681L;\n/** The underlying array used for storing the data. */\nprotected int[] baseArray;\n/**\n* Constructor with full specification.\n*\n* @param size\n* number of <code>int</code> values initially allowed in array\n* @param growth\n* maximum size increment for growing array\n*/\npublic IntArray(int size, int growth) {\nsuper(size, growth, int.class);\n}\n/**\n* Constructor with only initial size specified.\n*\n* @param size\n* number of <code>int</code> values initially allowed in array\n*/\npublic IntArray(int size) {\nsuper(size, int.class);\n}\n/**\n* Default constructor.\n*/\npublic IntArray() {\nthis(DEFAULT_SIZE);\n}\n/**\n* Copy (clone) constructor.\n*\n* @param base\n* instance being copied\n*/\npublic IntArray(IntArray base) {\nsuper(base);\n}\n/**\n* Get the backing array. This method is used by the type-agnostic base\n* class code to access the array used for type-specific storage.\n*\n* @return backing array object\n*/\n@Override\nprotected final Object getArray() {\nreturn baseArray;\n}\n/**\n* Set the backing array. This method is used by the type-agnostic base\n* class code to set the array used for type-specific storage.\n*\n*/\n@Override\nprotected final void setArray(Object array) {\nbaseArray = (int[]) array;\n}\n/**\n* Add a value to the array, appending it after the current values.\n*\n* @param value\n* value to be added\n* @return index number of added element\n*/\npublic final int add(int value) {\nint index = getAddIndex();\nbaseArray[index] = value;\nreturn index;\n}\n/**\n* Add a value at a specified index in the array.\n*\n* @param index\n* index position at which to insert element\n* @param value\n* value to be inserted into array\n*/\npublic void add(int index, int value) {\nmakeInsertSpace(index);\nbaseArray[index] = value;\n}\n/**\n* Retrieve the value present at an index position in the array.\n*\n* @param index\n* index position for value to be retrieved\n* @return value from position in the array\n*/\npublic final int get(int index) {\nif (index < countPresent) {\nreturn baseArray[index];\n}\nthrow new ArrayIndexOutOfBoundsException(\"Invalid index value\");\n}\n/**\n* Set the value at an index position in the array.\n*\n* @param index\n* index position to be set\n* @param value\n* value to be set\n*/\npublic final void set(int index, int value) {\nif (index < countPresent) {\nbaseArray[index] = value;\n} else {\nthrow new ArrayIndexOutOfBoundsException(\"Invalid index value\");\n}\n}\n/**\n* Constructs and returns a simple array containing the same data as held in\n* this growable array.\n*\n* @return array containing a copy of the data\n*/\npublic int[] toArray() {\nreturn (int[]) buildArray(int.class, 0, countPresent);\n}\n/**\n* Constructs and returns a simple array containing the same data as held in\n* a portion of this growable array.\n*\n* @param offset\n* start offset in array\n* @param length\n* number of characters to use\n* @return array containing a copy of the data\n*/\npublic int[] toArray(int offset, int length) {\nreturn (int[]) buildArray(int.class, offset, length);\n}\n/**\n* Duplicates the object with the generic call.\n*\n* @return a copy of the object\n*/\n@Override\npublic Object clone() {\nreturn new IntArray(this);\n}\n}"}
{"className":"jfreerails.util.ArrayBase","javaDoc":"/**\n* Base class for type-specific growable array classes with any type of values\n* (including primitive types). This class builds on the basic structure\n* provided by <code>GrowableBase</code>, specializing it for usage as a\n* growable array. See the base class description for details of the\n* implementation.\n* <p>\n*\n* Growable arrays based on this class are not synchronized in order to provide\n* the best possible performance for typical usage scenarios, so explicit\n* synchronization must be implemented by the subclass or the application in\n* cases where they are to be modified in a multithreaded environment.\n* <p>\n*\n* Subclasses need to implement the abstract methods defined by the base class\n* for working with the data array, as well as the actual data access methods\n* (at least the basic <code>add()</code>, <code>get()</code>,\n* <code>set()</code>, and <code>toArray()</code> methods).\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/","code":"/**\n* Base class for type-specific growable array classes with any type of values\n* (including primitive types). This class builds on the basic structure\n* provided by <code>GrowableBase</code>, specializing it for usage as a\n* growable array. See the base class description for details of the\n* implementation.\n* <p>\n*\n* Growable arrays based on this class are not synchronized in order to provide\n* the best possible performance for typical usage scenarios, so explicit\n* synchronization must be implemented by the subclass or the application in\n* cases where they are to be modified in a multithreaded environment.\n* <p>\n*\n* Subclasses need to implement the abstract methods defined by the base class\n* for working with the data array, as well as the actual data access methods\n* (at least the basic <code>add()</code>, <code>get()</code>,\n* <code>set()</code>, and <code>toArray()</code> methods).\n*\n* @author Dennis M. Sosnoski\n* @version 1.0\n*/\npublic abstract class ArrayBase extends GrowableBase implements Serializable {\n/** The number of values currently present in the array. */\nprotected int countPresent;\n/**\n* Constructor with full specification.\n*\n* @param size\n* number of elements initially allowed in array\n* @param growth\n* maximum size increment for growing array\n* @param type\n* array element type\n*/\npublic ArrayBase(int size, int growth, Class type) {\nsuper(size, growth, type);\n}\n/**\n* Constructor with partial specification.\n*\n* @param size\n* number of elements initially allowed in array\n* @param type\n* array element type\n*/\npublic ArrayBase(int size, Class type) {\nthis(size, Integer.MAX_VALUE, type);\n}\n/**\n* Copy (clone) constructor.\n*\n* @param base\n* instance being copied\n*/\npublic ArrayBase(ArrayBase base) {\nsuper(base);\nSystem.arraycopy(base.getArray(), 0, getArray(), 0, base.countPresent);\ncountPresent = base.countPresent;\n}\n/**\n* Get the array for another instance of this class. This is a convenience\n* method to allow subclasses access to the backing array of other\n* subclasses.\n*\n* @param other\n* subclass instance to get array from\n* @return backing array object\n*/\nprotected static Object getArray(ArrayBase other) {\nreturn other.getArray();\n}\n/**\n* Gets the array offset for appending a value to those in the array. If the\n* underlying array is full, it is grown by the appropriate size increment\n* so that the index value returned is always valid for the array in use by\n* the time of the return.\n*\n* @return index position for added element\n*/\nprotected final int getAddIndex() {\nint index = countPresent++;\nif (countPresent > countLimit) {\ngrowArray(countPresent);\n}\nreturn index;\n}\n/**\n* Makes room to insert a value at a specified index in the array.\n*\n* @param index\n* index position at which to insert element\n*/\nprotected void makeInsertSpace(int index) {\nif (index >= 0 && index <= countPresent) {\nif (++countPresent > countLimit) {\ngrowArray(countPresent);\n}\nif (index < countPresent - 1) {\nObject array = getArray();\nSystem.arraycopy(array, index, array, index + 1, countPresent\n- index - 1);\n}\n} else {\nthrow new ArrayIndexOutOfBoundsException(\"Invalid index value\");\n}\n}\n/**\n* Remove a range of value from the array. The index positions for values\n* above the range removed are decreased by the number of values removed.\n*\n* @param from\n* index number of first value to be removed\n* @param to\n* index number past last value to be removed\n*/\npublic void remove(int from, int to) {\nif (from >= 0 && to <= countPresent && from <= to) {\nif (to < countPresent) {\nint change = from - to;\nObject base = getArray();\nSystem.arraycopy(base, to, base, from, countPresent - to);\ndiscardValues(countPresent + change, countPresent);\ncountPresent += change;\n}\n} else {\nthrow new ArrayIndexOutOfBoundsException(\"Invalid remove range\");\n}\n}\n/**\n* Remove a value from the array. All values above the index removed are\n* moved down one index position.\n*\n* @param index\n* index number of value to be removed\n*/\npublic void remove(int index) {\nremove(index, index + 1);\n}\n/**\n* Get the number of values currently present in the array.\n*\n* @return count of values present\n*/\npublic final int size() {\nreturn countPresent;\n}\n/**\n* Sets the number of values currently present in the array. If the new size\n* is greater than the current size, the added values are initialized to the\n* default values. If the new size is less than the current size, all values\n* dropped from the array are discarded.\n*\n* @param count\n* number of values to be set\n*/\npublic void setSize(int count) {\nif (count > countLimit) {\ngrowArray(count);\n} else if (count < countPresent) {\ndiscardValues(count, countPresent);\n}\ncountPresent = count;\n}\n/**\n* Set the array to the empty state.\n*/\npublic final void clear() {\nsetSize(0);\n}\n/**\n* Constructs and returns a simple array containing the same data as held in\n* a portion of this growable array. This override of the base class method\n* checks that the portion specified actually has data present before\n* constructing the returned array.\n*\n* @param type\n* element type for constructed array\n* @param offset\n* start offset in array\n* @param length\n* number of characters to use\n* @return array containing a copy of the data\n*/\n@Override\nprotected Object buildArray(Class type, int offset, int length) {\nif (offset + length <= countPresent) {\nreturn super.buildArray(type, offset, length);\n}\nthrow new ArrayIndexOutOfBoundsException();\n}\n}"}
{"className":"jfreerails.util.List3D","javaDoc":null,"code":"public interface List3D<T> extends Serializable {\nint sizeD1();\nint sizeD2(int d1);\nint sizeD3(int d1, int d2);\nT get(int d1, int d2, int d3);\nList<T> get(int d1, int d2);\nT removeLastD3(int d1, int d2);\nvoid removeLastD1();\nvoid removeLastD2(int d1);\nint addD1();\nint addD2(int d1);\nint addD3(int d1, int d2, T element);\nvoid set(int d1, int d2, int d3, T element);\n}"}
{"className":"jfreerails.util.List3DDiff","javaDoc":null,"code":"public class List3DDiff<T> extends ListXDDiffs<T> implements List3D<T> {\nprivate static final long serialVersionUID = 14976913635251766L;\nprivate final List3D<T> underlyingList;\npublic List3DDiff(SortedMap<ListKey, Object> diffs, List3D<T> list,\nEnum listID) {\nsuper(diffs, listID);\nthis.underlyingList = list;\n}\npublic int addD1() {\nreturn super.addDimension();\n}\npublic int addD2(int d1) {\nreturn super.addDimension(d1);\n}\npublic int addD3(int d1, int d2, T element) {\nreturn super.addElement(element, d1, d2);\n}\npublic T get(int d1, int d2, int d3) {\nreturn super.get(d1, d2, d3);\n}\n@Override\nObject getUnderlyingList() {\nreturn underlyingList;\n}\n@Override\nint getUnderlyingSize(int... dim) {\nif(dim.length == 0)\nreturn underlyingList.sizeD1();\nif(dim.length == 1){\nif (underlyingList.sizeD1() <= dim[0])\nreturn -1;\nreturn underlyingList.sizeD2(dim[0]);\n}\nif(dim.length == 2){\nif (underlyingList.sizeD1() <= dim[0])\nreturn -1;\nif (underlyingList.sizeD2(dim[0]) <= dim[1])\nreturn -1;\nreturn underlyingList.sizeD3(dim[0], dim[1]);\n}\nthrow new IllegalArgumentException(String.valueOf(dim.length));\n}\npublic void removeLastD1() {\nsuper.removeLastList();\n}\npublic void removeLastD2(int d1) {\nsuper.removeLastList(d1);\n}\npublic T removeLastD3(int d1, int d2) {\nreturn super.removeLast(d1, d2);\n}\npublic void set(int d1, int d2, int d3, T element) {\nsuper.set(element, d1, d2, d3);\n}\npublic int sizeD1() {\nreturn super.size();\n}\npublic int sizeD2(int d1) {\nreturn super.size(d1);\n}\npublic int sizeD3(int d1, int d2) {\nreturn super.size(d1, d2);\n}\n@Override\nT uGet(int... i) {\nif (i.length != 3)\nthrow new IllegalArgumentException();\nreturn underlyingList.get(i[0], i[1], i[2]);\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof List3D))\nreturn false;\nreturn Lists.equals(this, (List3D)obj);\n}\n@Override\npublic int hashCode() {\nreturn sizeD1();\n}\npublic List<T> get(int d1, int d2) {\nList<T> list = new ArrayList<T>();\nfor(int d3 = 0; d3 < sizeD3(d1, d2); d3++) {\nlist.add(get(d1, d2, d3));\n}\nreturn list;\n}\n}"}
{"className":"jfreerails.util.ClassLocater","javaDoc":"/**\n* An essential part of Java - locates any Class, anywhere.\n* <P> * This class should have been part of the JDK for the last 7 years, but Sun\n* hasn't added it, so we did it instead :).\n* <P>\n* No static methods since people are already using this in environments where\n* they need multiple separately configured copies running in parallel. Sun's\n* JVM design (caching classloaders) ensure that cached class data is\n* automatically shared between instances; it could be made faster by storing an\n* internal DB rather than re-instantiating, but the time-savings are minuscule\n* (might save some milliseconds if you have 1000 classes).\n* <p>Usage Tips</p>\n* If you are using this to automatically find all plugins that your users have\n* for your API then the easiest thing to do is declare a package that plugins\n* are in. Note: you could also declare a naming convention, as many open-source\n* projects have done when writing poor alternatives to this method. This is bad\n* practice, since java already has a naming-convention system - packages - and\n* we can easily use that - but it required more coding to make it work. There\n* are cases where you cannot use the packages this way (though personally I'd\n* recommend you re-think your design in that case), and in those cases you can\n* easily use a class-naming convention instead. So, everyone should be happy.\n* <P>\n* If you reserve a package for plugins, e.g. declare that all plugins must be\n* in package \"org.javagamesfactory.plugins\", then you simply pass something\n* like \"org\\.javagamesfactory\\.plugins\\..*\" in (regex meaning \"all things in\n* that package). This class will actually find all things in that package\n* <i>even if they are in different copies of that package, in different JAR\n* files, or different directories</i>.\n* <P>\n* To use a naming convention, e.g. all plugin class names start with the text\n* \"PLUGIN\" you would do something like: \".*\\.PLUGIN.*\".\n* <p>\n* In all cases, note the fact that regex's have special meaning for dot, so you\n* have to escape it when you just mean a full-stop. Read the java API docs for\n* java.util.regex for more information\n*\n* @see java.util.regex.Pattern\n*/","code":"/**\n* An essential part of Java - locates any Class, anywhere.\n* <P> * This class should have been part of the JDK for the last 7 years, but Sun\n* hasn't added it, so we did it instead :).\n* <P>\n* No static methods since people are already using this in environments where\n* they need multiple separately configured copies running in parallel. Sun's\n* JVM design (caching classloaders) ensure that cached class data is\n* automatically shared between instances; it could be made faster by storing an\n* internal DB rather than re-instantiating, but the time-savings are minuscule\n* (might save some milliseconds if you have 1000 classes).\n* <p>Usage Tips</p>\n* If you are using this to automatically find all plugins that your users have\n* for your API then the easiest thing to do is declare a package that plugins\n* are in. Note: you could also declare a naming convention, as many open-source\n* projects have done when writing poor alternatives to this method. This is bad\n* practice, since java already has a naming-convention system - packages - and\n* we can easily use that - but it required more coding to make it work. There\n* are cases where you cannot use the packages this way (though personally I'd\n* recommend you re-think your design in that case), and in those cases you can\n* easily use a class-naming convention instead. So, everyone should be happy.\n* <P>\n* If you reserve a package for plugins, e.g. declare that all plugins must be\n* in package \"org.javagamesfactory.plugins\", then you simply pass something\n* like \"org\\.javagamesfactory\\.plugins\\..*\" in (regex meaning \"all things in\n* that package). This class will actually find all things in that package\n* <i>even if they are in different copies of that package, in different JAR\n* files, or different directories</i>.\n* <P>\n* To use a naming convention, e.g. all plugin class names start with the text\n* \"PLUGIN\" you would do something like: \".*\\.PLUGIN.*\".\n* <p>\n* In all cases, note the fact that regex's have special meaning for dot, so you\n* have to escape it when you just mean a full-stop. Read the java API docs for\n* java.util.regex for more information\n*\n* @see java.util.regex.Pattern\n*/\npublic class ClassLocater {\nprotected static Logger logger = Logger.getLogger(\"jgf.classlocater\");\nprotected LinkedList<String> skipPrefixes = new LinkedList<String>();\n/**\n* Finds all classes that implement or extend a given class name, and\n* instantiates precisely one copy of each\n*\n* @param className\n* fully qualified class or interface to find subclasses of, e.g.\n* \"java.lang.String\"\n* @param skipPrefixes\n* prefixes of fully qualified packages or class names to\n* completely ignore (i.e. not bother to check), making it\n* faster, e.g. \"java.\", \"com.sun\"\n* @return instantiated objects\n*/\npublic static List instantiateOneOfEach(String className,\nString[] skipPrefixes) {\nClass[] classes = null;\nLinkedList<Object> instances = new LinkedList<Object>();\ntry {\nClassLocater locater = new ClassLocater();\nfor (int i = 0; i < skipPrefixes.length; i++) {\nlocater.addSkipPrefix(skipPrefixes[i]);\n}\nclasses = locater.getSubclassesOf(Class.forName(className));\nlogger.info(\"Found \" + classes.length + \" classes that implement \"\n+ className + \"...\");\nif (logger.getLevel().equals(Level.FINE))\nfor (int i = 0; i < classes.length; i++) {\nlogger.fine(\"Found \" + classes[i].getName()\n+ \" that implements \" + className + \"...\");\n}\n} catch (Exception e) {\nlogger.log(Level.SEVERE, \"Attempting to find \" + className\n+ \" implementers\", e);\n}\n// Iterate through all, instantiating them\nlogger.fine(\"Instantiating each class\");\nfor (int i = 0; i < classes.length; i++) {\ntry {\nObject o = classes[i].newInstance();\ninstances.add(o);\n} catch (Throwable e) {\nlogger.log(Level.SEVERE, \"Failed to process: \"\n+ classes[i].getName(), e);\n}\n}\nreturn instances;\n}\n/**\n* Automatically adds sun's classes, the java library classes, and the\n* Apache log4j classes (a lib used by ClassLocater!) to the skip list; it's\n* very unlikely that you're trying to locate any of these!\n*/\npublic ClassLocater() {\naddSkipPrefix(\"org.apache.log4j.\");\naddSkipPrefix(\"com.sun.\");\naddSkipPrefix(\"java\");\naddSkipPrefix(\"junit\");\n}\n/**\n* Adds a prefix for classes (and packages) to completely ignore, based on\n* their package + class name.\n* <p>\n* For example, \"org.apache.log4j\".\n* <P>\n* The advantage of this method is that you don't have to bother with regex\n* syntax. Also, it is remembered between calls to getSubclassesOf - so it's\n* useful if you know you never care about certain packages.\n*\n* @param s\n* prefix of fully qualified class names to ignore\n*/\npublic void addSkipPrefix(String s) {\nskipPrefixes.add(s);\n}\n/**\n* Find all instances of the given <code>Class</code> or interface by\n* loading all classes on the class path.\n* <P>\n* Delegates to the other version, but passing in \".*\" as the regex, i.e.\n* \"anything at all\"\n*\n* @param targetType\n* the superclass of all returned classes.\n* @return an array of all subclasses of <code>targetType</code>\n*/\npublic Class[] getSubclassesOf(Class targetType) {\nreturn getSubclassesOf(targetType, \".*\");\n}\n/**\n* Find all subclasses of the given <code>Class</code> or interface by\n* loading only those classes with names that match the given regular\n* expression.\n* <P>\n* Once all classes have been checked, it will output at WARN a list of all\n* the classes that were referenced by other classes but are not installed\n* in the classpath. This can be incredibly useful - it catches situations\n* where e.g. you thought a class was on the classpath but you put it in the\n* wrong directory etc.\n* <P>\n* It can also be very annoying because java uses dynamic linking so it is\n* LEGAL for many classes to be missing, just so long as you never use them\n* at runtime. Because this class tries to use *every* class, it triggers\n* errors on lots that you don't care about - use addSkipPrefix( class or\n* package you dont use even though its on the classpath ) and they will be\n* skipped (i.e. not even examined by this method).\n* <P>\n* OR improve your regex so that it is more selective about the packages\n* where your classes could conceivable be located!\n*\n* @param targetType\n* the superclass of all returned classes.\n* @param regex\n* a regular expression that will match with every subclass\n* @return an array of all subclasses of <code>targetType</code>\n*/\n@SuppressWarnings(\"unchecked\")\npublic Class[] getSubclassesOf(Class targetType, String regex) {\nlogger.info(\"Looking for all classes with names matching regex = \"\n+ regex + \" and which are subtypes of \" + targetType.getName());\nStringBuffer sbSkips = new StringBuffer();\nfor (Iterator i2 = skipPrefixes.iterator(); i2.hasNext();) {\nsbSkips.append(i2.next().toString() + \"*\");\nif (i2.hasNext())\nsbSkips.append(\", \");\n}\nlogger.info(\"...unless they match: \" + sbSkips.toString());\nLinkedList<Class> matches = new LinkedList<Class>();\nHashMap<String, LinkedList<String>> missingRequiredClasses = new HashMap<String, LinkedList<String>>();\n// maps class name to list of classes that needed it\nlogger.fine(\"Creating ClassPath object to do class search...\");\nClassPath cp = new ClassPath();\nlogger.fine(\"Iterating through all classes in ClassPath...\");\nfor (Iterator iter = cp.getAllClassNames().iterator(); iter.hasNext();) {\nString className = (String) iter.next();\nboolean skip = false;\nfor (Iterator i2 = skipPrefixes.iterator(); i2.hasNext();) {\nString prefix = (String) i2.next();\nif (className.startsWith(prefix)) {\nlogger.fine(\"Skipping class = \" + className\n+ \" because it has a prefix of \" + prefix);\nskip = true;\nbreak;\n}\n}\nif (skip)\ncontinue;\nlogger.fine(\"Processing class: \" + className);\nif (className.matches(regex)\n&& !className.equals(targetType.getName())) {\nlogger\n.fine(\"...matches regex; instantiating and checking type\");\nClass clazz = null;\ntry {\nclazz = Class.forName(className);\n}\n/*\n* catch (ClassNotFoundException cnfx ) { continue; }\n*/\ncatch (NoClassDefFoundError cnfx) {\n/*\n* This is ridiculous. Please, everyone, ask sun to add a\n* \"getMissingClass()\" method to NoClassDefFoundError: Sun,\n* you have had TEN YEARS to fix this!\n*/\nif (cnfx.getMessage() == null) {\nlogger\n.log(\nLevel.WARNING,\n\"NoClassDefFoundError but Sun didn't fill-in the message; no idea which class it was; ignoring it and moving on\",\ncnfx);\ncontinue;\n}\nString missingClassName = cnfx.getMessage().replace('/',\n'.');\nLinkedList<String> misses = missingRequiredClasses\n.get(missingClassName);\nif (misses == null) {\nmisses = new LinkedList<String>();\nmissingRequiredClasses.put(missingClassName, misses);\n}\nmisses.add(className);\ncontinue;\n} catch (UnsatisfiedLinkError cnfx) {\ncontinue;\n} catch (Throwable t) {\nlogger.log(Level.WARNING,\n\"Unexpected error - REMOVING this class (\"\n+ className + \") without checking it\", t);\ncontinue;\n} finally {\nif (clazz != null && targetType.isAssignableFrom(clazz)) {\nlogger\n.fine(className\n+ \" matches and is correct type; adding to results\");\nmatches.add(clazz);\n}\n}\n}\n}\nif (missingRequiredClasses.size() > 0) {\nlogger\n.warning(\"The following classes were needed by some of the classes I found, but could not themselves be found.\"\n+ \"Check you have the required libraries, that they are on the classpath, and that all JAR's are in your manifest as needed\");\nlogger\n.warning(\"If you don't care about some of the classes that used these missing classes, add the users to the skip list and you will get no errors from them\");\nfor (Iterator<String> iter = missingRequiredClasses.keySet()\n.iterator(); iter.hasNext();) {\nString className = iter.next();\nLinkedList<String> neededBy = missingRequiredClasses\n.get(className);\nStringBuffer sb = new StringBuffer();\nfor (Iterator<String> iterator = neededBy.iterator(); iterator\n.hasNext();) {\nString referencingClass = iterator.next();\nsb.append(referencingClass);\nif (iterator.hasNext())\nsb.append(\", \");\n}\nlogger.warning(\"class: \" + className + \" was needed by class\"\n+ (neededBy.size() == 1 ? \"\" : \"es\") + \": \" + sb);\n}\n}\nlogger.info(\"found \" + matches.size() + \" classes.\");\nreturn matches.toArray(new Class[matches.size()]);\n}\n}"}
{"className":"jfreerails.util.ClassPath","javaDoc":"/**\n* ClassPath finds and records the fully qualified name of every Class on the\n* classpath via the system property \"java.class.path\".\n* <p>\n* Based on original prototype by duncanIdaho for javagaming.org.\n*\n* @author adam@jgf\n*/","code":"/**\n* ClassPath finds and records the fully qualified name of every Class on the\n* classpath via the system property \"java.class.path\".\n* <p>\n* Based on original prototype by duncanIdaho for javagaming.org.\n*\n* @author adam@jgf\n*/\npublic class ClassPath {\nprotected Logger logger = Logger.getLogger(\"jgf.classlocater.classpath\");\nprotected LinkedList<String> pathElementsThatHaveAlreadyBeenProcessed;\nprotected LinkedList<File> jarsThatHAveAlreadyBeenProcessed;\n/**\n* create a new ClassPath instance and find all classes on the classpath\n*/\npublic ClassPath() {\n}\npublic List getAllClassNames() {\nString path = null;\npathElementsThatHaveAlreadyBeenProcessed = new LinkedList<String>();\njarsThatHAveAlreadyBeenProcessed = new LinkedList<File>();\nLinkedList<String> pendingClassPathElements = new LinkedList<String>();\nLinkedList<String> processedClassPathElements = new LinkedList<String>();\ntry {\npath = System.getProperty(\"java.class.path\");\n} catch (Exception x) {\nx.printStackTrace();\n}\nlogger.info(\"scanning classpath: \" + path);\nStringTokenizer toke = new StringTokenizer(path, File.pathSeparator);\nwhile (toke.hasMoreTokens()) {\nString pathElement = toke.nextToken();\npendingClassPathElements.add(pathElement);\n}\nfor (Iterator<String> iter = pendingClassPathElements.iterator(); iter\n.hasNext();) {\nString pathElement = iter.next();\nLinkedList<String> processPendingElement = processPendingElement(pathElement);\nprocessedClassPathElements.addAll(processPendingElement);\n}\nreturn processedClassPathElements;\n}\n/**\n* Clones the supplied list, then goes through it processing every element.\n*\n*/\nprotected LinkedList<String> processPendingElement(String pathElement) {\nLinkedList<String> discoveredClasses = new LinkedList<String>();\nFile elementFile = new File(pathElement);\nString elementName = elementFile.getAbsolutePath();\n// do NOT process dupes\nif (pathElementsThatHaveAlreadyBeenProcessed.contains(elementName))\nreturn discoveredClasses;\ntry {\nif (elementName.endsWith(\".jar\")) {\nJarFile jar = null;\nManifest man = null;\njar = new JarFile(elementFile);\nman = jar.getManifest();\n// Find any nested path elements inside the JAR's own private\n// class-path...\nif (!(jarsThatHAveAlreadyBeenProcessed.contains(elementFile))) {\nif (man != null) {\nlogger.fine(\"Jarfile = \" + elementFile\n+ \" was not in jarsalreadydone (size = \"\n+ jarsThatHAveAlreadyBeenProcessed.size());\njarsThatHAveAlreadyBeenProcessed.add(elementFile);\nList extraPathElements = findPathElementsInJar(man,\njar, elementFile);\nlogger.info(\"...[\" + elementFile + \"] contained \"\n+ extraPathElements.size()\n+ \" additional path elements\");\nfor (Iterator iter = extraPathElements.iterator(); iter\n.hasNext();) {\nString element = (String) iter.next();\ndiscoveredClasses\n.addAll(processPendingElement(element));\n}\n}\n// ...and add all the direct-listed classes that were in the\n// JAR\nEnumeration e = jar.entries();\nwhile (e.hasMoreElements()) {\nJarEntry entry = (JarEntry) e.nextElement();\nif (!entry.isDirectory()\n&& entry.getName().endsWith(\".class\")) {\nString className = getClassNameFrom(entry.getName());\ndiscoveredClasses.add(className);\n}\n}\n}\n} else if (elementName.endsWith(\".zip\")) {\ndiscoveredClasses.addAll(getZipContents(elementFile));\n} else if (elementName.endsWith(\".class\")) {\nString className = convertToClass(elementFile);\ndiscoveredClasses.add(className);\n} else {\ndiscoveredClasses.addAll(getDirectoryContents(elementFile));\n}\n// Mark this element as having been processed, and do NOT process\n// dupes\npathElementsThatHaveAlreadyBeenProcessed.add(elementName);\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn discoveredClasses;\n}\n/**\n* @param classFile\n* a class file listed on the classpath itself.\n*/\nprotected String convertToClass(File classFile) {\nreturn getClassNameFrom(classFile.getName());\n}\n/**\n* replace ANY slashes with dots and remove the .class at the end of the\n* file name.\n*\n* @param entryName\n* a file name relative to the classpath. A class of package org\n* found in directory bin would be passed into this method as\n* \"org/MyClass.class\"\n* @return a fully qualified Class name.\n*/\nprivate String getClassNameFrom(String entryName) {\nString foo = entryName.replace('/', '.');\nfoo = foo.replace('\\\\', '.');\nreturn foo.substring(0, foo.lastIndexOf('.'));\n}\n/**\n* Finds all path elements in the supplied JAR and returns them as a list\n*\n* @param man\n* the manifest of the given jar\n* @param jar\n* the jar associated with the given manifest.\n*/\nprotected LinkedList<String> findPathElementsInJar(Manifest man,\nJarFile jar, File jarFile) {\nLinkedList<String> result = new LinkedList<String>();\nAttributes atts = man.getMainAttributes();\nSet keys = atts.keySet();\nIterator i = keys.iterator();\nwhile (i.hasNext()) {\nObject key = i.next();\nString value = (String) atts.get(key);\nlogger.fine(jar.getName() + \" \" + key + \": \" + value);\nif (key.toString().equals(\"Class-Path\")) {\nlogger.info(\"scanning \" + jar.getName()\n+ \"'s manifest classpath: \" + value);\nStringTokenizer toke = new StringTokenizer(value);\nwhile (toke.hasMoreTokens()) {\nString element = toke.nextToken();\nif (jarFile.getParent() == null)\nresult.add(element);\nelse {\nresult.add(jarFile.getParent() + File.separator\n+ element);\n}\n}\n}\n}\nreturn result;\n}\n/**\n* Adds all class names found in the zip mentioned\n*\n* @param zipFile\n*/\nprotected LinkedList<String> getZipContents(File zipFile) {\nLinkedList<String> result = new LinkedList<String>();\nZipFile zip = null;\ntry {\nzip = new JarFile(zipFile);\n} catch (IOException iox) {\n}\nif (zip != null) {\nEnumeration e = zip.entries();\nwhile (e.hasMoreElements()) {\nZipEntry entry = (ZipEntry) e.nextElement();\nif (!entry.isDirectory() && entry.getName().endsWith(\".class\")) {\nString className = getClassNameFrom(entry.getName());\nresult.add(className);\n}\n}\n}\nreturn result;\n}\n/**\n* This method takes a top level classpath dir i.e. 'classes' or bin\n*\n* @param dir\n*/\nprotected LinkedList<String> getDirectoryContents(File dir) {\nLinkedList<String> result = new LinkedList<String>();\n// drill through contained dirs ... this is expected to be the\n// 'classes' or 'bin' dir\nFile files[] = dir.listFiles();\nif (null == files) {\nlogger.info(\"dir.listFiles() returned null for \" + dir);\nreturn result;\n}\nfor (int i = 0; i < files.length; ++i) {\nFile f = files[i];\nif (f.isDirectory()) {\nresult.addAll(getDirectoryContents(\"\", f));\n} else {\nif (f.getName().endsWith(\".class\"))\nresult.add(convertToClass(f));\n}\n}\nreturn result;\n}\n/**\n* This method does the real directory recursion, passing along the the\n* corresponding package-path to this directory.\n*\n* @param pathTo\n* the preceding path to this directory\n* @param dir\n* a directory to search for class files\n*/\nprotected LinkedList<String> getDirectoryContents(String pathTo, File dir) {\nLinkedList<String> result = new LinkedList<String>();\nString pathToHere = pathTo + dir.getName() + File.separator;\nFile files[] = dir.listFiles();\nfor (int i = 0; i < files.length; ++i) {\nFile f = files[i];\nif (f.isDirectory()) {\nresult.addAll(getDirectoryContents(pathToHere, f));\n} else {\nif (f.getName().endsWith(\".class\")) {\nString absFilePath = pathToHere + f.getName();\nresult.add(getClassNameFrom(absFilePath));\n}\n}\n}\nreturn result;\n}\n}"}
{"className":"jfreerails.util.FreerailsIntIterator","javaDoc":"/**\n* Returns a series of ints.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Returns a series of ints.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface FreerailsIntIterator {\nboolean hasNextInt();\nint nextInt();\n}"}
{"className":"jfreerails.world.top.SKEYTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class SKEYTest extends TestCase {\npublic void testGetNumberOfKeys() {\nassertTrue(SKEY.getNumberOfKeys() > 5);\n}\npublic void testThatAllTheFieldsDefinedInSKEYAreInstancesOFSKEY() {\nField[] fields = SKEY.class.getFields();\nfor (int i = 0; i < fields.length; i++) {\nString name = fields[i].getName();\nint modifiers = fields[i].getModifiers();\nif (!name.equals(\"shared\")) {\nassertTrue(\"All the fields of SKEY should be static\", Modifier\n.isStatic(modifiers));\n}\nassertTrue(\"All the fields of SKEY should be public\", Modifier\n.isPublic(modifiers));\nassertTrue(\"All the fields of SKEY should be final\", Modifier\n.isFinal(modifiers));\ntry {\nif (Modifier.isStatic(modifiers)) {\nObject o = fields[i].get(null);\nassertTrue(\"All the fields of SKEY should be instances of\"\n+ \" SKEY\", o instanceof SKEY);\n}\n} catch (IllegalAccessException e) {\nassertTrue(false);\n}\n}\n}\n}"}
{"className":"jfreerails.world.top.WorldDiffsTest","javaDoc":"/**\n* JUnit test for WorldDifferences.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for WorldDifferences.\n*\n* @author Luke\n*\n*/\npublic class WorldDiffsTest extends TestCase {\nPlayer player0 = new Player(\"player0\", 0);\nPlayer player1 = new Player(\"player1\", 1);\npublic void testSharedLists() {\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nCargoType mailCT = new CargoType(10, \"Mail\", Categories.Mail);\nCargoType passengersCT = new CargoType(10, \"Passengers\",\nCategories.Passengers);\nunderlyingWorld.add(SKEY.CARGO_TYPES, mailCT);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(0, worldDiff.listDiffs());\nassertEquals(1, worldDiff.size(SKEY.CARGO_TYPES));\nFreerailsSerializable f = worldDiff.get(SKEY.CARGO_TYPES, 0);\nassertEquals(\"The mail cargotype should be accessible.\", mailCT, f);\nworldDiff.add(SKEY.CARGO_TYPES, passengersCT);\nassertEquals(2, worldDiff.size(SKEY.CARGO_TYPES));\nassertEquals(\"2 Diffs: the length of the list + the actual element\", 2,\nworldDiff.listDiffs());\nf = worldDiff.removeLast(SKEY.CARGO_TYPES);\nassertEquals(passengersCT, f);\nassertEquals(0, worldDiff.listDiffs());\nf = worldDiff.removeLast(SKEY.CARGO_TYPES);\nassertEquals(mailCT, f);\nassertEquals(\"1 Diff: the list length.\", 1, worldDiff.listDiffs());\nassertEquals(0 , worldDiff.size(SKEY.CARGO_TYPES));\nworldDiff.add(SKEY.CARGO_TYPES, mailCT);\nassertEquals(0, worldDiff.listDiffs());\nworldDiff.set(SKEY.CARGO_TYPES, 0, passengersCT);\nassertEquals(\"1 Diff: element 0\", 1, worldDiff.listDiffs());\n}\npublic void testPlayers() {\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(0, worldDiff.listDiffs());\nassertEquals(1, worldDiff.getNumberOfPlayers());\nPlayer p = worldDiff.getPlayer(0);\nassertEquals(player0, p);\nassertTrue(worldDiff.isPlayer(player0.getPrincipal()));\n// Test adding a player.\nint n = worldDiff.addPlayer(player1);\nassertEquals(1, n);\nassertEquals(2, worldDiff.getNumberOfPlayers());\np = worldDiff.getPlayer(1);\nassertEquals(player1, p);\nassertTrue(worldDiff.isPlayer(player1.getPrincipal()));\n}\npublic void testNonSharedLists() {\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nStationModel station0 = new StationModel();\nunderlyingWorld.add(player0.getPrincipal(), KEY.STATIONS, station0);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(0, worldDiff.listDiffs());\n// First, for an existing player\nassertEquals(1, worldDiff.size(player0.getPrincipal(), KEY.STATIONS));\nFreerailsSerializable fs = worldDiff.get(player0.getPrincipal(),\nKEY.STATIONS, 0);\nassertEquals(station0, fs);\n// Add a station.\nStationModel station1 = new StationModel();\nworldDiff.add(player0.getPrincipal(), KEY.STATIONS, station1);\nassertEquals(2, worldDiff.size(player0.getPrincipal(), KEY.STATIONS));\nfs = worldDiff.get(player0.getPrincipal(), KEY.STATIONS, 1);\nassertEquals(station1, fs);\n// Change a station.\nStationModel station2 = new StationModel();\nworldDiff.set(player0.getPrincipal(), KEY.STATIONS, 0, station2);\nfs = worldDiff.get(player0.getPrincipal(), KEY.STATIONS, 0);\nassertEquals(station2, fs);\n// Remove both stations.\nfs = worldDiff.removeLast(player0.getPrincipal(), KEY.STATIONS);\nassertEquals(station1, fs);\nfs = worldDiff.removeLast(player0.getPrincipal(), KEY.STATIONS);\nassertEquals(station2, fs);\nassertEquals(0, worldDiff.size(player0.getPrincipal(), KEY.STATIONS));\n// Add a station again.\nint i = worldDiff.add(player0.getPrincipal(), KEY.STATIONS, station1);\nassertEquals(0, i);\nassertEquals(1, worldDiff.size(player0.getPrincipal(), KEY.STATIONS));\n// Second, for a new player\nworldDiff.addPlayer(player1);\nassertEquals(2, worldDiff.getNumberOfPlayers());\nassertEquals(player1, worldDiff.getPlayer(1));\nassertEquals(0, worldDiff.size(player1.getPrincipal(), KEY.STATIONS));\nworldDiff.add(player1.getPrincipal(), KEY.STATIONS, station1);\nassertEquals(1, worldDiff.size(player1.getPrincipal(), KEY.STATIONS));\nworldDiff.set(player1.getPrincipal(), KEY.STATIONS, 0, station2);\nworldDiff.add(player1.getPrincipal(), KEY.STATIONS, station1);\n}\npublic void testUsingNullElements() {\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nStationModel station0 = new StationModel();\nStationModel station1 = null;\nunderlyingWorld.add(player0.getPrincipal(), KEY.STATIONS, station0);\nunderlyingWorld.add(player0.getPrincipal(), KEY.STATIONS, station1);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(station0, worldDiff.get(player0\n.getPrincipal(), KEY.STATIONS, 0));\nassertEquals(station1, worldDiff.get(player0\n.getPrincipal(), KEY.STATIONS, 1));\nworldDiff.set(player0.getPrincipal(), KEY.STATIONS, 0, station1);\nworldDiff.set(player0.getPrincipal(), KEY.STATIONS, 1, station0);\n}\npublic void testItem() {\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nStationModel station0 = new StationModel();\nStationModel station1 = new StationModel();\nunderlyingWorld.set(ITEM.GAME_RULES, station0); // why not!\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(station0, worldDiff.get(ITEM.GAME_RULES));\nworldDiff.set(ITEM.GAME_RULES, station1);\nassertEquals(station1, worldDiff.get(ITEM.GAME_RULES));\n}\npublic void testMap() {\nWorldImpl underlyingWorld = new WorldImpl(21, 8);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(21, worldDiff.getMapWidth());\nassertEquals(8, worldDiff.getMapHeight());\nFreerailsTile tile = (FreerailsTile) underlyingWorld.getTile(2, 2);\nassertNotNull(tile);\nassertEquals(tile, worldDiff.getTile(2, 2));\nFreerailsTile newTile = FreerailsTile.getInstance(999);\nworldDiff.setTile(3, 5, newTile);\nassertEquals(newTile, worldDiff.getTile(3, 5));\nIterator<ImPoint> it = worldDiff.getMapDiffs();\nassertEquals(new ImPoint(3, 5), it.next());\n}\npublic void testAccount(){\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nWorldDiffs worldDiff = new WorldDiffs(underlyingWorld);\nassertEquals(0, worldDiff.numberOfMapDifferences());\nassertEquals(0, worldDiff.listDiffs());\n}\npublic void testEquals(){\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nWorldDiffs a = new WorldDiffs(underlyingWorld);\nWorldDiffs b = new WorldDiffs(underlyingWorld);\nassertEquals(a, a);\nassertEquals(a, b);\nassertEquals(a, underlyingWorld);\nassertEquals(underlyingWorld, a);\n}\npublic void testGetListDiffs(){\nWorldImpl underlyingWorld = new WorldImpl(10, 10);\nunderlyingWorld.addPlayer(player0);\nWorldDiffs diffs = new WorldDiffs(underlyingWorld);\nCityModel city = new CityModel(\"Bristol\", 10, 4);\ndiffs.add(SKEY.CITIES, city);\nIterator<ListKey> it = diffs.getListDiffs();\n@SuppressWarnings(\"unused\")\nListKey lk1 = it.next();\nListKey lk2 = it.next();\nassertFalse(it.hasNext());\nListKey expected = new ListKey(Element, SHARED_LISTS, SKEY.CITIES.getKeyID(), 0);\nassertEquals(expected, lk2);\n}\n}"}
{"className":"jfreerails.world.top.KEYTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*\n*/\npublic class KEYTest extends TestCase {\npublic void testGetNumberOfKeys() {\n// There were 4 keys when a wrote this test,\n// but I expect the number to increase.\nassertTrue(KEY.getNumberOfKeys() >= 4);\n}\npublic void testThatAllTheFieldsDefinedInKEYAreInstancesOFKEY() {\nField[] fields = KEY.class.getFields();\nfor (int i = 0; i < fields.length; i++) {\nString name = fields[i].getName();\nint modifiers = fields[i].getModifiers();\nif (!name.equals(\"shared\")) {\nassertTrue(\"All the fields of KEY should be static\", Modifier\n.isStatic(modifiers));\n}\nassertTrue(\"All the fields of KEY should be public\", Modifier\n.isPublic(modifiers));\nassertTrue(\"All the fields of KEY should be final\", Modifier\n.isFinal(modifiers));\ntry {\nif (Modifier.isStatic(modifiers)) {\nObject o = fields[i].get(null);\nassertTrue(\"All the fields of KEY should be instances of\"\n+ \" KEY\", o instanceof KEY);\n}\n} catch (IllegalAccessException e) {\nassertTrue(false);\n}\n}\n}\npublic void testToString() {\nassertEquals(\"Key.toString() should return the field name\", \"TRAINS\",\nKEY.TRAINS.toString());\n}\n}"}
{"className":"jfreerails.world.top.NonNullElementsTest","javaDoc":"/**\n* This junit TestCase tests NonNullElements.\n*\n* @author Luke\n*\n*/","code":"/**\n* This junit TestCase tests NonNullElements.\n*\n* @author Luke\n*\n*/\npublic class NonNullElementsTest extends TestCase {\nWorld w;\nStationModel station1;\nStationModel station2;\nStationModel station3;\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\npublic static Test suite() {\nTestSuite testSuite = new TestSuite(NonNullElementsTest.class);\nreturn testSuite;\n}\n@Override\nprotected void setUp() {\nw = new WorldImpl();\nstation1 = new StationModel(10, 20, \"Station1\", 4, 0);\nstation2 = new StationModel(15, 16, \"Station2\", 4, 1);\nstation3 = new StationModel(30, 50, \"Station3\", 4, 2);\nw.addPlayer(MapFixtureFactory.TEST_PLAYER);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, station1);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, null);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, station2);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, null);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, null);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, station3);\n}\npublic void testNext() {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(WorldIterator.BEFORE_FIRST, wi.getRowID());\nassertEquals(WorldIterator.BEFORE_FIRST, wi.getIndex());\n// Look at first station\nboolean b = wi.next();\nassertTrue(b);\nint index = wi.getIndex();\nassertEquals(0, index);\nassertEquals(0, wi.getRowID());\nassertEquals(station1, wi.getElement());\n// Look at second station\nassertTrue(wi.next());\nassertEquals(2, wi.getIndex());\nassertEquals(1, wi.getRowID());\nassertEquals(station2, wi.getElement());\nWorldIterator wi2 = new NonNullElements(SKEY.TRACK_RULES, w);\nassertTrue(!wi2.next());\n}\npublic void testGotoIndex() {\nWorldIterator wi = new NonNullElements(KEY.STATIONS, w,\nMapFixtureFactory.TEST_PRINCIPAL);\nassertEquals(WorldIterator.BEFORE_FIRST, wi.getRowID());\nassertEquals(WorldIterator.BEFORE_FIRST, wi.getIndex());\nwi.gotoIndex(2);\nassertEquals(2, wi.getIndex());\nassertEquals(1, wi.getRowID());\ntry {\nwi.gotoIndex(100);\nassertTrue(false);\n} catch (NoSuchElementException e) {\n}\n}\n}"}
{"className":"jfreerails.world.top.WorldImplTest","javaDoc":"/**\n* Junit test.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit test.\n*\n* @author Luke\n*\n*/\npublic class WorldImplTest extends TestCase {\nprivate final FreerailsSerializable fs = new TestState(1);\npublic void testGet() {\nWorldImpl w = new WorldImpl();\nw.add(SKEY.TERRAIN_TYPES, fs);\nassertEquals(w.get(SKEY.TERRAIN_TYPES, 0), fs);\n}\npublic void testConstructor() {\nWorld w = new WorldImpl();\nassertEquals(\"The width should be zero\", 0, w.getMapWidth());\nassertEquals(\"The height should be zero\", 0, w.getMapHeight());\n}\n/**\n* Tests that changing the object returned by defensiveCopy() does not alter\n* the world object that was copied.\n*/\npublic void testDefensiveCopy() {\nWorld original;\nWorld copy;\noriginal = new WorldImpl();\ncopy = original.defensiveCopy();\nassertNotSame(\"The copies should be different objects.\", original, copy);\nassertEquals(\"The copies should be logically equal.\", original, copy);\ncopy.add(SKEY.TERRAIN_TYPES, fs);\nassertFalse(original.equals(copy));\nassertFalse(copy.equals(original));\nassertEquals(1, copy.size(SKEY.TERRAIN_TYPES));\nassertEquals(0, original.size(SKEY.TERRAIN_TYPES));\n}\npublic void testEquals() {\nWorld original;\nWorld copy;\noriginal = new WorldImpl();\ncopy = original.defensiveCopy();\nPlayer player = new Player(\"Name\", 0);\nint index = copy.addPlayer(player);\nassertEquals(index, 0);\nassertFalse(copy.equals(original));\noriginal.addPlayer(player);\nassertEquals(\"The copies should be logically equal.\", original, copy);\nassertTrue(Utils.equalsBySerialization(original, copy));\nTransaction t = new Receipt(new Money(100),\nTransaction.Category.MISC_INCOME);\ncopy.addTransaction(player.getPrincipal(), t);\nassertEquals(new Money(100), copy.getCurrentBalance(player\n.getPrincipal()));\nassertFalse(copy.equals(original));\n}\npublic void testEquals2() {\nWorld original;\nWorld copy, copy2;\noriginal = new WorldImpl();\ncopy = original.defensiveCopy();\ncopy2 = original.defensiveCopy();\n// Test adding players.\nPlayer a = new Player(\"Fred\");\nPlayer b = new Player(\"John\");\noriginal.addPlayer(a);\ncopy.addPlayer(b);\nassertFalse(copy.equals(original));\ncopy.removeLastPlayer();\nassertTrue(copy2.equals(copy));\ncopy.addPlayer(a);\nassertTrue(copy.equals(original));\n}\npublic void testActivityLists() {\nWorld w = new WorldImpl();\nPlayer player = new Player(\"Name\", 0);\nw.addPlayer(player);\nFreerailsPrincipal principal = player.getPrincipal();\n// Test adding activities.\nassertEquals(0, w.size(principal));\nActivity act = new TestActivity(30);\nint actIndex = w.addActiveEntity(principal, act);\nassertEquals(0, actIndex);\nassertEquals(1, w.size(principal));\nactIndex = w.addActiveEntity(principal, act);\nassertEquals(1, actIndex);\nassertEquals(2, w.size(principal));\n// Then removing them.\nActivity expected = new TestActivity(30);\nassertEquals(expected, act);\nActivity actual = w.removeLastActiveEntity(principal);\nassertEquals(actual, expected);\nassertEquals(1, w.size(principal));\n}\npublic static class TestState implements FreerailsSerializable {\nprivate static final long serialVersionUID = 5122023949873919060L;\npublic final int x;\npublic TestState(int x) {\nthis.x = x;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TestState))\nreturn false;\nfinal TestState testState = (TestState) o;\nif (x != testState.x)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn x;\n}\n}\npublic static class TestActivity implements Activity {\nprivate static final long serialVersionUID = 1298936498785131183L;\nprivate final double duration;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TestActivity))\nreturn false;\nfinal TestActivity testActivity = (TestActivity) o;\nif (duration != testActivity.duration)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn (int) duration;\n}\npublic TestActivity(int duration) {\nthis.duration = duration;\n}\npublic double duration() {\nreturn duration;\n}\npublic FreerailsSerializable getState(double dt) {\nreturn new TestState((int) dt);\n}\n@Override\npublic String toString() {\nreturn getClass().getName() + \"{\" + duration + \"}\";\n}\n}\npublic void testBoundsContain(){\nWorld w = new WorldImpl();\nassertFalse(w.boundsContain(1, 1));\nassertFalse(w.boundsContain(0, 0));\nassertFalse(w.boundsContain(-1, -1));\nw = new WorldImpl(5, 10);\nassertTrue(w.boundsContain(0, 0));\nassertTrue(w.boundsContain(4, 9));\nassertFalse(w.boundsContain(-1, -1));\nassertFalse(w.boundsContain(5, 10));\n}\npublic void testBankAccount(){\nWorldImpl world = new WorldImpl();\nPlayer p = new Player(\"Test\", 0);\nint playerID = world.addPlayer(p);\nassertEquals(0, playerID);\nFreerailsPrincipal fp = world.getPlayer(playerID).getPrincipal();\nTransaction t = new AddItemTransaction(Category.BOND, 1, 2, new Money(100));\nassertEquals(new Money(0), world.getCurrentBalance(fp));\nworld.addTransaction(fp, t);\nassertEquals(1, world.getNumberOfTransactions(fp));\nassertEquals(new Money(100), world.getCurrentBalance(fp));\nTransaction t2 = world.getTransaction(fp, 0);\nassertEquals(t, t2);\nTransaction t3 = world.removeLastTransaction(fp);\nassertEquals(t, t3);\nassertEquals(new Money(0), world.getCurrentBalance(fp));\n}\n}"}
{"className":"jfreerails.world.top.ItemsTransactionAggregatorTest","javaDoc":null,"code":"public class ItemsTransactionAggregatorTest extends TestCase {\npublic void test1(){\nWorld w = new WorldImpl();\nPlayer player = new Player(\"name\", 0);\nw.addPlayer(player);\nFreerailsPrincipal fp = w.getPlayer(0).getPrincipal();\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(w, fp);\naggregator.setCategory(TRACK);\nint quant = aggregator.calculateQuantity();\nassertEquals(0, quant);\nTransaction t = new AddItemTransaction(Category.TRACK, 10, 5 , new Money(100));\nw.addTransaction(fp, t);\nquant = aggregator.calculateQuantity();\nassertEquals(5, quant);\nt = new AddItemTransaction(Category.TRACK, 10, 11 , new Money(200));\nw.addTransaction(fp, t);\n}\n}"}
{"className":"jfreerails.world.JavaDocPlaceholder","javaDoc":"/**\n* This class does nothing and is only here so that javadoc gets generated\n* correctly.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class does nothing and is only here so that javadoc gets generated\n* correctly.\n*\n* @author Luke\n*\n*/\npublic class JavaDocPlaceholder {\n}"}
{"className":"jfreerails.world.Constants","javaDoc":"/**\n* game constants\n*\n* @author Roland Spatzenegger\n* @version $Revision 1.1$\n*/","code":"/**\n* game constants\n*\n* @author Roland Spatzenegger\n* @version $Revision 1.1$\n*/\npublic final class Constants {\n/**\n* size of a tile (height and width)\n*/\npublic static final int TILE_SIZE = 30;\n}"}
{"className":"jfreerails.world.cargo.CargoBundleTest","javaDoc":null,"code":"public class CargoBundleTest extends TestCase {\npublic void testEquals() {\nMutableCargoBundle bundle1 = new MutableCargoBundle();\nMutableCargoBundle bundle2 = new MutableCargoBundle();\nCargoBatch batch1 = new CargoBatch(1, 2, 3, 4, 5);\nCargoBatch batch2 = new CargoBatch(4, 2, 3, 4, 5);\nint q1 = 10;\nint q2 = 20;\nbundle1.addCargo(batch1, q1);\nbundle1.addCargo(batch2, q2);\nassertBundlesNotEqual(bundle1, bundle2);\nbundle2.addCargo(batch2, q2);\nassertBundlesNotEqual(bundle1, bundle2);\nbundle2.addCargo(batch1, q1);\nassertBundlesEqual(bundle1, bundle2);\n}\nprivate void assertBundlesEqual(MutableCargoBundle a, MutableCargoBundle b) {\nassertEquals(a, b);\nassertEquals(a, a);\nassertEquals(b, a);\nImmutableCargoBundle immA = a.toImmutableCargoBundle();\nassertEquals(immA, immA);\nassertEquals(immA, b);\nImmutableCargoBundle immB = b.toImmutableCargoBundle();\nassertEquals(immA, immB);\nSerializable cloneA = Utils.cloneBySerialisation(immA);\nSerializable cloneB = Utils.cloneBySerialisation(immB);\nassertEquals(cloneA, cloneB);\nassertEquals(a, immB);\n}\nprivate void assertBundlesNotEqual(MutableCargoBundle a,\nMutableCargoBundle b) {\nassertFalse(a.equals(b));\nassertFalse(b.equals(a));\nassertFalse(a.toImmutableCargoBundle().equals(b));\nassertFalse(a.toImmutableCargoBundle().equals(\nb.toImmutableCargoBundle()));\nassertFalse(a.equals(b.toImmutableCargoBundle()));\n}\n}"}
{"className":"jfreerails.world.cargo.CargoTypeTest","javaDoc":"/**\n* JUnit test for CargoType.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for CargoType.\n*\n* @author Luke\n*\n*/\npublic class CargoTypeTest extends TestCase {\npublic void testCargoType() {\n// Test that invalid categories get rejected.\ntry {\nnew CargoType(10, \"Test\", Categories\n.getCategory(\"Non valid category\"));\nfail();\n} catch (Exception e) {\n}\ntry {\nnew CargoType(10, \"Test\", Categories.Mail);\n} catch (Exception e) {\nfail();\n}\n}\n}"}
{"className":"jfreerails.world.top.ReadOnlyWorld","javaDoc":"/**\n* <p>\n* This interface defines a unified set of methods to access the elements that\n* make up the game world. The game world is composed of the following\n* specific-purpose collections into which one can put game world elements.\n* </p>\n* <ul>\n* A list of players.\n* </ul>\n* <ul>\n* A 2D grid - the map.\n* </ul>\n* <ul>\n* A series of lists that are accessible using the keys defined in {@link SKEY}\n* </ul>\n* <ul>\n* Another series of lists indexed by player and accessible using the keys\n* defined in {@link KEY}\n* </ul>\n* <ul>\n* A collection items accessible using the keys defined in {@link ITEM}\n* </ul>\n* <ul>\n* A list of financial transactions for each of the players\n* </ul>\n* <p>\n* Example: the following code gets player1's train #5.\n* </p>\n* <p>\n* <CODE>TrainModel t = (TrainModel)world.get(KEY.TRAINS, 5, player1);</CODE>\n* </p>\n* <p>\n* The motivation for accessing lists using keys is that one does not need to\n* add a new class or change the interface of the World class when a new list is\n* added. Instead one can just add a new entry to the class KEY.\n* </p>\n* <p>\n* Code that loops through lists should handle null values gracefully\n* </p>\n*\n*\n* @author Luke\n* @author Rob\n*/","code":"/**\n* <p>\n* This interface defines a unified set of methods to access the elements that\n* make up the game world. The game world is composed of the following\n* specific-purpose collections into which one can put game world elements.\n* </p>\n* <ul>\n* A list of players.\n* </ul>\n* <ul>\n* A 2D grid - the map.\n* </ul>\n* <ul>\n* A series of lists that are accessible using the keys defined in {@link SKEY}\n* </ul>\n* <ul>\n* Another series of lists indexed by player and accessible using the keys\n* defined in {@link KEY}\n* </ul>\n* <ul>\n* A collection items accessible using the keys defined in {@link ITEM}\n* </ul>\n* <ul>\n* A list of financial transactions for each of the players\n* </ul>\n* <p>\n* Example: the following code gets player1's train #5.\n* </p>\n* <p>\n* <CODE>TrainModel t = (TrainModel)world.get(KEY.TRAINS, 5, player1);</CODE>\n* </p>\n* <p>\n* The motivation for accessing lists using keys is that one does not need to\n* add a new class or change the interface of the World class when a new list is\n* added. Instead one can just add a new entry to the class KEY.\n* </p>\n* <p>\n* Code that loops through lists should handle null values gracefully\n* </p>\n*\n*\n* @author Luke\n* @author Rob\n*/\npublic interface ReadOnlyWorld extends FreerailsMutableSerializable {\nboolean boundsContain(int x, int y);\nboolean boundsContain(FreerailsPrincipal p, KEY k, int index);\nboolean boundsContain(SKEY k, int index);\nGameTime currentTime();\n/**\n* Returns the element mapped to the specified item.\n*/\nFreerailsSerializable get(ITEM item);\n/**\n* Returns the element at the specified position in the specified list.\n*/\nFreerailsSerializable get(FreerailsPrincipal p, KEY key, int index);\n/**\n* Returns the element at the specified position in the specified list.\n*/\nFreerailsSerializable get(SKEY key, int index);\nActivityIterator getActivities(FreerailsPrincipal p, int index);\nMoney getCurrentBalance(FreerailsPrincipal p);\nint getID(FreerailsPrincipal p);\n/**\n* Returns the height of the map in tiles.\n*/\nint getMapHeight();\n/**\n* Returns the width of the map in tiles.\n*/\nint getMapWidth();\nint getNumberOfPlayers();\nint getNumberOfTransactions(FreerailsPrincipal p);\nint getNumberOfActiveEntities(FreerailsPrincipal p);\nPlayer getPlayer(int i);\n/**\n* Returns the tile at the specified position on the map.\n*/\nFreerailsSerializable getTile(int x, int y);\nTransaction getTransaction(FreerailsPrincipal p, int i);\nGameTime getTransactionTimeStamp(FreerailsPrincipal p, int i);\npublic Pair<Transaction, GameTime> getTransactionAndTimeStamp(\nFreerailsPrincipal p, int i);\nboolean isPlayer(FreerailsPrincipal p);\n/**\n* Returns the number of elements in the specified list.\n*/\nint size(FreerailsPrincipal p, KEY key);\n/**\n* Returns the number of elements in the specified list.\n*/\nint size(SKEY key);\n/**\n* Returns number of active entities belonging to the specified principal.\n*/\nint size(FreerailsPrincipal p);\n}"}
{"className":"jfreerails.world.top.ITEM","javaDoc":"/**\n* <p>\n* This class provides a set of keys to access the items of which there can only\n* be one instance in the game world in the game world (for example, the current\n* time).\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/","code":"/**\n* <p>\n* This class provides a set of keys to access the items of which there can only\n* be one instance in the game world in the game world (for example, the current\n* time).\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/\n@jfreerails.util.InstanceControlled\npublic class ITEM implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257846593180151859L;\n/** Maps key numbers to KEYs. */\nprivate static final ITEM[] keys = new ITEM[getNumberOfKeys()];\n// START OF KEYS\npublic static final ITEM CALENDAR = new ITEM();\npublic static final ITEM GAME_RULES = new ITEM();\npublic static final ITEM GAME_SPEED = new ITEM();\npublic static final ITEM ECONOMIC_CLIMATE = new ITEM();\n// END OF KEYS\nprivate static int numberOfKeys = 0;\nprivate final int keyNumber;\nprivate ITEM() {\nthis.keyNumber = numberOfKeys;\nkeys[keyNumber] = this;\nnumberOfKeys++;\n}\nstatic int getNumberOfKeys() {\nreturn ITEM.class.getFields().length;\n}\nint getKeyID() {\nreturn keyNumber;\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn keys[this.keyNumber];\n}\n@Override\npublic String toString() {\nreturn Utils.findConstantFieldName(this);\n}\n}"}
{"className":"jfreerails.world.top.NonNullElements","javaDoc":"/**\n* Iterates over one of the lists on the world object only returning non null\n* elements.\n*\n* @author Luke\n*\n*/","code":"/**\n* Iterates over one of the lists on the world object only returning non null\n* elements.\n*\n* @author Luke\n*\n*/\npublic class NonNullElements implements WorldIterator {\nprivate final KEY key;\nprivate final SKEY skey;\nprivate final ReadOnlyWorld w;\nprivate final FreerailsPrincipal principal;\nprivate int index = BEFORE_FIRST;\nprivate int row = BEFORE_FIRST;\nprivate int size = -1;\npublic NonNullElements(SKEY k, ReadOnlyWorld world) {\nif (null == k) {\nthrow new NullPointerException();\n}\nif (null == world) {\nthrow new NullPointerException();\n}\nkey = null;\nprincipal = null;\nskey = k;\nw = world;\n}\npublic NonNullElements(KEY k, ReadOnlyWorld world, FreerailsPrincipal p) {\nkey = k;\nw = world;\nprincipal = p;\nskey = null;\nif (null == k) {\nthrow new NullPointerException();\n}\nif (null == world) {\nthrow new NullPointerException();\n}\nif (null == p) {\nthrow new NullPointerException();\n}\n}\npublic boolean next() {\nint nextIndex = index; // this is used to look ahead.\ndo {\nnextIndex++;\nif (nextIndex >= listSize()) {\nreturn false;\n}\n} while (!testCondition(nextIndex));\nrow++;\nindex = nextIndex;\nreturn true;\n}\npublic void reset() {\nindex = -1;\nrow = -1;\nsize = -1;\n}\npublic FreerailsSerializable getElement() {\nreturn listGet(index);\n}\nprivate FreerailsSerializable listGet(int i) {\nif (null == this.skey) {\nreturn w.get(principal, key, i);\n}\nreturn w.get(skey, i);\n}\nprivate int listSize() {\nif (null == this.skey) {\nreturn w.size(principal, key);\n}\nreturn w.size(this.skey);\n}\npublic int getIndex() {\nreturn index;\n}\npublic int getRowID() {\nreturn row;\n}\npublic int size() {\nif (-1 == size) { // lazy loading, if we have already calculated the\n// size don't do it again.\nint tempSize = 0;\nfor (int i = 0; i < listSize(); i++) {\nif (null != listGet(i)) {\ntempSize++;\n}\n}\nsize = tempSize;\n}\nreturn size;\n}\npublic boolean previous() {\nint previousIndex = index; // this is used to look back.\ndo {\npreviousIndex--;\nif (previousIndex < 0) {\nreturn false;\n}\n} while (!testCondition(previousIndex));\nrow--;\nindex = previousIndex;\nreturn true;\n}\n/** Moves the cursor to the specified index. */\npublic void gotoIndex(int i) {\nint newRow = -1;\nfor (int j = 0; j < listSize(); j++) {\nif (testCondition(j)) {\nnewRow++;\nif (i == j) {\nreset();\nthis.index = i;\nthis.row = newRow;\nreturn;\n}\n}\n}\nthrow new NoSuchElementException(\"Index:\" + String.valueOf(i)\n+ \" Size:\" + listSize() + \" Row:\" + newRow);\n}\nprotected boolean testCondition(int i) {\nreturn null != listGet(i);\n}\npublic int getNaturalNumber() {\nreturn getRowID() + 1;\n}\npublic void gotoRow(int newRow) {\nif (row == newRow) {\nreturn;\n}\nif (row < newRow) {\nwhile (row != newRow) {\nnext();\n}\n} else {\nwhile (row != newRow) {\nprevious();\n}\n}\nreturn;\n}\npublic static int row2index(ReadOnlyWorld w, KEY key, FreerailsPrincipal p,\nint row) {\nint count = 0;\nfor (int i = 0; i < w.size(p, key); i++) {\nif (w.get(p, key, i) != null) {\nif (count == row) {\nreturn i;\n}\ncount++;\n}\n}\nthrow new NoSuchElementException(String.valueOf(row));\n}\n}"}
{"className":"jfreerails.world.top.MapFixtureFactory","javaDoc":"/**\n* This class is used to generate fixtures for Junit tests.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class is used to generate fixtures for Junit tests.\n*\n* @author Luke\n*\n*/\npublic class MapFixtureFactory {\n/** Only subclasses should use these constants. */\npublic static final Player TEST_PLAYER = new Player(\"test player\", 0);\npublic static final FreerailsPrincipal TEST_PRINCIPAL = TEST_PLAYER\n.getPrincipal();\n/**\n* Returns a world object with a map of the specified size with the terrain\n* and cargo types setup.\n*/\npublic static World getWorld(int w, int h) {\nFreerailsTile tile = FreerailsTile.getInstance(0);\nWorld world = new WorldImpl(w, h);\ngenerateTerrainTypesList(world);\ngenerateCargoTypesList(world);\nfor (int x = 0; x < w; x++) {\nfor (int y = 0; y < w; y++) {\nworld.setTile(x, y, tile);\n}\n}\nreturn world;\n}\npublic static void generateTrackRuleList(World world) {\nTrackRule[] trackRulesArray = new TrackRule[3];\nTrackRuleProperties[] trackRuleProperties = new TrackRuleProperties[3];\nLegalTrackConfigurations[] legalTrackConfigurations = new LegalTrackConfigurations[3];\nLegalTrackPlacement[] legalTrackPlacement = new LegalTrackPlacement[3];\nHashSet<TerrainType.Category> cannotBuildOnTheseTerrainTypes = new HashSet<TerrainType.Category>();\ncannotBuildOnTheseTerrainTypes.add(TerrainType.Category.Ocean);\n// 1st track type..\nString[] trackTemplates0 = { \"000010000\", \"010010000\", \"010010010\",\n\"100111000\", \"001111000\", \"010110000\", \"100110000\", \"100011000\" };\nlegalTrackConfigurations[0] = new LegalTrackConfigurations(-1,\ntrackTemplates0);\ntrackRuleProperties[0] = new TrackRuleProperties(1, false, \"type0\",\nTrackRule.TrackCategories.track, 0, 0, 10, 0);\nlegalTrackPlacement[0] = new LegalTrackPlacement(\ncannotBuildOnTheseTerrainTypes,\nLegalTrackPlacement.PlacementRule.ANYWHERE_EXCEPT_ON_THESE);\ntrackRulesArray[0] = new TrackRuleImpl(trackRuleProperties[0],\nlegalTrackConfigurations[0], legalTrackPlacement[0]);\n// 2nd track type..\nString[] trackTemplates1 = { \"000010000\", \"010010000\", \"010010010\" };\nlegalTrackConfigurations[1] = new LegalTrackConfigurations(-1,\ntrackTemplates1);\ntrackRuleProperties[1] = new TrackRuleProperties(2, false, \"type1\",\nTrackRule.TrackCategories.track, 0, 0, 20, 0);\nlegalTrackPlacement[1] = new LegalTrackPlacement(\ncannotBuildOnTheseTerrainTypes,\nLegalTrackPlacement.PlacementRule.ANYWHERE_EXCEPT_ON_THESE);\ntrackRulesArray[1] = new TrackRuleImpl(trackRuleProperties[1],\nlegalTrackConfigurations[1], legalTrackPlacement[1]);\n// 3rd track type..\ntrackRuleProperties[2] = new TrackRuleProperties(3, false, \"type2\",\nTrackRule.TrackCategories.track, 0, 0, 30, 0);\nString[] trackTemplates2 = { \"000010000\" };\nlegalTrackConfigurations[2] = new LegalTrackConfigurations(-1,\ntrackTemplates2);\nlegalTrackPlacement[2] = new LegalTrackPlacement(\ncannotBuildOnTheseTerrainTypes,\nLegalTrackPlacement.PlacementRule.ANYWHERE_EXCEPT_ON_THESE);\ntrackRulesArray[2] = new TrackRuleImpl(trackRuleProperties[2],\nlegalTrackConfigurations[2], legalTrackPlacement[2]);\n// Add track rules to world\nfor (int i = 0; i < trackRulesArray.length; i++) {\nworld.add(SKEY.TRACK_RULES, trackRulesArray[i]);\n}\n// Add the terrain types if necessary.\nif (world.size(SKEY.TERRAIN_TYPES) == 0) {\ngenerateTerrainTypesList(world);\n}\n}\n/** Adds hard coded cargo types. */\npublic static void generateCargoTypesList(World world) {\nworld.add(SKEY.CARGO_TYPES, new CargoType(0, \"Mail\", Categories.Mail));\nworld.add(SKEY.CARGO_TYPES, new CargoType(0, \"Passengers\",\nCategories.Passengers));\nworld.add(SKEY.CARGO_TYPES, new CargoType(0, \"Goods\",\nCategories.Fast_Freight));\nworld.add(SKEY.CARGO_TYPES, new CargoType(0, \"Steel\",\nCategories.Slow_Freight));\nworld.add(SKEY.CARGO_TYPES, new CargoType(0, \"Coal\",\nCategories.Bulk_Freight));\n}\n/** Adds hard coded terrain types. */\nprivate static void generateTerrainTypesList(World world) {\nworld.add(SKEY.TERRAIN_TYPES, new TileTypeImpl(\nTerrainType.Category.Country, \"Grassland\"));\nworld.add(SKEY.TERRAIN_TYPES, new TileTypeImpl(\nTerrainType.Category.Urban, \"City\"));\nworld.add(SKEY.TERRAIN_TYPES, new TileTypeImpl(\nTerrainType.Category.Resource, \"Mine\"));\nworld.add(SKEY.TERRAIN_TYPES, new TileTypeImpl(\nTerrainType.Category.Industry, \"Factory\"));\nworld.add(SKEY.TERRAIN_TYPES, new TileTypeImpl(\nTerrainType.Category.Ocean, \"Ocean\"));\n}\n}"}
{"className":"jfreerails.world.top.WorldMapListener","javaDoc":"/**\n* Classes that need to be notified of changes to the map on the world object\n* should implement this interface.\n*\n* @author Luke Lindsay\n*\n*\n*/","code":"/**\n* Classes that need to be notified of changes to the map on the world object\n* should implement this interface.\n*\n* @author Luke Lindsay\n*\n*\n*/\npublic interface WorldMapListener {\n/**\n* Called when tiles have changed.\n*\n* @param tilesChanged\n* rectangle containing the tiles that have change; all the\n* points contained by the rectangle must be within the map's\n* bounds.\n*/\nvoid tilesChanged(Rectangle tilesChanged);\n}"}
{"className":"jfreerails.world.top.World","javaDoc":"/**\n* <p>\n* This class implements methods which can be used to alter the world. Notice\n* that in contrast to, say, <CODE>java.util.List</CODE> there is no remove()\n* method that shifts any subsequent elements to the left (subtracts one from\n* their indices). This means that an elements' position in a list can be used\n* as an address space independent way to reference the element. If you want to\n* remove an element from a list, you should set it to null, e.g.\n* </p>\n* <p>\n* <CODE>world.set(KEY.TRAINS, 5, null, player);</CODE>\n* </P>\n* <p>\n* Code that loops through lists should handle null values gracefully\n* </p>\n*\n* @author Luke\n* @author rob\n*/","code":"/**\n* <p>\n* This class implements methods which can be used to alter the world. Notice\n* that in contrast to, say, <CODE>java.util.List</CODE> there is no remove()\n* method that shifts any subsequent elements to the left (subtracts one from\n* their indices). This means that an elements' position in a list can be used\n* as an address space independent way to reference the element. If you want to\n* remove an element from a list, you should set it to null, e.g.\n* </p>\n* <p>\n* <CODE>world.set(KEY.TRAINS, 5, null, player);</CODE>\n* </P>\n* <p>\n* Code that loops through lists should handle null values gracefully\n* </p>\n*\n* @author Luke\n* @author rob\n*/\npublic interface World extends ReadOnlyWorld {\nint addActiveEntity(FreerailsPrincipal principal, Activity element);\nvoid add(FreerailsPrincipal principal, int index, Activity element);\n/**\n* Appends the specified element to the end of the specified list and returns\n* the index that can be used to retrieve it.\n*/\nint add(FreerailsPrincipal principal, KEY key, FreerailsSerializable element);\n/**\n* Appends the specified element to the end of the specified list and returns\n* the index that can be used to retrieve it.\n*\n*/\nint add(SKEY key, FreerailsSerializable element);\nint addPlayer(Player player);\n/**\n* Adds the specified transaction to the specified principal's bank account.\n*/\nvoid addTransaction(FreerailsPrincipal p, Transaction t);\n/**\n* Returns a copy of this world object - making changes to this copy will\n* not change this object.\n*/\nWorld defensiveCopy();\nActivity removeLastActiveEntity(FreerailsPrincipal principal);\nActivity removeLastActivity(FreerailsPrincipal principal, int index);\n/**\n* Removes the last element from the specified list.\n*/\nFreerailsSerializable removeLast(FreerailsPrincipal principal, KEY key);\n/**\n* Removes the last element from the specified list.\n*\n*/\nFreerailsSerializable removeLast(SKEY key);\n/**\n* Removes and returns the last transaction added the the specified\n* principal's bank account. This method is only here so that moves that add\n* transactions can be undone.\n*/\nTransaction removeLastTransaction(FreerailsPrincipal p);\nPlayer removeLastPlayer();\n/**\n* Replaces the element mapped to the specified item with the specified\n* element.\n*\n*/\nvoid set(ITEM item, FreerailsSerializable element);\n/**\n* Replaces the element at the specified position in the specified list with\n* the specified element.\n*/\nvoid set(FreerailsPrincipal principal, KEY key, int index,\nFreerailsSerializable element);\n/**\n* Replaces the element at the specified position in the specified list with\n* the specified element.\n*\n*/\nvoid set(SKEY key, int index, FreerailsSerializable element);\n/**\n* Replaces the tile at the specified position on the map with the specified\n* tile.\n*\n*/\nvoid setTile(int x, int y, FreerailsSerializable tile);\nvoid setTime(GameTime t);\n}"}
{"className":"jfreerails.world.top.WorldDiffs","javaDoc":"/**\n* An implementation of World that only stores differences relative to an\n* underlying world object. Below is some stylised code showing what this class\n* does. The <code>key</code> object could be a location on the map, a\n* position in a list etc. <code><pre>\n* HashMap underlyingWorldObject;\n*\n* HashMap differences;\n*\n* public void put(Object key, Object value) {\n* if (underlyingWorldObject.get(key).equals(value)) {\n* if (differences.containsKey(key)) {\n* differences.remove(key);\n* }\n* } else {\n* differences.put(key, value);\n* }\n* }\n*\n* public Object get(Object key) {\n* if (differences.containsKey(key)) {\n* return differences.get(key);\n* } else {\n* return underlyingWorldObject.get(key);\n* }\n* }\n* </code></pre>\n*\n* The advantages of using an instance of this class instead of a copy of the\n* world object are:\n* <ol>\n* <li> Uses less memory.</li>\n* <li> Lets you pinpoint where differences on the map are, so you don't need to\n* check every tile. </li>\n* </ol>\n*\n*\n* @author Luke\n* @version 2\n*\n*/","code":"/**\n* An implementation of World that only stores differences relative to an\n* underlying world object. Below is some stylised code showing what this class\n* does. The <code>key</code> object could be a location on the map, a\n* position in a list etc. <code><pre>\n* HashMap underlyingWorldObject;\n*\n* HashMap differences;\n*\n* public void put(Object key, Object value) {\n* if (underlyingWorldObject.get(key).equals(value)) {\n* if (differences.containsKey(key)) {\n* differences.remove(key);\n* }\n* } else {\n* differences.put(key, value);\n* }\n* }\n*\n* public Object get(Object key) {\n* if (differences.containsKey(key)) {\n* return differences.get(key);\n* } else {\n* return underlyingWorldObject.get(key);\n* }\n* }\n* </code></pre>\n*\n* The advantages of using an instance of this class instead of a copy of the\n* world object are:\n* <ol>\n* <li> Uses less memory.</li>\n* <li> Lets you pinpoint where differences on the map are, so you don't need to\n* check every tile. </li>\n* </ol>\n*\n*\n* @author Luke\n* @version 2\n*\n*/\npublic class WorldDiffs extends WorldImpl {\npublic enum LISTID {\nACTIVITY_LISTS, BANK_ACCOUNTS, CURRENT_BALANCE, ITEMS, LISTS, PLAYERS, SHARED_LISTS\n}\nprivate static final long serialVersionUID = -5993786533926919956L;\nprivate final SortedMap<ListKey, Object> listDiff;\n/** Stores the differences on the map, ImPoint are used as keys. */\nprivate final HashMap<ImPoint, Object> mapDiff;\nprivate final WorldImpl underlying;\npublic WorldDiffs(ReadOnlyWorld row){\nlistDiff = new TreeMap<ListKey, Object>();\nmapDiff = new HashMap<ImPoint, Object>();\n//Bit of a hack but it's not clear there is a better way, LL\nunderlying = (WorldImpl)row;\nactivityLists = new List3DDiff<ActivityAndTime>(listDiff,\nunderlying.activityLists, LISTID.ACTIVITY_LISTS);\nbankAccounts = new List2DDiff<TransactionAndTimeStamp>(listDiff,\nunderlying.bankAccounts, LISTID.BANK_ACCOUNTS);\ncurrentBalance = new List1DDiff<Money>(listDiff,\nunderlying.currentBalance, LISTID.CURRENT_BALANCE);\nitems = new List1DDiff<FreerailsSerializable>(listDiff,\nunderlying.items, LISTID.ITEMS);\nlists = new List3DDiff<FreerailsSerializable>(listDiff,\nunderlying.lists, LISTID.LISTS);\nplayers = new List1DDiff<Player>(listDiff, underlying.players,\nLISTID.PLAYERS);\nsharedLists = new List2DDiff<FreerailsSerializable>(listDiff,\nunderlying.sharedLists, LISTID.SHARED_LISTS);\ntime = underlying.time;\n}\n/**\n* The iterator returns instances of java.awt.Point that store the\n* coordinates of tiles that are different to the underlying world object.\n*/\npublic Iterator<ImPoint> getMapDiffs() {\nreturn mapDiff.keySet().iterator();\n}\npublic Iterator<ListKey> getListDiffs() {\nreturn listDiff.keySet().iterator();\n}\npublic Object getDiff(ListKey key){\nreturn listDiff.get(key);\n}\n@Override\npublic int getMapHeight() {\nreturn underlying.getMapHeight();\n}\n@Override\npublic int getMapWidth() {\nreturn underlying.getMapWidth();\n}\n@Override\npublic FreerailsSerializable getTile(int x, int y) {\nImPoint p = new ImPoint(x, y);\nif (this.mapDiff.containsKey(p)) {\nreturn (FreerailsSerializable) this.mapDiff.get(p);\n}\nreturn underlying.getTile(x, y);\n}\n/** Used by unit tests. */\npublic int numberOfMapDifferences() {\nreturn this.mapDiff.size();\n}\n/** Used by unit tests. */\npublic int listDiffs() {\nreturn listDiff.size();\n}\n/**\n* After this method returns, all differences are cleared and calls to\n* methods on this object should produce the same results as calls the the\n* corresponding methods on the underlying world object.\n*/\npublic void reset() {\ntime = underlying.currentTime();\nmapDiff.clear();\nlistDiff.clear();\n}\n@Override\npublic void setTile(int x, int y, FreerailsSerializable tile) {\nImPoint p = new ImPoint(x, y);\nif (Utils.equal(underlying.getTile(x, y), tile)) {\nif (this.mapDiff.containsKey(p)) {\nthis.mapDiff.remove(p);\nreturn;\n}\n} else {\nthis.mapDiff.put(p, tile);\n}\n}\npublic boolean isDifferent(){\nreturn (mapDiff.size() != 0) || (listDiff.size() != 0);\n}\npublic ReadOnlyWorld getUnderlying() {\nreturn underlying;\n}\n}"}
{"className":"jfreerails.world.top.ItemsTransactionAggregator","javaDoc":"/**\n* Adds up the number of assets.\n*\n* @author Luke\n*\n*/","code":"/**\n* Adds up the number of assets.\n*\n* @author Luke\n*\n*/\npublic class ItemsTransactionAggregator extends TransactionAggregator {\npublic static final int ANY_VALUE = Integer.MIN_VALUE;\nprivate int type = ANY_VALUE;\nprivate Transaction.Category category = null;\nprivate int[] quantities;\nprivate int quantityRunningTotal;\n/**\n* Stores the quantities and monetary values of a series of items.\n*\n* @author Luke\n*\n*/\npublic static class QuantitiesAndValues {\npublic int[] quantities;\npublic Money[] values;\n}\npublic ItemsTransactionAggregator(ReadOnlyWorld w,\nFreerailsPrincipal principal) {\nsuper(w, principal);\n}\n/**\n* Returns true if the transaction with the specified ID has an acceptable\n* type and category.\n*/\n@Override\nprotected boolean condition(int transactionID) {\nTransaction t = w.getTransaction(principal, transactionID);\nif (!(t instanceof AddItemTransaction)) {\nreturn false;\n}\nAddItemTransaction addItemTransaction = (AddItemTransaction) t;\nboolean isTypeAcceptable = (type == ANY_VALUE)\n|| (type == addItemTransaction.getType());\nboolean isCategoryAcceptable = (category == null)\n|| (category == addItemTransaction.getCategory());\nreturn isCategoryAcceptable && isTypeAcceptable;\n}\npublic int calculateQuantity() {\nQuantitiesAndValues qnv = calculateQuantitiesAndValues();\nreturn qnv.quantities[0];\n}\npublic QuantitiesAndValues calculateQuantitiesAndValues() {\nQuantitiesAndValues returnValue = new QuantitiesAndValues();\nreturnValue.values = super.calculateValues();\nreturnValue.quantities = this.quantities;\nreturn returnValue;\n}\n@Override\nprotected void incrementRunningTotal(int transactionID) {\nsuper.incrementRunningTotal(transactionID);\nTransaction t = w.getTransaction(principal, transactionID);\nAddItemTransaction addItemTransaction = (AddItemTransaction) t;\nquantityRunningTotal += addItemTransaction.getQuantity();\n}\n@Override\nprotected void setTotalsArrayLength(int length) {\nsuper.setTotalsArrayLength(length);\nquantities = new int[length];\nquantityRunningTotal = 0;\n}\n@Override\nprotected void storeRunningTotal(int timeIndex) {\n/*\n* Note, a negative sign since we are totalling the value of assets not\n* their impact on the operating funds.\n*/\nmonetaryTotals[timeIndex] = new Money(-runningTotal);\nquantities[timeIndex] = quantityRunningTotal;\n}\npublic Transaction.Category getCategory() {\nreturn category;\n}\npublic void setCategory(Transaction.Category category) {\nthis.category = category;\n}\npublic int getType() {\nreturn type;\n}\npublic void setType(int type) {\nthis.type = type;\n}\n}"}
{"className":"jfreerails.world.top.WorldIterator","javaDoc":"/**\n* This interface lets the caller access the results of a search in the\n* gameworld. It is similar in concept to <code>java.sql.ResultSet</code>.\n*\n* @author Luke\n*\n*/","code":"/**\n* This interface lets the caller access the results of a search in the\n* gameworld. It is similar in concept to <code>java.sql.ResultSet</code>.\n*\n* @author Luke\n*\n*/\npublic interface WorldIterator {\npublic static final int BEFORE_FIRST = -1;\n/**\n* Moves the cursor down one row from its current position.\n*/\nboolean next();\n/**\n* Moves the cursor up one row from its current position.\n*/\nboolean previous();\n/**\n* Moves the cursor to before the first element and updates any cached\n* values.\n*/\nvoid reset();\n/** Returns the element the cursor is pointing to. */\nFreerailsSerializable getElement();\n/**\n* Returns the index of the element the cursor is pointing to. The value\n* returned is index you would need to use in\n* <code>World.get(KEY key, int index)</code> to retrieve the same element\n* as is returned by <code>getElement()</code>\n*/\nint getIndex();\n/**\n* Returns the number of the row where the cursor is (the first row is 0).\n*/\nint getRowID();\n/** Returns the number of rows. */\nint size();\n/**\n* Moves the cursor to the specified index.\n*\n* @throws NoSuchElementException\n* if index out of range\n*/\nvoid gotoIndex(int i);\n/** Moves the cursor to the specified index. */\nvoid gotoRow(int row);\n/**\n* Returns the number of the row where the cursor is (the first row is 1).\n*/\nint getNaturalNumber();\n}"}
{"className":"jfreerails.world.top.WorldImpl","javaDoc":"/**\n* An implementation of World that uses standard java.util collections\n* internally.\n*\n* @author Luke\n*\n*/","code":"/**\n* An implementation of World that uses standard java.util collections\n* internally.\n*\n* @author Luke\n*\n*/\npublic class WorldImpl implements World {\npublic class ActivityIteratorImpl implements ActivityIterator {\npublic int activityIndex = 0;\nprivate ActivityAndTime ant;\nprivate List<ActivityAndTime> currentList;\npublic int size;\npublic ActivityIteratorImpl(int playerIndex, int index) {\ncurrentList = activityLists.get(playerIndex, index);\nsize = currentList.size();\nant = currentList.get(activityIndex);\n}\npublic double absolute2relativeTime(double t) {\ndouble dt = t - ant.startTime;\ndt = Math.min(dt, ant.act.duration());\nreturn dt;\n}\npublic Activity getActivity() {\nreturn ant.act;\n}\npublic double getDuration() {\nreturn ant.act.duration();\n}\npublic double getFinishTime() {\ndouble ticks = ant.startTime + ant.act.duration();\nreturn ticks;\n}\npublic double getStartTime() {\nreturn ant.startTime;\n}\npublic FreerailsSerializable getState(double t) {\ndouble dt = absolute2relativeTime(t);\nreturn ant.act.getState(dt);\n}\npublic boolean hasNext() {\nreturn (activityIndex + 1) < size;\n}\npublic void nextActivity() {\nif (!hasNext()) {\nthrow new NoSuchElementException();\n}\nactivityIndex++;\nant = currentList.get(activityIndex);\n}\npublic void gotoLastActivity() {\nactivityIndex = size - 1;\nant = currentList.get(activityIndex);\n}\npublic boolean hasPrevious() {\nreturn activityIndex >= 1;\n}\npublic void previousActivity() throws NoSuchElementException {\nif (!hasPrevious()) {\nthrow new NoSuchElementException();\n}\nactivityIndex--;\nant = currentList.get(activityIndex);\n}\n}\npublic static class ActivityAndTime implements FreerailsSerializable {\nprivate static final long serialVersionUID = -5149207279086814649L;\npublic final Activity act;\npublic final double startTime;\nActivityAndTime(Activity act, double time) {\nthis.act = act;\nstartTime = time;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ActivityAndTime))\nreturn false;\nfinal ActivityAndTime activityAndTime = (ActivityAndTime) o;\nif (!act.equals(activityAndTime.act))\nreturn false;\nif (startTime != activityAndTime.startTime)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = act.hashCode();\nresult = 29 * result + (int) startTime;\nreturn result;\n}\n}\nprivate static final long serialVersionUID = 3544393612684505393L;\n/** A 3D list: D1 is player, D2 is train id, D3 is train position. */\nList3D<ActivityAndTime> activityLists;\n/** A 2D list: D1 is player, D2 is transaction. */\nList2D<TransactionAndTimeStamp> bankAccounts;\nList1D<Money> currentBalance;\nList1D<FreerailsSerializable> items;\n/** A 3D list: D1 is player, D2 is type, D3 is element. */\nList3D<FreerailsSerializable> lists;\nFreerailsSerializable[][] map;\nList1D<Player> players;\n/** A 2D list: D1 is type, D2 is element. */\nList2D<FreerailsSerializable> sharedLists;\nGameTime time = GameTime.BIG_BANG;\npublic WorldImpl() {\nthis(0, 0);\n}\npublic WorldImpl(int mapWidth, int mapHeight) {\nactivityLists = new List3DImpl<ActivityAndTime>(0, 0);\nbankAccounts = new List2DImpl<TransactionAndTimeStamp>(0);\ncurrentBalance = new List1DImpl<Money>();\nitems = new List1DImpl<FreerailsSerializable>(ITEM.getNumberOfKeys());\nlists = new List3DImpl<FreerailsSerializable>(0, KEY.getNumberOfKeys());\nplayers = new List1DImpl<Player>();\nsharedLists = new List2DImpl<FreerailsSerializable>(SKEY\n.getNumberOfKeys());\ntime = GameTime.BIG_BANG;\nsetupItems();\nsetupMap(mapWidth, mapHeight);\n}\n@SuppressWarnings(\"unchecked\")\npublic void add(FreerailsPrincipal p, int index, Activity element) {\nint playerIndex = p.getWorldIndex();\nint lastID = activityLists.sizeD3(playerIndex, index) - 1;\nActivityAndTime last = activityLists.get(playerIndex, index, lastID);\ndouble duration = last.act.duration();\ndouble lastFinishTime = last.startTime + duration;\ndouble thisStartTime = Math.max(lastFinishTime, currentTime()\n.getTicks());\nActivityAndTime ant = new ActivityAndTime(element, thisStartTime);\nactivityLists.addD3(playerIndex, index, ant);\n}\npublic int add(FreerailsPrincipal p, KEY key, FreerailsSerializable element) {\nint playerIndex = p.getWorldIndex();\nreturn lists.addD3(playerIndex, key.getKeyID(), element);\n}\npublic int add(SKEY key, FreerailsSerializable element) {\nreturn sharedLists.addD2(key.getKeyID(), element);\n}\npublic int addActiveEntity(FreerailsPrincipal p, Activity element) {\nint playerIndex = p.getWorldIndex();\nint index = activityLists.addD2(playerIndex);\nActivityAndTime ant = new ActivityAndTime(element, currentTime()\n.getTicks());\nactivityLists.addD3(playerIndex, index, ant);\nreturn index;\n}\n/**\n* @param player\n* Player to add\n* @return index of the player\n*/\npublic int addPlayer(Player player) {\nif (null == player) {\nthrow new NullPointerException();\n}\nint index = players.add(player);\nbankAccounts.addD1();\ncurrentBalance.add(new Money(0));\nlists.addD1();\nfor (int i = 0; i < KEY.getNumberOfKeys(); i++) {\nlists.addD2(index);\n}\nactivityLists.addD1();\nreturn index;\n}\npublic void addTransaction(FreerailsPrincipal p, Transaction t) {\nint playerIndex = p.getWorldIndex();\nTransactionAndTimeStamp tats = new TransactionAndTimeStamp(t, time);\nbankAccounts.addD2(playerIndex, tats);\nMoney oldBalance = currentBalance.get(playerIndex);\nMoney newBalance = new Money(t.deltaCash().getAmount()\n+ oldBalance.getAmount());\ncurrentBalance.set(playerIndex, newBalance);\n}\npublic boolean boundsContain(FreerailsPrincipal p, KEY k, int index) {\nif (!isPlayer(p)) {\nreturn false;\n} else if (index >= 0 && index < this.size(p, k)) {\nreturn true;\n} else {\nreturn false;\n}\n}\npublic boolean boundsContain(int x, int y) {\nif (x >= 0 && x < getMapWidth() && y >= 0 && y < getMapHeight()) {\nreturn true;\n}\nreturn false;\n}\npublic boolean boundsContain(SKEY k, int index) {\nreturn (index >= 0 && index < this.size(k));\n}\npublic GameTime currentTime() {\nreturn time;\n}\npublic World defensiveCopy() {\nreturn (World) Utils.cloneBySerialisation(this);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof WorldImpl) {\nWorldImpl test = (WorldImpl) o;\n// Compare players\nint numberOfPlayers = getNumberOfPlayers();\nif (numberOfPlayers != test.getNumberOfPlayers())\nreturn false;\nfor (int i = 0; i < numberOfPlayers; i++) {\nif (!getPlayer(i).equals(test.getPlayer(i)))\nreturn false;\n}\n// Compare lists\nif (!lists.equals(test.lists)) {\nreturn false;\n}\nif (!sharedLists.equals(test.sharedLists)) {\nreturn false;\n}\nif (!activityLists.equals(test.activityLists)) {\nreturn false;\n}\nif (!items.equals(test.items)) {\nreturn false;\n}\nif (!bankAccounts.equals(test.bankAccounts)) {\nreturn false;\n}\n// Compare maps\nif ((this.getMapWidth() != test.getMapWidth())\n|| (this.getMapHeight() != test.getMapHeight())) {\nreturn false;\n}\nfor (int x = 0; x < this.getMapWidth(); x++) {\nfor (int y = 0; y < this.getMapHeight(); y++) {\nif (!getTile(x, y).equals(test.getTile(x, y))) {\nreturn false;\n}\n}\n}\n// phew!\nreturn true;\n}\nreturn false;\n}\npublic FreerailsSerializable get(FreerailsPrincipal p, KEY key, int index) {\nint playerIndex = p.getWorldIndex();\nreturn lists.get(playerIndex, key.getKeyID(), index);\n}\npublic FreerailsSerializable get(ITEM item) {\nreturn items.get(item.getKeyID());\n}\npublic FreerailsSerializable get(SKEY key, int index) {\nreturn sharedLists.get(key.getKeyID(), index);\n}\npublic ActivityIterator getActivities(final FreerailsPrincipal p, int index) {\nfinal int playerIndex = p.getWorldIndex();\nreturn new ActivityIteratorImpl(playerIndex, index);\n}\npublic Money getCurrentBalance(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nreturn currentBalance.get(playerIndex);\n}\npublic int getID(FreerailsPrincipal p) {\nreturn p.getWorldIndex();\n}\npublic int getMapHeight() {\nif (map.length == 0) {\n// When the map size is 0*0 we get a\n// java.lang.ArrayIndexOutOfBoundsException: 0\n// if we don't have the check above.\nreturn 0;\n}\nreturn map[0].length;\n}\npublic int getMapWidth() {\nreturn map.length;\n}\npublic int getNumberOfPlayers() {\nreturn players.size();\n}\npublic int getNumberOfTransactions(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nreturn bankAccounts.sizeD2(playerIndex);\n}\npublic Player getPlayer(int i) {\nreturn players.get(i);\n}\npublic FreerailsSerializable getTile(int x, int y) {\nreturn map[x][y];\n}\npublic Transaction getTransaction(FreerailsPrincipal p, int i) {\nint playerIndex = p.getWorldIndex();\nTransactionAndTimeStamp tats = bankAccounts.get(playerIndex, i);\nreturn tats.getT();\n}\npublic GameTime getTransactionTimeStamp(FreerailsPrincipal p, int i) {\nint playerIndex = p.getWorldIndex();\nTransactionAndTimeStamp tats = bankAccounts.get(playerIndex, i);\nreturn tats.getTimeStamp();\n}\npublic Pair<Transaction, GameTime> getTransactionAndTimeStamp(\nFreerailsPrincipal p, int i) {\nint playerIndex = p.getWorldIndex();\nTransactionAndTimeStamp tats = bankAccounts.get(playerIndex, i);\nreturn new Pair<Transaction, GameTime>(tats.getT(), tats.getTimeStamp());\n}\n@Override\npublic int hashCode() {\nint result;\nresult = players.size();\nreturn result;\n}\npublic boolean isPlayer(FreerailsPrincipal p) {\nif (p.getWorldIndex() >= 0 && p.getWorldIndex() < players.size()) {\nreturn true;\n} else {\nreturn false;\n}\n}\npublic FreerailsSerializable removeLast(FreerailsPrincipal p, KEY key) {\nint playerIndex = p.getWorldIndex();\nreturn lists.removeLastD3(playerIndex, key.getKeyID());\n}\npublic FreerailsSerializable removeLast(SKEY key) {\nreturn sharedLists.removeLastD2(key.getKeyID());\n}\npublic Activity removeLastActiveEntity(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nint lastID = activityLists.sizeD2(playerIndex) - 1;\nActivity act = activityLists.removeLastD3(playerIndex, lastID).act;\nactivityLists.removeLastD2(playerIndex);\nreturn act;\n}\npublic Activity removeLastActivity(FreerailsPrincipal p, int index) {\nint playerIndex = p.getWorldIndex();\nif (activityLists.sizeD3(playerIndex, index) < 2)\nthrow new IllegalStateException();\nActivity act = activityLists.removeLastD3(playerIndex, index).act;\nreturn act;\n}\n/**\n* Removes the last player to be added.\n*\n* @return the player that was removed.\n* @throws IllegalStateException\n* if any elements belonging to the player have not been\n* removed.\n*/\npublic Player removeLastPlayer() {\nint playerID = bankAccounts.removeLastD1();\nwhile (lists.sizeD2(playerID) > 0)\nlists.removeLastD2(playerID);\nlists.removeLastD1();\ncurrentBalance.removeLast();\nactivityLists.removeLastD1();\nreturn players.removeLast();\n}\npublic Transaction removeLastTransaction(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nTransactionAndTimeStamp tats = bankAccounts.removeLastD2(playerIndex);\nMoney oldBalance = currentBalance.get(playerIndex);\nMoney newBalance = new Money(oldBalance.getAmount()\n- tats.getT().deltaCash().getAmount());\ncurrentBalance.set(playerIndex, newBalance);\nreturn tats.getT();\n}\npublic void set(FreerailsPrincipal p, KEY key, int index,\nFreerailsSerializable element) {\nint playerIndex = p.getWorldIndex();\nlists.set(playerIndex, key.getKeyID(), index, element);\n}\npublic void set(ITEM item, FreerailsSerializable element) {\nitems.set(item.getKeyID(), element);\n}\npublic void set(SKEY key, int index, FreerailsSerializable element) {\nsharedLists.set(key.getKeyID(), index, element);\n}\npublic void setTile(int x, int y, FreerailsSerializable element) {\nmap[x][y] = element;\n}\npublic void setTime(GameTime t) {\ntime = t;\n}\nvoid setupItems() {\nthis.set(ITEM.CALENDAR, new GameCalendar(1200, 1840));\ntime = new GameTime(0);\nthis.set(ITEM.ECONOMIC_CLIMATE, EconomicClimate.MODERATION);\n}\npublic void setupMap(int mapWidth, int mapHeight) {\nmap = new FreerailsSerializable[mapWidth][mapHeight];\nfor (int x = 0; x < mapWidth; x++) {\nfor (int y = 0; y < mapHeight; y++) {\nmap[x][y] = FreerailsTile.NULL;\n}\n}\n}\npublic int size(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nreturn activityLists.sizeD2(playerIndex);\n}\npublic int size(FreerailsPrincipal p, KEY key) {\nint playerIndex = p.getWorldIndex();\nreturn lists.sizeD3(playerIndex, key.getKeyID());\n}\npublic int size(SKEY key) {\nreturn sharedLists.sizeD2(key.getKeyID());\n}\npublic int getNumberOfActiveEntities(FreerailsPrincipal p) {\nint playerIndex = p.getWorldIndex();\nreturn activityLists.sizeD2(playerIndex);\n}\n}"}
{"className":"jfreerails.world.top.WorldListListener","javaDoc":"/**\n* Classes that need to be notified of changes to the lists on the world object\n* should implement this interface.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Classes that need to be notified of changes to the lists on the world object\n* should implement this interface.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface WorldListListener {\nvoid listUpdated(KEY key, int index, FreerailsPrincipal principal);\nvoid itemAdded(KEY key, int index, FreerailsPrincipal principal);\nvoid itemRemoved(KEY key, int index, FreerailsPrincipal principal);\n}"}
{"className":"jfreerails.world.top.KEY","javaDoc":"/**\n* <p>\n* This class provides a set of keys to access the lists of elements in the game\n* world that are indexed by player.\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/","code":"/**\n* <p>\n* This class provides a set of keys to access the lists of elements in the game\n* world that are indexed by player.\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/\n@jfreerails.util.InstanceControlled\npublic class KEY implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257572793275987001L;\n/** Maps key numbers to KEYs. */\nprivate static final KEY[] keys = new KEY[15];\n// START OF KEYS\npublic static final KEY TRAINS = new KEY();\n// public static final KEY TRAIN_POSITIONS = new KEY();\npublic static final KEY STATIONS = new KEY();\n/** The cargo waiting at stations or carried by trains. */\npublic static final KEY CARGO_BUNDLES = new KEY();\npublic static final KEY TRAIN_SCHEDULES = new KEY();\n// END OF KEYS\nprivate static int numberOfKeys;\nprivate final int keyNumber;\nprivate KEY() {\nthis.keyNumber = numberOfKeys;\nkeys[keyNumber] = this;\nnumberOfKeys++;\n}\nstatic int getNumberOfKeys() {\nreturn numberOfKeys;\n}\nint getKeyID() {\nreturn keyNumber;\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn keys[this.keyNumber];\n}\n@Override\npublic String toString() {\nreturn Utils.findConstantFieldName(this);\n}\npublic static KEY getKey(int keyNum) {\nreturn keys[keyNum];\n}\n}"}
{"className":"jfreerails.world.top.TypeID","javaDoc":"/**\n* This class stores an SKEY and an item index.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* This class stores an SKEY and an item index.\n*\n* @author Luke Lindsay\n*/\npublic class TypeID {\nprivate final int id;\nprivate final SKEY key;\npublic TypeID(int id, SKEY key) {\nthis.id = id;\nthis.key = key;\n}\npublic SKEY getKey() {\nreturn key;\n}\npublic int getID() {\nreturn id;\n}\n}"}
{"className":"jfreerails.world.top.SKEY","javaDoc":"/**\n* <p>\n* This class provides a set of keys to access the lists of elements in the game\n* world that are shared by all players.\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/","code":"/**\n* <p>\n* This class provides a set of keys to access the lists of elements in the game\n* world that are shared by all players.\n* </P>\n*\n* <p>\n* It implements the typesafe enum pattern (see Bloch, <I>Effective Java</I>\n* item 21)\n* </p>\n*\n* @author Luke\n*/\n@jfreerails.util.InstanceControlled\npublic class SKEY implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257847679739506737L;\n/** Maps key numbers to KEYs. */\nprivate static final SKEY[] keys = new SKEY[getNumberOfKeys()];\n// START OF KEYS\npublic static final SKEY TERRAIN_TYPES = new SKEY();\npublic static final SKEY WAGON_TYPES = new SKEY();\npublic static final SKEY CARGO_TYPES = new SKEY();\npublic static final SKEY CITIES = new SKEY();\npublic static final SKEY ENGINE_TYPES = new SKEY();\npublic static final SKEY TRACK_RULES = new SKEY();\n// END OF SKEYS\nprivate static int numberOfKeys;\nprivate final int keyNumber;\nprivate SKEY() {\nthis.keyNumber = numberOfKeys;\nkeys[keyNumber] = this;\nnumberOfKeys++;\n}\nstatic int getNumberOfKeys() {\nreturn SKEY.class.getFields().length;\n}\nint getKeyID() {\nreturn keyNumber;\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn keys[this.keyNumber];\n}\n@Override\npublic String toString() {\nreturn Utils.findConstantFieldName(this);\n}\nstatic SKEY getKey(int keyNum) {\nreturn keys[keyNum];\n}\n}"}
{"className":"jfreerails.world.top.WagonAndEngineTypesFactory","javaDoc":"/**\n* This class adds hard coded wagon and engine types to the World. Later the\n* wagon and engine types will be defined in an xml file, but this will do for\n* now.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class adds hard coded wagon and engine types to the World. Later the\n* wagon and engine types will be defined in an xml file, but this will do for\n* now.\n*\n* @author Luke\n*\n*/\npublic class WagonAndEngineTypesFactory {\npublic void addTypesToWorld(World w) {\n// Wagon types\nWagonType[] wagonTypes = new WagonType[] {\nnew WagonType(\"Mail\", WagonType.MAIL),\nnew WagonType(\"Passengers\", WagonType.PASSENGER),\nnew WagonType(\"Livestock\", WagonType.FAST_FREIGHT),\nnew WagonType(\"Coffee\", WagonType.SLOW_FREIGHT),\nnew WagonType(\"Wood\", WagonType.BULK_FREIGHT), };\nfor (int i = 0; i < wagonTypes.length; i++) {\nw.add(SKEY.WAGON_TYPES, wagonTypes[i]);\n}\n// Engine types\nEngineType[] engineTypes = new EngineType[] {\nnew EngineType(\"Grasshopper\", 1000, new Money(10000), 10,\nnew Money(100)),\nnew EngineType(\"Norris\", 1000, new Money(10000), 15, new Money(\n100)), };\nfor (int i = 0; i < engineTypes.length; i++) {\nw.add(SKEY.ENGINE_TYPES, engineTypes[i]);\n}\n}\n}"}
{"className":"jfreerails.world.top.GameRules","javaDoc":"/**\n* Stores rules governing what players are allowed to do, for example whether\n* they can connect their track to the track of other players.\n*\n* @author Luke\n*\n*/","code":"/**\n* Stores rules governing what players are allowed to do, for example whether\n* they can connect their track to the track of other players.\n*\n* @author Luke\n*\n*/\npublic class GameRules implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3258125847557978416L;\nprivate final boolean canConnect2OtherRRTrack;\nprivate final boolean mustConnect2ExistingTrack;\npublic static final GameRules DEFAULT_RULES = new GameRules(true, false);\npublic static final GameRules NO_RESTRICTIONS = new GameRules(false, true);\n@Override\npublic int hashCode() {\nint result;\nresult = (canConnect2OtherRRTrack ? 1 : 0);\nresult = 29 * result + (mustConnect2ExistingTrack ? 1 : 0);\nreturn result;\n}\nprivate GameRules(boolean mustConnect, boolean canConnect2others) {\ncanConnect2OtherRRTrack = canConnect2others;\nmustConnect2ExistingTrack = mustConnect;\n}\npublic synchronized boolean isCanConnect2OtherRRTrack() {\nreturn canConnect2OtherRRTrack;\n}\npublic synchronized boolean isMustConnect2ExistingTrack() {\nreturn mustConnect2ExistingTrack;\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof GameRules)) {\nreturn false;\n}\nGameRules test = (GameRules) obj;\nreturn this.canConnect2OtherRRTrack == test.canConnect2OtherRRTrack\n&& this.mustConnect2ExistingTrack == test.mustConnect2ExistingTrack;\n}\n}"}
{"className":"jfreerails.world.top.TransactionAggregator","javaDoc":"/**\n*\n* Adds up the value of transactions. Implements GoF Template Method pattern.\n* Subclasses that aggregate a monetary sum should only override the method\n* <code>condition(int)</code>; subclasses that aggregate a non-monetary sum\n* should override all 4 protected methods.\n*\n*\n* @author Luke\n*\n*/","code":"/**\n*\n* Adds up the value of transactions. Implements GoF Template Method pattern.\n* Subclasses that aggregate a monetary sum should only override the method\n* <code>condition(int)</code>; subclasses that aggregate a non-monetary sum\n* should override all 4 protected methods.\n*\n*\n* @author Luke\n*\n*/\npublic abstract class TransactionAggregator {\nprotected final ReadOnlyWorld w;\nprotected final FreerailsPrincipal principal;\nprotected Money[] monetaryTotals;\nprotected int runningTotal = 0;\nprivate final GameTime[] DEFAULT_INTERVAL = new GameTime[] {\nGameTime.BIG_BANG, GameTime.END_OF_THE_WORLD };\nprivate GameTime[] timeValues = DEFAULT_INTERVAL;\npublic GameTime[] getTimes() {\n// return defensive copy.\nreturn timeValues.clone();\n}\npublic void setTimes(GameTime[] times) {\nif (1 > times.length) {\nthrow new IllegalArgumentException(\n\"There must be at least two values.\");\n}\ntimeValues = new GameTime[times.length];\ntimeValues[0] = times[0]; // since we start counting at 1.\nfor (int i = 1; i < times.length; i++) {\nif (times[i].getTicks() < times[i - 1].getTicks()) {\nthrow new IllegalArgumentException(\"Time at index \" + (i - 1)\n+ \" > time at index \" + i + \".\");\n}\ntimeValues[i] = times[i];\n}\n}\npublic TransactionAggregator(ReadOnlyWorld w, FreerailsPrincipal principal) {\nthis.w = w;\nthis.principal = principal;\n}\n/** Returns the sum of the appropriate transactions. Do not override. */\nfinal public Money calculateValue() {\nMoney[] values = calculateValues();\nreturn values[0];\n}\n/**\n* Returns the sum of the appropriate transactions up to (inclusive) each of\n* the specified times. Do not override.\n*/\nfinal public Money[] calculateValues() {\nsetTotalsArrayLength(timeValues.length - 1);\nint timeIndex = 0;\nint numberOfTransactions = w.getNumberOfTransactions(this.principal);\nsetTotalsArrayLength(timeValues.length - 1);\nfor (int i = 0; i < numberOfTransactions; i++) {\nGameTime time = w.getTransactionTimeStamp(principal, i);\nint transactionTime = time.getTicks();\nwhile (timeValues[timeIndex].getTicks() <= transactionTime) {\nstoreTotalIfAppropriate(timeIndex);\ntimeIndex++;\nif (timeIndex >= timeValues.length) {\n/*\n* The current transaction occurred after the last of the\n* specified times.\n*/\nreturn monetaryTotals;\n}\n}\nif (timeIndex > 0 && condition(i)) {\nincrementRunningTotal(i);\n}\n}\n/*\n* There are no more transactions and the last transaction occurred\n* before one or more of the specified times.\n*/\nwhile (timeIndex < timeValues.length) {\nstoreTotalIfAppropriate(timeIndex);\ntimeIndex++;\n}\nreturn monetaryTotals;\n}\nprivate void storeTotalIfAppropriate(int timeIndex) {\nif (timeIndex > 0) {\nstoreRunningTotal(timeIndex - 1);\n}\n}\n/**\n* Creates a new array with the specified length to store monetary totals\n* and sets the running total to zero. Subclasses that aggregate other\n* quantities should override this method and create the appropriate arrays.\n*/\nprotected void setTotalsArrayLength(int length) {\nmonetaryTotals = new Money[length];\nrunningTotal = 0;\n}\nprotected void incrementRunningTotal(int transactionID) {\nTransaction t = w.getTransaction(principal, transactionID);\nrunningTotal += t.deltaCash().getAmount();\n}\n/**\n* Stores the current running total in the totals array at the specified\n* position.\n*/\nprotected void storeRunningTotal(int timeIndex) {\nmonetaryTotals[timeIndex] = new Money(runningTotal);\n}\n/** Returns true if we should count the specified transactions. */\nabstract protected boolean condition(int transactionID);\n}"}
{"className":"jfreerails.world.cargo.MutableCargoBundle","javaDoc":"/**\n* This CargoBundle implementation uses a <code>java.util.SortedMap</code> to\n* map quantities to cargo batches.\n*\n* @author Luke\n*\n*/","code":"/**\n* This CargoBundle implementation uses a <code>java.util.SortedMap</code> to\n* map quantities to cargo batches.\n*\n* @author Luke\n*\n*/\npublic class MutableCargoBundle implements CargoBundle {\nprivate final SortedMap<CargoBatch, Integer> sortedMap;\nprivate int updateID = 0;\npublic MutableCargoBundle() {\nsortedMap = new TreeMap<CargoBatch, Integer>();\n}\npublic MutableCargoBundle(ImmutableCargoBundle imcb) {\nthis();\nIterator<CargoBatch> it = imcb.cargoBatchIterator();\nwhile (it.hasNext()) {\nCargoBatch cb = it.next();\naddCargo(cb, imcb.getAmount(cb));\n}\n}\npublic void addCargo(CargoBatch cb, int amount) {\nint amountAlready = this.getAmount(cb);\nthis.setAmount(cb, amount + amountAlready);\nupdateID++;\n}\n/**\n* Note, calling hasNext() or next() on the returned iterator throws a\n* ConcurrentModificationException if this CargoBundle has changed since the\n* iterator was acquired.\n*/\npublic Iterator<CargoBatch> cargoBatchIterator() {\nfinal Iterator<CargoBatch> it = sortedMap.keySet().iterator();\n/*\n* A ConcurrentModificationException used to get thrown when the amount\n* of cargo was set to 0, since this resulted in the key being removed\n* from the hashmap. The iterator below throws a\n* ConcurrentModificationException whenever this CargoBundle has been\n* changed since the iterator was acquired. This should mean that if the\n* cargo bundle gets changed while the iterator is in use, you will know\n* about it straight away.\n*/\nreturn new Iterator<CargoBatch>() {\nfinal int updateIDAtCreation = updateID;\npublic boolean hasNext() {\nif (updateIDAtCreation != updateID) {\nthrow new ConcurrentModificationException();\n}\nreturn it.hasNext();\n}\npublic CargoBatch next() {\nif (updateIDAtCreation != updateID) {\nthrow new ConcurrentModificationException();\n}\nreturn it.next();\n}\npublic void remove() {\nthrow new UnsupportedOperationException(\n\"Use CargoBundle.setAmount(CargoBatch cb, 0)\");\n}\n};\n}\npublic boolean contains(CargoBatch cb) {\nreturn sortedMap.containsKey(cb);\n}\n@Override\npublic boolean equals(Object arg0) {\nif (null == arg0) {\nreturn false;\n}\nif (!(arg0 instanceof CargoBundle)) {\nreturn false;\n}\nreturn ImmutableCargoBundle.equals(this, (CargoBundle) arg0);\n}\npublic int getAmount(CargoBatch cb) {\nif (contains(cb)) {\nInteger i = sortedMap.get(cb);\nreturn i.intValue();\n}\nreturn 0;\n}\npublic int getAmount(int cargoType) {\nIterator<CargoBatch> it = cargoBatchIterator();\nint amount = 0;\nwhile (it.hasNext()) {\nCargoBatch cb = it.next();\nif (cb.getCargoType() == cargoType) {\namount += getAmount(cb);\n}\n}\nreturn amount;\n}\n@Override\npublic int hashCode() {\nreturn sortedMap.size();\n}\npublic void setAmount(CargoBatch cb, int amount) {\nif (0 == amount) {\nsortedMap.remove(cb);\n} else {\nsortedMap.put(cb, new Integer(amount));\n}\nupdateID++;\n}\npublic int size() {\nreturn sortedMap.size();\n}\npublic ImmutableCargoBundle toImmutableCargoBundle() {\nreturn new ImmutableCargoBundle(sortedMap);\n}\n@Override\npublic String toString() {\nreturn toImmutableCargoBundle().toString();\n}\n}"}
{"className":"jfreerails.world.cargo.CargoBundle","javaDoc":null,"code":"public interface CargoBundle {\n/**\n* Note, calling hasNext() or next() on the returned iterator throws a\n* ConcurrentModificationException if this CargoBundle has changed since the\n* iterator was acquired.\n*/\nIterator<CargoBatch> cargoBatchIterator();\nboolean contains(CargoBatch cb);\nint getAmount(CargoBatch cb);\nint getAmount(int cargoType);\nint size();\n}"}
{"className":"jfreerails.world.cargo.CargoType","javaDoc":"/**\n* Represents a type of cargo.\n*\n* @author luke\n*/","code":"/**\n* Represents a type of cargo.\n*\n* @author luke\n*/\nfinal public class CargoType implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3834874680581369912L;\npublic enum Categories {\nMail(0), Passengers(1), Fast_Freight(2), Slow_Freight(3), Bulk_Freight(\n4);\nprivate int nr;\nprivate Categories(int nr) {\nthis.nr = nr;\n}\npublic int getNumber() {\nreturn nr;\n}\npublic static Categories getCategory(String cat) {\nfor (Categories cmp : values()) {\nif (cmp.toString().equals(cat)) {\nreturn cmp;\n}\n}\nthrow new IllegalArgumentException(\"Category:\" + cat + \" unknown.\");\n}\n};\npublic static int getNumberOfCategories() {\nreturn Categories.values().length;\n}\nprivate final Categories category;\nprivate final String name;\nprivate final int unitWeight;\npublic CargoType(int weight, String s, Categories cat) {\nunitWeight = weight;\ncategory = cat;\nname = s;\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof CargoType))\nreturn false;\nCargoType other = (CargoType) obj;\nreturn other.unitWeight == this.unitWeight && other.name.equals(name)\n&& other.category.equals(category);\n}\npublic Categories getCategory() {\nreturn category;\n}\n/** Returns the name, replacing any underscores with spaces. */\npublic String getDisplayName() {\nreturn this.name.replace('_', ' ');\n}\npublic String getName() {\nreturn name;\n}\npublic int getUnitWeight() {\nreturn unitWeight;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = unitWeight;\nresult = 29 * result + category.hashCode();\nresult = 29 * result + name.hashCode();\nreturn result;\n}\n@Override\npublic String toString() {\nreturn name;\n}\n}"}
{"className":"jfreerails.world.cargo.ImmutableCargoBundle","javaDoc":"/**\n* This class represents a bundle of cargo made up of quantities of cargo from\n* different {@link CargoBatch}s.\n* <p>\n* For example:\n* </p>\n* <table border=\"\" summary=\"example\">\n* <tr>\n* <td><strong>Cargo Batch</strong></td>\n* <td><strong>Quantity</strong></td>\n* </tr>\n* <tr>\n* <td>passengers from (1, 5) created at 01:00</td>\n* <td>2</td>\n* </tr>\n* <tr>\n* <td>passengers from (1, 5) created at 01:25</td>\n* <td>1</td>\n* </tr>\n* <tr>\n* <td>coal from (4,10) created at 02:50</td>\n* <td>8</td>\n* </tr>\n* <tr>\n* <td>mail from (6, 10) created at 04:45</td>\n* <td>10</td>\n* </tr>\n* </table>\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents a bundle of cargo made up of quantities of cargo from\n* different {@link CargoBatch}s.\n* <p>\n* For example:\n* </p>\n* <table border=\"\" summary=\"example\">\n* <tr>\n* <td><strong>Cargo Batch</strong></td>\n* <td><strong>Quantity</strong></td>\n* </tr>\n* <tr>\n* <td>passengers from (1, 5) created at 01:00</td>\n* <td>2</td>\n* </tr>\n* <tr>\n* <td>passengers from (1, 5) created at 01:25</td>\n* <td>1</td>\n* </tr>\n* <tr>\n* <td>coal from (4,10) created at 02:50</td>\n* <td>8</td>\n* </tr>\n* <tr>\n* <td>mail from (6, 10) created at 04:45</td>\n* <td>10</td>\n* </tr>\n* </table>\n*\n* @author Luke\n*\n*/\npublic class ImmutableCargoBundle implements CargoBundle, FreerailsSerializable {\npublic static final ImmutableCargoBundle EMPTY_BUNDLE = new ImmutableCargoBundle();\nprivate static final long serialVersionUID = 3257566187666814009L;\npublic static boolean equals(CargoBundle a, CargoBundle b) {\nIterator<CargoBatch> it = a.cargoBatchIterator();\nif (a.size() != b.size())\nreturn false;\nwhile (it.hasNext()) {\nCargoBatch batch = it.next();\nif (a.getAmount(batch) != b.getAmount(batch)) {\nreturn false;\n}\n}\nreturn true;\n}\nprivate final ImInts amounts;\nprivate final ImList<CargoBatch> batches;\nprivate ImmutableCargoBundle() {\nbatches = new ImList<CargoBatch>();\namounts = new ImInts();\n}\npublic ImmutableCargoBundle(SortedMap<CargoBatch, Integer> sortedMap) {\nint size = sortedMap.size();\nint[] amountsArray = new int[size];\nCargoBatch[] batchesArray = new CargoBatch[size];\nint i = 0;\nfor (CargoBatch batch : sortedMap.keySet()) {\nbatchesArray[i] = batch;\namountsArray[i] = sortedMap.get(batch);\ni++;\n}\nbatches = new ImList<CargoBatch>(batchesArray);\namounts = new ImInts(amountsArray);\n}\npublic Iterator<CargoBatch> cargoBatchIterator() {\nreturn new Iterator<CargoBatch>() {\nint index = 0;\npublic boolean hasNext() {\nreturn index < batches.size();\n}\npublic CargoBatch next() {\nCargoBatch o = batches.get(index);\nindex++;\nreturn o;\n}\npublic void remove() {\nthrow new UnsupportedOperationException();\n}\n};\n}\npublic boolean contains(CargoBatch cb) {\nfor (int i = 0; i < batches.size(); i++) {\nif (batches.get(i).equals(cb)) {\nreturn true;\n}\n}\nreturn false;\n}\n@Override\npublic boolean equals(Object arg0) {\nif (null == arg0) {\nreturn false;\n}\nif (!(arg0 instanceof CargoBundle)) {\nreturn false;\n}\nreturn equals(this, (CargoBundle) arg0);\n}\npublic int getAmount(CargoBatch cb) {\nint amount = 0;\nfor (int i = 0; i < batches.size(); i++) {\nif (batches.get(i).equals(cb)) {\namount += amounts.get(i);\n}\n}\nreturn amount;\n}\npublic int getAmount(int cargoType) {\nint amount = 0;\nfor (int i = 0; i < batches.size(); i++) {\nif (batches.get(i).getCargoType() == cargoType) {\namount += amounts.get(i);\n}\n}\nreturn amount;\n}\n@Override\npublic int hashCode() {\nreturn amounts.size();\n}\npublic int size() {\nreturn batches.size();\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(\"CargoBundle {\\n\");\nfor (int i = 0; i < batches.size(); i++) {\nsb.append(amounts.get(i));\nsb.append(\" units of cargo type \");\nsb.append(batches.get(i));\nsb.append(\"\\n\");\n}\nsb.append(\"}\");\nreturn sb.toString();\n}\n}"}
{"className":"jfreerails.world.cargo.CargoBatch","javaDoc":"/**\n* This class represents a cargo batch (cargo of the same batch is cargo of the\n* same type that was produced at the same location at the same time).\n*\n* @author Luke\n*/","code":"/**\n* This class represents a cargo batch (cargo of the same batch is cargo of the\n* same type that was produced at the same location at the same time).\n*\n* @author Luke\n*/\npublic class CargoBatch implements FreerailsSerializable,\nComparable<CargoBatch> {\nprivate static final long serialVersionUID = 3257006557605540149L;\nprivate final int cargoType;\nprivate final int sourceX;\nprivate final int sourceY;\nprivate final int stationOfOrigin;\nprivate final long timeCreated;\npublic CargoBatch(int type, int x, int y, long time, int origin) {\ncargoType = type;\nsourceX = x;\nsourceY = y;\ntimeCreated = time;\nstationOfOrigin = origin;\n}\npublic int getStationOfOrigin() {\nreturn stationOfOrigin;\n}\npublic int getCargoType() {\nreturn cargoType;\n}\npublic int getSourceX() {\nreturn sourceX;\n}\npublic int getSourceY() {\nreturn sourceY;\n}\npublic long getTimeCreated() {\nreturn timeCreated;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof CargoBatch) {\nCargoBatch test = (CargoBatch) o;\nif (test.getCargoType() == this.cargoType\n&& test.getSourceX() == this.sourceX\n&& test.sourceY == this.sourceY\n&& test.timeCreated == this.timeCreated\n&& test.stationOfOrigin == this.stationOfOrigin) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\n@Override\npublic int hashCode() {\nint result = 17;\nresult = 37 * result + this.cargoType;\nresult = 37 * result + this.sourceX;\nresult = 37 * result + this.sourceY;\nresult = 37 * result + this.stationOfOrigin;\nresult = 37 * result\n+ (int) (this.timeCreated ^ (this.timeCreated >>> 32));\nreturn result;\n}\npublic int compareTo(CargoBatch o) {\nif (timeCreated != o.timeCreated)\nreturn (int) (timeCreated - o.timeCreated);\nif (cargoType != o.cargoType)\nreturn (cargoType - o.cargoType);\nif (stationOfOrigin != o.stationOfOrigin)\nreturn (stationOfOrigin - o.stationOfOrigin);\nif (sourceX != o.sourceX)\nreturn (sourceX - o.sourceX);\nif (sourceY != o.sourceY)\nreturn (sourceY - o.sourceY);\nreturn 0;\n}\n}"}
{"className":"jfreerails.world.track.TrackConfiguration","javaDoc":"/**\n* An instance of this class represents one of the possible track configurations\n* in a map square - the combinations of directions in which track can be laid.\n* Instances of this class cannot be created and must be obtained via the static\n* methods herein.\n*\n* @author Luke\n*/","code":"/**\n* An instance of this class represents one of the possible track configurations\n* in a map square - the combinations of directions in which track can be laid.\n* Instances of this class cannot be created and must be obtained via the static\n* methods herein.\n*\n* @author Luke\n*/\nfinal public class TrackConfiguration implements FlatTrackTemplate {\nprivate static final long serialVersionUID = 3618695301330974512L;\nprivate static final ArrayList<TrackConfiguration> flatTrackConfigurations = setupConfigurations();\npublic static final int LENGTH_OF_STRAIGHT_TRACK_PIECE = 200;\n/**\n* @return the superposition of two track templates\n*/\npublic static TrackConfiguration add(FlatTrackTemplate c,\nFlatTrackTemplate v) {\n/*\n* int x=v.getX()+1; int y=v.getY()+1; int oldTemplate\n* =c.getTrackGraphicsNumber(); int newTemplate = oldTemplate | (1 <<\n* (3 * y + x));\n*/\nint newTemplate = c.get9bitTemplate() | v.get9bitTemplate();\nreturn from9bitTemplate(newTemplate);\n}\npublic static TrackConfiguration from9bitTemplate(int i) {\nreturn flatTrackConfigurations.get(i);\n}\npublic static TrackConfiguration getFlatInstance(Step v) {\nreturn from9bitTemplate(v.get9bitTemplate());\n}\npublic static TrackConfiguration getFlatInstance(String trackTemplate) {\nint i = TrackConfiguration.stringTemplate2Int(trackTemplate);\nreturn (flatTrackConfigurations.get(i));\n}\nprivate static ArrayList<TrackConfiguration> setupConfigurations() {\nArrayList<TrackConfiguration> configurations = new ArrayList<TrackConfiguration>(\n512);\nfor (int i = 0; i < 512; i++) {\nconfigurations.add(i, new TrackConfiguration(i));\n}\nreturn configurations;\n}\npublic static int stringTemplate2Int(String templateString) {\n// Hack - so that result is as expected by earlier written code.\nStringBuffer strb = new StringBuffer(templateString);\nstrb = strb.reverse();\ntemplateString = strb.toString();\n// End of hack\nreturn Integer.parseInt(templateString, 2);\n}\n/**\n* @return the TrackConfiguration representing the track section c minus the\n* track sections represented by v.\n*/\npublic static TrackConfiguration subtract(FlatTrackTemplate c,\nFlatTrackTemplate v) {\n/*\n* int x=v.getX()+1; int y=v.getY()+1; int oldTemplate\n* =c.getTrackGraphicsNumber(); int newTemplate = oldTemplate ^ (1 <<\n* (3 * y + x));\n*/\nint newTemplate = c.get9bitTemplate() & (~v.get9bitTemplate());\nreturn from9bitTemplate(newTemplate);\n}\nprivate final int length;\nprivate final int configuration;\nprivate TrackConfiguration(int configuration) {\nthis.configuration = configuration;\n// Calculate length.\nint tempLength = 0;\nStep[] vectors = Step.getList();\nfor (int i = 0; i < vectors.length; i++) {\nif (this.contains(vectors[i].get9bitTemplate())) {\ntempLength += vectors[i].getLength();\n}\n}\nlength = tempLength;\n}\npublic boolean contains(FlatTrackTemplate ftt) {\nint trackTemplate = ftt.get9bitTemplate();\nreturn contains(trackTemplate);\n}\npublic boolean contains(int trackTemplate) {\nif ((trackTemplate | this.configuration) == this.configuration) {\nreturn true;\n}\nreturn false;\n}\npublic int get8bitTemplate() {\nint newTemplate = 0;\nStep[] vectors = Step.getList();\nfor (int i = 0; i < vectors.length; i++) {\nif (this.contains(vectors[i])) {\nnewTemplate = newTemplate | vectors[i].get8bitTemplate();\n}\n}\nreturn newTemplate;\n}\n/**\n* @return an int representing this track configuration.\n*/\npublic int get9bitTemplate() {\nreturn configuration;\n}\n/**\n* Returns the length of track used in this configuration. Used to calculate\n* the cost of building track.\n*/\npublic int getLength() {\nreturn length;\n}\npublic Iterator getPossibleConfigurationsIterator() {\nreturn flatTrackConfigurations.iterator();\n}\npublic int getTrackGraphicsID() {\nreturn configuration;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (o == null || getClass() != o.getClass())\nreturn false;\nfinal TrackConfiguration that = (TrackConfiguration) o;\nif (configuration != that.configuration)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn configuration;\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn TrackConfiguration.from9bitTemplate(this.configuration);\n}\n/**\n* Returns a String representing this configuration, for example \"north,\n* south\".\n*/\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nint matches = 0;\nif (contains(TrackConfiguration.getFlatInstance(\"000010000\"))) {\nsb.append(\"tile center\");\n} else {\nsb.append(\"no tile center\");\n}\nfor (int i = 0; i < 8; i++) {\nStep v = Step.getInstance(i);\nif (contains(v)) {\nsb.append(\",\");\nsb.append(v);\nmatches++;\n}\n}\nreturn sb.toString().trim();\n}\n}"}
{"className":"jfreerails.world.track.TrackRule","javaDoc":"/**\n* Defines methods to access the properties of a track type.\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* Defines methods to access the properties of a track type.\n*\n* @author Luke Lindsay 09 October 2001\n*/\npublic interface TrackRule extends FreerailsSerializable, Comparable<TrackRule> {\npublic enum TrackCategories {\ntrack, bridge, tunnel, station, non\n}\nTrackCategories getCategory();\nboolean canBuildOnThisTerrainType(TerrainType.Category TerrainType);\nboolean isStation();\nboolean isDouble();\nMoney getPrice();\nMoney getFixedCost();\nMoney getMaintenanceCost();\nint getStationRadius();\nString getTypeName();\nboolean testTrackPieceLegality(int a9bitTemplate);\nboolean trackPieceIsLegal(TrackConfiguration config);\nint getMaximumConsecutivePieces();\nStep[] getLegalRoutes(Step directionComingFrom);\nIterator<TrackConfiguration> getLegalConfigurationsIterator();\n}"}
{"className":"jfreerails.world.track.FreerailsTile","javaDoc":"/**\n* A tile on the map.\n*\n* Instances are stored in a HashMap to avoid creating 100,000s of objects.\n*\n* @author Luke\n*/","code":"/**\n* A tile on the map.\n*\n* Instances are stored in a HashMap to avoid creating 100,000s of objects.\n*\n* @author Luke\n*/\npublic class FreerailsTile implements TerrainTile,\nFreerailsSerializable {\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (o == null || getClass() != o.getClass())\nreturn false;\nfinal FreerailsTile that = (FreerailsTile) o;\nif (terrainType != that.terrainType)\nreturn false;\nif (trackPiece != null ? !trackPiece.equals(that.trackPiece)\n: that.trackPiece != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (trackPiece != null ? trackPiece.hashCode() : 0);\nresult = 29 * result + terrainType;\nreturn result;\n}\nprivate static final long serialVersionUID = 3617574907538847544L;\npublic static final FreerailsTile NULL = new FreerailsTile(0);\nprivate final TrackPiece trackPiece;\nprivate final int terrainType;\nprivate static HashMap<FreerailsTile, FreerailsTile> instances = new HashMap<FreerailsTile, FreerailsTile>();\npublic static FreerailsTile getInstance(int terrainType) {\nFreerailsTile tile = new FreerailsTile(terrainType);\nif (instances.containsKey(tile)) {\nreturn instances.get(tile);\n}\ninstances.put(tile, tile);\nreturn tile;\n}\npublic static FreerailsTile getInstance(int terrainType,\nTrackPiece trackPiece) {\nFreerailsTile tile = new FreerailsTile(terrainType, trackPiece);\nif (instances.containsKey(tile)) {\nreturn instances.get(tile);\n}\ninstances.put(tile, tile);\nreturn tile;\n}\nprivate Object readResolve() throws ObjectStreamException {\nif (instances.containsKey(this)) {\nreturn instances.get(this);\n}\ninstances.put(this, this);\nreturn this;\n}\nprivate FreerailsTile(int terrainType) {\nthis.terrainType = terrainType;\nthis.trackPiece = NullTrackPiece.getInstance();\n}\nprivate FreerailsTile(int terrainType, TrackPiece trackPiece) {\nthis.terrainType = terrainType;\nthis.trackPiece = trackPiece;\n}\npublic int getTerrainTypeID() {\nreturn terrainType;\n}\n@Override\npublic String toString() {\nreturn \"trackPiece=\" + trackPiece.toString() + \" and terrainType is \"\n+ terrainType;\n}\npublic TrackPiece getTrackPiece() {\nreturn trackPiece;\n}\npublic boolean hasTrack(){\nreturn trackPiece.getTrackTypeID() != NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER;\n}\n}"}
{"className":"jfreerails.world.track.LegalTrackPlacement","javaDoc":"/**\n* This class encapsulates the rules governing where, that is, on what terrain,\n* track of a given type can be built.\n*\n* @author lindsal\n*/","code":"/**\n* This class encapsulates the rules governing where, that is, on what terrain,\n* track of a given type can be built.\n*\n* @author lindsal\n*/\npublic final class LegalTrackPlacement implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3616445687756437049L;\nprivate final ImHashSet<TerrainType.Category> terrainTypes;// = new\n// HashSet<TerrainType.Category>();\npublic enum PlacementRule {\nONLY_ON_THESE, ANYWHERE_EXCEPT_ON_THESE\n}\nprivate final PlacementRule placementRule;\n@Override\npublic int hashCode() {\nreturn (placementRule != null ? placementRule.hashCode() : 0);\n}\npublic LegalTrackPlacement(HashSet<TerrainType.Category> types,\nPlacementRule placementRule) {\nthis.placementRule = placementRule;\nIterator<TerrainType.Category> iterator = types.iterator();\nHashSet<TerrainType.Category> temp = new HashSet<TerrainType.Category>();\nwhile (iterator.hasNext()) {\ntemp.add(iterator.next());\n}\nterrainTypes = new ImHashSet<TerrainType.Category>(temp);\n}\npublic boolean canBuildOnThisTerrain(TerrainType.Category terrainType) {\nif (PlacementRule.ONLY_ON_THESE == placementRule) {\nreturn terrainTypes.contains(terrainType);\n}\nreturn !terrainTypes.contains(terrainType);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof LegalTrackPlacement) {\nLegalTrackPlacement test = (LegalTrackPlacement) o;\nif (this.placementRule.equals(test.getPlacementRule())\n&& this.terrainTypes.equals(test.terrainTypes)) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\npublic PlacementRule getPlacementRule() {\nreturn placementRule;\n}\n}"}
{"className":"jfreerails.world.track.EightRotationsOfTrackPieceProducer","javaDoc":"/**\n* This class provides a method to get the eight rotations of a track template.\n* E.g. if the template is: 010 010 110 it returns: 010 001 100 010 110 111 110\n* 100 000 etc.\n*\n*\n* @author Luke Lindsay\n* @version 1.0\n*/","code":"/**\n* This class provides a method to get the eight rotations of a track template.\n* E.g. if the template is: 010 010 110 it returns: 010 001 100 010 110 111 110\n* 100 000 etc.\n*\n*\n* @author Luke Lindsay\n* @version 1.0\n*/\npublic class EightRotationsOfTrackPieceProducer {\n/**\n* The method that returns the rotations.\n*\n* @param trackBlueprint\n* A 9bit value that serves as the template.\n* @return An array of 8 9-bit values that have been generated by rotating\n* the template.\n*/\npublic static int[] getRotations(int trackBlueprint) {\nint trackTemplate = trackBlueprint;\nint[] derivedTrackPieces = new int[8];\nfor (int i = 0; i < 8; i++) {\nderivedTrackPieces[i] = trackTemplate;\nboolean[][] trackTemplateBooleanArray = getTrackBooleanArray(trackTemplate);\ntrackTemplateBooleanArray = rotateTrackNodeClockwise(trackTemplateBooleanArray);\ntrackTemplate = getTrackGraphicID(trackTemplateBooleanArray);\n}\nreturn derivedTrackPieces;\n}\nprivate static boolean[][] getTrackBooleanArray(int trackGraphicInt) {\nboolean[][] trackBooleanArray = new boolean[3][3];\nfor (int y = 0; y < 3; y++) {\nfor (int x = 0; x < 3; x++) {\nif (((trackGraphicInt >> (3 * y + x)) & 1) == 1) {\ntrackBooleanArray[x][y] = true;\n}\n}\n}\nreturn trackBooleanArray;\n}\nprivate static int getTrackGraphicID(boolean[][] railsList) {\nint trackGraphicNumber = 0;\nfor (int y = 0; y < 3; y++) {\nfor (int x = 0; x < 3; x++) {\nif (railsList[x][y]) {\ntrackGraphicNumber = trackGraphicNumber\n| (1 << (3 * y + x));\n}\n}\n}\nreturn trackGraphicNumber;\n}\nprivate static boolean[][] rotateTrackNodeClockwise(boolean[][] source) {\nPoint[][] grabValueFrom = new Point[3][];\ngrabValueFrom[0] = new Point[] { new Point(0, 1), new Point(0, 0),\nnew Point(1, 0) };\ngrabValueFrom[1] = new Point[] { new Point(0, 2), new Point(1, 1),\nnew Point(2, 0) };\ngrabValueFrom[2] = new Point[] { new Point(1, 2), new Point(2, 2),\nnew Point(2, 1) };\n/*\n* I think there is a neater way of doing this, let me know if you know\n* it! Luke\n*/\nboolean[][] output = new boolean[3][3];\nfor (int y = 0; y < 3; y++) {\nfor (int x = 0; x < 3; x++) {\nPoint point = grabValueFrom[y][x];\n/*\n* y,x because of the way I defined grabValueFrom[][] above.\n*/\noutput[x][y] = source[point.x][point.y];\n}\n}\nreturn output;\n}\n}"}
{"className":"jfreerails.world.track.TrackRuleProperties","javaDoc":"/**\n* Stores some of the properties of a track type.\n*\n* @author Luke\n*/","code":"/**\n* Stores some of the properties of a track type.\n*\n* @author Luke\n*/\nfinal public class TrackRuleProperties implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3618704101752387641L;\nprivate final boolean enableDoubleTrack;\nprivate final Money maintenanceCost;\nprivate final Money price;\nprivate final Money fixedCost;\nprivate final TrackRule.TrackCategories category;\nprivate final int rGBvalue;\nprivate final int stationRadius;\nprivate final String typeName;\npublic TrackRuleProperties(int rgb, boolean doubleTrack, String name,\nTrackRule.TrackCategories c, int radius, int price,\nint maintenance, int fixedCost) {\nstationRadius = radius;\nrGBvalue = rgb;\nenableDoubleTrack = doubleTrack;\ntypeName = name;\ncategory = c;\nthis.price = new Money(price);\nthis.maintenanceCost = new Money(maintenance);\nthis.fixedCost = new Money(fixedCost);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof TrackRuleProperties) {\nTrackRuleProperties test = (TrackRuleProperties) o;\nif (rGBvalue == test.getRGBvalue()\n&& enableDoubleTrack == test.isEnableDoubleTrack()\n&& typeName.equals(test.getTypeName())\n&& category == test.category\n&& stationRadius == test.stationRadius) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\npublic Money getMaintenanceCost() {\nreturn maintenanceCost;\n}\npublic Money getPrice() {\nreturn price;\n}\nprivate int getRGBvalue() {\nreturn rGBvalue;\n}\npublic int getStationRadius() {\nreturn stationRadius;\n}\npublic String getTypeName() {\nreturn typeName;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = rGBvalue;\nresult = 29 * result + (enableDoubleTrack ? 1 : 0);\nresult = 29 * result + typeName.hashCode();\nresult = 29 * result + category.hashCode();\nresult = 29 * result + stationRadius;\nresult = 29 * result + price.hashCode();\nresult = 29 * result + fixedCost.hashCode();\nresult = 29 * result + maintenanceCost.hashCode();\nreturn result;\n}\npublic boolean isEnableDoubleTrack() {\nreturn enableDoubleTrack;\n}\npublic boolean isStation() {\nreturn category.equals(TrackRule.TrackCategories.station);\n}\npublic TrackRule.TrackCategories getCategory() {\nreturn category;\n}\npublic Money getFixedCost() {\nreturn fixedCost;\n}\n}"}
{"className":"jfreerails.world.track.TrackPiece","javaDoc":"/**\n* Defines methods to access the properties of the track on a tile.\n*\n* @author Luke\n*/","code":"/**\n* Defines methods to access the properties of the track on a tile.\n*\n* @author Luke\n*/\npublic interface TrackPiece extends FreerailsSerializable {\nint getTrackGraphicID();\nint getTrackTypeID();\nTrackRule getTrackRule();\nTrackConfiguration getTrackConfiguration();\nint getOwnerID();\n}"}
{"className":"jfreerails.world.track.TrackRuleImpl","javaDoc":"/**\n* This class encapsulates the rules that apply to a type of track node. They\n* concern: the legal routes trains can travel across the node, whether the\n* node's track can be doubled, on which terrain types it can be built, and the\n* maximum number of consecutive nodes of this type (used for bridges and\n* tunnels).\n*\n* @author Luke Lindsay 09 October 2001\n*/","code":"/**\n* This class encapsulates the rules that apply to a type of track node. They\n* concern: the legal routes trains can travel across the node, whether the\n* node's track can be doubled, on which terrain types it can be built, and the\n* maximum number of consecutive nodes of this type (used for bridges and\n* tunnels).\n*\n* @author Luke Lindsay 09 October 2001\n*/\nfinal public class TrackRuleImpl implements TrackRule {\nprivate static final long serialVersionUID = 3257281414171801401L;\nprivate final LegalTrackConfigurations legalConfigurations;\nprivate final LegalTrackPlacement legalTrackPlacement;\nprivate final TrackRuleProperties properties;\n/*\n* Track templates are 9 bit values, so there are 512 possible templates. If\n* legalTrackTemplate[x]==true, then x is a legal track-template. Example:\n* 000 111 000 This represents a horizontal straight.\n*/\npublic TrackRuleImpl(TrackRuleProperties p, LegalTrackConfigurations lc,\nLegalTrackPlacement ltp) {\nif (null == p || null == lc || null == ltp) {\nthrow new java.lang.IllegalArgumentException();\n}\nproperties = p;\nlegalConfigurations = lc;\nlegalTrackPlacement = ltp;\n}\npublic boolean canBuildOnThisTerrainType(TerrainType.Category TerrainType) {\nreturn legalTrackPlacement.canBuildOnThisTerrain(TerrainType);\n}\n/**\n* If the specified object is a track rule, comparison is by category then\n* price.\n*/\npublic int compareTo(TrackRule otherRule) {\nint comp = otherRule.getCategory().compareTo(getCategory());\nif (comp != 0) {\nreturn -comp;\n}\nlong dPrice = this.properties.getPrice().getAmount()\n- otherRule.getPrice().getAmount();\nreturn (int) dPrice;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof TrackRuleImpl) {\nTrackRuleImpl trackRuleImpl = (TrackRuleImpl) o;\nboolean propertiesFieldsEqual = this.properties\n.equals(trackRuleImpl.getProperties());\nboolean legalConfigurationsEqual = this.legalConfigurations\n.equals(trackRuleImpl.getLegalConfigurations());\nboolean legalTrackPlacementEqual = this.legalTrackPlacement\n.equals(trackRuleImpl.getLegalTrackPlacement());\nif (propertiesFieldsEqual && legalConfigurationsEqual\n&& legalTrackPlacementEqual) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\npublic TrackRule.TrackCategories getCategory() {\nreturn properties.getCategory();\n}\npublic LegalTrackConfigurations getLegalConfigurations() {\nreturn legalConfigurations;\n}\npublic Iterator<TrackConfiguration> getLegalConfigurationsIterator() {\nreturn legalConfigurations.getLegalConfigurationsIterator();\n}\npublic Step[] getLegalRoutes(Step directionComingFrom) {\n// TODO add code..\nreturn null;\n}\npublic LegalTrackPlacement getLegalTrackPlacement() {\nreturn legalTrackPlacement;\n}\npublic Money getMaintenanceCost() {\nreturn properties.getMaintenanceCost();\n}\npublic int getMaximumConsecutivePieces() {\nreturn legalConfigurations.getMaximumConsecutivePieces();\n}\npublic Money getPrice() {\nreturn this.properties.getPrice();\n}\npublic TrackRuleProperties getProperties() {\nreturn properties;\n}\npublic int getStationRadius() {\nreturn this.properties.getStationRadius();\n}\npublic String getTypeName() {\nreturn properties.getTypeName();\n}\n@Override\npublic int hashCode() {\nint result;\nresult = properties.hashCode();\nresult = 29 * result + legalConfigurations.hashCode();\nresult = 29 * result + legalTrackPlacement.hashCode();\nreturn result;\n}\npublic boolean isStation() {\nreturn properties.isStation();\n}\npublic boolean testTrackPieceLegality(int trackTemplateToTest) {\nTrackConfiguration trackConfiguration = TrackConfiguration\n.from9bitTemplate(trackTemplateToTest);\nreturn legalConfigurations\n.trackConfigurationIsLegal(trackConfiguration);\n}\n@Override\npublic String toString() {\nreturn getTypeName();\n}\npublic boolean trackPieceIsLegal(TrackConfiguration config) {\nreturn legalConfigurations.trackConfigurationIsLegal(config);\n}\npublic boolean isDouble() {\nreturn properties.isEnableDoubleTrack();\n}\npublic Money getFixedCost() {\nreturn properties.getFixedCost();\n}\n}"}
{"className":"jfreerails.world.track.TrackPieceImpl","javaDoc":"/**\n* Represents the track on a tile.\n*\n* @author Luke\n*/","code":"/**\n* Represents the track on a tile.\n*\n* @author Luke\n*/\nfinal public class TrackPieceImpl implements TrackPiece {\nprivate static final long serialVersionUID = 4049080423458027569L;\nprivate final TrackConfiguration configuration;\nprivate final TrackRule trackType;\nprivate final int ownerID;\nprivate final int ruleNumber;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (o == null || getClass() != o.getClass())\nreturn false;\nfinal TrackPieceImpl that = (TrackPieceImpl) o;\nif (ownerID != that.ownerID)\nreturn false;\nif (ruleNumber != that.ruleNumber)\nreturn false;\nif (!configuration.equals(that.configuration))\nreturn false;\nif (!trackType.equals(that.trackType))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = configuration.hashCode();\nresult = 29 * result + trackType.hashCode();\nresult = 29 * result + ownerID;\nresult = 29 * result + ruleNumber;\nreturn result;\n}\npublic TrackPieceImpl(TrackConfiguration c, TrackRule type, int owner,\nint rule) {\nconfiguration = c;\ntrackType = type;\nownerID = owner;\nruleNumber = rule;\n}\npublic int getTrackGraphicID() {\nreturn configuration.getTrackGraphicsID();\n}\npublic TrackRule getTrackRule() {\nreturn trackType;\n}\npublic TrackConfiguration getTrackConfiguration() {\nreturn configuration;\n}\npublic int getOwnerID() {\nreturn ownerID;\n}\npublic int getTrackTypeID() {\nreturn ruleNumber;\n}\n}"}
{"className":"jfreerails.world.track.LegalTrackConfigurations","javaDoc":"/**\n* Stores the legal track configurations for a type of track.\n*\n* @author Luke.\n*/","code":"/**\n* Stores the legal track configurations for a type of track.\n*\n* @author Luke.\n*/\nfinal public class LegalTrackConfigurations implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3617295631735928119L;\nprivate final ImHashSet<TrackConfiguration> legalConfigs;// = new\n// HashSet<TrackConfiguration>();\nprivate final int maximumConsecutivePieces;\npublic LegalTrackConfigurations(int max,\nArrayList<String> legalTrackTemplatesArrayList) {\nmaximumConsecutivePieces = max;\nHashSet<TrackConfiguration> temp = new HashSet<TrackConfiguration>();\n// Iterate over the track templates.\nfor (int i = 0; i < legalTrackTemplatesArrayList.size(); i++) {\nString trackTemplateString = legalTrackTemplatesArrayList.get(i);\nprocessTemplate(trackTemplateString, temp);\n}\nlegalConfigs = new ImHashSet<TrackConfiguration>(temp);\n}\npublic LegalTrackConfigurations(int max, String[] legalTrackTemplatesArray) {\nmaximumConsecutivePieces = max;\nHashSet<TrackConfiguration> temp = new HashSet<TrackConfiguration>();\nfor (int i = 0; i < legalTrackTemplatesArray.length; i++) {\nprocessTemplate(legalTrackTemplatesArray[i], temp);\n}\nlegalConfigs = new ImHashSet<TrackConfiguration>(temp);\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof LegalTrackConfigurations) {\nLegalTrackConfigurations test = (LegalTrackConfigurations) o;\nif (this.maximumConsecutivePieces == test\n.getMaximumConsecutivePieces()\n&& this.legalConfigs.equals(test.legalConfigs)) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\npublic Iterator<TrackConfiguration> getLegalConfigurationsIterator() {\nreturn legalConfigs.iterator();\n}\npublic int getMaximumConsecutivePieces() {\nreturn maximumConsecutivePieces;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = maximumConsecutivePieces;\nresult = 29 * result\n+ (legalConfigs != null ? legalConfigs.hashCode() : 0);\nreturn result;\n}\nstatic private void processTemplate(String trackTemplateString,\nHashSet<TrackConfiguration> temp) {\nint trackTemplate = Integer.parseInt(trackTemplateString, 2);\n// Check for invalid parameters.\nif ((trackTemplate > 511) || (trackTemplate < 0)) {\nthrow new IllegalArgumentException(\"trackTemplate = \"\n+ trackTemplate + \", it should be in the range 0-511\");\n}\nint[] rotationsOfTrackTemplate = EightRotationsOfTrackPieceProducer\n.getRotations(trackTemplate);\nfor (int k = 0; k < rotationsOfTrackTemplate.length; k++) {\nint i = rotationsOfTrackTemplate[k];\nTrackConfiguration trackConfiguration = TrackConfiguration\n.from9bitTemplate(i);\nif (!temp.contains(trackConfiguration)) {\ntemp.add(trackConfiguration);\n}\n}\n}\npublic boolean trackConfigurationIsLegal(\nTrackConfiguration trackConfiguration) {\nreturn legalConfigs.contains(trackConfiguration);\n}\n}"}
{"className":"jfreerails.world.track.NullTrackType","javaDoc":"/**\n* The type of a Null track piece. TODO maybe it would be simpler to get rid of\n* this and just check against null!\n*\n* @author lindsal\n*/","code":"/**\n* The type of a Null track piece. TODO maybe it would be simpler to get rid of\n* this and just check against null!\n*\n* @author lindsal\n*/\nfinal public class NullTrackType implements TrackRule {\nprivate static final long serialVersionUID = 3257849891614306614L;\npublic static final int NULL_TRACK_TYPE_RULE_NUMBER = -999;\nprivate static final NullTrackType nullTrackType = new NullTrackType();\nprivate NullTrackType() {\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn nullTrackType;\n}\npublic static NullTrackType getInstance() {\nreturn nullTrackType;\n}\npublic boolean canBuildOnThisTerrainType(TerrainType.Category TerrainType) {\nreturn true; // No track is possible anywhere.\n}\npublic Step[] getLegalRoutes(\njfreerails.world.common.Step directionComingFrom) {\nreturn new Step[0];\n}\npublic int getMaximumConsecutivePieces() {\nreturn -1;\n}\npublic String getTypeName() {\nreturn \"NullTrackType\";\n}\npublic boolean testTrackPieceLegality(int trackTemplateToTest) {\nif (trackTemplateToTest != 0) {\nreturn false;\n}\nreturn true;\n}\npublic boolean trackPieceIsLegal(TrackConfiguration config) {\nreturn testTrackPieceLegality(config.getTrackGraphicsID());\n}\npublic Iterator<TrackConfiguration> getLegalConfigurationsIterator() {\nthrow new UnsupportedOperationException(\"Method not implemented yet!\");\n}\npublic TrackPiece getTrackPiece(TrackConfiguration config, int owner) {\nthrow new UnsupportedOperationException(\"Method not implemented yet!\");\n}\npublic boolean isStation() {\nreturn false;\n}\n@Override\npublic boolean equals(Object o) {\nreturn o == this;\n}\n@Override\npublic int hashCode() {\nreturn 666;\n}\npublic int getStationRadius() {\nreturn 0;\n}\npublic Money getPrice() {\nreturn new Money(0);\n}\npublic Money getMaintenanceCost() {\nreturn new Money(0);\n}\npublic TrackCategories getCategory() {\nreturn TrackCategories.non;\n}\npublic int compareTo(TrackRule arg0) {\n// TODO Auto-generated method stub\nreturn 0;\n}\npublic boolean isDouble() {\nreturn false;\n}\npublic Money getFixedCost() {\nreturn Money.ZERO;\n}\n}"}
{"className":"jfreerails.world.track.TrackSection","javaDoc":"/**\n* Represents the track connecting two adjacent tiles.\n*\n* @author Luke\n*\n*/","code":"/**\n* Represents the track connecting two adjacent tiles.\n*\n* @author Luke\n*\n*/\npublic class TrackSection implements FreerailsSerializable {\nprivate static final long serialVersionUID = -3776624056097990938L;\nprivate final Step step;\nprivate final ImPoint tile;\npublic TrackSection(final Step step, final ImPoint tile) {\nImPoint otherTile = Step.move(tile, step);\nif(tile.compareTo(otherTile) > 0){\nthis.step = step.getOpposite();\nthis.tile = otherTile;\n}else{\nthis.step = step;\nthis.tile = tile;\n}\n}\n@Override\npublic int hashCode() {\nfinal int PRIME = 31;\nint result = 1;\nresult = PRIME * result + ((step == null) ? 0 : step.hashCode());\nresult = PRIME * result + ((tile == null) ? 0 : tile.hashCode());\nreturn result;\n}\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null)\nreturn false;\nif (getClass() != obj.getClass())\nreturn false;\nfinal TrackSection other = (TrackSection) obj;\nif (step == null) {\nif (other.step != null)\nreturn false;\n} else if (!step.equals(other.step))\nreturn false;\nif (tile == null) {\nif (other.tile != null)\nreturn false;\n} else if (!tile.equals(other.tile))\nreturn false;\nreturn true;\n}\n@Override\npublic String toString() {\nreturn tile.toString()+ \" \"+ step.toString();\n}\npublic ImPoint tileA(){\nreturn tile;\n}\npublic ImPoint tileB(){\nreturn Step.move(tile, step);\n}\n}"}
{"className":"jfreerails.world.track.NullTrackPiece","javaDoc":"/**\n* A track piece that doesn't exist - using this avoids needing to check against\n* null before calling the methods on a track piece.\n*\n* @author lindsal\n*/","code":"/**\n* A track piece that doesn't exist - using this avoids needing to check against\n* null before calling the methods on a track piece.\n*\n* @author lindsal\n*/\nfinal public class NullTrackPiece implements TrackPiece {\nprivate static final long serialVersionUID = 3258413915376268599L;\nprivate static final TrackPiece nullTrackPiece = new NullTrackPiece();\nprivate static final int NO_OWNER = Integer.MIN_VALUE;\nprivate NullTrackPiece() {\n}\npublic static TrackPiece getInstance() {\nreturn nullTrackPiece;\n}\npublic int getTrackGraphicID() {\nreturn 0;\n}\npublic TrackRule getTrackRule() {\nreturn NullTrackType.getInstance();\n}\npublic TrackConfiguration getTrackConfiguration() {\nreturn TrackConfiguration.from9bitTemplate(0);\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn nullTrackPiece;\n}\n@Override\npublic boolean equals(Object o) {\nreturn o == this;\n}\n@Override\npublic int hashCode() {\nreturn 777;\n}\npublic int getOwnerID() {\nreturn NO_OWNER;\n}\npublic int getTrackTypeID() {\nreturn NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER;\n}\n}"}
{"className":"jfreerails.world.train.TrainModel","javaDoc":"/**\n* Represents a train.\n*\n* @author Luke\n*/","code":"/**\n* Represents a train.\n*\n* @author Luke\n*/\npublic class TrainModel implements FreerailsSerializable {\npublic static final int WAGON_LENGTH = 24;\nprivate static final long serialVersionUID = 3545235825756812339L;\npublic static final int MAX_NUMBER_OF_WAGONS = 6;\npublic static final int MAX_TRAIN_LENGTH = (1 + MAX_NUMBER_OF_WAGONS)\n* WAGON_LENGTH;\nprivate final int scheduleId;\nprivate final int engineTypeId;\nprivate final ImInts wagonTypes;\nprivate final int cargoBundleId;\n@Override\npublic int hashCode() {\nint result;\nresult = scheduleId;\nresult = 29 * result + engineTypeId;\nresult = 29 * result + cargoBundleId;\nreturn result;\n}\npublic TrainModel getNewInstance(int newEngine, ImInts newWagons) {\nreturn new TrainModel(newEngine, newWagons, this.getScheduleID(), this\n.getCargoBundleID());\n}\npublic TrainModel(int engine, ImInts wagons, int scheduleID, int BundleId) {\nengineTypeId = engine;\nwagonTypes = wagons;\nscheduleId = scheduleID;\ncargoBundleId = BundleId;\n}\npublic TrainModel(ImInts wagons, int BundleId) {\nwagonTypes = wagons;\ncargoBundleId = BundleId;\nengineTypeId = 0;\nscheduleId = 0;\n}\npublic TrainModel(int engine, ImInts wagons, int scheduleID) {\nengineTypeId = engine;\nwagonTypes = wagons;\nscheduleId = scheduleID;\ncargoBundleId = 0;\n}\npublic TrainModel(int engine) {\nengineTypeId = engine;\nwagonTypes = new ImInts(0, 1, 2);\nscheduleId = 0;\ncargoBundleId = 0;\n}\npublic int getLength() {\nreturn (1 + wagonTypes.size()) * WAGON_LENGTH; // Engine + wagons.\n}\npublic boolean canAddWagon() {\nreturn wagonTypes.size() < MAX_NUMBER_OF_WAGONS;\n}\npublic int getNumberOfWagons() {\nreturn wagonTypes.size();\n}\npublic int getWagon(int i) {\nreturn wagonTypes.get(i);\n}\npublic int getEngineType() {\nreturn engineTypeId;\n}\npublic int getCargoBundleID() {\nreturn cargoBundleId;\n}\npublic int getScheduleID() {\nreturn scheduleId;\n}\npublic ImInts getConsist() {\nreturn wagonTypes;\n}\n@Override\npublic boolean equals(Object obj) {\nif (obj instanceof TrainModel) {\nTrainModel test = (TrainModel) obj;\nboolean b = this.cargoBundleId == test.cargoBundleId\n&& this.engineTypeId == test.engineTypeId\n&& this.wagonTypes.equals(test.wagonTypes)\n&& this.scheduleId == test.scheduleId;\nreturn b;\n}\nreturn false;\n}\n}"}
{"className":"jfreerails.world.train.TrainPathIterator","javaDoc":"/**\n* Exposes the path of a train. TODO needs better comment\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Exposes the path of a train. TODO needs better comment\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrainPathIterator implements FreerailsPathIterator {\nprivate static final long serialVersionUID = 3256999977816502584L;\nprivate final FreerailsIntIterator intIterator;\nprivate final PositionOnTrack p1 = new PositionOnTrack();\nprivate final PositionOnTrack p2 = new PositionOnTrack();\nprivate static final int tileSize = Constants.TILE_SIZE;\npublic TrainPathIterator(FreerailsIntIterator i) {\nintIterator = i;\np2.setValuesFromInt(intIterator.nextInt());\n}\npublic boolean hasNext() {\nreturn intIterator.hasNextInt();\n}\npublic void nextSegment(IntLine line) {\np1.setValuesFromInt(p2.toInt());\nline.x1 = p1.getX() * tileSize + tileSize / 2;\nline.y1 = p1.getY() * tileSize + tileSize / 2;\np2.setValuesFromInt(intIterator.nextInt());\nline.x2 = p2.getX() * tileSize + tileSize / 2;\nline.y2 = p2.getY() * tileSize + tileSize / 2;\n}\n}"}
{"className":"jfreerails.world.train.SpeedAgainstTime","javaDoc":null,"code":"public interface SpeedAgainstTime extends FreerailsSerializable {\n/**\n* Returns the distance travelled at time t. The returned value, s,\n* satisfies the following conditions:\n* <ol>\n* <li>s >= 0</li>\n* <li>s <= getS()</li>\n* <li>s = 0 if t = 0 </li>\n* <li>s = getS() if t = getT()</li>\n* </ol>\n*\n* @throws IllegalArgumentException\n* iff t < 0 or t > getT()\n* @return s\n*/\ndouble calcS(double t);\n/**\n* Returns the time taken to travel distance s. The returned value, t,\n* satisfies the following conditions:\n* <ol>\n* <li>t >= 0</li>\n* <li>t <= getT()</li>\n* <li>t = 0 if s = 0 </li>\n* <li>t = getT() if s = getS()</li>\n* </ol>\n*\n* @throws IllegalArgumentException\n* iff s < 0 or s > getS()\n* @return t\n*/\ndouble calcT(double s);\n/**\n* @throws IllegalArgumentException\n* iff t < 0 or t > getT()\n*/\ndouble calcV(double t);\n/**\n* @throws IllegalArgumentException\n* iff t < 0 or t > getT()\n*/\ndouble calcA(double t);\n/**\n* @return The time taken to travel the distance given by getS().\n*/\ndouble getT();\n/**\n* @return The distance traveled during at time given by getT().\n*/\ndouble getS();\n}"}
{"className":"jfreerails.world.train.Schedule","javaDoc":"/**\n* Defines methods to access a train's schedule.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Defines methods to access a train's schedule.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface Schedule {\npublic static int PRIORITY_ORDERS = 0;\npublic static final int MAXIMUM_NUMBER_OF_ORDER = 6;\nTrainOrdersModel getOrder(int i);\n/** Returns the number of the order the train is currently carry out. */\nint getOrderToGoto();\n/**\n* Returns the station number of the next station the train is scheduled to\n* stop at.\n*/\nint getStationToGoto();\n/** Returns the wagons to add at the next scheduled stop. */\nImInts getWagonsToAdd();\n/** Returns the value for the autoconsist flag at the next scheduled stop. */\nboolean autoConsist();\nboolean hasPriorityOrders();\n/**\n* Returns number of non priority orders + number of priority orders.\n*\n* @return Number of orders.\n*/\nint getNumOrders();\nint getNextScheduledOrder();\n}"}
{"className":"jfreerails.world.train.PathOnTiles","javaDoc":"/**\n* An immutable class that stores a path made up of OneTileMoveVectors.\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable class that stores a path made up of OneTileMoveVectors.\n*\n* @author Luke\n*\n*/\nstrictfp public class PathOnTiles implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3544386994122536753L;\nprivate final ImPoint start;\nprivate final ImList<Step> vectors;\n/**\n* @throws NullPointerException\n* if null == start\n* @throws NullPointerException\n* if null == vectorsList\n* @throws NullPointerException\n* if null == vectorsList.get(i) for any i;\n*/\npublic PathOnTiles(ImPoint start, List<Step> vectorsList) {\nif (null == start)\nthrow new NullPointerException();\nvectors = new ImList<Step>(vectorsList);\nvectors.checkForNulls();\nthis.start = start;\n}\n/**\n* @throws NullPointerException\n* if null == start\n* @throws NullPointerException\n* if null == vectors\n* @throws NullPointerException\n* if null == vectors[i] for any i;\n*/\npublic PathOnTiles(ImPoint start, Step... vectors) {\nif (null == start)\nthrow new NullPointerException();\nthis.vectors = new ImList<Step>(vectors);\nthis.vectors.checkForNulls();\nthis.start = start;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof PathOnTiles))\nreturn false;\nfinal PathOnTiles pathOnTiles = (PathOnTiles) o;\nif (!start.equals(pathOnTiles.start))\nreturn false;\nif (!vectors.equals(pathOnTiles.vectors))\nreturn false;\nreturn true;\n}\n/**\n* Returns the distance you would travel if you walked the all the way along\n* the path.\n*/\npublic double getTotalDistance() {\nreturn getDistance(vectors.size());\n}\npublic double getDistance(int steps) {\ndouble distanceSoFar = 0;\nfor (int i = 0; i < steps; i++) {\nStep v = vectors.get(i);\ndistanceSoFar += v.getLength();\n}\nreturn distanceSoFar;\n}\n/**\n* Returns the coordinates of the point you would be standing at if you\n* walked the specified distance along the path from the start point.\n*\n* @throws IllegalArgumentException\n* if distance < 0\n* @throws IllegalArgumentException\n* if distance > getLength()\n*/\npublic ImPoint getPoint(double distance) {\nif (0 > distance)\nthrow new IllegalArgumentException(\"distance:\" + distance + \" < 0\");\nint x = start.x * TILE_DIAMETER + TILE_DIAMETER / 2;\nint y = start.y * TILE_DIAMETER + TILE_DIAMETER / 2;\ndouble distanceSoFar = 0;\nfor (int i = 0; i < vectors.size(); i++) {\nStep v = vectors.get(i);\ndistanceSoFar += v.getLength();\nx += v.deltaX * TILE_DIAMETER;\ny += v.deltaY * TILE_DIAMETER;\nif (distanceSoFar == distance) {\nreturn new ImPoint(x, y);\n}\nif (distanceSoFar > distance) {\ndouble excess = distanceSoFar - distance;\nx -= v.deltaX * TILE_DIAMETER * excess / v.getLength();\ny -= v.deltaY * TILE_DIAMETER * excess / v.getLength();\nreturn new ImPoint(x, y);\n}\n}\nthrow new IllegalArgumentException(\"distance > getLength()\");\n}\npublic ImPoint getStart() {\nreturn start;\n}\npublic Step getStep(int i) {\nreturn vectors.get(i);\n}\npublic PositionOnTrack getFinalPosition() {\nint x = start.x;\nint y = start.y;\nfor (int i = 0; i < vectors.size(); i++) {\nStep v = vectors.get(i);\nx += v.deltaX;\ny += v.deltaY;\n}\nint i = vectors.size() - 1;\nStep finalStep = vectors.get(i);\nPositionOnTrack p = PositionOnTrack.createFacing(x, y, finalStep);\nreturn p;\n}\n/**\n* Returns the index of the step that takes the distance travelled over the\n* specified distance.\n*\n* @throws IllegalArgumentException\n* if distance < 0\n* @throws IllegalArgumentException\n* if distance > getLength()\n*/\npublic int getStepIndex(int distance) {\nif (0 > distance)\nthrow new IllegalArgumentException(\"distance < 0\");\nint distanceSoFar = 0;\nfor (int i = 0; i < vectors.size(); i++) {\nStep v = vectors.get(i);\ndistanceSoFar += v.getLength();\nif (distanceSoFar >= distance)\nreturn i;\n}\nthrow new IllegalArgumentException(\"distance > getLength()\");\n}\n@Override\npublic int hashCode() {\nreturn start.hashCode();\n}\npublic int steps() {\nreturn vectors.size();\n}\npublic PathOnTiles addSteps(Step... newSteps) {\nint oldLength = vectors.size();\nStep[] newPath = new Step[oldLength + newSteps.length];\nfor (int i = 0; i < oldLength; i++) {\nnewPath[i] = vectors.get(i);\n}\nfor (int i = 0; i < newSteps.length; i++) {\nnewPath[i + oldLength] = newSteps[i];\n}\nreturn new PathOnTiles(start, newPath);\n}\n/**\n* Returns a FreerailsPathIterator that exposes a sub section of the path\n* this object represents.\n*\n* @throws IllegalArgumentException\n* if offset < 0\n* @throws IllegalArgumentException\n* if length <= 0\n* @throws IllegalArgumentException\n* if offset + length > getLength()\n*\n*/\npublic FreerailsPathIterator subPath(double offset, double length) {\nif (offset < 0)\nthrow new IllegalArgumentException();\nif (length <= 0)\nthrow new IllegalArgumentException();\nif ((offset + length) > getTotalDistance())\nthrow new IllegalArgumentException(offset +\" + \"+ length+\" > \" +getTotalDistance());\nfinal LinkedList<ImPoint> points = new LinkedList<ImPoint>();\nImPoint tile = getStart();\nint tileX = tile.x;\nint tileY = tile.y;\nint distanceSoFar = 0;\nfor (int i = 0; i < vectors.size(); i++) {\nif (distanceSoFar > offset + length) {\nbreak;\n}\nif (distanceSoFar >= offset) {\nint x = TILE_DIAMETER / 2 + TILE_DIAMETER * tileX;\nint y = TILE_DIAMETER / 2 + TILE_DIAMETER * tileY;\npoints.add(new ImPoint(x, y));\n}\nStep v = vectors.get(i);\ntileX += v.deltaX;\ntileY += v.deltaY;\ndistanceSoFar += v.getLength();\n}\nImPoint first = getPoint(offset);\nif (points.size() == 0) {\npoints.addFirst(first);\n} else if (!points.getFirst().equals(first)) {\npoints.addFirst(first);\n}\nImPoint last = getPoint(offset + length);\nif (!points.getLast().equals(last)) {\npoints.addLast(last);\n}\nreturn new FreerailsPathIterator() {\nprivate static final long serialVersionUID = 1L;\nint index = 0;\npublic boolean hasNext() {\nreturn (index + 1) < points.size();\n}\npublic void nextSegment(IntLine line) {\nif (!hasNext()) {\nthrow new NoSuchElementException();\n}\nImPoint a = points.get(index);\nline.x1 = a.x;\nline.y1 = a.y;\nImPoint b = points.get(index + 1);\nline.x2 = b.x;\nline.y2 = b.y;\nindex++;\n}\n};\n}\npublic Iterator<ImPoint> tiles() {\nreturn new Iterator<ImPoint>() {\nint index = 0;\nImPoint next = start;\npublic boolean hasNext() {\nreturn next != null;\n}\npublic ImPoint next() {\nif (next == null)\nthrow new NoSuchElementException();\nImPoint returnValue = next;\nint x = next.x;\nint y = next.y;\nif (index < vectors.size()) {\nStep s = vectors.get(index);\nx += s.deltaX;\ny += s.deltaY;\nnext = new ImPoint(x, y);\n} else {\nnext = null;\n}\nindex++;\nreturn returnValue;\n}\npublic void remove() {\nthrow new UnsupportedOperationException();\n}\n};\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer(getClass().getName());\nsb.append(\"{\");\nsb.append(start.x);\nsb.append(\", \");\nsb.append(start.y);\nfor (int i = 0; i < vectors.size(); i++) {\nsb.append(\", \");\nsb.append(vectors.get(i));\n}\nsb.append(\"}\");\nreturn sb.toString();\n}\n}"}
{"className":"jfreerails.world.train.TrainPositionOnMap","javaDoc":"/**\n* This <b>immutable</b> class represents the position of a train as a String\n* of points. There must be at least two points. The first point is the position\n* of the front of the train; the last point is the position of the end of the\n* train. Any intermediate points are positions of 'kinks' in the track.\n*\n* Coordinates are expressed in display coordinates relative to the map origin\n* (as opposed to map squares).\n*\n*\n* <p>\n* Train positions can be combined and divided as illustrated below (notice what\n* happens to the head and tail that are combined)\n* </p>\n* <table width=\"100%\" border=\"0\">\n* <tr>\n* <td>if</td>\n* <td><code> a</code></td>\n* <td><code>=</code></td>\n* <td><code>{<strong>(10, 10)</strong>, (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code> b</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), <strong>(10, 10)</strong>}</code></td>\n* </tr>\n* <tr>\n* <td>then</td>\n* <td><code>a.addToHead(b)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code>b.addToTail(a)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and if</td>\n* <td><code> c</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>then</td>\n* <td><code>c.removeFromTail(a)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (10, 10)}</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code>c.removeFromHead(b)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(10, 10), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* </table>\n*\n*\n* @author Luke Lindsay 26-Oct-2002\n*\n*/","code":"/**\n* This <b>immutable</b> class represents the position of a train as a String\n* of points. There must be at least two points. The first point is the position\n* of the front of the train; the last point is the position of the end of the\n* train. Any intermediate points are positions of 'kinks' in the track.\n*\n* Coordinates are expressed in display coordinates relative to the map origin\n* (as opposed to map squares).\n*\n*\n* <p>\n* Train positions can be combined and divided as illustrated below (notice what\n* happens to the head and tail that are combined)\n* </p>\n* <table width=\"100%\" border=\"0\">\n* <tr>\n* <td>if</td>\n* <td><code> a</code></td>\n* <td><code>=</code></td>\n* <td><code>{<strong>(10, 10)</strong>, (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code> b</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), <strong>(10, 10)</strong>}</code></td>\n* </tr>\n* <tr>\n* <td>then</td>\n* <td><code>a.addToHead(b)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code>b.addToTail(a)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>and if</td>\n* <td><code> c</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* <tr>\n* <td>then</td>\n* <td><code>c.removeFromTail(a)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(1,1), (4,4), (5,5), (10, 10)}</code></td>\n* </tr>\n* <tr>\n* <td>and</td>\n* <td><code>c.removeFromHead(b)</code></td>\n* <td><code>=</code></td>\n* <td><code>{(10, 10), (20,20), (30,30), (40,40) }</code></td>\n* </tr>\n* </table>\n*\n*\n* @author Luke Lindsay 26-Oct-2002\n*\n*/\npublic class TrainPositionOnMap implements FreerailsSerializable {\npublic static final int CRASH_FRAMES_COUNT = 15;\nprivate static final long serialVersionUID = 3979269144611010865L;\nprivate final ImInts xpoints;\nprivate final ImInts ypoints;\nprivate final double speed, acceleration;\nprivate final SpeedTimeAndStatus.TrainActivity activity;\nprivate boolean crashSite = false;\npublic boolean isCrashSite() {\nreturn crashSite;\n}\npublic void setCrashSite(boolean isCrash) {\ncrashSite = isCrash;\n}\nprivate int frameCt = 1;\nprivate int frame = 0;\npublic int getFrameCt() {\nreturn frameCt;\n}\npublic void incrementFramCt() {\nif (frame > 0) {\nincrementFrame();\nframe = 0;\n} else {\nframe++;\n}\n}\npublic void incrementFrame() {\nframeCt++;\n}\n@Override\npublic int hashCode() {\nint result = 0;\n// TODO is there are danger of overflow here?\nfor (int i = 0; i < xpoints.size(); i++) {\nresult = 29 * result + xpoints.get(i);\n}\nfor (int i = 0; i < ypoints.size(); i++) {\nresult = 29 * result + ypoints.get(i);\n}\nreturn result;\n}\n@Override\npublic boolean equals(Object o) {\nif (null == o) {\nreturn false;\n}\nif (o == this) {\nreturn true;\n}\nif (o instanceof TrainPositionOnMap) {\nTrainPositionOnMap other = (TrainPositionOnMap) o;\nint thisLength = this.getLength();\nint otherLength = other.getLength();\nif (thisLength == otherLength) {\nFreerailsPathIterator path1;\nFreerailsPathIterator path2;\nIntLine line1 = new IntLine();\nIntLine line2 = new IntLine();\npath1 = other.path();\npath2 = this.path();\nwhile (path1.hasNext() && path2.hasNext()) {\npath1.nextSegment(line1);\npath2.nextSegment(line2);\nif (line1.x1 != line2.x1 || line1.y1 != line2.y1\n|| line1.x2 != line2.x2 || line1.y2 != line2.y2) {\nreturn false;\n}\n}\nif (path1.hasNext() || path2.hasNext()) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\npublic double calculateDistance() {\ndouble distance = 0;\nIntLine line = new IntLine();\nFreerailsPathIterator path = this.path();\nwhile (path.hasNext()) {\npath.nextSegment(line);\nint sumOfSquares = (line.x1 - line.x2) * (line.x1 - line.x2)\n+ (line.y1 - line.y2) * (line.y1 - line.y2);\ndistance += Math.sqrt(sumOfSquares);\n}\nreturn distance;\n}\npublic int getLength() {\nreturn xpoints.size();\n}\npublic ImInts getXPoints() {\nreturn xpoints;\n}\npublic ImInts getYPoints() {\nreturn ypoints;\n}\npublic int getX(int position) {\nreturn xpoints.get(position);\n}\npublic int getY(int position) {\nreturn ypoints.get(position);\n}\npublic FreerailsPathIterator path() {\nreturn new SimplePathIteratorImpl(this.xpoints, this.ypoints);\n}\npublic FreerailsPathIterator reversePath() {\nint length = xpoints.size();\nint[] reversed_xpoints = new int[length];\nint[] reversed_ypoints = new int[length];\nfor (int i = 0; i < length; i++) {\nreversed_xpoints[i] = xpoints.get(length - i - 1);\nreversed_ypoints[i] = ypoints.get(length - i - 1);\n}\nreturn new SimplePathIteratorImpl(reversed_xpoints, reversed_ypoints);\n}\npublic TrainPositionOnMap reverse() {\nint length = xpoints.size();\nint[] reversed_xpoints = new int[length];\nint[] reversed_ypoints = new int[length];\nfor (int i = 0; i < length; i++) {\nreversed_xpoints[i] = xpoints.get(length - i - 1);\nreversed_ypoints[i] = ypoints.get(length - i - 1);\n}\nreturn new TrainPositionOnMap(reversed_xpoints, reversed_ypoints,\nspeed, acceleration, activity);\n}\npublic TrainPositionOnMap(ImInts xs, ImInts ys) {\nthis.xpoints = xs;\nthis.ypoints = ys;\nthis.acceleration = 0d;\nthis.speed = 0d;\nthis.activity = SpeedTimeAndStatus.TrainActivity.READY;\n}\nprivate TrainPositionOnMap(int[] xs, int[] ys, double speed,\ndouble acceleration, SpeedTimeAndStatus.TrainActivity activity) {\nif (xs.length != ys.length) {\nthrow new IllegalArgumentException();\n}\nxpoints = new ImInts(xs);\nypoints = new ImInts(ys);\nthis.acceleration = acceleration;\nthis.speed = speed;\nthis.activity = activity;\n}\npublic static TrainPositionOnMap createInstance(int[] xpoints, int[] ypoints) {\nreturn new TrainPositionOnMap(xpoints, ypoints, 0d, 0d,\nSpeedTimeAndStatus.TrainActivity.READY);\n}\npublic TrainPositionOnMap addToHead(TrainPositionOnMap b) {\nTrainPositionOnMap a = this;\nreturn addBtoHeadOfA(b, a);\n}\nprivate TrainPositionOnMap addBtoHeadOfA(TrainPositionOnMap b,\nTrainPositionOnMap a) {\nif (aHeadEqualsBTail(a, b)) {\nint newLength = a.getLength() + b.getLength() - 2;\nint[] newXpoints = new int[newLength];\nint[] newYpoints = new int[newLength];\nint aLength = a.getLength();\nint bLength = b.getLength();\n// First copy the points from B\nfor (int i = 0; i < bLength - 1; i++) {\nnewXpoints[i] = b.getX(i);\nnewYpoints[i] = b.getY(i);\n}\n// Second copy the points from A.\nfor (int i = 1; i < aLength; i++) {\nnewXpoints[i + bLength - 2] = a.getX(i);\nnewYpoints[i + bLength - 2] = a.getY(i);\n}\nreturn new TrainPositionOnMap(newXpoints, newYpoints,\nb.acceleration, b.speed, b.activity);\n}\nthrow new IllegalArgumentException(\"Tried to add \" + b.toString()\n+ \" to the head of \" + a.toString());\n}\npublic boolean canAddToHead(TrainPositionOnMap b) {\nreturn aHeadEqualsBTail(this, b);\n}\npublic TrainPositionOnMap addToTail(TrainPositionOnMap a) {\nTrainPositionOnMap b = this;\nreturn addBtoHeadOfA(b, a);\n}\npublic boolean canAddToTail(TrainPositionOnMap b) {\nreturn aHeadEqualsBTail(b, this);\n}\npublic TrainPositionOnMap removeFromHead(TrainPositionOnMap b) {\nif (headsAreEqual(this, b)) {\nint newLength = this.getLength() - b.getLength() + 2;\nint[] newXpoints = new int[newLength];\nint[] newYpoints = new int[newLength];\nint bLength = b.getLength();\n// copy head from b\nint bHeadPosition = b.getLength() - 1;\nnewXpoints[0] = b.getX(bHeadPosition);\nnewYpoints[0] = b.getY(bHeadPosition);\n// Copy rest from this\nfor (int i = 1; i < newLength; i++) {\nint position = bLength + i - 2;\nnewXpoints[i] = this.getX(position);\nnewYpoints[i] = this.getY(position);\n}\nreturn new TrainPositionOnMap(newXpoints, newYpoints, speed,\nacceleration, activity);\n}\nthrow new IllegalArgumentException();\n}\npublic boolean canRemoveFromHead(TrainPositionOnMap b) {\nif (headsAreEqual(this, b)) {\nFreerailsPathIterator path = b.path();\nint i = 0;\nIntLine line = new IntLine();\nwhile (path.hasNext()) {\npath.nextSegment(line);\nif (this.getX(i) != line.x1 || this.getY(i) != line.y1) {\nreturn false;\n}\ni++;\n}\nreturn true;\n}\nreturn false;\n}\npublic TrainPositionOnMap removeFromTail(TrainPositionOnMap b) {\nif (tailsAreEqual(this, b)) {\nint newLength = this.getLength() - b.getLength() + 2;\nint[] newXpoints = new int[newLength];\nint[] newYpoints = new int[newLength];\n// Copy from this\nfor (int i = 0; i < newLength - 1; i++) {\nnewXpoints[i] = this.getX(i);\nnewYpoints[i] = this.getY(i);\n}\n// Copy tail from b\nnewXpoints[newLength - 1] = b.getX(0);\nnewYpoints[newLength - 1] = b.getY(0);\nreturn new TrainPositionOnMap(newXpoints, newYpoints, speed,\nacceleration, activity);\n}\nthrow new IllegalArgumentException();\n}\npublic boolean canRemoveFromTail(TrainPositionOnMap b) {\nif (tailsAreEqual(this, b)) {\nFreerailsPathIterator path = b.reversePath();\nint i = this.getLength() - 1;\nIntLine line = new IntLine();\nwhile (path.hasNext()) {\npath.nextSegment(line);\nif (this.getX(i) != line.x1 || this.getY(i) != line.y1) {\nreturn false;\n}\ni--;\n}\nreturn true;\n}\nreturn false;\n}\npublic static TrainPositionOnMap createInSameDirectionAsPath(\nFreerailsPathIterator path) {\nreturn createInSameDirectionAsPath(path, 0d, 0d,\nSpeedTimeAndStatus.TrainActivity.READY);\n}\npublic static TrainPositionOnMap createInSameDirectionAsPath(\nFreerailsPathIterator path, double speed, double acceleration,\nSpeedTimeAndStatus.TrainActivity activity) {\nIntArray xPointsIntArray = new IntArray();\nIntArray yPointsIntArray = new IntArray();\nIntLine line = new IntLine();\nint i = 0;\nwhile (path.hasNext()) {\npath.nextSegment(line);\nxPointsIntArray.add(i, line.x1);\nyPointsIntArray.add(i, line.y1);\ni++;\nif (i > 10000) {\nthrow new IllegalStateException(\n\"The TrainPosition has more than 10,000 points, which suggests that something is wrong.\");\n}\n}\nxPointsIntArray.add(i, line.x2);\nyPointsIntArray.add(i, line.y2);\nint[] xPoints;\nint[] yPoints;\nxPoints = xPointsIntArray.toArray();\nyPoints = yPointsIntArray.toArray();\nreturn new TrainPositionOnMap(xPoints, yPoints, speed, acceleration,\nactivity);\n}\npublic static boolean headsAreEqual(TrainPositionOnMap a,\nTrainPositionOnMap b) {\nint aHeadX = a.getX(0);\nint aHeadY = a.getY(0);\nint bHeadX = b.getX(0);\nint bHeadY = b.getY(0);\nif (aHeadX == bHeadX && aHeadY == bHeadY) {\nreturn true;\n}\nreturn false;\n}\npublic static boolean tailsAreEqual(TrainPositionOnMap a,\nTrainPositionOnMap b) {\nint aTailX = a.getX(a.getLength() - 1);\nint aTailY = a.getY(a.getLength() - 1);\nint bTailX = b.getX(b.getLength() - 1);\nint bTailY = b.getY(b.getLength() - 1);\nif (aTailX == bTailX && aTailY == bTailY) {\nreturn true;\n}\nreturn false;\n}\npublic static boolean aHeadEqualsBTail(TrainPositionOnMap a,\nTrainPositionOnMap b) {\nint aHeadX = a.getX(0);\nint aHeadY = a.getY(0);\nint bTailX = b.getX(b.getLength() - 1);\nint bTailY = b.getY(b.getLength() - 1);\nif (aHeadX == bTailX && aHeadY == bTailY) {\nreturn true;\n}\nreturn false;\n}\npublic static boolean bHeadEqualsATail(TrainPositionOnMap a,\nTrainPositionOnMap b) {\nreturn aHeadEqualsBTail(b, a);\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(\"TrainPosition {\");\nfor (int i = 0; i < xpoints.size(); i++) {\nsb.append(\"(\");\nsb.append(xpoints.get(i));\nsb.append(\", \");\nsb.append(ypoints.get(i));\nsb.append(\"), \");\n}\nsb.append(\"}\");\nreturn sb.toString();\n}\npublic double getAcceleration() {\nreturn acceleration;\n}\npublic SpeedTimeAndStatus.TrainActivity getActivity() {\nreturn activity;\n}\npublic double getSpeed() {\nreturn speed;\n}\n}"}
{"className":"jfreerails.world.train.WagonType","javaDoc":"/**\n* This class represents a wagon type, for example 'goods wagon'. It\n* encapsulates the properties of a wagon that are common to all wagons of the\n* same type.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents a wagon type, for example 'goods wagon'. It\n* encapsulates the properties of a wagon that are common to all wagons of the\n* same type.\n*\n* @author Luke\n*\n*/\npublic class WagonType implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3906368233710826292L;\npublic static final int BULK_FREIGHT = 4;\npublic static final int ENGINE = 5;\npublic static final int FAST_FREIGHT = 2;\npublic static final int MAIL = 0;\npublic static final int NUMBER_OF_CATEGORIES = 6;\npublic static final int PASSENGER = 1;\npublic static final int SLOW_FREIGHT = 3;\npublic static final int UNITS_OF_CARGO_PER_WAGON = 40;\nprivate final int typeCategory;\nprivate final String typeName;\npublic WagonType(String name, int category) {\ntypeName = name;\ntypeCategory = category;\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof WagonType))\nreturn false;\nWagonType other = (WagonType) obj;\nreturn other.typeCategory == this.typeCategory\n&& other.typeName.equals(typeName);\n}\npublic int getCategory() {\nreturn typeCategory;\n}\npublic String getName() {\nreturn typeName;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = typeCategory;\nresult = 29 * result + typeName.hashCode();\nreturn result;\n}\n@Override\npublic String toString() {\nreturn typeName;\n}\n}"}
{"className":"jfreerails.world.train.SimplePathIteratorImpl","javaDoc":"/**\n* Exposes a path stored as an array of x points and an array of y points.\n*\n* @author Luke\n*/","code":"/**\n* Exposes a path stored as an array of x points and an array of y points.\n*\n* @author Luke\n*/\npublic class SimplePathIteratorImpl implements FreerailsPathIterator {\nprivate static final long serialVersionUID = 3618420406261003576L;\nprivate final ImInts x;\nprivate final ImInts y;\nprivate int position = 0;\npublic SimplePathIteratorImpl(ImInts xpoints, ImInts ypoints) {\nx = xpoints;\ny = ypoints;\nif (x.size() != y.size()) {\nthrow new IllegalArgumentException(\n\"The array length of the array must be even\");\n}\n}\npublic SimplePathIteratorImpl( /* =const */\nint[] xpoints, /* =const */\nint[] ypoints) {\nx = new ImInts(xpoints);\ny = new ImInts(ypoints); // defensive copy.\nif (x.size() != y.size()) {\nthrow new IllegalArgumentException(\n\"The array length of the array must be even\");\n}\n}\npublic void nextSegment(IntLine line) {\nif (hasNext()) {\nline.x1 = x.get(position);\nline.y1 = y.get(position);\nline.x2 = x.get(position + 1);\nline.y2 = y.get(position + 1);\nposition++;\n} else {\nthrow new NoSuchElementException();\n}\n}\npublic boolean hasNext() {\nreturn (position + 1) < x.size();\n}\n}"}
{"className":"jfreerails.world.train.PathWalkerImpl","javaDoc":"/**\n* PathWalker that walks the path exposed by a FreerailsPathIterator.\n*\n* @author Luke\n*/","code":"/**\n* PathWalker that walks the path exposed by a FreerailsPathIterator.\n*\n* @author Luke\n*/\npublic class PathWalkerImpl implements PathWalker {\nprivate static final long serialVersionUID = 4050204158701155639L;\nprivate final FreerailsPathIterator it;\n/**\n* current segment of the path we are on.\n*/\nprivate final IntLine currentSegment = new IntLine();\nprivate double distanceAlongCurrentSegment = 0;\nprivate double distanceOfThisStepRemaining = 0;\nprivate boolean beforeFirst = true;\nprivate int lastX;\nprivate int lastY;\npublic PathWalkerImpl(FreerailsPathIterator i) {\nit = i;\n}\n/**\n* @return true if we still have more of the current segment, or more\n* segments left.\n*/\npublic boolean canStepForward() {\nif (currentSegment.getLength() > distanceAlongCurrentSegment) {\nreturn true;\n} else if (it.hasNext()) {\nreturn true;\n} else {\nreturn false;\n}\n}\n/**\n* Specify the distance this PathWalker is to progress along the current\n* step.\n*/\npublic void stepForward(double distance) {\ndistanceOfThisStepRemaining += distance;\n}\n/**\n* @return true if there is still some distance to go along this path\n*/\npublic boolean hasNext() {\nif (0 == distanceOfThisStepRemaining) {\nreturn false;\n} else if (distanceAlongCurrentSegment < currentSegment.getLength()) {\nreturn true;\n} else if (it.hasNext()) {\nreturn true;\n} else {\nreturn false;\n}\n}\npublic void nextSegment(IntLine line) {\nif (!hasNext()) {\nthrow new NoSuchElementException();\n}\n// If we are at the end of the current segment, start a new one.\nif (currentSegment.getLength() <= distanceAlongCurrentSegment) {\nstartNewSegment(line);\n} else {\nstartInMiddleOfSegment(line);\n}\ndouble remainingDistanceAlongCurrentSegment = currentSegment\n.getLength()\n- distanceAlongCurrentSegment;\nif (distanceOfThisStepRemaining > remainingDistanceAlongCurrentSegment) {\nendAtSegmentEnd(line, remainingDistanceAlongCurrentSegment);\n} else {\nendInMiddleOfSegment(line);\n}\n/*\n* Sanity check: the first point of the last line should equal the\n* second point of the current line.\n*\n*/\nif (!beforeFirst) {\nif (line.x1 != this.lastX) {\nthrow new IllegalStateException();\n}\nif (line.y1 != this.lastY) {\nthrow new IllegalStateException();\n}\n}\nthis.lastX = line.x2;\nthis.lastY = line.y2;\nbeforeFirst = false;\nreturn;\n}\nprivate void endInMiddleOfSegment(IntLine line) {\ndistanceAlongCurrentSegment += distanceOfThisStepRemaining;\ndistanceOfThisStepRemaining = 0;\nline.x2 = getCoordinateOnSegment(distanceAlongCurrentSegment,\ncurrentSegment.x1, currentSegment.x2);\nline.y2 = getCoordinateOnSegment(distanceAlongCurrentSegment,\ncurrentSegment.y1, currentSegment.y2);\n}\nprivate void endAtSegmentEnd(IntLine line,\ndouble remainingDistanceAlongCurrentSegment) {\nline.x2 = this.currentSegment.x2;\nline.y2 = this.currentSegment.y2;\nthis.distanceOfThisStepRemaining -= remainingDistanceAlongCurrentSegment;\ndistanceAlongCurrentSegment = this.currentSegment.getLength();\n}\nprivate void startInMiddleOfSegment(IntLine line) {\nline.x1 = getCoordinateOnSegment(distanceAlongCurrentSegment,\ncurrentSegment.x1, currentSegment.x2);\nline.y1 = getCoordinateOnSegment(distanceAlongCurrentSegment,\ncurrentSegment.y1, currentSegment.y2);\n}\nprivate void startNewSegment(IntLine line) {\nit.nextSegment(currentSegment);\ndistanceAlongCurrentSegment = 0;\nline.x1 = this.currentSegment.x1;\nline.y1 = this.currentSegment.y1;\n}\nprivate int getCoordinateOnSegment(double distanceAlongSegment,\nint coordinate1, int coordinate2) {\ndouble segmentLength = this.currentSegment.getLength();\ndouble delta = 0;\nif (0 != segmentLength) {\ndelta = (coordinate2 - coordinate1) * distanceAlongSegment\n/ segmentLength;\n}\nreturn coordinate1 + (int) delta;\n}\n}"}
{"className":"jfreerails.world.train.ConstAcc","javaDoc":null,"code":"strictfp public class ConstAcc implements FreerailsSerializable,\nSpeedAgainstTime {\nprivate static final long serialVersionUID = -2180666310811530761L;\npublic static final ConstAcc STOPPED = new ConstAcc(0, 0, 0, 0);\npublic static ConstAcc uas(double u, double a, double s) {\ndouble t = calcT(u, a, s);\nreturn new ConstAcc(a, t, u, s);\n}\nprivate static double calcT(double u, double a, double s) {\n// Note, Utils.solveQuadratic throws an exception if a == 0\nreturn a == 0 ? s / u : Utils.solveQuadratic(a * 0.5d, u, -s);\n}\npublic static ConstAcc uat(double u, double a, double t) {\ndouble s = u * t + a * t * t / 2;\nreturn new ConstAcc(a, t, u, s);\n}\nprivate final double u, a, finalS, finalT;\nprivate ConstAcc(double a, double t, double u, double s) {\nthis.a = a;\nthis.finalT = t;\nthis.u = u;\nthis.finalS = s;\n}\npublic double calcS(double t) {\nif(t == finalT) return finalS;\nvalidateT(t);\ndouble ds = u * t + a * t * t / 2;\nds = Math.min(ds, finalS);\nreturn ds;\n}\npublic double calcT(double s) {\nif(s == finalS ) return finalT;\nif(s < 0 || s > this.finalS )\nthrow new IllegalArgumentException(s+\" < 0 || \"+s+\" > \"+finalS );\ndouble returnValue = calcT(u, a, s);\nreturnValue = Math.min(returnValue, finalT);\nreturn returnValue;\n}\npublic double calcV(double t) {\nvalidateT(t);\nreturn u + a * t;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ConstAcc))\nreturn false;\nfinal ConstAcc constAcc = (ConstAcc) o;\nif (a != constAcc.a)\nreturn false;\nif (finalT != constAcc.finalT)\nreturn false;\nif (u != constAcc.u)\nreturn false;\nreturn true;\n}\npublic double calcA(double t) {\nvalidateT(t);\nreturn a;\n}\npublic double getT() {\nreturn finalT;\n}\npublic double getS() {\nreturn finalS;\n}\n@Override\npublic int hashCode() {\nint result;\nlong temp;\ntemp = u != +0.0d ? Double.doubleToLongBits(u) : 0l;\nresult = (int) (temp ^ (temp >>> 32));\ntemp = a != +0.0d ? Double.doubleToLongBits(a) : 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\ntemp = finalT != +0.0d ? Double.doubleToLongBits(finalT) : 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\nreturn result;\n}\nprivate void validateT(double t){\nif(t < 0 || t > finalT)\nthrow new IllegalArgumentException(\"(\"+t+\" < 0 || \"+t+\" > \"+finalT+\")\");\n}\n@Override\npublic String toString() {\nString str = \"ConstAcc [a=\" + a + \", u=\" + u + \", dt=\" + finalT + \"]\";\nreturn str;\n}\n}"}
{"className":"jfreerails.world.train.TrainOrdersModel","javaDoc":"/**\n* This class encapsulates the orders for a train.\n*\n* @author Luke\n*/","code":"/**\n* This class encapsulates the orders for a train.\n*\n* @author Luke\n*/\npublic class TrainOrdersModel implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3616453397155559472L;\nprivate static final int MAXIMUM_NUMBER_OF_WAGONS = 6;\npublic final boolean waitUntilFull;\npublic final boolean autoConsist;\n/** The wagon types to add; if null, then no change.*/\npublic final ImInts consist;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TrainOrdersModel))\nreturn false;\nfinal TrainOrdersModel trainOrdersModel = (TrainOrdersModel) o;\nif (autoConsist != trainOrdersModel.autoConsist)\nreturn false;\nif (stationId != trainOrdersModel.stationId)\nreturn false;\nif (waitUntilFull != trainOrdersModel.waitUntilFull)\nreturn false;\nif (consist != null ? !consist.equals(trainOrdersModel.consist)\n: trainOrdersModel.consist != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (waitUntilFull ? 1 : 0);\nresult = 29 * result + (autoConsist ? 1 : 0);\nresult = 29 * result + (consist != null ? consist.hashCode() : 0);\nresult = 29 * result + stationId;\nreturn result;\n}\npublic final int stationId; // The number of the station to goto.\npublic TrainOrdersModel(int station, ImInts newConsist, boolean wait,\nboolean auto) {\n// If there are no wagons, set wait = false.\nwait = (null == newConsist || 0 == newConsist.size()) ? false : wait;\nthis.waitUntilFull = wait;\nthis.consist = newConsist;\nthis.stationId = station;\nthis.autoConsist = auto;\n}\n/**\n* @return either (1) an array of cargo type ids or (2) null to represent\n* 'no change'.\n*/\npublic ImInts getConsist() {\nreturn this.consist;\n}\npublic int getStationID() {\nreturn stationId;\n}\npublic boolean isNoConsistChange() {\nreturn null == consist;\n}\npublic boolean getWaitUntilFull() {\nreturn waitUntilFull;\n}\npublic boolean orderHasWagons() {\nreturn null != consist && 0 != consist.size();\n}\npublic boolean hasLessThanMaximumNumberOfWagons() {\nreturn null == consist || consist.size() < MAXIMUM_NUMBER_OF_WAGONS;\n}\npublic boolean isAutoConsist() {\nreturn autoConsist;\n}\n}"}
{"className":"jfreerails.world.train.SpeedTimeAndStatus","javaDoc":"/**\n* Stores the speed and status of a train immediately after an instant of time.\n*\n* @author Luke\n*\n*/","code":"/**\n* Stores the speed and status of a train immediately after an instant of time.\n*\n* @author Luke\n*\n*/\npublic class SpeedTimeAndStatus implements FreerailsSerializable {\nprivate static final long serialVersionUID = 1L;\npublic enum TrainActivity {\nSTOPPED_AT_STATION, READY, WAITING_FOR_FULL_LOAD, STOPPED_AT_SIGNAL, CRASHED, NEEDS_UPDATING\n}\npublic final double dt;\npublic final double speed;\npublic final double acceleration;\npublic final double s;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof SpeedTimeAndStatus))\nreturn false;\nfinal SpeedTimeAndStatus speedTimeAndStatus = (SpeedTimeAndStatus) o;\nif (acceleration != speedTimeAndStatus.acceleration)\nreturn false;\nif (dt != speedTimeAndStatus.dt)\nreturn false;\nif (s != speedTimeAndStatus.s)\nreturn false;\nif (speed != speedTimeAndStatus.speed)\nreturn false;\nif (activity != null ? !activity.equals(speedTimeAndStatus.activity)\n: speedTimeAndStatus.activity != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nlong temp;\ntemp = dt != +0.0d ? Double.doubleToLongBits(dt) : 0l;\nresult = (int) (temp ^ (temp >>> 32));\ntemp = speed != +0.0d ? Double.doubleToLongBits(speed) : 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\ntemp = acceleration != +0.0d ? Double.doubleToLongBits(acceleration)\n: 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\ntemp = s != +0.0d ? Double.doubleToLongBits(s) : 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\nresult = 29 * result + (activity != null ? activity.hashCode() : 0);\nreturn result;\n}\nprivate final TrainActivity activity;\nSpeedTimeAndStatus(double acceleration, TrainActivity activity, double dt,\ndouble s, double speed) {\nif (dt < 0)\nthrow new IllegalArgumentException(String.valueOf(dt));\nthis.acceleration = acceleration;\nthis.activity = activity;\nthis.dt = dt;\nthis.s = s;\nthis.speed = speed;\n}\npublic TrainActivity getActivity() {\nreturn activity;\n}\n}"}
{"className":"jfreerails.world.train.CompositeSpeedAgainstTime","javaDoc":null,"code":"public class CompositeSpeedAgainstTime implements Activity<SpeedTimeAndStatus>,\nSpeedAgainstTime {\nprivate static final long serialVersionUID = 3146586143114534610L;\nprivate final ImList<SpeedAgainstTime> values;\nprivate final double finalT, finalS;\npublic CompositeSpeedAgainstTime(SpeedAgainstTime... accs) {\nvalues = new ImList<SpeedAgainstTime>(accs);\nvalues.checkForNulls();\ndouble tempDuration = 0, tempTotalDistance = 0;\nfor (int i = 0; i < accs.length; i++) {\ntempDuration += accs[i].getT();\ntempTotalDistance += accs[i].getS();\n}\nfinalT = tempDuration;\nfinalS = tempTotalDistance;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof CompositeSpeedAgainstTime))\nreturn false;\nfinal CompositeSpeedAgainstTime compositeSpeedAgainstTime = (CompositeSpeedAgainstTime) o;\nif (finalT != compositeSpeedAgainstTime.finalT)\nreturn false;\nif (finalS != compositeSpeedAgainstTime.finalS)\nreturn false;\nif (!values.equals(compositeSpeedAgainstTime.values))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nlong temp;\nresult = values.hashCode();\ntemp = finalT != +0.0d ? Double.doubleToLongBits(finalT) : 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\ntemp = finalS != +0.0d ? Double.doubleToLongBits(finalS)\n: 0l;\nresult = 29 * result + (int) (temp ^ (temp >>> 32));\nreturn result;\n}\npublic double duration() {\nreturn finalT;\n}\npublic SpeedTimeAndStatus getState(final double dt) {\ncheckT(dt);\ndouble acceleration;\nSpeedTimeAndStatus.TrainActivity activity = SpeedTimeAndStatus.TrainActivity.READY;\ndouble s = 0;\ndouble speed;\nTandI tai = getIndex(dt);\nSpeedAgainstTime acc = values.get(tai.i);\nspeed = acc.calcV(tai.offset);\nacceleration = acc.calcA(tai.offset);\ns = acc.calcS(tai.offset);\nreturn new SpeedTimeAndStatus(acceleration, activity, dt, s, speed);\n}\npublic double calcS(double t) {\nif(t == this.finalT) return this.finalS;\ncheckT(t);\nTandI tai = getIndex(t);\ndouble s = 0;\nfor (int i = 0; i < tai.i; i++) {\nSpeedAgainstTime acc = values.get(i);\ns += acc.getS();\n}\nSpeedAgainstTime acc = values.get(tai.i);\nif(tai.offset >= acc.getT()){\n//Note, it is possible for tai.offset > acc.getT()\n//even though we called checkT(t) above\ns += acc.getS();\n}else{\ns += acc.calcS(tai.offset);\n}\nreturn s;\n}\npublic double calcT(double s) {\nif(s == this.finalS) return this.finalT;\nif (s > finalS)\nthrow new IllegalArgumentException(String.valueOf(s));\ndouble sSoFar = 0;\ndouble tSoFar = 0;\nint i = 0;\nSpeedAgainstTime acc = values.get(i);\nwhile ((sSoFar + acc.getS()) < s) {\nsSoFar += acc.getS();\ntSoFar += acc.getT();\ni++;\nacc = values.get(i);\n}\ndouble sOffset = s - sSoFar;\nif(sOffset >= acc.getS()){\ntSoFar += acc.getT();\n}else{\ntSoFar += acc.calcT(sOffset);\n}\nreturn tSoFar;\n}\npublic double calcV(double t) {\ncheckT(t);\nTandI tai = getIndex(t);\nSpeedAgainstTime acc = values.get(tai.i);\nreturn acc.calcV(tai.offset);\n}\npublic double calcA(double t) {\ncheckT(t);\nTandI tai = getIndex(t);\nSpeedAgainstTime acc = values.get(tai.i);\nreturn acc.calcA(tai.offset);\n}\npublic double getT() {\nreturn finalT;\n}\npublic double getS() {\nreturn finalS;\n}\nprivate TandI getIndex(double t) {\ncheckT(t);\ndouble tSoFar = 0;\nfor (int i = 0; i < values.size(); i++) {\nSpeedAgainstTime acc = values.get(i);\nif (t <= (tSoFar + acc.getT())) {\ndouble offset = t - tSoFar;\nreturn new TandI(i, offset);\n}\ntSoFar += acc.getT();\n}\n// Should never happen since we call checkT() above!\nthrow new IllegalStateException(String.valueOf(t));\n}\n/** Used to enable 2 values to be returned from the method getIndex(double t) */\nprivate static class TandI {\nfinal double offset;\nfinal int i;\nTandI(int i, double t) {\nthis.i = i;\nthis.offset = t;\n}\n}\nvoid checkT(double t) {\nif (t < 0d || t > finalT)\nthrow new IllegalArgumentException(\"t=\"+t+\", but duration=\"+finalT);\n}\n}"}
{"className":"jfreerails.world.train.ImmutableSchedule","javaDoc":"/**\n* A Schedule that is immutable.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* A Schedule that is immutable.\n*\n* @author Luke Lindsay\n*\n*/\npublic class ImmutableSchedule implements Schedule, FreerailsSerializable {\nprivate static final long serialVersionUID = 3977858458324318264L;\nprivate final ImList<TrainOrdersModel> orders;\nprivate final int nextScheduledOrder;\n@Override\npublic int hashCode() {\nint result;\nresult = nextScheduledOrder;\nresult = 29 * result + (hasPriorityOrders ? 1 : 0);\nreturn result;\n}\nprivate final boolean hasPriorityOrders;\npublic ImmutableSchedule(TrainOrdersModel[] orders, int gotoStation,\nboolean hasPriorityOrders) {\nthis.orders = new ImList<TrainOrdersModel>(orders);\nthis.nextScheduledOrder = gotoStation;\nthis.hasPriorityOrders = hasPriorityOrders;\n}\npublic TrainOrdersModel getOrder(int i) {\nreturn orders.get(i);\n}\npublic int getOrderToGoto() {\nreturn hasPriorityOrders ? 0 : nextScheduledOrder;\n}\npublic int getStationToGoto() {\nint orderToGoto = getOrderToGoto();\nif (-1 == orderToGoto) {\nreturn -1;\n}\nTrainOrdersModel order = orders.get(orderToGoto);\nreturn order.getStationID();\n}\npublic ImInts getWagonsToAdd() {\nTrainOrdersModel order = orders.get(getOrderToGoto());\nreturn order.consist;\n}\npublic boolean hasPriorityOrders() {\nreturn hasPriorityOrders;\n}\npublic int getNumOrders() {\nreturn orders.size();\n}\npublic int getNextScheduledOrder() {\nreturn this.nextScheduledOrder;\n}\npublic boolean stopsAtStation(int stationNumber) {\nfor (int i = 0; i < this.getNumOrders(); i++) {\nTrainOrdersModel order = this.getOrder(i);\nif (order.getStationID() == stationNumber) {\nreturn true;\n}\n}\nreturn false;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof ImmutableSchedule) {\nImmutableSchedule test = (ImmutableSchedule) o;\nreturn this.hasPriorityOrders == test.hasPriorityOrders\n&& this.nextScheduledOrder == test.nextScheduledOrder\n&& this.orders.equals(test.orders);\n}\nreturn false;\n}\npublic boolean autoConsist() {\nTrainOrdersModel order = orders.get(getOrderToGoto());\nreturn order.autoConsist;\n}\n}"}
{"className":"jfreerails.world.train.EngineType","javaDoc":"/**\n* This class represents an engine type, for example 'Grass Hopper'. It\n* encapsulates the properties that are common to all engines of the same type.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents an engine type, for example 'Grass Hopper'. It\n* encapsulates the properties that are common to all engines of the same type.\n*\n* @author Luke\n*\n*/\nfinal public class EngineType implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3617014130905592630L;\nprivate final String engineTypeName;\nprivate final Money maintenance;\nprivate final int maxSpeed; // speed in mph\nprivate final int powerAtDrawbar;\nprivate final Money price;\npublic EngineType(String name, int power, Money m, int speed) {\nengineTypeName = name;\npowerAtDrawbar = power;\nprice = m;\nmaxSpeed = speed;\nmaintenance = new Money(0);\n}\npublic EngineType(String name, int power, Money m, int speed, Money maint) {\nengineTypeName = name;\npowerAtDrawbar = power;\nprice = m;\nmaxSpeed = speed;\nmaintenance = maint;\n}\n@Override\npublic boolean equals(Object obj) {\nif (!(obj instanceof EngineType))\nreturn false;\nEngineType other = (EngineType) obj;\nreturn engineTypeName.equals(other.engineTypeName)\n&& powerAtDrawbar == other.powerAtDrawbar && price.equals(other.price)\n&& maintenance.equals(other.maintenance)\n&& maxSpeed == other.maxSpeed;\n}\npublic String getEngineTypeName() {\nreturn engineTypeName;\n}\npublic Money getMaintenance() {\nreturn maintenance;\n}\npublic int getMaxSpeed() {\nreturn maxSpeed;\n}\npublic int getPowerAtDrawbar() {\nreturn powerAtDrawbar;\n}\npublic Money getPrice() {\nreturn price;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = powerAtDrawbar;\nresult = 29 * result + engineTypeName.hashCode();\nresult = 29 * result + price.hashCode();\nresult = 29 * result + maintenance.hashCode();\nresult = 29 * result + maxSpeed;\nreturn result;\n}\n@Override\npublic String toString() {\nreturn engineTypeName;\n}\n}"}
{"className":"jfreerails.world.train.MutableSchedule","javaDoc":"/**\n* This class represents a train's schedule. That is, which stations that the\n* train should visit and what wagons the engine should pull.\n*\n* @author lindsal\n*/","code":"/**\n* This class represents a train's schedule. That is, which stations that the\n* train should visit and what wagons the engine should pull.\n*\n* @author lindsal\n*/\npublic class MutableSchedule implements Schedule {\n/**\n* Vector of TrainOrdersModel.\n*/\nprivate final Vector<TrainOrdersModel> orders = new Vector<TrainOrdersModel>();\nprivate int nextScheduledOrder = -1;\n/**\n* Whether the train should ignore the stationToGoto and goto the first\n* station in the list.\n*/\nprivate boolean hasPriorityOrders = false;\npublic MutableSchedule() {\n}\npublic MutableSchedule(ImmutableSchedule s) {\nnextScheduledOrder = s.getNextScheduledOrder();\nhasPriorityOrders = s.hasPriorityOrders();\nfor (int i = 0; i < s.getNumOrders(); i++) {\norders.add(s.getOrder(i));\n}\n}\npublic ImmutableSchedule toImmutableSchedule() {\nTrainOrdersModel[] ordersArray = new TrainOrdersModel[orders.size()];\nfor (int i = 0; i < ordersArray.length; i++) {\nordersArray[i] = orders.get(i);\n}\nreturn new ImmutableSchedule(ordersArray, this.nextScheduledOrder,\nthis.hasPriorityOrders);\n}\npublic void setPriorityOrders(TrainOrdersModel order) {\nif (hasPriorityOrders) {\n// Replace existing priority orders.\norders.set(PRIORITY_ORDERS, order);\n} else {\n// Insert priority orders at position 0;\nhasPriorityOrders = true;\norders.add(PRIORITY_ORDERS, order);\nnextScheduledOrder++;\n}\n}\n/**\n* Removes the order at the specified position.\n*/\npublic void removeOrder(int orderNumber) {\nif (PRIORITY_ORDERS == orderNumber && hasPriorityOrders) {\n// If we are removing the priority stop.\nhasPriorityOrders = false;\n}\norders.remove(orderNumber);\n/* shift current station down */\nif (nextScheduledOrder > orderNumber) {\nnextScheduledOrder--;\n}\nif (orders.size() <= nextScheduledOrder) {\nnextScheduledOrder = firstScheduleStop();\n}\nif (0 == numberOfScheduledStops()) {\nnextScheduledOrder = -1;\n}\n}\nprivate int firstScheduleStop() {\nreturn hasPriorityOrders ? 1 : 0;\n}\nprivate int numberOfScheduledStops() {\nreturn orders.size() - firstScheduleStop();\n}\n/**\n* Inserts an order at the specified position. Note you must call\n* setPriorityOrders() to set the priority orders.\n*/\npublic void addOrder(int orderNumber, TrainOrdersModel order) {\norders.add(orderNumber, order);\nif (nextScheduledOrder >= orderNumber) {\nnextScheduledOrder++;\n}\nif (-1 == nextScheduledOrder && 0 < numberOfScheduledStops()) {\nnextScheduledOrder = firstScheduleStop();\n}\n}\npublic int addOrder(TrainOrdersModel order) {\nif (!canAddOrder()) {\nthrow new IllegalStateException();\n}\nint newOrderNumber = orders.size();\naddOrder(newOrderNumber, order);\nreturn newOrderNumber;\n}\npublic void setOrder(int orderNumber, TrainOrdersModel order) {\nif (orderNumber >= orders.size()) {\norders.add(order);\n} else {\norders.set(orderNumber, order);\n}\n}\npublic TrainOrdersModel getOrder(int i) {\nreturn orders.get(i);\n}\n/** Returns the number of the order the train is currently carry out. */\npublic int getOrderToGoto() {\nreturn nextScheduledOrder;\n}\npublic void setOrderToGoto(int i) {\nif (i < 0 || i >= orders.size()) {\nthrow new IllegalArgumentException(String.valueOf(i));\n}\nnextScheduledOrder = i;\n}\n/**\n* Returns the station number of the next station the train is scheduled to\n* stop at.\n*/\npublic int getStationToGoto() {\nreturn orders.get(nextScheduledOrder).getStationID();\n}\n/** Returns the wagons to add at the next scheduled stop. */\npublic ImInts getWagonsToAdd() {\nreturn orders.get(nextScheduledOrder).getConsist();\n}\n/**\n* If there are no priority orders, sets the station to goto to the next\n* station in the list of orders or if there are no more stations, the first\n* station in the list. If priority orders are set, the priority orders\n* orders are removed from the schedule and the goto station is not changed.\n*/\npublic void gotoNextStation() {\nif (hasPriorityOrders) {\nif (nextScheduledOrder != PRIORITY_ORDERS) {\nremoveOrder(PRIORITY_ORDERS);\nreturn;\n}\n}\nnextScheduledOrder++;\nif (orders.size() <= nextScheduledOrder) {\nnextScheduledOrder = 0;\n}\n}\npublic boolean hasPriorityOrders() {\nreturn this.hasPriorityOrders;\n}\n/**\n* Returns number of non priority orders + number of priority orders.\n*\n* @return Number of orders.\n*/\npublic int getNumOrders() {\nreturn orders.size();\n}\npublic boolean canPullUp(int orderNumber) {\nboolean isAlreadyAtTop = 0 == orderNumber;\nboolean isPriorityOrdersAbove = (orderNumber == 1 && this.hasPriorityOrders);\nreturn !isAlreadyAtTop && !isPriorityOrdersAbove;\n}\npublic boolean canPushDown(int orderNumber) {\nboolean isOrderPriorityOrders = (orderNumber == 0 && this.hasPriorityOrders);\nboolean isAlreadyAtBottom = orderNumber == this.orders.size() - 1;\nreturn !isOrderPriorityOrders && !isAlreadyAtBottom;\n}\npublic void pullUp(int orderNumber) {\nif (!canPullUp(orderNumber)) {\nthrow new IllegalArgumentException(String.valueOf(orderNumber));\n}\nboolean isGoingToThisStation = getOrderToGoto() == orderNumber;\nTrainOrdersModel order = getOrder(orderNumber);\nremoveOrder(orderNumber);\naddOrder(orderNumber - 1, order);\nif (isGoingToThisStation) {\nsetOrderToGoto(orderNumber - 1);\n}\n}\npublic void pushDown(int orderNumber) {\nif (!canPushDown(orderNumber)) {\nthrow new IllegalArgumentException(String.valueOf(orderNumber));\n}\nboolean isGoingToThisStation = getOrderToGoto() == orderNumber;\nTrainOrdersModel order = getOrder(orderNumber);\nremoveOrder(orderNumber);\naddOrder(orderNumber + 1, order);\nif (isGoingToThisStation) {\nsetOrderToGoto(orderNumber + 1);\n}\n}\npublic boolean canAddOrder() {\nint max = hasPriorityOrders ? MAXIMUM_NUMBER_OF_ORDER + 1\n: MAXIMUM_NUMBER_OF_ORDER;\nreturn max > getNumOrders();\n}\npublic boolean canSetGotoStation(int orderNumber) {\nreturn !(orderNumber == 0 && hasPriorityOrders);\n}\npublic int getNextScheduledOrder() {\nreturn this.nextScheduledOrder;\n}\npublic void removeAllStopsAtStation(int stationNumber) {\nint i = 0;\nwhile (i < this.getNumOrders()) {\nTrainOrdersModel order = this.getOrder(i);\nif (order.getStationID() == stationNumber) {\nthis.removeOrder(i);\n} else {\ni++;\n}\n}\n}\npublic boolean autoConsist() {\nreturn orders.get(nextScheduledOrder).autoConsist;\n}\n}"}
{"className":"jfreerails.world.train.TrainMotion","javaDoc":"/**\n* <p>\n* This immutable class provides methods that return a train's position and\n* speed at any time within an interval. An instance of this class will be\n* stored on the world object for each train rather the train's position. The\n* reasons for this are as follows.\n*\n* <ol type=\"i\">\n* <li> It decouples the number of game updates per second and number of frames\n* per second shown by the client. If the train's position were stored on the\n* world object, it would get updated each game tick. But this would mean that\n* if the game was being updated 10 times per second, even if the client was\n* displaying 50 FPS, the train's motion would still appear jerky since its\n* position would only change 10 times per second. </li>\n* <li>\n*\n* It makes supporting low bandwidth networks easier since it allows the server\n* to send updates less frequently. </li>\n* </p>\n*\n*\n* @author Luke\n* @see jfreerails.world.train.PathOnTiles\n* @see jfreerails.world.train.CompositeSpeedAgainstTime\n*/","code":"/**\n* <p>\n* This immutable class provides methods that return a train's position and\n* speed at any time within an interval. An instance of this class will be\n* stored on the world object for each train rather the train's position. The\n* reasons for this are as follows.\n*\n* <ol type=\"i\">\n* <li> It decouples the number of game updates per second and number of frames\n* per second shown by the client. If the train's position were stored on the\n* world object, it would get updated each game tick. But this would mean that\n* if the game was being updated 10 times per second, even if the client was\n* displaying 50 FPS, the train's motion would still appear jerky since its\n* position would only change 10 times per second. </li>\n* <li>\n*\n* It makes supporting low bandwidth networks easier since it allows the server\n* to send updates less frequently. </li>\n* </p>\n*\n*\n* @author Luke\n* @see jfreerails.world.train.PathOnTiles\n* @see jfreerails.world.train.CompositeSpeedAgainstTime\n*/\nstrictfp public class TrainMotion implements Activity<TrainPositionOnMap> {\nprivate static final long serialVersionUID = 3618423722025891641L;\nprivate final double duration, distanceEngineWillTravel;\nprivate final double initialPosition;\nprivate final PathOnTiles path;\nprivate final SpeedAgainstTime speeds;\nprivate final int trainLength;\nprivate final SpeedTimeAndStatus.TrainActivity activity;\n/**\n* Creates a new TrainMotion instance.\n*\n* @param path\n* the path the train will take.\n* @param engineStep\n* the position measured in tiles that trains engine is along the\n* path\n* @param trainLength\n* the length of the train, as returned by\n* <code>TrainModel.getLength()</code>.\n* @throws IllegalArgumentException\n* if trainLength is out the range\n* <code>trainLength &gt; TrainModel.WAGON_LENGTH || trainLength &lt; TrainModel.MAX_TRAIN_LENGTH</code>\n* @throws IllegalArgumentException\n* if\n* <code>path.getDistance(engineStep) &lt; trainLength</code>.\n* @throws IllegalArgumentException\n* if\n* <code>(path.getLength() - initialPosition) &gt; speeds.getTotalDistance()</code>.\n*/\npublic TrainMotion(PathOnTiles path, int engineStep, int trainLength,\nSpeedAgainstTime speeds) {\nif (trainLength < TrainModel.WAGON_LENGTH\n|| trainLength > TrainModel.MAX_TRAIN_LENGTH)\nthrow new IllegalArgumentException();\nthis.path = path;\nthis.speeds = speeds;\nthis.trainLength = trainLength;\nif(engineStep > path.steps())\nthrow new ArrayIndexOutOfBoundsException(String.valueOf(engineStep));\ninitialPosition = path.getDistance(engineStep);\nif (initialPosition < trainLength)\nthrow new IllegalArgumentException(\n\"The engine's initial position is not far enough along the path for \"\n+ \"the train's initial position to be specified.\");\ndouble totalPathDistance = path.getTotalDistance();\ndistanceEngineWillTravel = totalPathDistance - initialPosition;\nif (distanceEngineWillTravel > speeds.getS())\nthrow new IllegalArgumentException(\n\"The train's speed is not defined for the whole of the journey.\");\nif(distanceEngineWillTravel == 0){\nduration = 0d;\n}else{\ndouble tempDuration = speeds.calcT(distanceEngineWillTravel);\nwhile((speeds.calcS(tempDuration) - distanceEngineWillTravel) > 0){\ntempDuration -= Math.ulp(tempDuration);\n}\nduration = tempDuration;\n}\nactivity = SpeedTimeAndStatus.TrainActivity.READY;\nsanityCheck();\n}\n/** Checks we are not creating an object with an inconsistent state. That is, at the\n* time stored in the field duration, the engine must not have gone off the end of the path.*/\nprivate void sanityCheck() {\ndouble offset = calcOffSet(duration);\ndouble totalLength = path.getTotalDistance();\ndouble trainLengthDouble = trainLength;\nif(totalLength < offset + trainLengthDouble)\nthrow new IllegalStateException(offset +\" + \"+ trainLengthDouble+\" > \" +totalLength);\n}\npublic TrainMotion(PathOnTiles path, int trainLength, double duration, SpeedTimeAndStatus.TrainActivity act){\nthis.path = path;\nthis.trainLength = trainLength;\nthis.activity = act;\nthis.distanceEngineWillTravel = 0;\nthis.initialPosition = path.getTotalDistance();\nthis.speeds = ConstAcc.STOPPED;\nthis.duration = duration;\n}\nprivate double calcOffSet(double t) {\ndouble offset = getDistance(t) + initialPosition - trainLength;\nreturn offset;\n}\nvoid checkT(double t) {\nif (t < 0d || t > duration)\nthrow new IllegalArgumentException(\"t=\" + t + \", but duration=\"\n+ duration);\n}\npublic double duration() {\nreturn duration;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TrainMotion))\nreturn false;\nfinal TrainMotion trainMotion = (TrainMotion) o;\nif (trainLength != trainMotion.trainLength)\nreturn false;\nif (!path.equals(trainMotion.path))\nreturn false;\nif (!speeds.equals(trainMotion.speeds))\nreturn false;\nreturn true;\n}\n/**\n* Returns the train's distance along the track from the point the train was\n* at at time <code>getStart()</code> at the specified time.\n*\n* @param t\n* the time.\n* @return the distance\n* @throws IllegalArgumentException\n* if t is outside the interval\n*/\npublic double getDistance(double t) {\ncheckT(t);\nt = Math.min(t, speeds.getT());\nreturn speeds.calcS(t);\n}\npublic PositionOnTrack getFinalPosition() {\nreturn path.getFinalPosition();\n}\npublic double getSpeedAtEnd() {\ndouble finalT = speeds.getT();\nreturn speeds.calcV(finalT);\n}\n/**\n* Returns the train's position at the specified time.\n*\n* @param t\n* the time.\n* @return the train's position.\n* @throws IllegalArgumentException\n* if t is outside the interval\n*/\npublic TrainPositionOnMap getState(double t) {\nt = Math.min(t, speeds.getT());\ndouble offset = calcOffSet(t);\nFreerailsPathIterator pathIt = path.subPath(offset, trainLength);\ndouble speed = speeds.calcV(t);\ndouble acceleration = speeds.calcA(t);\nTrainPositionOnMap tpom = TrainPositionOnMap\n.createInSameDirectionAsPath(pathIt, speed, acceleration,\nactivity);\nreturn tpom.reverse();\n}\n/**\n* Returns a PathOnTiles object that identifies the tiles the train is on at\n* the specified time.\n*\n* @param t\n* the time.\n* @return an array of the tiles the train is on\n* @throws IllegalArgumentException\n* if t is outside the interval\n*/\npublic PathOnTiles getTiles(double t) {\ncheckT(t);\nt = Math.min(t, speeds.getT());\ndouble start = calcOffSet(t);\ndouble end = start + trainLength;\nArrayList<Step> steps = new ArrayList<Step>();\ndouble distanceSoFar = 0;\nint stepsBeforeStart = 0;\nint stepsAfterEnd = 0;\nfor (int i = 0; i < path.steps(); i++) {\nif (distanceSoFar > end)\nstepsAfterEnd++;\nStep step = path.getStep(i);\ndistanceSoFar += step.getLength();\nif (distanceSoFar < start)\nstepsBeforeStart++;\n}\nif (distanceSoFar < start) {\n// throw new IllegalStateException();\n}\nif (distanceSoFar < (end - 0.1)) {\n// throw new IllegalStateException();\n}\nint lastStep = path.steps() - stepsAfterEnd;\nfor (int i = stepsBeforeStart; i < lastStep; i++) {\nsteps.add(path.getStep(i));\n}\nImPoint p = path.getStart();\nint x = p.x;\nint y = p.y;\nfor (int i = 0; i < stepsBeforeStart; i++) {\nStep step = path.getStep(i);\nx += step.deltaX;\ny += step.deltaY;\n}\nImPoint startPoint = new ImPoint(x, y);\nPathOnTiles pathOnTiles = new PathOnTiles(startPoint, steps);\nreturn pathOnTiles;\n}\npublic int getTrainLength() {\nreturn trainLength;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = path.hashCode();\nresult = 29 * result + speeds.hashCode();\nresult = 29 * result + trainLength;\nreturn result;\n}\npublic PathOnTiles getPath() {\nreturn path;\n}\npublic SpeedTimeAndStatus.TrainActivity getActivity() {\nreturn activity;\n}\npublic double getInitialPosition() {\nreturn initialPosition;\n}\n}"}
{"className":"jfreerails.world.train.PathWalker","javaDoc":"/**\n* This interface lets the caller retrieve a path broken into a series of steps,\n* whose length the caller specifies. E.g. it could be used to get the sub\n* section of a path that a train travels during an given time interval.\n*\n* @author Luke\n*/","code":"/**\n* This interface lets the caller retrieve a path broken into a series of steps,\n* whose length the caller specifies. E.g. it could be used to get the sub\n* section of a path that a train travels during an given time interval.\n*\n* @author Luke\n*/\npublic interface PathWalker extends FreerailsPathIterator,\nFreerailsMutableSerializable {\n/**\n* Returns true if we have not reached the end of the path.\n*/\nboolean canStepForward();\n/**\n* Moves this path walker forward by the specified distance along the path\n* and returns a path iterator to retrieve the section of the path travelled\n* during this move.\n*/\nvoid stepForward(double distance);\n}"}
{"className":"jfreerails.world.track.TrackSectionTest","javaDoc":null,"code":"public class TrackSectionTest extends TestCase {\npublic void testEqualsObject() {\nTrackSection a = new TrackSection(Step.EAST, new ImPoint(10, 5));\nTrackSection b = new TrackSection(Step.WEST, new ImPoint(11, 5));\nassertEquals(a, a);\nassertEquals(b, b);\nassertEquals(a, b);\nassertEquals(b, a);\n}\n}"}
{"className":"jfreerails.world.track.TrackConfigurationTest","javaDoc":"/**\n* JUnit test.\n*\n* @author lindsal\n*/","code":"/**\n* JUnit test.\n*\n* @author lindsal\n*/\npublic class TrackConfigurationTest extends TestCase {\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\npublic static Test suite() {\nTestSuite suite = new TestSuite(TrackConfigurationTest.class);\nreturn suite;\n}\npublic TrackConfigurationTest(java.lang.String testName) {\nsuper(testName);\n}\npublic void testAdd() {\nTrackConfiguration a = TrackConfiguration.getFlatInstance(\"000010000\");\nTrackConfiguration b = TrackConfiguration.add(a, Step.NORTH_WEST);\nassertEquals(TrackConfiguration.getFlatInstance(\"100010000\"), b);\nassertEquals(false, a == b);\n}\npublic void testGet8And9bitTemplate() {\nfor (int i = 0; i < 512; i++) {\nTrackConfiguration tc = TrackConfiguration.from9bitTemplate(i);\nassertEquals(i, tc.get9bitTemplate());\n}\nfor (Step v : Step.getList()) {\nTrackConfiguration tc = TrackConfiguration.getFlatInstance(v);\nassertEquals(v.get9bitTemplate(), tc.get9bitTemplate());\nassertEquals(v.get8bitTemplate(), tc.get8bitTemplate());\nTrackConfiguration tc2 = TrackConfiguration.from9bitTemplate(v\n.get9bitTemplate());\nassertEquals(tc, tc2);\n}\n}\npublic void testGetLength() {\nTrackConfiguration a = TrackConfiguration.getFlatInstance(\"010010000\");\nTrackConfiguration b = TrackConfiguration.getFlatInstance(\"010010010\");\nassertEquals(30, a.getLength());\nassertEquals(60, b.getLength());\n}\npublic void testSubtract() {\nTrackConfiguration a = TrackConfiguration.getFlatInstance(\"100010000\");\nTrackConfiguration b = TrackConfiguration.subtract(a, Step.NORTH_WEST);\nassertEquals(TrackConfiguration.getFlatInstance(\"000010000\"), b);\n}\npublic void testToString() {\nTrackConfiguration a = TrackConfiguration.getFlatInstance(\"100010000\");\nassertEquals(\"tile center, north west\", a.toString());\na = TrackConfiguration.getFlatInstance(Step.NORTH_WEST);\nassertEquals(\"no tile center, north west\", a.toString());\na = TrackConfiguration.getFlatInstance(\"000010000\");\nassertEquals(\"tile center\", a.toString());\na = TrackConfiguration.getFlatInstance(\"000000000\");\nassertEquals(\"no tile center\", a.toString());\n// Check that no two track configurations have the same String\n// representation.\nHashSet<String> strings = new HashSet<String>();\nfor (int i = 0; i < 512; i++) {\nTrackConfiguration test = TrackConfiguration.from9bitTemplate(i);\nString toString = test.toString();\nif (strings.contains(toString)) {\nfail(toString + \" \" + i);\n}\nstrings.add(toString);\n}\n}\n}"}
{"className":"jfreerails.world.track.TrackPieceImplTest","javaDoc":null,"code":"public class TrackPieceImplTest extends TestCase {\nprivate World w;\n@Override\nprotected void setUp() throws Exception {\nw = MapFixtureFactory2.getCopy();\n}\npublic void testEqualsObject() {\nTrackConfiguration tc1 = TrackConfiguration.getFlatInstance(Step.NORTH);\nTrackRule rule0 = (TrackRule) w.get(SKEY.TRACK_RULES, 0);\nTrackRule rule4 = (TrackRule) w.get(SKEY.TRACK_RULES, 4);\nTrackPieceImpl tp1 = new TrackPieceImpl(tc1, rule0, 0, 0);\nassertEquals(tp1, tp1);\nTrackPieceImpl tp2 = new TrackPieceImpl(tc1, rule4, 0, 4);\nassertFalse(tp1.equals(tp2));\nTrackPieceImpl tp1Clone = (TrackPieceImpl) Utils\n.cloneBySerialisation(tp1);\nassertEquals(tp1, tp1Clone);\n}\n}"}
{"className":"jfreerails.world.track.LegalTrackConfigurationsTest","javaDoc":"/**\n* JUnit test.\n*\n* @author lindsal\n*/","code":"/**\n* JUnit test.\n*\n* @author lindsal\n*/\npublic class LegalTrackConfigurationsTest extends TestCase {\npublic LegalTrackConfigurationsTest(java.lang.String testName) {\nsuper(testName);\n}\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\npublic static Test suite() {\nreturn new TestSuite(LegalTrackConfigurationsTest.class);\n}\npublic void testTrackPieceIsLegal() {\nArrayList<String> templates = new ArrayList<String>();\ntemplates.add(\"000111000\");\nLegalTrackConfigurations ltc = new LegalTrackConfigurations(-1,\ntemplates);\nTrackConfiguration template = TrackConfiguration\n.getFlatInstance(\"010010010\");\nassertEquals(true, ltc.trackConfigurationIsLegal(template));\ntemplate = TrackConfiguration.getFlatInstance(\"010111000\");\nassertEquals(false, ltc.trackConfigurationIsLegal(template));\n}\n}"}
{"className":"jfreerails.world.train.CompositeSpeedAgainstTimeTest","javaDoc":null,"code":"public class CompositeSpeedAgainstTimeTest extends TestCase {\npublic void testBounds(){\nSpeedAgainstTime sat = ConstAcc.uas(10, 2, 400d);\nCompositeSpeedAgainstTime csat = new CompositeSpeedAgainstTime(sat);\ndouble t = csat.duration();\ndouble t2 = csat.calcT(400d);\nassertEquals(t, t2);\ndouble s = csat.calcS(t);\nassertEquals(400d, s);\ndouble t3 = csat.calcT(0d);\nassertEquals(0d, t3);\n}\npublic void testContract(){\nRandom r = new Random(123);\nfor(int i = 0 ; i < 1000; i++){\nint numberOfParts = r.nextInt(10) + 1;\nSpeedAgainstTime[] parts = new SpeedAgainstTime[numberOfParts];\nfor(int j = 0; j < numberOfParts; j++){\nparts[j] = ConstAcc.uat(r.nextDouble(), r.nextDouble(), r.nextDouble());\n}\nCompositeSpeedAgainstTime csat = new CompositeSpeedAgainstTime(parts);\nConstAccTest.checkContract(csat);\n}\n}\n}"}
{"className":"jfreerails.world.train.MutableScheduleTest","javaDoc":null,"code":"public class MutableScheduleTest extends TestCase {\npublic void test1() {\nTrainOrdersModel order0 = new TrainOrdersModel(0, null, false, false);\nTrainOrdersModel order1 = new TrainOrdersModel(1, null, false, false);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\nint station2Goto = s.getStationToGoto();\nassertEquals(0, station2Goto);\n// ImmutableSchedule is = s.toImmutableSchedule();\n//\n// int i = is.getStationToGoto();\n}\n}"}
{"className":"jfreerails.world.train.ConstAccTest","javaDoc":null,"code":"public class ConstAccTest extends TestCase {\npublic void testTandS() {\nSpeedAgainstTime acc1 = ConstAcc.uat(0, 10, 5);\ndouble s = acc1.getS();\nSpeedAgainstTime acc2 = ConstAcc.uas(0, 10, s);\nassertEquals(acc1, acc2);\nacc1 = ConstAcc.uat(10, 0, 5);\nassertEquals(50, acc1.getS(), 0.00001);\nacc2 = ConstAcc.uas(10, 0, acc1.getS());\nassertEquals(acc1, acc2);\n}\npublic void testEquals() {\nSpeedAgainstTime acc1 = ConstAcc.uat(0, 10, 4);\nSpeedAgainstTime acc2 = ConstAcc.uat(0, 10, 4);\nassertEquals(acc1, acc2);\n}\npublic void testContract(){\nRandom r = new Random(88);\nfor(int i = 0; i < 1000; i++){\nConstAcc acc1 = ConstAcc.uat(r.nextDouble(), r.nextDouble(), r.nextDouble());\ncheckContract(acc1);\nConstAcc acc2 = ConstAcc.uas(r.nextDouble(), r.nextDouble(), r.nextDouble());\ncheckContract(acc2);\n}\n}\n/** Checks the specified object satisfies the contract defined by\n* the interface SpeedAgainstTime.\n*/\npublic static void checkContract(SpeedAgainstTime sat){\ndouble s = sat.getS();\ndouble ulps = Math.ulp(s);\ndouble t = sat.getT();\ndouble ulpt = Math.ulp(t);\n//Check calcS()\ncheckCalcSCalcVandCalcA(sat, 0 - Double.MIN_VALUE);\ncheckCalcSCalcVandCalcA(sat, t + ulpt);\ncheckCalcSCalcVandCalcA(sat, 0 + Double.MIN_VALUE);\ncheckCalcSCalcVandCalcA(sat, t - ulpt);\nfor(double d = 0; d < 1d; d += 0.1d){\ncheckCalcSCalcVandCalcA(sat, t * d);\n}\ndouble actualS = sat.calcS(0);\nassertEquals(0d, actualS);\nactualS = sat.calcS(t);\nassertEquals(s, actualS);\n//Check calcT()\ncheckCalcT(sat, 0 - Double.MIN_VALUE);\ncheckCalcT(sat, s + ulps);\ncheckCalcT(sat, 0 + Double.MIN_VALUE);\ncheckCalcT(sat, s - ulps);\nfor(double d = 0; d < 1d; d += 0.1d){\ncheckCalcT(sat, s * d);\n}\ndouble actualT = sat.calcT(0);\nassertEquals(0d, actualT);\nactualT = sat.calcT(s);\nassertEquals(t, actualT);\n}\nprivate static void checkCalcSCalcVandCalcA(SpeedAgainstTime sat, double t){\nboolean exceptionExpected = (t < 0) || ( t > sat.getT());\ntry{\ndouble actualS = sat.calcS(t);\nassertTrue(actualS >= 0);\nassertTrue(actualS <= sat.getS());\nassertFalse(exceptionExpected);\n}catch (IllegalArgumentException e) {\nassertTrue(exceptionExpected);\n}\n//Also check getV and getA\ntry{\ndouble v = sat.calcV(t);\nassertTrue(v >= 0);\nassertFalse(exceptionExpected);\n}catch (IllegalArgumentException e) {\nassertTrue(exceptionExpected);\n}\ntry{\nsat.calcA(t);\nassertFalse(exceptionExpected);\n}catch (IllegalArgumentException e) {\nassertTrue(exceptionExpected);\n}\n}\nprivate static void checkCalcT(SpeedAgainstTime sat, double s){\nboolean exceptionExpected = (s < 0) || ( s > sat.getS());\ntry{\ndouble actualT = sat.calcT(s);\nassertTrue(actualT >= 0);\nassertTrue(actualT <= sat.getT());\nassertFalse(exceptionExpected);\n}catch (IllegalArgumentException e) {\nassertTrue(exceptionExpected);\n}\n}\n}"}
{"className":"jfreerails.world.train.SimplePathIteratorImplTest","javaDoc":"/**\n* Junit test.\n*\n* @author Luke\n*/","code":"/**\n* Junit test.\n*\n* @author Luke\n*/\npublic class SimplePathIteratorImplTest extends TestCase {\npublic SimplePathIteratorImplTest(String arg0) {\nsuper(arg0);\n}\npublic static void main(String[] args) {\njunit.textui.TestRunner.run(SimplePathIteratorImplTest.class);\n}\npublic void testHasNext() {\nint[] xpoints = { 0, 100 };\nint[] ypoints = { 0, 0 };\nFreerailsPathIterator it = new SimplePathIteratorImpl(xpoints, ypoints);\nassertTrue(it.hasNext());\nit.nextSegment(new IntLine(0, 0, 0, 0));\nassertTrue(!it.hasNext());\n}\npublic void testNextSegment() {\nint[] xpoints = { 1, 2, 3 };\nint[] ypoints = { 4, 5, 6 };\nFreerailsPathIterator it = new SimplePathIteratorImpl(xpoints, ypoints);\nassertTrue(it.hasNext());\nIntLine line = new IntLine(0, 0, 0, 0);\nit.nextSegment(line);\nassertLineEquals(1, 4, 2, 5, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(2, 5, 3, 6, line);\nassertTrue(!it.hasNext());\n}\nprivate void assertLineEquals(int x1, int y1, int x2, int y2, IntLine line) {\nassertEquals(x1, line.x1);\nassertEquals(x2, line.x2);\nassertEquals(y1, line.y1);\nassertEquals(y2, line.y2);\n}\n}"}
{"className":"jfreerails.world.train.TrainPositionOnMapTest","javaDoc":"/**\n* Junit test.\n*\n* @author Luke Lindsay 26-Oct-2002\n*\n*/","code":"/**\n* Junit test.\n*\n* @author Luke Lindsay 26-Oct-2002\n*\n*/\npublic class TrainPositionOnMapTest extends TestCase {\npublic TrainPositionOnMapTest(String arg0) {\nsuper(arg0);\n}\npublic void testGetLength() {\nTrainPositionOnMap a;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20, 30, 40 },\nnew int[] { 11, 22, 33, 44 });\nassertEquals(4, a.getLength());\n}\npublic void testGetPoint() {\nTrainPositionOnMap a;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nassertEquals(a.getX(0), 10);\nassertEquals(a.getY(0), 11);\nassertEquals(a.getX(1), 20);\nassertEquals(a.getY(1), 22);\n}\npublic void testPath() {\nTrainPositionOnMap a;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20, 30, 40 },\nnew int[] { 11, 22, 33, 44 });\nFreerailsPathIterator path = a.path();\nIntLine line = new IntLine();\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(10, 11, 20, 22));\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(20, 22, 30, 33));\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(30, 33, 40, 44));\nassertTrue(!path.hasNext());\n}\npublic void testReversePath() {\nTrainPositionOnMap a;\na = TrainPositionOnMap.createInstance(new int[] { 40, 30, 20, 10 },\nnew int[] { 44, 33, 22, 11 });\nFreerailsPathIterator path = a.reversePath();\nIntLine line = new IntLine();\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(10, 11, 20, 22));\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(20, 22, 30, 33));\nassertTrue(path.hasNext());\npath.nextSegment(line);\nassertEquals(line, new IntLine(30, 33, 40, 44));\nassertTrue(!path.hasNext());\n}\n/*\n* Test for TrainPosition createInstance(int[], int[])\n*/\npublic void testCreateInstanceIArrayIArray() {\ntry {\nTrainPositionOnMap.createInstance(new int[] { 40, 30, 20, 10 },\nnew int[] { 44, 33, 22, 11 });\n} catch (Exception e) {\nassertTrue(false);\n}\ntry {\nTrainPositionOnMap.createInstance(new int[] { 40, 30, 20 },\nnew int[] { 44, 33, 22, 11 });\nassertTrue(false);\n} catch (Exception e) {\n}\n}\n/*\n* public void testAdd() { TrainPosition a, b, c, d, e, f, g, h , i, j;\n* a=TrainPosition.createInstance(new int[] {10,20}, new int[]{11,22});\n* b=TrainPosition.createInstance(new int[] {20, 30}, new int[]{22,33});\n* c=TrainPosition.createInstance(new int[] {10, 30}, new int[]{11, 33});\n*\n* d=TrainPosition.add(a, b); assertEquals(d, c); e=TrainPosition.add(b, a);\n* assertEquals(e, c);\n*\n*\n* f = TrainPosition.createInstance( new int[] { 40, 50 }, new int[] { 44,\n* 55 }); g = TrainPosition.createInstance( new int[] { 10, 30, 40 }, new\n* int[] { 11, 33, 44 });\n*\n* i = TrainPosition.createInstance( new int[] { 10, 30, 50 }, new int[] {\n* 11, 33, 55 }); j = TrainPosition.add(f, g); assertEquals(i, j);\n*\n*\n* }\n*/\n/*\n* public void testRemove() { TrainPosition a, b, c, d, e, f, g, h , i, j ,\n* k; a=TrainPosition.createInstance(new int[] {10,20 ,40 , 50, 60}, new\n* int[]{11,22, 44, 55 , 66}); b=TrainPosition.createInstance(new int[] {10,\n* 20, 30}, new int[]{11,22,33}); c=TrainPosition.createInstance(new int[]\n* {48, 50, 60}, new int[]{49,55, 66});\n*\n* d=TrainPosition.createInstance(new int[] {30, 40 , 50, 60}, new int[]{33,\n* 44, 55, 66}); e=TrainPosition.createInstance(new int[] {10, 20, 40, 48},\n* new int[]{11, 22, 44, 49});\n*\n* f=TrainPosition.remove(a, b); assertEquals(f, d);\n*\n* g=TrainPosition.remove(a, c); assertEquals(g, e);\n*\n* h = TrainPosition.createInstance( new int[] { 10, 30, 50 }, new int[] {\n* 11, 33, 55 });\n*\n* i = TrainPosition.createInstance( new int[] { 10, 20 }, new int[] { 11,\n* 22 });\n*\n* j = TrainPosition.createInstance( new int[] { 20, 30, 50 }, new int[] {\n* 22, 33, 55 });\n*\n* k = TrainPosition.remove(h, i);\n*\n* assertEquals(k, j); }\n*\n*/\n/*\n* public void testCanBeAdded() { TrainPosition a, b, c, d;\n* a=TrainPosition.createInstance(new int[] {10,20}, new int[]{11,22});\n* b=TrainPosition.createInstance(new int[] {20, 30}, new int[]{22,33});\n* c=TrainPosition.createInstance(new int[] {30, 40}, new int[]{33,44});\n*\n* assertTrue(TrainPosition.canBeAdded(a, b));\n* assertTrue(TrainPosition.canBeAdded(b, a));\n* assertTrue(TrainPosition.canBeAdded(b, c));\n* assertTrue(!TrainPosition.canBeAdded(c, b));\n*\n* assertTrue(!TrainPosition.canBeAdded(a, c));\n* assertTrue(!TrainPosition.canBeAdded(c, a));\n*\n* //Test that we cannot add a position to itself\n* assertTrue(!TrainPosition.canBeAdded(a, a));\n* assertTrue(!TrainPosition.canBeAdded(b, b));\n* assertTrue(!TrainPosition.canBeAdded(c, c)); }\n*/\n/*\n* public void testCanBeRemoved() { TrainPosition a, b, c, d;\n* a=TrainPosition.createInstance(new int[] {10,20 ,40 , 50}, new\n* int[]{11,22, 44, 55}); b=TrainPosition.createInstance(new int[] {10, 20,\n* 30}, new int[]{11,22,33}); c=TrainPosition.createInstance(new int[] {30,\n* 40, 50}, new int[]{33,44,55});\n*\n* assertTrue(TrainPosition.canBeRemoved(a, b));\n*\n* assertTrue(!TrainPosition.canBeRemoved(b, a));\n*\n* assertTrue(TrainPosition.canBeRemoved(a, c));\n*\n* assertTrue(!TrainPosition.canBeRemoved(c, a));\n*\n* //Test that we cannot remove a position from itself\n* assertTrue(!TrainPosition.canBeRemoved(a, a));\n* assertTrue(!TrainPosition.canBeRemoved(b, b));\n* assertTrue(!TrainPosition.canBeRemoved(c, c)); }\n*/\npublic void testAddToHead() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\nTrainPositionOnMap d;\nTrainPositionOnMap f;\nTrainPositionOnMap g;\nTrainPositionOnMap i;\nTrainPositionOnMap j;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nb = TrainPositionOnMap.createInstance(new int[] { 20, 30 }, new int[] {\n22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 10, 30 }, new int[] {\n11, 33 });\nd = b.addToHead(a);\nassertEquals(d, c);\nf = TrainPositionOnMap.createInstance(new int[] { 40, 50 }, new int[] {\n44, 55 });\ng = TrainPositionOnMap.createInstance(new int[] { 10, 30, 40 },\nnew int[] { 11, 33, 44 });\ni = TrainPositionOnMap.createInstance(new int[] { 10, 30, 50 },\nnew int[] { 11, 33, 55 });\nj = f.addToHead(g);\nassertEquals(i, j);\n}\npublic void testCanAddToHead() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nb = TrainPositionOnMap.createInstance(new int[] { 20, 30 }, new int[] {\n22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 30, 40 }, new int[] {\n33, 44 });\nassertTrue(b.canAddToHead(a));\nassertTrue(!a.canAddToHead(b));\nassertTrue(c.canAddToHead(b));\nassertTrue(!b.canAddToHead(c));\nassertTrue(!c.canAddToHead(a));\nassertTrue(!a.canAddToHead(c));\n}\npublic void testAddToTail() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\nTrainPositionOnMap d;\nTrainPositionOnMap f;\nTrainPositionOnMap g;\nTrainPositionOnMap i;\nTrainPositionOnMap j;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nb = TrainPositionOnMap.createInstance(new int[] { 20, 30 }, new int[] {\n22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 10, 30 }, new int[] {\n11, 33 });\nd = a.addToTail(b);\nassertEquals(d, c);\nf = TrainPositionOnMap.createInstance(new int[] { 40, 50 }, new int[] {\n44, 55 });\ng = TrainPositionOnMap.createInstance(new int[] { 10, 30, 40 },\nnew int[] { 11, 33, 44 });\ni = TrainPositionOnMap.createInstance(new int[] { 10, 30, 50 },\nnew int[] { 11, 33, 55 });\nj = g.addToTail(f);\nassertEquals(i, j);\n}\npublic void testCanAddToTail() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nb = TrainPositionOnMap.createInstance(new int[] { 20, 30 }, new int[] {\n22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 30, 40 }, new int[] {\n33, 44 });\nassertTrue(!b.canAddToTail(a));\nassertTrue(a.canAddToTail(b));\nassertTrue(!c.canAddToTail(b));\nassertTrue(b.canAddToTail(c));\nassertTrue(!c.canAddToTail(a));\nassertTrue(!a.canAddToTail(c));\n}\npublic void testCanRemoveFromHead() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20, 40, 50 },\nnew int[] { 11, 22, 44, 55 });\nb = TrainPositionOnMap.createInstance(new int[] { 10, 20, 30 },\nnew int[] { 11, 22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 30, 40, 50 },\nnew int[] { 33, 44, 55 });\nassertTrue(!b.canRemoveFromHead(a));\nassertTrue(a.canRemoveFromHead(b));\nassertTrue(!c.canRemoveFromHead(b));\nassertTrue(!b.canRemoveFromHead(c));\nassertTrue(!c.canRemoveFromHead(a));\nassertTrue(!a.canRemoveFromHead(c));\n}\npublic void testRemoveFromTail() {\nTrainPositionOnMap a;\nTrainPositionOnMap c;\nTrainPositionOnMap e;\nTrainPositionOnMap f;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20, 40, 50, 60 },\nnew int[] { 11, 22, 44, 55, 66 });\nc = TrainPositionOnMap.createInstance(new int[] { 48, 50, 60 },\nnew int[] { 49, 55, 66 });\ne = TrainPositionOnMap.createInstance(new int[] { 10, 20, 40, 48 },\nnew int[] { 11, 22, 44, 49 });\nf = a.removeFromTail(c);\nassertEquals(e, f);\n}\npublic void testCanRemoveFromTail() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20, 40, 50 },\nnew int[] { 11, 22, 44, 55 });\nb = TrainPositionOnMap.createInstance(new int[] { 10, 20, 30 },\nnew int[] { 11, 22, 33 });\nc = TrainPositionOnMap.createInstance(new int[] { 30, 40, 50 },\nnew int[] { 33, 44, 55 });\nassertTrue(!b.canRemoveFromTail(a));\nassertTrue(!a.canRemoveFromTail(b));\nassertTrue(!c.canRemoveFromTail(b));\nassertTrue(!b.canRemoveFromTail(c));\nassertTrue(!c.canRemoveFromTail(a));\nassertTrue(a.canRemoveFromTail(c));\n}\npublic void testEquals() {\nTrainPositionOnMap a;\nTrainPositionOnMap b;\nTrainPositionOnMap c;\na = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nb = TrainPositionOnMap.createInstance(new int[] { 10, 20 }, new int[] {\n11, 22 });\nc = TrainPositionOnMap.createInstance(new int[] { 30, 40 }, new int[] {\n33, 44 });\nassertTrue(!a.equals(null));\nassertTrue(!a.equals(new Object()));\nassertTrue(a.equals(a));\nassertTrue(a.equals(b));\nassertTrue(!a.equals(c));\n}\n/*\n* Test for TrainPosition createInstance(FreerailsPathIterator)\n*/\npublic void testCreateInstanceFreerailsPathIterator() {\nFreerailsPathIterator path = new SimplePathIteratorImpl(new int[] { 40,\n30, 20, 10 }, new int[] { 44, 33, 22, 11 });\nTrainPositionOnMap a = TrainPositionOnMap\n.createInSameDirectionAsPath(path);\nassertEquals(a.getLength(), 4);\nassertEquals(a.getX(0), 40);\nassertEquals(a.getY(0), 44);\nassertEquals(a.getX(1), 30);\nassertEquals(a.getY(1), 33);\nassertEquals(a.getX(2), 20);\nassertEquals(a.getY(2), 22);\nassertEquals(a.getX(3), 10);\nassertEquals(a.getY(3), 11);\n}\npublic void testCreateInOppositeDirectionToPath() {\nFreerailsPathIterator path = new SimplePathIteratorImpl(new int[] { 40,\n30, 20, 10 }, new int[] { 44, 33, 22, 11 });\nTrainPositionOnMap a = TrainPositionOnMap.createInSameDirectionAsPath(\npath).reverse();\nassertEquals(a.getLength(), 4);\nassertEquals(a.getX(3), 40);\nassertEquals(a.getY(3), 44);\nassertEquals(a.getX(2), 30);\nassertEquals(a.getY(2), 33);\nassertEquals(a.getX(1), 20);\nassertEquals(a.getY(1), 22);\nassertEquals(a.getX(0), 10);\nassertEquals(a.getY(0), 11);\n}\n}"}
{"className":"jfreerails.world.train.PathWalkerImplTest","javaDoc":"/**\n* JUnit test.\n*\n* @author Luke\n*/","code":"/**\n* JUnit test.\n*\n* @author Luke\n*/\npublic class PathWalkerImplTest extends TestCase {\nFreerailsPathIterator it;\nPathWalker pw;\npublic PathWalkerImplTest(String arg0) {\nsuper(arg0);\n}\npublic static void main(String[] args) {\njunit.textui.TestRunner.run(PathWalkerImplTest.class);\n}\n/*\n* Test for boolean canStepForward()\n*/\npublic void testCanStepForward() {\nsetup();\nassertTrue(pw.canStepForward());\npw.stepForward(500); // The path length is 200;\nmoveToNextLimit();\nassertTrue(!pw.canStepForward());\nsetup();\nassertTrue(pw.canStepForward());\npw.stepForward(10);\nassertTrue(pw.canStepForward());\nIntLine line = new IntLine();\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertLineEquals(0, 0, 10, 0, line);\nassertTrue(!pw.hasNext());\nassertTrue(pw.canStepForward());\npw.stepForward(500); // The path length is 200;\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertLineEquals(10, 0, 100, 0, line);\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertLineEquals(100, 0, 100, 100, line);\nassertTrue(!pw.canStepForward());\n}\nprivate void moveToNextLimit() {\nIntLine line = new IntLine();\nwhile (pw.hasNext()) {\npw.nextSegment(line);\n}\n}\npublic void testHasNext() {\nIntLine line = new IntLine();\nsetup();\nassertTrue(!pw.hasNext());\npw.stepForward(10);\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertLineEquals(0, 0, 10, 0, line);\nassertTrue(!pw.hasNext());\nsetup();\nassertTrue(!pw.hasNext());\npw.stepForward(110);\nassertTrue(pw.hasNext());\nline = new IntLine();\npw.nextSegment(line);\nassertLineEquals(0, 0, 100, 0, line);\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertLineEquals(100, 0, 100, 10, line);\nassertTrue(!pw.hasNext());\n/*\n* Now test with underlying pathIterators with few elements.\n*/\nArrayList<Point> points = new ArrayList<Point>();\nassertHasNextEqualsFalse(points);\npoints = new ArrayList<Point>();\npoints.add(new Point(0, 0));\nassertHasNextEqualsFalse(points);\npoints = new ArrayList<Point>();\npoints.add(new Point(0, 0));\npoints.add(new Point(100, 0));\nFreerailsPathIterator it2 = FreerailsPathIteratorImpl\n.forwardsIterator(points);\nassertTrue(it2.hasNext());\npw = new PathWalkerImpl(it2);\nassertTrue(!pw.hasNext());\npw.stepForward(1000);\nassertTrue(pw.hasNext());\npw.nextSegment(line);\nassertTrue(!pw.hasNext());\n}\nvoid assertHasNextEqualsFalse(ArrayList<Point> points) {\nFreerailsPathIterator it2 = FreerailsPathIteratorImpl\n.forwardsIterator(points);\nassertTrue(!it2.hasNext());\npw = new PathWalkerImpl(it2);\npw.stepForward(100);\nassertTrue(!pw.hasNext());\n}\npublic void setup() {\nint[] xpoints = { 0, 100, 100 };\nint[] ypoints = { 0, 0, 100 };\nit = new SimplePathIteratorImpl(xpoints, ypoints);\npw = new PathWalkerImpl(it);\n}\nprivate void assertLineEquals(int x1, int y1, int x2, int y2, IntLine line) {\nassertEquals(x1, line.x1);\nassertEquals(x2, line.x2);\nassertEquals(y1, line.y1);\nassertEquals(y2, line.y2);\n}\n}"}
{"className":"jfreerails.world.train.TrainMotionTest","javaDoc":null,"code":"public class TrainMotionTest extends TestCase {\n/*\nthis= TrainMotion (id=49)\nactivity= SpeedTimeAndStatus$TrainActivity (id=107)\nname= \"READY\"\nordinal= 1\ndistanceEngineWillTravel= 30.0\nduration= 3.9936298481613424\ninitialPosition= 42.42640687119285\npath= PathOnTiles (id=48)\nstart= ImPoint (id=73)\nx= 14\ny= 5\nvectors= ImList<E> (id=75)\nelementData= FreerailsSerializable[2] (id=77)\n[0]= Step (id=79)\ndeltaX= 1\ndeltaY= 1\nflatTrackTemplate= 256\nlength= 42.42640687119285\n[1]= Step (id=82)\ndeltaX= 1\ndeltaY= 0\nflatTrackTemplate= 32\nlength= 30.0\nspeeds= CompositeSpeedAgainstTime (id=111)\nduration= 10.972888751347389\ntotalDistance= 97.57359312880715\nvalues= ImList<E> (id=114)\nelementData= FreerailsSerializable[2] (id=118)\n[0]= ConstAcc (id=119)\na= 0.5\ndt= 6.972888751347389\nu= 6.5135556243263055\n[1]= ConstAcc (id=121)\na= 0.0\ndt= 4.0\nu= 10.0\ntrainLength= 24\nt= 3.9936298481613424\noffset= 48.42640687119287\nlength= 24.0\n72.42640687119285\n*/\npublic void test4Bug1266695(){\n//The figures are copied from the debugger.\nImPoint start = new ImPoint(14, 5);\nStep[] vectors= {Step.getInstance(1,1), Step.getInstance(1,0)};\nPathOnTiles path = new PathOnTiles(start, vectors);\nConstAcc constAcc0 = ConstAcc.uat(6.5135556243263055d, 0.5d, 6.972888751347389d);\nConstAcc constAcc1 = ConstAcc.uat(10.0, 0.0d, 4.0d);\nSpeedAgainstTime speeds = new CompositeSpeedAgainstTime(constAcc0, constAcc1);\ndouble expectedTotalDistance= 97.57359312880715d; //Copied from debugger.\ndouble actualTotalDistance = speeds.getS();\nassertEquals(expectedTotalDistance, actualTotalDistance,0d);\ndouble expectedDuration = 10.972888751347389d;\ndouble actualDuration = speeds.getT();\nassertEquals(expectedDuration, actualDuration,0d);\nint engineStep = 1;\nint trainLength = 24;\nTrainMotion motion = new TrainMotion(path,engineStep, trainLength, speeds);\ndouble expectedInitialPosition = 42.42640687119285;\ndouble actualInitialPosition = motion.getInitialPosition();\nassertEquals(expectedInitialPosition, actualInitialPosition,0d);\n//Different from above\ndouble tooLongDuration = 3.9936298481613424d;\nactualDuration = motion.duration();\nassertTrue(tooLongDuration > actualDuration);\n//This method used to throw an exception\n@SuppressWarnings(\"unused\") Object o = motion.getState(actualDuration);\n}\n}"}
{"className":"jfreerails.world.train.IntLineTest","javaDoc":"/**\n* Junit test.\n*\n* @author Luke\n*/","code":"/**\n* Junit test.\n*\n* @author Luke\n*/\npublic class IntLineTest extends TestCase {\npublic IntLineTest(String arg0) {\nsuper(arg0);\n}\npublic static void main(String[] args) {\njunit.textui.TestRunner.run(IntLineTest.class);\n}\npublic void testGetLength() {\nIntLine line = new IntLine(0, 0, 100, 0);\nassertEquals(100, line.getLength(), 0.1);\n}\n}"}
{"className":"jfreerails.world.train.PathOnTilesTest","javaDoc":"/**\n* JUnit test for PathOnTiles.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for PathOnTiles.\n*\n* @author Luke\n*\n*/\npublic class PathOnTilesTest extends TestCase {\npublic void testPathOnTiles() {\nImPoint start = null;\nStep[] vectors = null;\nassertTrue(throwsException(start, vectors));\nstart = new ImPoint();\nassertTrue(throwsException(start, vectors));\nvectors = new Step[] { null, null };\nassertTrue(throwsException(start, vectors));\nvectors = new Step[] { NORTH, SOUTH };\nassertFalse(throwsException(start, vectors));\n}\npublic void testGetStepIndex() {\nImPoint start = new ImPoint();\nStep[] vectors = new Step[] { SOUTH_EAST, EAST, EAST };\nPathOnTiles path = new PathOnTiles(start, vectors);\nassertEquals(0, path.getStepIndex(0));\nassertEquals(0, path.getStepIndex(1));\nassertEquals(0, path.getStepIndex(30));\nassertEquals(1, path.getStepIndex(60));\nassertEquals(2, path.getStepIndex(90));\n}\npublic void testGetLength() {\nImPoint start = new ImPoint();\nStep[] vectors = new Step[] { EAST, EAST, EAST };\nPathOnTiles path = new PathOnTiles(start, vectors);\nassertEquals(3 * Step.TILE_DIAMETER, path.getTotalDistance(), 0.001);\n}\npublic void testGetPoint() {\nImPoint start = new ImPoint();\nStep[] vectors = new Step[] { EAST, EAST, EAST };\nPathOnTiles path = new PathOnTiles(start, vectors);\nImPoint expected = new ImPoint(15, 15);\nImPoint actual = path.getPoint(0);\nassertEquals(expected, actual);\nexpected = new ImPoint(45, 15);\nactual = path.getPoint(30);\nassertEquals(expected, actual);\nexpected = new ImPoint(60, 15);\nactual = path.getPoint(45);\nassertEquals(expected, actual);\n}\npublic void testSubPath() {\nImPoint start = new ImPoint();\nStep[] vectors = new Step[] { EAST, EAST, EAST };\nPathOnTiles path = new PathOnTiles(start, vectors);\n// First check.\nFreerailsPathIterator pathIt = path.subPath(0, path.getTotalDistance());\nImPoint[] expected = { new ImPoint(15, 15), new ImPoint(45, 15),\nnew ImPoint(75, 15), new ImPoint(105, 15) };\ncheckPath(pathIt, expected);\n// Second check\npathIt = path.subPath(3, path.getTotalDistance() - 3);\nexpected = new ImPoint[] { new ImPoint(18, 15), new ImPoint(45, 15),\nnew ImPoint(75, 15), new ImPoint(105, 15) };\ncheckPath(pathIt, expected);\n// 3rd check\ndouble i = path.getTotalDistance() - 10;\npathIt = path.subPath(3, i);\nexpected = new ImPoint[] { new ImPoint(18, 15), new ImPoint(45, 15),\nnew ImPoint(75, 15), new ImPoint(98, 15) };\ncheckPath(pathIt, expected);\n// 4th check, with a path just 1 tile long.\nstart = new ImPoint(5, 5);\nvectors = new Step[] { SOUTH_WEST };\npath = new PathOnTiles(start, vectors);\npathIt = path.subPath(18, 24);\nIntLine line = new IntLine();\nassertTrue(pathIt.hasNext());\npathIt.nextSegment(line);\nassertEquals(\"The length of the train.\", 24, line.getLength(), 1d);\nassertFalse(pathIt.hasNext());\n// 5th check, same as 2nd but with different starting position.\nvectors = new Step[] { EAST, EAST, EAST };\nstart = new ImPoint(4, 7);\npath = new PathOnTiles(start, vectors);\npathIt = path.subPath(3, path.getTotalDistance() - 3);\nexpected = new ImPoint[] { new ImPoint(18, 15), new ImPoint(45, 15),\nnew ImPoint(75, 15), new ImPoint(105, 15) };\nfor (int j = 0; j < expected.length; j++) {\nint x = expected[j].x + start.x * TILE_DIAMETER;\nint y = expected[j].y + start.y * TILE_DIAMETER;\nexpected[j] = new ImPoint(x, y);\n}\n// for (ImPoint point : expected) {\n// point.x += start.x * TILE_DIAMETER;\n// point.y += start.y * TILE_DIAMETER;\n// }\ncheckPath(pathIt, expected);\n}\nprivate void checkPath(FreerailsPathIterator pathIt, ImPoint[] expected) {\nIntLine line = new IntLine();\nfor (int i = 0; i < expected.length - 1; i++) {\nassertTrue(pathIt.hasNext());\npathIt.nextSegment(line);\nassertEquals(expected[i].x, line.x1);\nassertEquals(expected[i + 1].x, line.x2);\nassertEquals(expected[i].y, line.y1);\nassertEquals(expected[i + 1].y, line.y2);\n}\nassertFalse(pathIt.hasNext());\n}\nboolean throwsException(ImPoint start, Step[] vectors) {\ntry {\nnew PathOnTiles(start, vectors);\nreturn false;\n} catch (Exception e) {\nreturn true;\n}\n}\npublic void testTiles() {\nPathOnTiles path = new PathOnTiles(new ImPoint(5, 5), SOUTH_WEST,\nNORTH_EAST);\nIterator<ImPoint> it = path.tiles();\nassertEquals(new ImPoint(5, 5), it.next());\nassertEquals(new ImPoint(4, 6), it.next());\nassertEquals(new ImPoint(5, 5), it.next());\nassertFalse(it.hasNext());\n}\n}"}
{"className":"jfreerails.world.common.PositionOnTrackTest","javaDoc":"/**\n* Junit test for PositionOnTrack.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* Junit test for PositionOnTrack.\n*\n* @author Luke Lindsay\n*\n*/\npublic class PositionOnTrackTest extends TestCase {\n/**\n* Constructor for PositionOnTrackTest.\n*\n* @param arg0\n*/\npublic PositionOnTrackTest(String arg0) {\nsuper(arg0);\n}\npublic void testValidation() {\nassertTrue(PositionOnTrack.MAX_COORDINATE < 70000);\nassertTrue(PositionOnTrack.MAX_COORDINATE > 10000);\nassertEquals(PositionOnTrack.MAX_DIRECTION, 7);\nassertNoException(0, 0, Step.EAST);\nassertNoException(PositionOnTrack.MAX_COORDINATE,\nPositionOnTrack.MAX_COORDINATE, Step.NORTH_WEST);\nassertException(-1, 0, Step.EAST);\nassertException(0, -1, Step.EAST);\nassertException(PositionOnTrack.MAX_COORDINATE + 1,\nPositionOnTrack.MAX_COORDINATE, Step.NORTH_WEST);\nassertException(PositionOnTrack.MAX_COORDINATE,\nPositionOnTrack.MAX_COORDINATE + 1, Step.NORTH_WEST);\n}\npublic void testToInt() {\nPositionOnTrack p1 = PositionOnTrack.createComingFrom(10, 20,\nStep.NORTH);\nPositionOnTrack p2 = PositionOnTrack.createComingFrom(10, 30,\nStep.NORTH);\nassertTrue(p1.toInt() != p2.toInt());\n}\npublic void testSetValuesFromInt() {\nPositionOnTrack p1 = PositionOnTrack.createComingFrom(10, 20,\nStep.NORTH);\nint i = p1.toInt();\nPositionOnTrack p2 = PositionOnTrack\n.createComingFrom(60, 70, Step.EAST);\nassertTrue(!p1.equals(p2));\np2.setValuesFromInt(i);\nassertEquals(p1, p2);\nStep v = Step.getInstance(7); // 7 is the\n// maximum\n// vector\n// number.\np1 = PositionOnTrack.createComingFrom(PositionOnTrack.MAX_COORDINATE,\nPositionOnTrack.MAX_COORDINATE, v);\ni = p1.toInt();\n}\n/*\n* Test for boolean equals(Object)\n*/\npublic void testEqualsObject() {\nPositionOnTrack p1 = PositionOnTrack.createComingFrom(10, 20,\nStep.NORTH);\nPositionOnTrack p2 = PositionOnTrack.createComingFrom(10, 20,\nStep.NORTH);\nassertEquals(p1, p2);\np1 = PositionOnTrack.createComingFrom(10, 50, Step.NORTH);\np2 = PositionOnTrack.createComingFrom(10, 20, Step.NORTH);\nassertTrue(!p1.equals(p2));\n}\nprivate void assertNoException(int x, int y, Step v) {\ntry {\nPositionOnTrack.createComingFrom(x, y, v);\n} catch (Exception e) {\nassertTrue(false);\n}\n}\nprivate void assertException(int x, int y, Step v) {\ntry {\nPositionOnTrack.createComingFrom(x, y, v);\nassertTrue(false);\n} catch (Exception e) {\n}\n}\npublic void testGetOpposite() {\nPositionOnTrack p1 = PositionOnTrack.createComingFrom(10, 10,\nStep.NORTH);\nPositionOnTrack p2 = p1.getOpposite();\nassertNotNull(p2);\nPositionOnTrack p3 = PositionOnTrack.createComingFrom(10, 11,\nStep.SOUTH);\nassertEquals(p3, p2);\n}\n}"}
{"className":"jfreerails.world.common.StepTest","javaDoc":"/**\n* JUnit test for OneTileMoveVector.\n*\n* @author Luke\n*/","code":"/**\n* JUnit test for OneTileMoveVector.\n*\n* @author Luke\n*/\npublic class StepTest extends TestCase {\nfinal Step n = Step.NORTH;\nfinal Step ne = Step.NORTH_EAST;\nfinal Step e = Step.EAST;\nfinal Step se = Step.SOUTH_EAST;\nfinal Step s = Step.SOUTH;\nfinal Step sw = Step.SOUTH_WEST;\nfinal Step w = Step.WEST;\nfinal Step nw = Step.NORTH_WEST;\npublic StepTest(String arg0) {\nsuper(arg0);\n}\npublic void testGetDirection() {\ndouble d = 0;\nassertTrue(d == n.getDirection());\nd = 2 * Math.PI / 8 * 1;\nassertTrue(d == ne.getDirection());\n}\npublic void testGetNearestVector() {\n// Each vector should be the nearest to itself!\nStep[] vectors = Step.getList();\nfor (int i = 0; i < vectors.length; i++) {\nStep v = vectors[i];\nStep v2 = Step.getNearestVector(v.deltaX, v.deltaY);\nassertEquals(v, v2);\n}\nassertNearest(n, 0, -1);\nassertNearest(n, 0, -99);\nassertNearest(n, 2, -5);\nassertNearest(n, -2, -5);\nassertNearest(s, 2, 5);\nassertNearest(w, -5, -1);\nassertNearest(sw, -4, 3);\nassertNearest(ne, 10, -6);\nassertNearest(ne, 10, -6);\n}\nprivate void assertNearest(Step v, int dx, int dy) {\nStep v2 = Step.getNearestVector(dx, dy);\nassertEquals(v, v2);\n}\npublic void testGetNewTemplateNumber() {\nassertEquals(Step.NORTH.get8bitTemplate(), 1);\nassertEquals(Step.NORTH_EAST.get8bitTemplate(), 2);\nassertEquals(Step.EAST.get8bitTemplate(), 4);\n}\n}"}
{"className":"jfreerails.world.common.GameCalenderTest","javaDoc":"/**\n* Junit test for GameCalendar.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit test for GameCalendar.\n*\n* @author Luke\n*\n*/\npublic class GameCalenderTest extends TestCase {\npublic void testGetYear() {\nGameCalendar gc = new GameCalendar(10, 1900);\nassertEquals(\"1900\", gc.getYearAsString(0));\nassertEquals(\"1900\", gc.getYearAsString(5));\nassertEquals(\"1901\", gc.getYearAsString(10));\nassertEquals(\"1950\", gc.getYearAsString(505));\n}\npublic void testGetTimeOfDay() {\nGameCalendar gc = new GameCalendar(24, 1900);\nassertEquals(\"00:00\", gc.getTimeOfDay(0));\nassertEquals(\"01:00\", gc.getTimeOfDay(1));\nassertEquals(\"15:00\", gc.getTimeOfDay(15));\ngc = new GameCalendar(24 * 60, 1900);\nassertEquals(\"00:00\", gc.getTimeOfDay(0));\nassertEquals(\"00:10\", gc.getTimeOfDay(10));\nassertEquals(\"05:10\", gc.getTimeOfDay(310));\n}\npublic void testGetYearAndMonth() {\nGameCalendar gc = new GameCalendar(12, 1900);\nassertEquals(\"Jan 1900\", gc.getYearAndMonth(0));\nassertEquals(\"Feb 1900\", gc.getYearAndMonth(1));\nassertEquals(\"Mar 1900\", gc.getYearAndMonth(2));\nassertEquals(\"Mar 1901\", gc.getYearAndMonth(14));\n}\n}"}
{"className":"jfreerails.world.common.ImIntsTest","javaDoc":null,"code":"public class ImIntsTest extends TestCase {\n/*\n* Test method for 'jfreerails.world.common.ImInts.append(int...)'\n*/\npublic void testAppend() {\nint[] a = { 1, 2, 3 };\nint[] b = { 4, 5, 6, 7 };\nint[] c = { 1, 2, 3, 4, 5, 6, 7 };\nImInts ai = new ImInts(a);\nImInts ci = new ImInts(c);\nassertFalse(ci.equals(ai));\nassertEquals(ci, ai.append(b));\n}\npublic void testRemoveLast(){\n//Test method does not change original\nImInts original = new ImInts(1,2, 3, 4);\nImInts clone = (ImInts) Utils.cloneBySerialisation(original);\nassertEquals(original, clone);\noriginal.removeLast();\nassertEquals(original, clone);\nImInts actual, expected;\nactual = (new ImInts( 1, 2, 3)).removeLast();\nexpected = new ImInts(1,2);\nassertEquals(expected, actual);\nactual = (new ImInts( 1, 2)).removeLast();\nexpected = new ImInts(1);\nassertEquals(expected, actual);\nactual = (new ImInts( 1, 2, 4, 3)).removeLast();\nexpected = new ImInts(1, 2, 4);\nassertEquals(expected, actual);\n}\npublic void testEquals(){\nint[] a = { 1, 2, 3 };\nint[] b = { 1, 2, 3 };\nImInts ai = new ImInts(a);\nImInts bi = new ImInts(b);\nassertEquals(ai, bi);\nImInts ci = new ImInts(1, 2, 3 );\nassertEquals(ai, ci);\n}\n}"}
{"className":"jfreerails.world.terrain.MiscTest","javaDoc":null,"code":"public class MiscTest extends TestCase {\npublic void testCityModel() {\nCityModel cm1 = new CityModel(\"London\", 20, 70);\nCityModel cm2 = new CityModel(\"Cardiff\", 20, 70);\ntestHashCodeAndEquals(cm1);\ntestHashCodeAndEquals(cm2);\nassertDifferent(cm1, cm2);\n}\npublic void testTileTypeImpl() {\nProduction[] prod = { new Production(69, 10) };\nConsumption[] cons = { new Consumption(4, 4), new Consumption(4, 5) };\nConversion[] conv = { new Conversion(50, 30) };\ntestHashCodeAndEquals(prod[0]);\ntestHashCodeAndEquals(cons[0]);\ntestHashCodeAndEquals(conv[0]);\nTileTypeImpl tt = new TileTypeImpl(0, Category.Country, \"Grassland\",\n100, prod, cons, conv, 10);\ntestHashCodeAndEquals(tt);\nConversion[] conv2 = { new Conversion(5, 30) };\nTileTypeImpl tt2 = new TileTypeImpl(0, Category.Country, \"Grassland\",\n100, prod, cons, conv2, 10);\nassertFalse(tt.equals(tt2));\n}\nprivate void testHashCodeAndEquals(Serializable a) {\nSerializable copy = Utils.cloneBySerialisation(a);\nassertEquals(a, a);\nassertEquals(a, copy);\nassertEquals(a.hashCode(), copy.hashCode());\n}\nprivate void assertDifferent(Object a, Object b) {\nassertFalse(a.equals(b));\nassertFalse(a.hashCode() == b.hashCode());\n}\n}"}
{"className":"jfreerails.client.view.BalanceSheetGeneratorTest","javaDoc":"/**\n* JUnit test for BalanceSheetGenerator.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for BalanceSheetGenerator.\n*\n* @author Luke\n*\n*/\npublic class BalanceSheetGeneratorTest extends TestCase {\nPlayer player;\nWorld world;\npublic void testBondsFigure() {\nBalanceSheetGenerator generator = new BalanceSheetGenerator(world,\nplayer.getPrincipal());\nMoney expectedBondValue = new Money(BondTransaction.BOND_VALUE_ISSUE\n.getAmount());\nassertEquals(expectedBondValue.changeSign(), generator.total.loans);\nassertEquals(expectedBondValue.changeSign(), generator.ytd.loans);\n}\npublic void testStockHolderEquityFigure() {\nBalanceSheetGenerator generator = new BalanceSheetGenerator(world,\nplayer.getPrincipal());\nMoney expectStockHolderEquity = new Money(-500000);\nassertEquals(expectStockHolderEquity, generator.total.equity);\n}\n@Override\nprotected void setUp() throws Exception {\nworld = new WorldImpl(10, 10);\nplayer = new Player(\"Player X\", world.getNumberOfPlayers());\nworld.set(ITEM.CALENDAR, new GameCalendar(1200, 1840));\nworld.setTime(new GameTime(0));\nMove addPlayerMove = AddPlayerMove.generateMove(world, player);\nMoveStatus ms = addPlayerMove.doMove(world, player.getPrincipal());\nassertTrue(ms.message, ms.ok);\nworld.setTime(new GameTime(100));\n}\n}"}
{"className":"jfreerails.client.view.IncomeStatementGeneratorTest","javaDoc":"/**\n* JUnit test for IncomeStatementGenerator.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for IncomeStatementGenerator.\n*\n* @author Luke\n*\n*/\npublic class IncomeStatementGeneratorTest extends TestCase {\nWorld w;\nIncomeStatementGenerator balanceSheetGenerator;\npublic void testCalExpense() {\nCategories mail = Categories.Mail;\nMoney m = balanceSheetGenerator.calRevenue(mail);\nassertEquals(0, m.getAmount());\nCargoType ct = (CargoType) w.get(SKEY.CARGO_TYPES, 0);\nassertEquals(mail, ct.getCategory());\nMoney amount = new Money(100);\naddTrans(mail, amount);\naddTrans(Categories.Passengers, amount);\nm = balanceSheetGenerator.calRevenue(mail);\nassertEquals(amount, m);\n}\nprivate void addTrans(Categories category, Money amount) {\nfor (int i = 0; i < w.size(SKEY.CARGO_TYPES); i++) {\nCargoType ct = (CargoType) w.get(SKEY.CARGO_TYPES, i);\nif (ct.getCategory().equals(category)) {\nCargoBatch cb = new CargoBatch(i, 0, 0, 0, 0);\nw.addTransaction(MapFixtureFactory.TEST_PRINCIPAL,\nnew DeliverCargoReceipt(amount, 10, 0, cb, 1));\nreturn;\n}\n}\nthrow new IllegalArgumentException(category.toString());\n}\n@Override\nprotected void setUp() throws Exception {\nw = new WorldImpl();\nw.addPlayer(MapFixtureFactory.TEST_PLAYER);\nMapFixtureFactory.generateCargoTypesList(w);\nbalanceSheetGenerator = new IncomeStatementGenerator(w,\nMapFixtureFactory.TEST_PRINCIPAL);\n}\n}"}
{"className":"jfreerails.client.view.TrainScheduleJPanelTest","javaDoc":null,"code":"public class TrainScheduleJPanelTest extends TestCase {\nTrainScheduleJPanel jpanel;\n@Override\nprotected void setUp() throws Exception {\n//jpanel = new TrainScheduleJPanel();\n//World w = MapFixtureFactory2.getCopy();\n}\n/*\n* [ 1384249 ] Unexpected Exception: TrainScheduleJPanel.java line 661\n*/\npublic void testBug1384249(){\n}\n}"}
{"className":"jfreerails.client.view.HtmlJPanelTest","javaDoc":"/**\n* Tests the populateTokens method on HtmlJPanel.\n*\n* @author Luke\n*\n*/","code":"/**\n* Tests the populateTokens method on HtmlJPanel.\n*\n* @author Luke\n*\n*/\npublic class HtmlJPanelTest extends TestCase {\npublic void testPopulateTokens() {\nString template = \"test\";\nHashMap<String, String> context = new HashMap<String, String>();\nString output = HtmlJPanel.populateTokens(template, context);\nassertEquals(template, output);\ntemplate = \"Hello $name$, $question$\";\ncontext.put(\"name\", \"Luke\");\ncontext.put(\"question\", \"how are you?\");\nString expectedOutput = \"Hello Luke, how are you?\";\noutput = HtmlJPanel.populateTokens(template, context);\nassertEquals(expectedOutput, output);\nObject objectContext = new Object() {\n@SuppressWarnings(\"unused\")\npublic String name = \"Luke\";\n@SuppressWarnings(\"unused\")\npublic String question = \"how are you?\";\n};\noutput = HtmlJPanel.populateTokens(template, objectContext);\nassertEquals(expectedOutput, output);\n}\npublic void testPopulateTokens2(){\nString template = \"Hey $a.name$ I would like you to meet $b.name$\";\nString expectedOutput = \"Hey Tom I would like you to meet Claire\";\nObject objectContext = new Object() {\n@SuppressWarnings(\"unused\")\npublic Person a = new Person(\"Tom\");\n@SuppressWarnings(\"unused\")\npublic Person b = new Person(\"Claire\");\n};\nString output = HtmlJPanel.populateTokens(template, objectContext);\nassertEquals(expectedOutput, output);\n}\npublic static class Person{\npublic String name;\npublic Person(String name){\nthis.name = name;\n}\n}\n}"}
{"className":"jfreerails.client.view.BrokerScreenGeneratorTest","javaDoc":null,"code":"public class BrokerScreenGeneratorTest extends TestCase {\nprivate World world;\nint playerID;\nFreerailsPrincipal principal;\n@Override\nprotected void setUp() throws Exception {\n// TODO Auto-generated method stub\nsuper.setUp();\nworld = new WorldImpl(10, 10);\n// Set the time..\nworld.set(ITEM.CALENDAR, new GameCalendar(12000, 1840));\nPlayer p = MapFixtureFactory.TEST_PLAYER;\nAddPlayerMove apm = AddPlayerMove.generateMove(world, p);\nMoveStatus ms = apm.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.isOk());\nplayerID = world.getNumberOfPlayers() - 1;\nprincipal = p.getPrincipal();\n}\n/**\n* Testcase to reproduce bug [ 1341365 ] Exception when calculating stock\n* price after buying shares\n*/\npublic void testBuyingStock() {\nfor (int i = 0; i < 9; i++) {\nStockPrice stockPrice = new StockPriceCalculator(world).calculate()[playerID];\nMoney sharePrice = stockPrice.treasuryBuyPrice;\nStockTransaction t = StockTransaction.buyOrSellStock(playerID,\nStockTransaction.STOCK_BUNDLE_SIZE, sharePrice);\nMove move = new AddTransactionMove(principal, t);\nMoveStatus ms = move.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.isOk());\n//The line below threw an exception that caused bug 1341365.\nBrokerScreenGenerator brokerScreenGenerator = new BrokerScreenGenerator(world, principal);\nassertNotNull(brokerScreenGenerator);\n}\n}\n}"}
{"className":"jfreerails.client.common.ImageManagerImplTest","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class ImageManagerImplTest extends TestCase {\npublic void testIsValid() {\nassertTrue(ImageManagerImpl.isValid(\"cursor/infomode.png\"));\nassertFalse(ImageManagerImpl.isValid(\"/cursor/infomode.png\"));\n}\n}"}
{"className":"jfreerails.client.common.BinaryNumberFormatterTest","javaDoc":"/**\n* This class formats and integer as a binary number with a specified number of\n* digits.\n*\n* @author Luke Lindsay 03-Nov-2002\n*\n*/","code":"/**\n* This class formats and integer as a binary number with a specified number of\n* digits.\n*\n* @author Luke Lindsay 03-Nov-2002\n*\n*/\npublic class BinaryNumberFormatterTest extends TestCase {\npublic BinaryNumberFormatterTest(String arg0) {\nsuper(arg0);\n}\npublic void testBinaryFormat() {\nassertEquals(\"0\", BinaryNumberFormatter.format(0, 1));\nassertEquals(\"1\", BinaryNumberFormatter.format(1, 1));\nassertEquals(\"00\", BinaryNumberFormatter.format(0, 2));\nassertEquals(\"01\", BinaryNumberFormatter.format(1, 2));\nassertEquals(\"10\", BinaryNumberFormatter.format(2, 2));\nassertEquals(\"11\", BinaryNumberFormatter.format(3, 2));\nassertEquals(\"1111\", BinaryNumberFormatter.format(15, 4));\ntry {\nBinaryNumberFormatter.format(-1, 2);\nassertTrue(false);\n} catch (IllegalArgumentException e) {\n}\ntry {\nBinaryNumberFormatter.format(4, 2);\nassertTrue(false);\n} catch (IllegalArgumentException e) {\n}\n}\n}"}
{"className":"jfreerails.client.renderer.BuildTrackControllerTest","javaDoc":"/** Unit test for BuildTrackController. */","code":"/** Unit test for BuildTrackController. */\npublic class BuildTrackControllerTest extends TestCase {\nWorld w;\nModelRootImpl modelRoot;\nBuildTrackController buildTrackController;\nTrackMoveProducer trackBuilder;\nint singleTrackRuleID = -1;\nint doubleTrackRuleID = -1;\n@Override\nprotected void setUp() throws Exception {\nw = MapFixtureFactory2.getCopy();\nmodelRoot = new ModelRootImpl();\nFreerailsPrincipal p = w.getPlayer(0).getPrincipal();\nmodelRoot.setup(w, p);\nbuildTrackController = new BuildTrackController(w, modelRoot);\nMoveExecutor executor = new SimpleMoveExecutor(w, 0);\ntrackBuilder = new TrackMoveProducer(executor, w, modelRoot);\nfor (int i = 0; i < w.size(SKEY.TRACK_RULES); i++) {\nfinal Integer ruleID = new Integer(i);\nTrackRule rule = (TrackRule) w.get(SKEY.TRACK_RULES, i);\nif (rule.getTypeName().equals(\"standard track\")) {\nsingleTrackRuleID = ruleID;\n}\nif (rule.getTypeName().equals(\"double track\")) {\ndoubleTrackRuleID = ruleID;\n}\n}\nassertFalse(singleTrackRuleID == -1);\nassertFalse(doubleTrackRuleID == -1);\n// unit tests should be silent!\nmodelRoot.setProperty(Property.PLAY_SOUNDS, false);\n}\npublic void testBuildTrack() {\nImPoint from = new ImPoint(10, 10);\nmodelRoot.setProperty(Property.CURSOR_POSITION, from);\nImPoint to = new ImPoint(20, 10);\nbuildTrackController.setProposedTrack(to, trackBuilder);\nbuildTrackController.updateUntilComplete();\nassertTrue(buildTrackController.isBuildTrackSuccessful());\n// See if any track has actually been built.\nFreerailsTile tile = (FreerailsTile) w.getTile(10, 10);\nassertFalse(tile.hasTrack());\nbuildTrackController.updateWorld(trackBuilder);\ntile = (FreerailsTile) w.getTile(10, 10);\nassertTrue(tile.hasTrack());\ntile = (FreerailsTile) w.getTile(20, 10);\nassertTrue(tile.hasTrack());\n}\npublic void testUpgradeTrack() {\n// Build the track.\ntestBuildTrack();\n// Change the strategy.\nBuildTrackStrategy bts = BuildTrackStrategy.getSingleRuleInstance(\ndoubleTrackRuleID, modelRoot.getWorld());\ntrackBuilder.setBuildTrackStrategy(bts);\ntrackBuilder.setTrackBuilderMode(BuildMode.UPGRADE_TRACK);\n// Upgrade part of the track.\nmodelRoot.setProperty(Property.CURSOR_POSITION, new ImPoint(15, 10));\nbuildTrackController\n.setProposedTrack(new ImPoint(20, 10), trackBuilder);\nbuildTrackController.updateUntilComplete();\nassertTrue(buildTrackController.isBuildTrackSuccessful());\nbuildTrackController.updateWorld(trackBuilder);\nFreerailsTile tile = (FreerailsTile) w.getTile(10, 10);\nassertEquals(singleTrackRuleID, tile.getTrackPiece().getTrackTypeID());\ntile = (FreerailsTile) w.getTile(15, 10);\nassertEquals(doubleTrackRuleID, tile.getTrackPiece().getTrackTypeID());\ntile = (FreerailsTile) w.getTile(17, 10);\nassertEquals(doubleTrackRuleID, tile.getTrackPiece().getTrackTypeID());\ntile = (FreerailsTile) w.getTile(20, 10);\nassertEquals(doubleTrackRuleID, tile.getTrackPiece().getTrackTypeID());\n}\npublic void testRemoveTrack() {\n// Build the track.\ntestBuildTrack();\n// Then remove some of it.\ntrackBuilder.setTrackBuilderMode(BuildMode.REMOVE_TRACK);\nImPoint from = new ImPoint(15, 10);\nmodelRoot.setProperty(Property.CURSOR_POSITION, from);\nImPoint to = new ImPoint(20, 10);\nbuildTrackController.setProposedTrack(to, trackBuilder);\nbuildTrackController.updateUntilComplete();\nassertTrue(buildTrackController.isBuildTrackSuccessful());\nbuildTrackController.updateWorld(trackBuilder);\n}\n}"}
{"className":"jfreerails.client.renderer.SquareTileBackgroundRendererTest","javaDoc":null,"code":"public class SquareTileBackgroundRendererTest extends TestCase {\nMapLayerRenderer renderer = new MapLayerRenderer(){\npublic void paintTile(Graphics g, int tileX, int tileY) {\n}\npublic void refreshTile(int x, int y) {\n}\npublic void refreshAll() {\n}\npublic void paintRect(Graphics g, Rectangle visibleRect) {\n}\n};\n/** Testcase to reproduce bug [ 1303162 ] Unexpected Exception:*/\npublic void testRefreshBeforeBufferIsSet(){\nSquareTileBackgroundRenderer stbr = new SquareTileBackgroundRenderer(renderer);\nstbr.refreshAll();\nstbr.refreshTile(1, 2);\n}\n}"}
{"className":"jfreerails.client.renderer.TrainRendererTest","javaDoc":"/**\n*\n* @author Luke\n*/","code":"/**\n*\n* @author Luke\n*/\npublic class TrainRendererTest {\npublic TrainRendererTest() {\n}\n@Test\npublic void testTrainImages() {\nRenderersRoot rr = new MyRenderersRoot();\nTrainImages wagonImages = rr.getWagonImages(0);\nassertNotNull(wagonImages);\nTrainImages engineImages = rr.getEngineImages(0);\nassertNotNull(engineImages);\nfor (Step step : Step.getList()) {\nImage overheadImage = wagonImages.getOverheadImage(step.getID());\nassertTrue(overheadImage instanceof BufferedImage);\n}\n}\n@Test\npublic void testHit1() {\nPoint wagonCenter = new Point(100, 100);\nPoint mouseClick = new Point(100, 100);\nboolean hit = isHit(wagonCenter, mouseClick, Step.NORTH);\nassertTrue(hit);\n}\n@Test\npublic void testHit2() {\nPoint wagonCenter = new Point(100, 100);\nPoint mouseClick = new Point(90, 100);\nboolean hit = isHit(wagonCenter, mouseClick, Step.NORTH);\nassertFalse(hit);\n}\n@Test\npublic void testHit3() {\nPoint wagonCenter = new Point(100, 100);\nPoint mouseClick = new Point(85, 100);\nboolean hit = isHit(wagonCenter, mouseClick, Step.NORTH);\nassertFalse(hit);\n}\n@Test\npublic void testHit4() {\nPoint wagonCenter = new Point(100, 100);\nPoint mouseClick = new Point(84, 100);\nboolean hit = isHit(wagonCenter, mouseClick, Step.NORTH);\nassertFalse(hit);\n}\n@Test\npublic void testHit5() {\nPoint wagonCenter = new Point(100, 100);\nPoint mouseClick = new Point(96, 100);\nboolean hit = isHit(wagonCenter, mouseClick, Step.NORTH);\nassertTrue(hit);\n}\npublic boolean isHit(Point wagonCenter, Point mouseClick, Step step) {\nList<Map.Entry<Point, Step>> positions = new ArrayList<>();\npositions.add(new AbstractMap.SimpleImmutableEntry<>(wagonCenter, step));\nRenderersRoot rr = new MyRenderersRoot();\nTrainModel train = new TrainModel(0);\nTrainRenderer tr = new TrainRenderer(rr);\nboolean hit = tr.isHit(mouseClick, train, positions);\nreturn hit;\n}\n}"}
{"className":"jfreerails.client.renderer.MyRenderersRoot","javaDoc":null,"code":"class MyRenderersRoot implements RenderersRoot {\nstatic ImageManager imageManager = new ImageManagerImpl(\"/jfreerails/client/graphics/\");\nprivate TrainImages trainImages;\npublic MyRenderersRoot() {\ntry {\nthis.trainImages = new TrainImages(imageManager, \"mail\");\n} catch (IOException ex) {\nLogger.getLogger(MyRenderersRoot.class.getName()).log(Level.SEVERE, null, ex);\nfail();\n}\n}\n@Override\npublic TrackPieceRenderer getTrackPieceView(int i) {\nthrow new UnsupportedOperationException(\"Not supported yet.\");\n}\n@Override\npublic TrainImages getWagonImages(int type) {\nreturn this.trainImages;\n}\n@Override\npublic TrainImages getEngineImages(int type) {\nreturn this.trainImages;\n}\n@Override\npublic boolean validate(ReadOnlyWorld world) {\nthrow new UnsupportedOperationException(\"Not supported yet.\");\n}\n@Override\npublic Image getImage(String relativeFilename) throws IOException {\nthrow new UnsupportedOperationException(\"Not supported yet.\");\n}\n@Override\npublic Image getScaledImage(String relativeFilename, int height) throws IOException {\nthrow new UnsupportedOperationException(\"Not supported yet.\");\n}\n@Override\npublic TileRenderer getTileViewWithNumber(int i) {\nthrow new UnsupportedOperationException(\"Not supported yet.\");\n}\n}"}
{"className":"jfreerails.server.CityEconomicModelTest","javaDoc":"/**\n* JUnit Test for CityEconomic.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit Test for CityEconomic.\n*\n* @author Luke\n*\n*/\npublic class CityEconomicModelTest extends TestCase {\n/**\n* Tests generating populated CityEconomicModel from cities on the map.\n*/\npublic void testLoadFromMap() {\nWorld w = MapFixtureFactory.getWorld(100, 100);\nCityModel newYork = new CityModel(\"New York\", 10, 20);\nw.add(SKEY.CITIES, newYork);\nCityEconomicModel city = new CityEconomicModel();\ncity.loadFromMap(w, 0);\nassertEquals(0, city.industryTiles.size());\nassertEquals(0, city.urbanTiles.size());\nassertEquals(\"A city is a 7*7 area\", 49, city.clearTiles.size());\n}\n/** Tests calculating the utility of a City. */\npublic void testUtilityCalculation() {\n}\n}"}
{"className":"jfreerails.server.CargoAtStationsGeneratorTest","javaDoc":"/**\n* JUnit test for CargoAtStationsGenerator.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for CargoAtStationsGenerator.\n*\n* @author Luke\n*\n*/\npublic class CargoAtStationsGeneratorTest extends TestCase {\npublic void testCalculateAmountToAdd() {\nCargoAtStationsGenerator cargoGenerator = new CargoAtStationsGenerator();\nint amount = cargoGenerator.calculateAmountToAdd(12, 0);\nassertEquals(1, amount);\nassertCorrectTotalAddedOverYear(0);\nassertCorrectTotalAddedOverYear(12);\nassertCorrectTotalAddedOverYear(14);\nassertCorrectTotalAddedOverYear(140);\nassertCorrectTotalAddedOverYear(3);\n}\n/**\n* If, say, 14 units get added each year, some month we should add 1 and\n* others we should add 2 such that over the year exactly 14 units get\n* added.\n*/\nprivate void assertCorrectTotalAddedOverYear(final int unitPerYear) {\nCargoAtStationsGenerator cargoGenerator = new CargoAtStationsGenerator();\nint amountAddedThisSoFar = 0;\nfor (int i = 0; i < 12; i++) {\namountAddedThisSoFar += cargoGenerator.calculateAmountToAdd(\nunitPerYear, i);\n}\nassertEquals(unitPerYear, amountAddedThisSoFar);\n}\n}"}
{"className":"jfreerails.server.TrackMaintenanceMoveGeneratorTest","javaDoc":"/**\n* JUnit test for TrackMaintenanceMoveGenerator.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* JUnit test for TrackMaintenanceMoveGenerator.\n*\n* @author Luke Lindsay\n*\n*/\npublic class TrackMaintenanceMoveGeneratorTest extends TestCase {\nprivate World w;\n@Override\nprotected void setUp() throws Exception {\nw = new WorldImpl(20, 20);\nw.addPlayer(MapFixtureFactory.TEST_PLAYER);\nMapFixtureFactory.generateTrackRuleList(w);\n}\npublic void testCalculateNumberOfEachTrackType() {\nint[] actual;\nint[] expected;\nactual = calNumOfEachTrackType();\n/*\n* actual = ItemsTransactionAggregator.calulateNumberOfEachTrackType(w,\n* MapFixtureFactory.TEST_PRINCIPAL, 0);\n*/\nexpected = new int[] { 0, 0, 0 }; // No track has been built yet.\nassertTrue(Arrays.equals(expected, actual));\naddTrack(0, 10);\nactual = calNumOfEachTrackType();\nexpected = new int[] { 10, 0, 0 };\nassertTrue(Arrays.equals(expected, actual));\naddTrack(2, 20);\nactual = calNumOfEachTrackType();\nexpected = new int[] { 10, 0, 20 };\nassertTrue(Arrays.equals(expected, actual));\n}\nprivate int[] calNumOfEachTrackType() {\nint[] actual;\nItemsTransactionAggregator aggregator = new ItemsTransactionAggregator(\nw, MapFixtureFactory.TEST_PRINCIPAL);\nactual = new int[3];\naggregator.setType(0);\nactual[0] = aggregator.calculateQuantity();\naggregator.setType(1);\nactual[1] = aggregator.calculateQuantity();\naggregator.setType(2);\nactual[2] = aggregator.calculateQuantity();\nreturn actual;\n}\n/**\n* Utility method to add the specified number of units of the specified track\n* type.\n*/\nprivate void addTrack(int trackType, int quantity) {\nAddItemTransaction t = new AddItemTransaction(\nTransaction.Category.TRACK, trackType, quantity, new Money(\ntrackType));\nw.addTransaction(MapFixtureFactory.TEST_PRINCIPAL, t);\n}\n}"}
{"className":"jfreerails.server.MapFixtureFactory2Test","javaDoc":"/**\n*\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n*\n*\n* @author Luke Lindsay\n*\n*/\npublic class MapFixtureFactory2Test extends TestCase {\nWorld w1;\npublic void testGetCopy() {\nWorld w2;\nw1 = getCopy();\nassertNotNull(w1);\nw2 = getCopy();\nassertNotNull(w2);\nassertNotSame(w1, w2);\nassertEquals(w1, w2);\n}\npublic void testLists() {\nassertTrue(w1.size(SKEY.CARGO_TYPES) > 0);\nassertTrue(w1.size(SKEY.TRACK_RULES) > 0);\nassertTrue(w1.size(SKEY.TERRAIN_TYPES) > 0);\n}\npublic void testMap() {\nassertEquals(w1.getMapWidth(), 50);\nassertEquals(w1.getMapWidth(), 50);\n}\npublic void testPlayers() {\nassertEquals(4, w1.getNumberOfPlayers());\n}\npublic void testThatStockIsIssued(){\nFreerailsPrincipal p = w1.getPlayer(0).getPrincipal();\nint stock = 0;\nMoney cash = w1.getCurrentBalance(p);\nassertEquals(new Money(1000000), cash);\nint numberOfTransactions = w1.getNumberOfTransactions(p);\nassertTrue(numberOfTransactions > 0);\nfor(int i = 0; i < numberOfTransactions; i++){\nTransaction t = w1.getTransaction(p, i);\nif(t.getCategory().equals(Transaction.Category.ISSUE_STOCK)){\nAddItemTransaction ait = (AddItemTransaction)t;\nstock += ait.getQuantity();\n}\n}\nassertEquals(100000, stock);\n}\n@Override\nprotected void setUp() throws Exception {\n// TODO Auto-generated method stub\nsuper.setUp();\nw1 = getCopy();\n}\n}"}
{"className":"jfreerails.network.AbstractEchoGameServerTestCase","javaDoc":"/**\n* Test cases that use EchoGameServer should extend this class.\n*\n* @author Luke\n*\n*/","code":"/**\n* Test cases that use EchoGameServer should extend this class.\n*\n* @author Luke\n*\n*/\npublic abstract class AbstractEchoGameServerTestCase extends TestCase {\nInetConnectionAccepter server;\nEchoGameServer echoGameServer;\nfinal String ipAddress = \"127.0.0.1\";\n@Override\nprotected synchronized void setUp() throws Exception {\nechoGameServer = EchoGameServer.startServer();\n/*\n* There was a problem that occurred intermittently when the unit tests\n* were run as a batch. I think it was to do with reusing ports in quick\n* succession. Passing 0 as the port allow us to listen on an\n* unspecified port whose number we obtain by calling getLocalPort().\n* Since making this change, the problem has not occurred.\n*/\nserver = new InetConnectionAccepter(0, echoGameServer);\nThread serverThread = new Thread(server);\nserverThread.start();\n}\n@Override\nprotected synchronized void tearDown() throws Exception {\nserver.stop();\n}\n}"}
{"className":"jfreerails.network.InetConnectionTest","javaDoc":"/**\n* Junit test for NewInetConnection.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit test for NewInetConnection.\n*\n* @author Luke\n*\n*/\npublic class InetConnectionTest extends AbstractEchoGameServerTestCase {\npublic void testConnecting() {\ntry {\nassertEquals(0, echoGameServer.countOpenConnections());\nInetConnection connection = new InetConnection(ipAddress, server\n.getLocalPort());\nconnection.open();\nassertEquals(1, echoGameServer.countOpenConnections());\nInetConnection connection2 = new InetConnection(ipAddress, server\n.getLocalPort());\nconnection2.open();\nassertEquals(2, echoGameServer.countOpenConnections());\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\n}"}
{"className":"jfreerails.network.LocalConnectionTest","javaDoc":"/**\n* JUnit test for NewLocalConnection.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for NewLocalConnection.\n*\n* @author Luke\n*\n*/\npublic class LocalConnectionTest extends TestCase {\nprivate LocalConnection localConnection;\nprivate final FreerailsSerializable[] EmptyArray = new FreerailsSerializable[0];\npublic void testReadFromClient() {\nFreerailsSerializable[] objectsRead;\ntry {\nobjectsRead = localConnection.readFromClient();\nassertNotNull(objectsRead);\nassertTrue(Arrays.equals(EmptyArray, objectsRead));\nMoney m = new Money(100);\nlocalConnection.writeToServer(m); // From the client.\nobjectsRead = localConnection.readFromClient();\nFreerailsSerializable[] expectedArray = {m};\nassertEquals(expectedArray.length, objectsRead.length);\nassertTrue(Arrays.equals(expectedArray, objectsRead));\nobjectsRead = localConnection.readFromClient();\nassertTrue(Arrays.equals(EmptyArray, objectsRead));\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\npublic void testWait() {\ntry {\nMoney m = new Money(100);\nlocalConnection.writeToServer(m);\n// Since we have just added an object, there is no need to wait.\nObject o = localConnection.waitForObjectFromClient();\nassertEquals(m, o);\nlocalConnection.writeToClient(m);\no = localConnection.waitForObjectFromServer();\nassertEquals(m, o);\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\npublic void testReadFromServer() {\nFreerailsSerializable[] objectsRead;\ntry {\nobjectsRead = localConnection.readFromServer();\nassertNotNull(objectsRead);\nassertTrue(Arrays.equals(EmptyArray, objectsRead));\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\npublic void testClose() {\ntry {\nlocalConnection.disconnect();\nMoney m = new Money(100);\nlocalConnection.writeToClient(m);\nfail();\n} catch (Exception e) {\n}\n}\npublic void testIsOpen() {\nassertTrue(localConnection.isOpen());\n}\n@Override\nprotected void setUp() throws Exception {\nlocalConnection = new LocalConnection();\n}\n}"}
{"className":"jfreerails.network.EchoGameServerTest","javaDoc":"/**\n* JUnit test for EchoGameServer.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for EchoGameServer.\n*\n* @author Luke\n*\n*/\npublic class EchoGameServerTest extends AbstractEchoGameServerTestCase {\n/**\n* Tests connecting to an EchoGameServer using instances of\n* InetConnection2Server.\n*/\npublic void testConnecting() {\ntry {\nassertEquals(0, echoGameServer.countOpenConnections());\nInetConnection2Server con1 = new InetConnection2Server(ipAddress,\nserver.getLocalPort());\nInetConnection2Server con2 = new InetConnection2Server(ipAddress,\nserver.getLocalPort());\nassertEquals(2, echoGameServer.countOpenConnections());\ncon1.writeToServer(new Money(99));\ncon1.flush();\nFreerailsSerializable fs = con2.waitForObject();\nassertEquals(new Money(99), fs);\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\n}"}
{"className":"jfreerails.network.specifics.MovePrecommitterTest","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class MovePrecommitterTest extends TestCase {\nprivate World w;\nprivate MovePrecommitter committer;\n@Override\nprotected void setUp() throws Exception {\nw = new WorldImpl(10, 10);\ncommitter = new MovePrecommitter(w);\n}\n/** Test simple case of precommitting then fully committing moves. */\npublic void test1() {\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\nassertFalse(oldtime.equals(newTime));\nMove m = new TimeTickMove(oldtime, newTime);\nMoveStatus ms = m.tryDoMove(w, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\ncommitter.toServer(m);\n/* The move m should now have been precommitted. */\nassertEquals(newTime, getTime());\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(1, committer.precomitted.size());\ncommitter.fromServer(ms);\n/* The move m should now be full committed. */\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\nassertEquals(newTime, getTime());\n}\n/** Test test clash. */\npublic void test2() {\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\nassertFalse(oldtime.equals(newTime));\nMove m = new TimeTickMove(oldtime, newTime);\nMoveStatus ms = m.tryDoMove(w, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\ncommitter.toServer(m);\n/* The move m should now have been precommitted. */\nassertEquals(newTime, getTime());\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(1, committer.precomitted.size());\ncommitter.fromServer(m);\nassertFalse(m.tryDoMove(w, Player.AUTHORITATIVE).ok);\n/* The move m should now be full committed. */\nassertEquals(1, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\nassertEquals(newTime, getTime());\ncommitter.precommitMoves();\n/*\n* The committer should be block since the move on the uncommitted list\n* fails to go through.\n*/\nassertTrue(committer.blocked);\nassertEquals(1, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\nMove m2 = new TimeTickMove(newTime, oldtime);\ncommitter.fromServer(m2);\nassertEquals(oldtime, getTime());\ncommitter.fromServer(ms);\nassertEquals(newTime, getTime());\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\n}\n/** Test test rejection 1. */\npublic void test3() {\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\nassertFalse(oldtime.equals(newTime));\nMove m = new TimeTickMove(oldtime, newTime);\nMoveStatus ms = m.tryDoMove(w, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\ncommitter.toServer(m);\n/* The move m should now have been precommitted. */\nassertEquals(newTime, getTime());\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(1, committer.precomitted.size());\n/* Now, suppose the server rejected the move.. */\nMoveStatus rejection = MoveStatus.moveFailed(\"Rejected!\");\ncommitter.fromServer(rejection);\nassertEquals(oldtime, getTime());\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\n}\n/** Test test rejection 2. */\npublic void test4() {\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\nassertFalse(oldtime.equals(newTime));\n/* the following move should fail! */\nMove m = new TimeTickMove(newTime, oldtime);\nMoveStatus ms = m.tryDoMove(w, Player.AUTHORITATIVE);\nassertFalse(ms.ok);\ncommitter.toServer(m);\nassertTrue(committer.blocked);\nassertEquals(1, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\ncommitter.fromServer(ms);\nassertFalse(committer.blocked);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\n}\npublic void testPreMoves1() {\nPreMove pm = TimeTickPreMove.INSTANCE;\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\ncommitter.fromServer(pm);\nassertEquals(newTime, getTime());\n}\npublic void testPreMoves2() {\nPreMove pm = TimeTickPreMove.INSTANCE;\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\n// Send a premove to the server.\ncommitter.toServer(pm);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(1, committer.precomitted.size());\nassertEquals(newTime, getTime());\n// The server accepts it..\ncommitter.fromServer(PreMoveStatus.PRE_MOVE_OK);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\nassertEquals(newTime, getTime());\n}\npublic void testPreMoves3() {\nPreMove pm = TimeTickPreMove.INSTANCE;\nGameTime oldtime = getTime();\nGameTime newTime = oldtime.nextTick();\n// Send a premove to the server.\ncommitter.toServer(pm);\nassertEquals(0, committer.uncomitted.size());\nassertEquals(1, committer.precomitted.size());\nassertEquals(newTime, getTime());\n// The server rejects it.\ncommitter.fromServer(PreMoveStatus.failed(\"failed\"));\nassertEquals(0, committer.uncomitted.size());\nassertEquals(0, committer.precomitted.size());\nassertEquals(oldtime, getTime());\n}\nprivate GameTime getTime() {\nreturn w.currentTime();\n}\n}"}
{"className":"jfreerails.network.specifics.FreerailsClientTest","javaDoc":"/**\n* Tests FreerailsClient with a network server.\n*\n* @author Luke\n*\n*/","code":"/**\n* Tests FreerailsClient with a network server.\n*\n* @author Luke\n*\n*/\npublic class FreerailsClientTest extends AbstractFreerailsServerTestCase {\npublic void testLogon() {\ntry {\n/* Test 1 : connecting a client. */\nassertEquals(\"No client connected yet.\", 0, server\n.countOpenConnections());\nFreerailsClient client = new FreerailsClient();\nLogOnResponse response = client.connect(getIpAddress(), getPort(),\n\"name\", \"password\");\nassertTrue(response.isSuccessful());\nassertEquals(1, server.countOpenConnections());\nassertMapsAndSaveGamesReceived(client);\nassertConnectClientsEquals(client, new ImStringList(\"name\"));\n/* Test 2 : a client that has already logged on. */\nFreerailsClient client2 = new FreerailsClient();\nresponse = client2.connect(getIpAddress(), getPort(), \"name\",\n\"password\");\nassertFalse(\"The player is already logged on.\", response\n.isSuccessful());\nassertEquals(1, server.countOpenConnections());\n/* Test 3 : connecting a client. */\nFreerailsClient client3 = new FreerailsClient();\nresponse = client3.connect(getIpAddress(), getPort(), \"name3\",\n\"password\");\nassertTrue(response.isSuccessful());\nassertEquals(2, server.countOpenConnections());\n/* read list of connected clients. */\nassertConnectClientsEquals(client,\nnew ImStringList(\"name\", \"name3\"));\nassertMapsAndSaveGamesReceived(client3);\nassertConnectClientsEquals(client3, new ImStringList(\"name\",\n\"name3\"));\n/* Test 4 : disconnect the client from test 1. */\nclient.disconnect();\nassertEquals(1, server.countOpenConnections());\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\nprivate void assertConnectClientsEquals(FreerailsClient client,\nImStringList expectedPlayerNames) throws IOException,\nInterruptedException {\nMessage2Client message2Client = (Message2Client) client.read();\nmessage2Client.execute(client);\nImStringList actualPlayerNames = (ImStringList) client\n.getProperty(ClientProperty.CONNECTED_CLIENTS);\nassertNotNull(actualPlayerNames);\nassertEquals(expectedPlayerNames, actualPlayerNames);\n}\nprivate void assertMapsAndSaveGamesReceived(FreerailsClient client)\nthrows IOException, InterruptedException {\n// 2 commands to read.\nMessage2Client message2Client = (Message2Client) client.read();\nmessage2Client.execute(client);\nmessage2Client = (Message2Client) client.read();\nmessage2Client.execute(client);\nObject maps = client.getProperty(ClientProperty.MAPS_AVAILABLE);\nassertNotNull(maps);\nObject savedGames = client\n.getProperty(ClientProperty.SAVED_GAMES);\nassertNotNull(savedGames);\n}\n}"}
{"className":"jfreerails.network.specifics.AbstractFreerailsServerTestCase","javaDoc":"/**\n* Test cases that use FreerailsGameServer <b>and</b> connect over the Internet\n* should extend this class .\n*\n* @author Luke\n*\n*/","code":"/**\n* Test cases that use FreerailsGameServer <b>and</b> connect over the Internet\n* should extend this class .\n*\n* @author Luke\n*\n*/\npublic abstract class AbstractFreerailsServerTestCase extends TestCase {\nprivate InetConnectionAccepter connectionAccepter;\nprotected FreerailsGameServer server;\nprivate final String ipAddress = \"127.0.0.1\";\n@Override\nprotected synchronized void setUp() throws Exception {\nserver = FreerailsGameServer\n.startServer(new SavedGamesManager4UnitTests());\nconnectionAccepter = new InetConnectionAccepter(0, server);\nThread serverThread = new Thread(connectionAccepter);\nserverThread.start();\n}\n@Override\nprotected synchronized void tearDown() throws Exception {\nconnectionAccepter.stop();\n}\nprotected int getPort() {\nreturn connectionAccepter.getLocalPort();\n}\nprotected String getIpAddress() {\nreturn ipAddress;\n}\n}"}
{"className":"jfreerails.network.specifics.FreerailsClientWithLocalServerTest","javaDoc":"/**\n* This test uses clients connected to a local server. This means anything sent\n* to the server arrives instantly, which makes writing the test easier.\n*\n* @author Luke\n* @see FreerailsClientTest\n*/","code":"/**\n* This test uses clients connected to a local server. This means anything sent\n* to the server arrives instantly, which makes writing the test easier.\n*\n* @author Luke\n* @see FreerailsClientTest\n*/\npublic class FreerailsClientWithLocalServerTest extends TestCase {\nprivate FreerailsGameServer server;\nprivate SavedGamesManager4UnitTests savedGamesManager;\n@Override\nprotected void setUp() throws Exception {\nsavedGamesManager = new SavedGamesManager4UnitTests();\nserver = new FreerailsGameServer(savedGamesManager);\n}\n/** Copy & pasted from FreerailsClientTest, then edited. */\npublic void testLogon() {\ntry {\n/* Test 1 : connecting a client. */\nassertEquals(\"No client connected yet.\", 0, server\n.countOpenConnections());\nFreerailsClient client = new FreerailsClient();\nLogOnResponse response = client.connect(server, \"name\", \"password\");\nassertTrue(response.isSuccessful());\nassertEquals(1, server.countOpenConnections());\n// Check the client gets its properties updated.\nclient.update();\nassertNotNull(client\n.getProperty(ClientControlInterface.ClientProperty.CONNECTED_CLIENTS));\nassertNotNull(client\n.getProperty(ClientControlInterface.ClientProperty.MAPS_AVAILABLE));\nassertNotNull(client\n.getProperty(ClientControlInterface.ClientProperty.SAVED_GAMES));\n/* Test 2 : a client that has already logged on. */\nFreerailsClient client1 = new FreerailsClient();\nresponse = client1.connect(server, \"name\", \"password\");\nassertFalse(\"The player is already logged on.\", response\n.isSuccessful());\nassertEquals(1, server.countOpenConnections());\n/* Test 3 : connecting a client. */\nFreerailsClient client3 = new FreerailsClient();\nresponse = client3.connect(server, \"name3\", \"password\");\nassertTrue(response.isSuccessful());\nassertEquals(2, server.countOpenConnections());\n/* Test 4 : disconnect the client from test 1. */\nclient.disconnect();\nassertEquals(1, server.countOpenConnections());\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\npublic void testNewGame() {\nassertEquals(0, server.countOpenConnections());\n/* Connect 2 clients. */\nFreerailsClient client0 = new FreerailsClient();\nLogOnResponse response0 = client0\n.connect(server, \"client0\", \"password\");\nassertTrue(response0.isSuccessful());\nFreerailsClient client1 = new FreerailsClient();\nLogOnResponse response1 = client1\n.connect(server, \"client1\", \"password\");\nassertTrue(response1.isSuccessful());\nassertEquals(2, server.countOpenConnections());\nclient0.update();\nclient1.update();\n/* Start a new game. */\nassertNull(client0.getWorld());\nassertNull(client1.getWorld());\nImStringList mapNames = (ImStringList) client0\n.getProperty(ClientProperty.MAPS_AVAILABLE);\nfinal int commandID = 66;\nMessage2Server message2 = new NewGameMessage2Server(commandID, mapNames\n.get(0));\nclient0.write(message2);\nassertTrue(server.isNewPlayersAllowed());\nserver.update();\nassertFalse(\"New players cannot be added once the game has started.\",\nserver.isNewPlayersAllowed());\n/*\n* Note, the following would have happened anyway when client0.update();\n* gets called.\n*/\nFreerailsSerializable obj = client0.read();\nMessage2Client cc = (Message2Client) obj;\nclient0.write(cc.execute(client0));\nobj = client0.read();\nMessageStatus status = (MessageStatus) obj;\nassertTrue(status.isSuccessful());\nassertEquals(commandID, status.getId());\n/* The server should have sent a message2 that sets the world object. */\nclient0.update();\nclient1.update();\nassertNotNull(client0.getWorld());\nassertNotNull(client1.getWorld());\n/* The server will not have read the players confirmation yet. */\nassertFalse(server.isConfirmed(0));\nassertFalse(server.isConfirmed(1));\nserver.update();\n/* Now it will. */\nassertTrue(server.isConfirmed(0));\nassertTrue(server.isConfirmed(1));\n/*\n* The number of players on the world object should be the same as the\n* number of players under the ClientControlInterface.CONNECTED_CLIENTS\n* key\n*/\nint connectedPlayers = ((ImStringList) client0\n.getProperty(ClientProperty.CONNECTED_CLIENTS)).size();\nint playersOnWorldObject = client0.getWorld().getNumberOfPlayers();\nassertEquals(connectedPlayers, playersOnWorldObject);\nWorld w = client0.getWorld();\nassertNotNull(w.getPlayer(0));\nassertNotNull(w.getPlayer(1));\n/*\n* Now check that attempts to log on by new players are rejected.\n*/\nassertEquals(2, server.countOpenConnections());\nFreerailsClient client = new FreerailsClient();\nLogOnResponse response = client.connect(server, \"Late player\",\n\"password\");\nassertFalse(response.isSuccessful());\nassertEquals(2, server.countOpenConnections());\n}\n/** Tests sending moves between client and server. */\npublic void testSendingMoves() {\ntry {\n/* Set up and start a game with 2 clients. */\nFreerailsClient client0 = new FreerailsClient();\nLogOnResponse response0 = client0.connect(server, \"client0\",\n\"password\");\nassertTrue(response0.isSuccessful());\nFreerailsClient client1 = new FreerailsClient();\nLogOnResponse response1 = client1.connect(server, \"client1\",\n\"password\");\nassertTrue(response1.isSuccessful());\nclient0.update();\nclient1.update();\nImStringList mapNames = (ImStringList) client0\n.getProperty(ClientProperty.MAPS_AVAILABLE);\nMessage2Server message2 = new NewGameMessage2Server(99, mapNames\n.get(0));\nclient0.write(message2);\nserver.update();\nclient0.update();\nclient1.update();\n/* Now try sending some moves. */\nWorld world = client0.getWorld();\nPlayer player0 = world.getPlayer(0);\nFreerailsPrincipal principal0 = player0.getPrincipal();\nTransaction t = new Receipt(new Money(100),\nTransaction.Category.MISC_INCOME);\nMove move = new AddTransactionMove(principal0, t);\nWorld copyOfWorld = world.defensiveCopy();\nassertEquals(copyOfWorld, world);\nMoveStatus status = move.doMove(copyOfWorld, principal0);\nassertTrue(status.isOk());\n// client0.write(move);\nclient0.processMove(move);\nserver.update();\nMoveStatus reply = (MoveStatus) client0.read();\nassertEquals(MoveStatus.MOVE_OK, reply);\nclient0.processMessage(reply);\n/*\n* After performing an update, the server and 2 clients' copies of\n* the world object should be in the same state.\n*/\nserver.update();\nclient0.update();\nclient1.update();\nassertEquals(copyOfWorld, world);\nassertEquals(copyOfWorld, client1.getWorld());\nassertEquals(copyOfWorld, server.getCopyOfWorld());\n/* Test disconnecting and reconnecting during play. */\nclient0.disconnect();\nclient1.processMove(move);\n// client1.write(move);\nmove.doMove(client1.getWorld(), principal0);\nclient1.update();\nserver.update();\nclient1.update();\nassertFalse(world.equals(client1.getWorld()));\nresponse0 = client0.connect(server, \"client0\", \"password\");\nassertTrue(response0.isSuccessful());\nassertEquals(0, response0.getPlayerID());\n} catch (Exception e) {\ne.printStackTrace();\nfail(e.getMessage());\n}\n}\n/** Tests sending premoves between client and server. */\npublic void testSendingPreMoves() {\ntry {\n/* Set up and start a game with 2 clients. */\nFreerailsClient client0 = new FreerailsClient();\nLogOnResponse response0 = client0.connect(server, \"client0\",\n\"password\");\nassertTrue(response0.isSuccessful());\nFreerailsClient client1 = new FreerailsClient();\nLogOnResponse response1 = client1.connect(server, \"client1\",\n\"password\");\nassertTrue(response1.isSuccessful());\nclient0.update();\nclient1.update();\nImStringList mapNames = (ImStringList) client0\n.getProperty(ClientProperty.MAPS_AVAILABLE);\nMessage2Server message2 = new NewGameMessage2Server(99, mapNames\n.get(0));\nclient0.write(message2);\nserver.update();\nclient0.update();\nclient1.update();\n/* Now try sending some premoves. */\nPlayer player0 = client0.getWorld().getPlayer(0);\nFreerailsPrincipal principal0 = player0.getPrincipal();\nPreMove pm = TimeTickPreMove.INSTANCE;\nWorld copyOfWorld = client0.getWorld().defensiveCopy();\nassertEquals(copyOfWorld, client0.getWorld());\nMove move = pm.generateMove(copyOfWorld);\nMoveStatus status = move.doMove(copyOfWorld, principal0);\nassertTrue(status.isOk());\nclient0.processPreMove(pm);\nserver.update();\nPreMoveStatus reply = (PreMoveStatus) client0.read();\nassertEquals(PreMoveStatus.PRE_MOVE_OK, reply);\nclient0.processMessage(reply);\nserver.update();\nclient0.update();\nclient1.update();\nassertEquals(copyOfWorld, client0.getWorld());\nassertEquals(copyOfWorld, client1.getWorld());\nassertEquals(copyOfWorld, server.getCopyOfWorld());\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\npublic void testLoadingGame() {\ntry {\nint commandID = 0;\n// Add client to server.\nFreerailsClient client0 = new FreerailsClient();\nLogOnResponse response0 = client0.connect(server, \"client0\",\n\"password\");\nassertTrue(response0.isSuccessful());\nclient0.update();\n// Start game\nImStringList mapNames = (ImStringList) client0\n.getProperty(ClientProperty.MAPS_AVAILABLE);\nMessage2Server newGameMessage2 = new NewGameMessage2Server(\ncommandID++, mapNames.get(0));\nMessageStatus cm = newGameMessage2.execute(server);\nassertTrue(cm.isSuccessful());\n// Save game and stop server\nString savedGameName = \"game1\";\nMessage2Server saveGameMessage2 = new SaveGameMessage2Server(\ncommandID++, savedGameName);\ncm = saveGameMessage2.execute(server);\nassertTrue(cm.isSuccessful());\nserver.stopGame();\n// Start 2nd server with saved game\nserver = new FreerailsGameServer(savedGamesManager);\nserver.loadgame(savedGameName);\nassertEquals(0, server.countOpenConnections());\n// Attempt to attach invalid player.\nclient0 = new FreerailsClient();\nresponse0 = client0.connect(server, \"client0\", \"batman\");\nassertFalse(\"bad password\", response0.isSuccessful());\nassertEquals(0, server.countOpenConnections());\nresponse0 = client0.connect(server, \"client1\", \"password\");\nassertFalse(\"bad username\", response0.isSuccessful());\nassertEquals(0, server.countOpenConnections());\nresponse0 = client0.connect(server, \"client0\", \"password\");\nassertTrue(\"Ok, same username and password as before.\", response0\n.isSuccessful());\nassertEquals(1, server.countOpenConnections());\n} catch (Exception e) {\ne.printStackTrace();\nfail();\n}\n}\n}"}
{"className":"jfreerails.network.specifics.FreerailsGameServerTest","javaDoc":"/**\n* Junit test for FreerailsGameServer - tests logging on.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit test for FreerailsGameServer - tests logging on.\n*\n* @author Luke\n*\n*/\npublic class FreerailsGameServerTest extends TestCase {\nprivate FreerailsGameServer server;\npublic void testLogon() {\nLogOnResponse response;\n/* Test 1 */\nLogOnRequest request1 = new LogOnRequest(\"Name\", \"password\");\nresponse = server.logon(request1);\nassertTrue(\"Simple case, should go through.\", response.isSuccessful());\nassertEquals(\"1st logon is player 0\", 0, response.getPlayerID());\n/* Test 2 */\nLogOnRequest request2 = new LogOnRequest(\"Name2\", \"password2\");\nresponse = server.logon(request2);\nassertTrue(\"Simple case, should go through.\", response.isSuccessful());\nassertEquals(\"2nd logon is player 1\", 1, response.getPlayerID());\n/* Test 3: When player is already logged on. */\nLogOnRequest request3 = new LogOnRequest(\"Name\", \"password\");\nresponse = server.logon(request3);\nassertFalse(\"Player is already logged on.\", response.isSuccessful());\n/* Test 4: When new logons are not allowed. */\nserver.setNewPlayersAllowed(false);\nLogOnRequest request4 = new LogOnRequest(\"Name4\", \"password4\");\nresponse = server.logon(request4);\nassertFalse(\"New logons are not allowed.\", response.isSuccessful());\n/* Test 5: When the player has logged off, then tries to log on. */\nserver.logoff(0);\nLogOnRequest request5 = request1;\nresponse = server.logon(request5);\nassertTrue(\"Player 0 has logged off, so should succeed.\", response\n.isSuccessful());\nassertEquals(\"Should keep the same player id\", 0, response\n.getPlayerID());\n/*\n* Test 6: When the player has logged off, then tries to log on with\n* wrong password.\n*/\nserver.logoff(0);\nLogOnRequest request6 = new LogOnRequest(\"Name\", \"batman\");\nresponse = server.logon(request6);\nassertFalse(\"Player 0 has logged off, but the password is wrong.\",\nresponse.isSuccessful());\n}\n@Override\nprotected void setUp() throws Exception {\nserver = new FreerailsGameServer(new SavedGamesManager4UnitTests());\n}\n}"}
{"className":"jfreerails.controller.FinancialDataGathererTest","javaDoc":"/**\n* JUnit test for FinancialDataGatherer.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for FinancialDataGatherer.\n*\n* @author Luke\n*\n*/\npublic class FinancialDataGathererTest extends TestCase {\nWorld w;\nPlayer player;\n@Override\nprotected void setUp() throws Exception {\nplayer =new Player(\"Player X\", 0);\nw = new WorldImpl();\nMove addPlayer = AddPlayerMove.generateMove(w, player);\nMoveStatus ms = addPlayer.doMove(w, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\n}\npublic void testCanIssueBond() {\nFinancialDataGatherer fdg = new FinancialDataGatherer(w, player\n.getPrincipal());\nassertTrue(fdg.canIssueBond()); // 5%\nassertTrue(addBond()); // 6%\nassertTrue(addBond()); // 7%\nassertFalse(addBond()); // 8% so can't\nfdg = new FinancialDataGatherer(w, player.getPrincipal());\nassertEquals(8, fdg.nextBondInterestRate());\n}\n/**\n* Adds a bond and returns true if another bond can be added. Written to\n* avoid copy & paste in testCanIssueBond().\n*/\nprivate boolean addBond() {\nFinancialDataGatherer fdg;\nw.addTransaction(player.getPrincipal(), BondTransaction.issueBond(5));\nfdg = new FinancialDataGatherer(w, player.getPrincipal());\nboolean canIssueBond = fdg.canIssueBond();\nreturn canIssueBond;\n}\npublic void testNextBondInterestRate() {\nFinancialDataGatherer fdg = new FinancialDataGatherer(w, player\n.getPrincipal());\nassertEquals(5, fdg.nextBondInterestRate());\nw.addTransaction(player.getPrincipal(), BondTransaction.issueBond(5));\nfdg = new FinancialDataGatherer(w, player.getPrincipal());\nassertEquals(6, fdg.nextBondInterestRate());\n}\npublic void testTreasuryStock() {\nFreerailsPrincipal principal = player.getPrincipal();\nFinancialDataGatherer fdg = new FinancialDataGatherer(w, principal);\nassertEquals(0, fdg.treasuryStock());\nint treasuryStock = 10000;\nint totalStock = FinancialMoveProducer.IPO_SIZE;\nint publicStock = totalStock - treasuryStock;\nTransaction t = StockTransaction.buyOrSellStock(0, treasuryStock, new Money(5));\nw.addTransaction(principal, t);\nfdg = new FinancialDataGatherer(w, principal);\nassertEquals(treasuryStock,\nfdg.treasuryStock());\nassertEquals(totalStock,\nfdg.totalShares());\nassertEquals(publicStock,\nfdg.sharesHeldByPublic());\n}\npublic void testBuyingStakesInOtherRRs(){\nw = new WorldImpl();\nPlayer[] players = new Player[2];\nfor(int i = 0; i < players.length; i++){\nplayers[i] = new Player(\"Player \"+i, i);\nMove addPlayer = AddPlayerMove.generateMove(w, players[i]);\nMoveStatus ms = addPlayer.doMove(w, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\n}\n//Make player #0 buy stock in player #1\nint quantity = 10000;\nTransaction t = StockTransaction.buyOrSellStock(1, quantity, new Money(5));\nw.addTransaction(players[0].getPrincipal(), t);\nFinancialDataGatherer fdg = new FinancialDataGatherer(w, players[0].getPrincipal());\nassertEquals(0, fdg.treasuryStock());\nint actual = fdg.getStockInRRs()[1];\nassertEquals(quantity, actual);\n}\npublic void testTotalShares() {\nFinancialDataGatherer fdg = new FinancialDataGatherer(w, player\n.getPrincipal());\nint expected = FinancialMoveProducer.IPO_SIZE;\nassertEquals(expected, fdg.totalShares());\n}\n}"}
{"className":"jfreerails.controller.SharePriceCalculatorTest","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class SharePriceCalculatorTest extends TestCase {\npublic void test1() {\nSharePriceCalculator cal = new SharePriceCalculator();\ncal.networth = 100000;\ncal.profitsLastYear = 100000;\ncal.stockholderEquity = 500000;\ncal.totalShares = 100000;\nlong expected = (100000 + 500000 + 100000 * 5) / 100000;\nassertEquals(expected, cal.calculatePrice());\n}\n}"}
{"className":"jfreerails.controller.PathOnTrackFinderTest","javaDoc":"/**\n* @author Luke\n*\n*/","code":"/**\n* @author Luke\n*\n*/\npublic class PathOnTrackFinderTest extends TestCase {\nWorld w;\nTrackMoveProducer producer;\nPathOnTrackFinder pathFinder;\nStationBuilder stationBuilder;\nBuildTrackStrategy bts;\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\nw = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(w, 0);\nModelRoot mr = new ModelRootImpl();\nproducer = new TrackMoveProducer(me, w, mr);\npathFinder = new PathOnTrackFinder(w);\nstationBuilder = new StationBuilder(me);\nbts = BuildTrackStrategy.getDefault(w);\n}\n@Override\nprotected void tearDown() throws Exception {\nsuper.tearDown();\n}\npublic void testPathAsVectors1() {\nStep[] path = { EAST, EAST, SOUTH_EAST };\nImPoint start = new ImPoint(5, 5);\nImPoint end = Step.move(start, path);\nproducer.buildTrack(start, path);\ntry {\npathFinder.setupSearch(start, end);\npathFinder.search(-1);\nassertEquals(IncrementalPathFinder.PATH_FOUND, pathFinder\n.getStatus());\nStep[] pathFound = pathFinder.pathAsVectors();\nassertTrue(Arrays.equals(path, pathFound));\n} catch (PathNotFoundException e) {\nfail();\n}\n}\npublic void testPathAsVectors2() {\nStep[] path = { EAST, EAST, SOUTH_EAST, EAST, EAST, NORTH_EAST };\nImPoint start = new ImPoint(5, 5);\nImPoint end = Step.move(start, path);\nproducer.buildTrack(start, path);\ntry {\npathFinder.setupSearch(start, end);\npathFinder.search(-1);\nassertEquals(IncrementalPathFinder.PATH_FOUND, pathFinder\n.getStatus());\nStep[] pathFound = pathFinder.pathAsVectors();\nassertTrue(Arrays.equals(path, pathFound));\n} catch (PathNotFoundException e) {\nfail();\n}\n}\npublic void testSetupSearch() {\nStep[] path = { EAST, EAST, SOUTH_EAST };\nImPoint start = new ImPoint(5, 5);\nImPoint end = Step.move(start, path);\nproducer.buildTrack(start, path);\ntry {\npathFinder.setupSearch(start, end);\n} catch (PathNotFoundException e) {\nfail(\"Track at both of the points so no exception should be thrown\");\n}\ntry {\npathFinder.setupSearch(start, new ImPoint(10, 10));\nfail(\"No track at one of the points so an exception should be thrown\");\n} catch (PathNotFoundException e) {\n}\ntry {\npathFinder.setupSearch(new ImPoint(10, 10), end);\nfail(\"No track at one of the points so an exception should be thrown\");\n} catch (PathNotFoundException e) {\n}\n}\n}"}
{"className":"jfreerails.controller.MoveTrainPreMove1stTest","javaDoc":"/**\n* JUnit test for MoveTrainPreMove, tests moving round a loop of track.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for MoveTrainPreMove, tests moving round a loop of track.\n*\n* @author Luke\n*\n*/\npublic class MoveTrainPreMove1stTest extends AbstractMoveTestCase {\nTrackMoveProducer trackBuilder;\nStationBuilder stationBuilder;\nFreerailsPrincipal principal;\nprivate ImPoint stationA;\nprivate ImPoint stationB;\nImmutableSchedule defaultSchedule;\n@Override\nprotected void setupWorld() {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\ntrackBuilder = new TrackMoveProducer(me, world, mr);\nstationBuilder = new StationBuilder(me);\n// Build track.\nstationBuilder\n.setStationType(stationBuilder.getTrackTypeID(\"terminal\"));\nStep[] track = { EAST, EAST, EAST, EAST, EAST, EAST, EAST, EAST, EAST };\nstationA = new ImPoint(10, 10);\nMoveStatus ms0 = trackBuilder.buildTrack(stationA, track);\nassertTrue(ms0.ok);\n// Build 2 stations.\nMoveStatus ms1 = stationBuilder.buildStation(stationA);\nassertTrue(ms1.ok);\nstationB = new ImPoint(19, 10);\nMoveStatus ms2 = stationBuilder.buildStation(stationB);\nassertTrue(ms2.ok);\nTrainOrdersModel order0 = new TrainOrdersModel(1, null, false, false);\nTrainOrdersModel order1 = new TrainOrdersModel(0, null, false, false);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\ndefaultSchedule = s.toImmutableSchedule();\nImPoint start = new ImPoint(10, 10);\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0),\nstart, principal, defaultSchedule);\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, principal);\nassertTrue(ms.ok);\n}\npublic void testNextVector() {\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nStep actual = preMove.nextStep(world);\nassertNotNull(actual);\n// The train is at station A, so should head east to station B.\nassertEquals(EAST, actual);\n}\npublic void testNextSpeeds() {\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nSpeedAgainstTime speeds = preMove.nextSpeeds(world, EAST);\nassertNotNull(speeds);\nassertEquals(speeds.calcV(0), 0d);\nassertTrue(speeds.getS() >= EAST.getLength());\ndouble t = speeds.getT();\nassertTrue(t > 0);\nassertTrue(speeds.calcV(t) > 0);\n}\n@Override\npublic void testMove() {\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nMove m = preMove.generateMove(world);\nassertNotNull(m);\nassertSurvivesSerialisation(m);\n}\npublic void testMove2() {\nMoveStatus ms;\nMove m;\nsetupLoopOfTrack();\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nTrainMotion tm = ta.findCurrentMotion(3);\nassertEquals(0d, tm.duration());\nPathOnTiles expected = new PathOnTiles(new ImPoint(5, 5), SOUTH_WEST);\nassertEquals(expected, tm.getPath());\nPositionOnTrack pot = tm.getFinalPosition();\nint x = pot.getX();\nassertEquals(4, x);\nint y = pot.getY();\nassertEquals(6, y);\nassertEquals(SOUTH_WEST, pot.facing());\nMoveTrainPreMove moveTrain = new MoveTrainPreMove(0, principal);\nassertEquals(NORTH_EAST, moveTrain.nextStep(world));\nm = moveTrain.generateMove(world);\nms = m.doMove(world, principal);\nassertTrue(ms.ok);\nTrainMotion tm2 = ta.findCurrentMotion(3);\nassertFalse(tm.equals(tm2));\nexpected = new PathOnTiles(new ImPoint(5, 5), SOUTH_WEST, NORTH_EAST);\nassertEquals(expected, tm2.getPath());\nassertTrue(tm2.duration() > 3d);\n// The expected value is 3.481641930846211, found from\n// stepping thu code in debugger.\nassertTrackHere(tm2.getTiles(tm2.duration()));\npot = tm2.getFinalPosition();\nassertEquals(4, x);\nassertEquals(6, y);\n// assertEquals(SOUTH, pot.facing());\nassertTrackHere(x, y);\nassertEquals(EAST, moveTrain.nextStep(world));\nMoveTrainPreMove2ndTest.incrTime(world, principal);\nm = moveTrain.generateMove(world);\nms = m.doMove(world, principal);\nassertTrue(ms.ok);\nTrainMotion tm3 = ta.findCurrentMotion(100);\nassertFalse(tm3.equals(tm2));\nexpected = new PathOnTiles(new ImPoint(4, 6), NORTH_EAST, EAST);\nassertEquals(expected, tm3.getPath());\nassertTrackHere(tm3.getTiles(tm3.duration()));\nassertTrackHere(tm3.getTiles(tm3.duration() / 2));\nassertTrackHere(tm3.getTiles(0));\nassertTrackHere(tm3.getPath());\nassertEquals(SOUTH_EAST, moveTrain.nextStep(world));\nMoveTrainPreMove2ndTest.incrTime(world, principal);\nm = moveTrain.generateMove(world);\nms = m.doMove(world, principal);\nassertTrue(ms.ok);\n}\nprivate void setupLoopOfTrack() {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\nTrackMoveProducer producer = new TrackMoveProducer(me, world, mr);\nStep[] trackPath = { EAST, SOUTH_EAST, SOUTH, SOUTH_WEST, WEST,\nNORTH_WEST, NORTH, NORTH_EAST };\nImPoint from = new ImPoint(5, 5);\nMoveStatus ms = producer.buildTrack(from, trackPath);\nassertTrue(ms.ok);\nTrainOrdersModel[] orders = {};\nImmutableSchedule is = new ImmutableSchedule(orders, -1, false);\nAddTrainPreMove addTrain = new AddTrainPreMove(0, new ImInts(), from,\nprincipal, is);\nMove m = addTrain.generateMove(world);\nms = m.doMove(world, principal);\nassertTrue(ms.ok);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nTrainMotion motion = ta.findCurrentMotion(0);\nassertNotNull(motion);\nPathOnTiles expected = new PathOnTiles(from, SOUTH_WEST);\nPathOnTiles actual = motion.getTiles(motion.duration());\nassertEquals(expected, actual);\n}\npublic void testMovingRoundLoop() {\nsetupLoopOfTrack();\nMoveTrainPreMove moveTrain = new MoveTrainPreMove(0, principal);\nMove m = moveTrain.generateMove(world);\nassertTrue(m.doMove(world, principal).ok);\n}\npublic void testGetTiles() {\nsetupLoopOfTrack();\nMoveTrainPreMove moveTrain = new MoveTrainPreMove(0, principal);\nMove m = moveTrain.generateMove(world);\nassertTrue(m.doMove(world, principal).ok);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nTrainMotion motion = ta.findCurrentMotion(1);\ndouble duration = motion.duration();\nassertTrue(duration > 1);\nint trainLength = motion.getTrainLength();\nfor (int i = 0; i < 10; i++) {\ndouble t = i == 0 ? 0 : duration * i / 10;\nPathOnTiles tiles = motion.getTiles(t);\nassertTrue(\"t=\" + t, tiles.steps() > 0);\nassertTrue(\"t=\" + t, tiles.getTotalDistance() >= trainLength);\n}\n}\npublic void testFindNextVector() {\nsetupLoopOfTrack();\nPositionOnTrack pot = PositionOnTrack.createFacing(4, 6, SOUTH_WEST);\nImPoint target = new ImPoint();\nStep expected = NORTH_EAST;\nassertEquals(expected, MoveTrainPreMove.findNextStep(world, pot,\ntarget));\npot.move(expected);\nexpected = EAST;\nassertEquals(expected, MoveTrainPreMove.findNextStep(world, pot,\ntarget));\npot.move(expected);\nexpected = SOUTH_EAST;\nassertEquals(expected, MoveTrainPreMove.findNextStep(world, pot,\ntarget));\npot.move(expected);\nexpected = SOUTH;\nassertEquals(expected, MoveTrainPreMove.findNextStep(world, pot,\ntarget));\npot.move(expected);\n}\n}"}
{"className":"jfreerails.controller.AddTrainPreMoveTest","javaDoc":"/**\n* Junit test for AddTrainPreMove.\n*\n* @author Luke\n*\n*/","code":"/**\n* Junit test for AddTrainPreMove.\n*\n* @author Luke\n*\n*/\npublic class AddTrainPreMoveTest extends AbstractMoveTestCase {\nTrackMoveProducer trackBuilder;\nStationBuilder stationBuilder;\nFreerailsPrincipal principal;\nprivate ImPoint stationA;\nprivate ImPoint stationB;\nImmutableSchedule defaultSchedule;\n@Override\nprotected void setupWorld() {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\ntrackBuilder = new TrackMoveProducer(me, world, mr);\nstationBuilder = new StationBuilder(me);\n// Build track.\nstationBuilder\n.setStationType(stationBuilder.getTrackTypeID(\"terminal\"));\nStep[] track = {EAST, EAST, EAST, EAST, EAST, EAST, EAST, EAST, EAST};\nstationA = new ImPoint(10, 10);\nMoveStatus ms0 = trackBuilder.buildTrack(stationA, track);\nassertTrue(ms0.ok);\n// Build 2 stations.\nMoveStatus ms1 = stationBuilder.buildStation(stationA);\nassertTrue(ms1.ok);\nstationB = new ImPoint(19, 10);\nMoveStatus ms2 = stationBuilder.buildStation(stationB);\nassertTrue(ms2.ok);\nTrainOrdersModel order0 = new TrainOrdersModel(0, null, false, false);\nTrainOrdersModel order1 = new TrainOrdersModel(1, null, false, false);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\ndefaultSchedule = s.toImmutableSchedule();\n}\n@Override\npublic void testMove() {\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0),\nstationA, principal, defaultSchedule);\nMove m = preMove.generateMove(world);\nassertDoMoveIsOk(m);\nassertUndoMoveIsOk(m);\nassertSurvivesSerialisation(m);\n}\n/**\n* Check that the path on tiles created for the new train is actually on\n* the track.\n*/\npublic void testPathOnTiles() {\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0),\nstationA, principal, defaultSchedule);\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nTrainMotion motion = ta.findCurrentMotion(0);\nassertNotNull(motion);\nPathOnTiles path = motion.getTiles(motion.duration());\nassertTrackHere(path);\n}\npublic void testMove2() {\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0),\nstationA, principal, defaultSchedule);\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\nActivityIterator ai = world.getActivities(principal, 0);\nTrainMotion tm = (TrainMotion) ai.getActivity();\nassertEquals(0d, tm.duration());\nassertEquals(0d, tm.getSpeedAtEnd());\nassertEquals(0d, tm.getDistance(0));\nPositionOnTrack pot = tm.getFinalPosition();\nassertNotNull(pot);\nassertEquals(EAST, pot.facing());\nassertEquals(13, pot.getX());\nassertEquals(10, pot.getY());\n}\npublic void testGetSchedule() {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\nTrackMoveProducer producer = new TrackMoveProducer(me, world, mr);\nStep[] trackPath = {EAST, SOUTH_EAST, SOUTH, SOUTH_WEST, WEST,\nNORTH_WEST, NORTH, NORTH_EAST};\nImPoint from = new ImPoint(5, 5);\nMoveStatus ms = producer.buildTrack(from, trackPath);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\nTrainOrdersModel[] orders = {};\nImmutableSchedule is = new ImmutableSchedule(orders, -1, false);\nAddTrainPreMove addTrain = new AddTrainPreMove(0, new ImInts(), from,\nprincipal, is);\nMove m = addTrain.generateMove(world);\nms = m.doMove(world, principal);\nif (!ms.ok) {\nthrow new IllegalStateException(ms.message);\n}\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nassertNotNull(ta.getTarget());\n}\npublic void testInvalidSchedule() {\ntry {\nTrainOrdersModel order0 = new TrainOrdersModel(10, null, false, false);\nTrainOrdersModel order1 = new TrainOrdersModel(1, null, false, false);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\nImmutableSchedule invalidSchedule = s.toImmutableSchedule();\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0),\nstationA, principal, invalidSchedule);\npreMove.generateMove(world);\nfail();\n} catch (ArrayIndexOutOfBoundsException e) {\n}\n}\n}"}
{"className":"jfreerails.controller.TrackBuildingTest","javaDoc":null,"code":"public class TrackBuildingTest extends TestCase {\nWorld w;\nTrackMoveProducer producer;\nTrackPathFinder pathFinder;\nStationBuilder stationBuilder;\nBuildTrackStrategy bts;\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\nw = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(w, 0);\nModelRoot mr = new ModelRootImpl();\nproducer = new TrackMoveProducer(me, w, mr);\nFreerailsPrincipal principal = w.getPlayer(0).getPrincipal();\npathFinder = new TrackPathFinder(w, principal);\nstationBuilder = new StationBuilder(me);\nbts = BuildTrackStrategy.getDefault(w);\n}\n/** Tests building track from 5,5 to 10,5 */\npublic void testBuildingStraight() {\nImPoint from = new ImPoint(5, 5);\nImPoint to = new ImPoint(10, 5);\ntry {\n// Check there is no track before we build it.\nfor (int x = 5; x <= 10; x++) {\nTrackPiece tp = ((FreerailsTile) w.getTile(x, 5)).getTrackPiece();\nassertEquals(NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER, tp\n.getTrackTypeID());\n}\npathFinder.setupSearch(from, to, bts);\npathFinder.search(-1);\nassertEquals(pathFinder.getStatus(),\nIncrementalPathFinder.PATH_FOUND);\nStep[] path = pathFinder.pathAsVectors();\nassertEquals(path.length, 5);\nfor (int i = 0; i < 5; i++) {\nassertEquals(Step.EAST, path[i]);\n}\nMoveStatus ms = producer.buildTrack(from, path);\nassertTrue(ms.message, ms.ok);\n// Check track has been built.\nfor (int x = 5; x <= 10; x++) {\nTrackPiece tp = ((FreerailsTile) w.getTile(x, 5)).getTrackPiece();\nassertEquals(0, tp.getTrackTypeID());\n}\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n/** Tests building track from 5,5 to 6,5 */\npublic void testBuildingOneTrackPiece() {\nImPoint from = new ImPoint(5, 5);\nImPoint to = new ImPoint(6, 5);\ntry {\n// Check there is no track before we build it.\nTrackPiece tp1 = ((FreerailsTile) w.getTile(5, 5)).getTrackPiece();\nassertEquals(NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER, tp1\n.getTrackTypeID());\nTrackPiece tp2 = ((FreerailsTile) w.getTile(6, 5)).getTrackPiece();\nassertEquals(NullTrackType.NULL_TRACK_TYPE_RULE_NUMBER, tp2\n.getTrackTypeID());\npathFinder.setupSearch(from, to, bts);\npathFinder.search(-1);\nassertEquals(pathFinder.getStatus(),\nIncrementalPathFinder.PATH_FOUND);\nStep[] path = pathFinder.pathAsVectors();\nassertEquals(path.length, 1);\nassertEquals(Step.EAST, path[0]);\nMoveStatus ms = producer.buildTrack(from, path);\nassertTrue(ms.message, ms.ok);\n// Check track has been built.\ntp1 = ((FreerailsTile) w.getTile(5, 5)).getTrackPiece();\nassertEquals(0, tp1.getTrackTypeID());\ntp2 = ((FreerailsTile) w.getTile(6, 5)).getTrackPiece();\nassertEquals(0, tp2.getTrackTypeID());\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n/**\n* There is a bug where if a section of track has a terminal on the end, you\n* cannot extend the track through the terminal. Instead, the track path\n* finder finds a route that misses out the terminal.\n*\n*/\npublic void testTerminalProblem() {\ntry {\nImPoint from = new ImPoint(5, 5);\nStep[] path = { EAST, EAST, EAST };\nMoveStatus ms = producer.buildTrack(from, path);\nassertTrue(ms.ok);\nint terminalStationType = stationBuilder.getTrackTypeID(\"terminal\");\nstationBuilder.setStationType(terminalStationType);\nms = stationBuilder.buildStation(new ImPoint(8, 5));\nassertTrue(ms.ok);\npathFinder.setupSearch(new ImPoint(7, 5), new ImPoint(9, 5), bts);\npathFinder.search(-1);\npath = pathFinder.pathAsVectors();\nassertEquals(2, path.length);\nStep[] expectedPath = { EAST, EAST };\nassertTrue(Arrays.equals(expectedPath, path));\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n/**\n* There is a bug where if you build a straight section of double track\n* going E, then move the cursor to the end and attempt to build more double\n* track going SE, the track path finder builds a loop rather than just\n* building track going SE\n*\n*/\npublic void testDoubleTrackProblem() {\ntry {\nint trackTypeID = stationBuilder.getTrackTypeID(\"double track\");\nbts = BuildTrackStrategy.getSingleRuleInstance(trackTypeID, w);\nproducer.setBuildTrackStrategy(bts);\nImPoint a = new ImPoint(5, 5);\nImPoint b = new ImPoint(6, 5);\nImPoint c = new ImPoint(7, 6);\npathFinder.setupSearch(a, b, bts);\npathFinder.search(-1);\nStep[] path = pathFinder.pathAsVectors();\nStep[] expectedPath = { EAST };\nassertTrue(Arrays.equals(expectedPath, path));\nMoveStatus ms = producer.buildTrack(a, path);\nassertTrue(ms.ok);\nTrackPiece tp = ((FreerailsTile) w.getTile(b.x, b.y)).getTrackPiece();\nassertEquals(\"We just build double track here.\", trackTypeID, tp\n.getTrackTypeID());\npathFinder.setupSearch(b, c, bts);\npathFinder.search(-1);\npath = pathFinder.pathAsVectors();\nassertEquals(1, path.length);\nexpectedPath = new Step[] { SOUTH_EAST };\nassertTrue(Arrays.equals(expectedPath, path));\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n/**\n* There is a bug where if you try to start building track on a 90 degree\n* bend, no track path is found even when one should exist.\n*\n*/\npublic void testStartSearchOnSharpCurve() {\ntry {\nImPoint from = new ImPoint(5, 5);\nStep[] path = { EAST, SOUTH };\nMoveStatus ms = producer.buildTrack(from, path);\nassertTrue(ms.ok);\npathFinder.setupSearch(new ImPoint(6, 5), new ImPoint(6, 7), bts);\npathFinder.search(-1);\npath = pathFinder.pathAsVectors();\nassertEquals(2, path.length);\nassertEquals(SOUTH, path[0]);\nassertEquals(SOUTH, path[1]);\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n}"}
{"className":"jfreerails.controller.TrainStopsHandlerTest","javaDoc":"/**\n* Test for\n* @author Luke\n*/","code":"/**\n* Test for\n* @author Luke\n*/\npublic class TrainStopsHandlerTest {\nWorld w;\npublic TrainStopsHandlerTest() {\n}\n@Before\npublic void setup() throws Exception {\nMapCustomizer mc = new MapCustomizer();\nImPoint a = new ImPoint(10, 10);\nImPoint b = new ImPoint(20, 20);\nmc.buildTrack(a, b).buildStation(a).buildStation(b);\nmc.buildTrain(a, 0, 0);\nw = mc.w;\n}\n/**\nA train can have an empty schedule if all stops are removed from the\n* schedule or all the stations on the schedule are bulldozed.\n*\n* See bug #199 Unexpected Exception: null line -1\n*/\n@Test\npublic void testWithEmptySchedule() {\nFreerailsPrincipal principal = w.getPlayer(0).getPrincipal();\nassertEquals(2, w.size(principal, KEY.STATIONS));\nassertEquals(1, w.size(principal, KEY.TRAINS));\nWorldDiffs diffs = new WorldDiffs(w);\nTrainStopsHandler tsh = new TrainStopsHandler(0, principal, diffs);\nassertFalse(tsh.isWaiting4FullLoad());\nImmutableSchedule schedule = new MutableSchedule().toImmutableSchedule();\nw.set(principal, KEY.TRAIN_SCHEDULES, 0, schedule);\nboolean waiting4FullLoad = tsh.isWaiting4FullLoad();\nassertFalse(waiting4FullLoad);\n}\n}"}
{"className":"jfreerails.controller.ToAndFroPathIteratorTest","javaDoc":"/**\n* JUnit test for ToAndFroPathIteratorTest.\n*\n* @author Luke Lindsay 30-Oct-2002\n*\n*/","code":"/**\n* JUnit test for ToAndFroPathIteratorTest.\n*\n* @author Luke Lindsay 30-Oct-2002\n*\n*/\npublic class ToAndFroPathIteratorTest extends TestCase {\npublic ToAndFroPathIteratorTest(String arg0) {\nsuper(arg0);\n}\npublic void testNextSegment() {\nList<Point> l = new ArrayList<Point>();\nIntLine line = new IntLine();\nl.add(new Point(0, 1));\nl.add(new Point(10, 11));\nl.add(new Point(20, 22));\nFreerailsPathIterator it = new ToAndFroPathIterator(l);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(0, 1, 10, 11, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(10, 11, 20, 22, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(20, 22, 10, 11, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(10, 11, 0, 1, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(0, 1, 10, 11, line);\nassertTrue(it.hasNext());\nit.nextSegment(line);\nassertLineEquals(10, 11, 20, 22, line);\n}\nprivate void assertLineEquals(int x1, int y1, int x2, int y2, IntLine line) {\nassertEquals(x1, line.x1);\nassertEquals(x2, line.x2);\nassertEquals(y1, line.y1);\nassertEquals(y2, line.y2);\n}\n}"}
{"className":"jfreerails.controller.BuildTrackExplorerTest","javaDoc":"/**\n* JUnit test for BuildTrackExplorer.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for BuildTrackExplorer.\n*\n* @author Luke\n*\n*/\npublic class BuildTrackExplorerTest extends TestCase {\nprivate WorldImpl world;\nprivate Player testPlayer = new Player(\"test\", 0);\nprivate FreerailsPrincipal principal;\n@Override\nprotected void setUp() throws Exception {\nworld = new WorldImpl(20, 20);\nworld.addPlayer(testPlayer);\nworld.set(ITEM.GAME_RULES, GameRules.NO_RESTRICTIONS);\nprincipal = testPlayer.getPrincipal();\nMapFixtureFactory.generateTrackRuleList(world);\n}\n/**\n* On a blank map, we should be able to build track in any direction as long\n* as it does not go off the map.\n*/\npublic void test1() {\nPositionOnTrack start;\n// Test starting in the middle of the map.\nstart = PositionOnTrack.createComingFrom(10, 10, Step.NORTH);\nBuildTrackExplorer explorer = new BuildTrackExplorer(world, principal);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.NORTH, 10, 9, explorer);\nassertNextVertexIs(Step.NORTH_EAST, 11, 9, explorer);\nassertNextVertexIs(Step.EAST, 11, 10, explorer);\n// We miss out SW, S, and SE since we don't want to double back on\n// ourselves.\nassertNextVertexIs(Step.WEST, 9, 10, explorer);\nassertNextVertexIs(Step.NORTH_WEST, 9, 9, explorer);\nassertFalse(explorer.hasNextEdge());\n// Test starting in the top left of the map.\nstart = PositionOnTrack.createComingFrom(0, 0, Step.SOUTH_EAST);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.EAST, 1, 0, explorer);\nassertNextVertexIs(Step.SOUTH_EAST, 1, 1, explorer);\nassertNextVertexIs(Step.SOUTH, 0, 1, explorer);\nassertFalse(explorer.hasNextEdge());\n// Test starting in the bottom right of the map.\nstart = PositionOnTrack.createComingFrom(19, 19, Step.NORTH_WEST);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.NORTH, 19, 18, explorer);\nassertNextVertexIs(Step.WEST, 18, 19, explorer);\nassertNextVertexIs(Step.NORTH_WEST, 18, 18, explorer);\nassertFalse(explorer.hasNextEdge());\n}\n/** Test when we cannot build on some terrain types. */\npublic void test2() {\n// Check the the Ocean type is where we think it is.\nint oceanTypeNumber = 4;\nTileTypeImpl ocean = (TileTypeImpl) world.get(SKEY.TERRAIN_TYPES,\noceanTypeNumber);\nassertEquals(TerrainType.Category.Ocean, ocean.getCategory());\n// Check that track cannot be built on ocean.\nfor (int i = 0; i < world.size(SKEY.TRACK_RULES); i++) {\nTrackRule rule = (TrackRule) world.get(SKEY.TRACK_RULES, i);\nassertFalse(rule.canBuildOnThisTerrainType(ocean.getCategory()));\n}\n// Place some ocean.\nFreerailsTile tile = FreerailsTile.getInstance(oceanTypeNumber);\nworld.setTile(10, 9, tile);\nworld.setTile(11, 10, tile);\nPositionOnTrack start;\n// Test starting in the middle of the map.\nstart = PositionOnTrack.createComingFrom(10, 10, Step.NORTH);\nBuildTrackExplorer explorer = new BuildTrackExplorer(world, principal);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.NORTH_EAST, 11, 9, explorer);\n// We miss out SW, S, and SE since we don't want to double back on\n// ourselves.\nassertNextVertexIs(Step.WEST, 9, 10, explorer);\nassertNextVertexIs(Step.NORTH_WEST, 9, 9, explorer);\nassertFalse(explorer.hasNextEdge());\n}\n/** Test for illegal track configurations. */\npublic void test3() {\n// Build some track, from 10, 10 diagonally SE.\nint y = 10;\nint x = 10;\nfor (int i = 0; i < 4; i++) {\nStep v = Step.SOUTH_EAST;\nbuildTrack(x, y, v);\nx += v.deltaX;\ny += v.deltaY;\n}\n// If we enter 10, 10 from the south, we should be able to build track S\n// & SW.\nPositionOnTrack start = PositionOnTrack.createComingFrom(10, 10,\nStep.SOUTH);\nBuildTrackExplorer explorer = new BuildTrackExplorer(world, principal);\nexplorer.setPosition(start.toInt());\n// SE is going along existing track\nassertNextVertexIs(Step.SOUTH_EAST, 11, 11, explorer);\n// S is building new track.\nassertNextVertexIs(Step.SOUTH, 10, 11, explorer);\nassertFalse(explorer.hasNextEdge());\n// If we enter 10, 11 from the north, we should be able to build track\n// N, E, W, & NW.\nstart = PositionOnTrack.createComingFrom(10, 11, Step.NORTH);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.NORTH, 10, 10, explorer);\nassertNextVertexIs(Step.EAST, 11, 11, explorer);\nassertNextVertexIs(Step.WEST, 9, 11, explorer);\nassertNextVertexIs(Step.NORTH_WEST, 9, 10, explorer);\nassertFalse(explorer.hasNextEdge());\n// If we enter 10, 12 from the north, we also should be able to build\n// track N, E, W, & NW.\nstart = PositionOnTrack.createComingFrom(10, 12, Step.NORTH);\nexplorer.setPosition(start.toInt());\nassertNextVertexIs(Step.NORTH, 10, 11, explorer);\nassertNextVertexIs(Step.EAST, 11, 12, explorer);\nassertNextVertexIs(Step.WEST, 9, 12, explorer);\nassertNextVertexIs(Step.NORTH_WEST, 9, 11, explorer);\nassertFalse(explorer.hasNextEdge());\n}\nprivate void assertNextVertexIs(Step oneTileMoveVector, int x, int y,\nBuildTrackExplorer explorer) {\nassertTrue(explorer.hasNextEdge());\nexplorer.nextEdge();\nPositionOnTrack pos = new PositionOnTrack(explorer\n.getVertexConnectedByEdge());\nassertEquals(PositionOnTrack.createComingFrom(x, y, oneTileMoveVector),\npos);\n}\nprivate void buildTrack(int x, int y, Step direction) {\nTrackRule rule = (TrackRule) world.get(SKEY.TRACK_RULES, 0);\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(new ImPoint(x, y), direction, rule,\nrule, world, MapFixtureFactory.TEST_PRINCIPAL);\nMoveStatus ms = move.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\n}\n}"}
{"className":"jfreerails.controller.MoveTrainPreMove3rdTest","javaDoc":"/** Unit test for MoveTrainPreMove, tests pathfinding.*/","code":"/** Unit test for MoveTrainPreMove, tests pathfinding.*/\npublic class MoveTrainPreMove3rdTest extends TestCase {\nTrackMoveProducer trackBuilder;\nStationBuilder stationBuilder;\nFreerailsPrincipal principal;\nprivate ImPoint stationA;\nWorld world;\nStep[] line1 = { EAST, NORTH_EAST, EAST, NORTH_EAST, NORTH};\nStep[] line2 = { WEST, WEST, SOUTH_WEST, SOUTH, SOUTH_EAST, EAST};\nStep[] line3 = { NORTH_WEST, NORTH_WEST, NORTH, NORTH, NORTH_EAST};\n@Override\nprotected void setUp() throws Exception {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\ntrackBuilder = new TrackMoveProducer(me, world, mr);\nstationBuilder = new StationBuilder(me);\n// Build track.\nstationBuilder\n.setStationType(stationBuilder.getTrackTypeID(\"terminal\"));\nstationA = new ImPoint(10, 10);\nMoveStatus ms0 = trackBuilder.buildTrack(stationA, line1);\nassertTrue(ms0.ok);\nms0 = trackBuilder.buildTrack(stationA, line2);\nassertTrue(ms0.ok);\nms0 = trackBuilder.buildTrack(stationA, line3);\nassertTrue(ms0.ok);\n}\npublic void testFindingPath(){\nfindPath2Target(new ImPoint(14, 7), line1);\nfindPath2Target(new ImPoint(9, 13), line2);\nfindPath2Target(new ImPoint(9, 13), line2);\n}\nprivate void findPath2Target(ImPoint target1, Step[] expectedPath) {\nFreerailsTile tile = (FreerailsTile)world.getTile(target1.x, target1.y);\nassertTrue(tile.hasTrack());\nPositionOnTrack pot = PositionOnTrack.createFacing(10, 10, EAST);\nfor (int i = 0; i < expectedPath.length; i++) {\nStep expected = expectedPath[i];\nStep actual = MoveTrainPreMove.findNextStep(world,pot, target1);\nassertEquals(String.valueOf(i), expected, actual);\npot.move(expected);\n}\n}\n}"}
{"className":"jfreerails.controller.FlatTrackExplorerTest","javaDoc":"/**\n* JUnit test for FlatTrackExplorer.\n*\n* 24-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* JUnit test for FlatTrackExplorer.\n*\n* 24-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/\npublic class FlatTrackExplorerTest extends TestCase {\nprivate WorldImpl world;\npublic FlatTrackExplorerTest(String arg0) {\nsuper(arg0);\n}\nprivate Player testPlayer = new Player(\"test\", 0);\n@Override\nprotected void setUp() {\nworld = new WorldImpl(20, 20);\nworld.addPlayer(testPlayer);\nworld.set(ITEM.GAME_RULES, GameRules.NO_RESTRICTIONS);\nMapFixtureFactory.generateTrackRuleList(world);\nTrackRule rule = (TrackRule) world.get(SKEY.TRACK_RULES, 0);\nStep[] vectors = { Step.WEST, Step.EAST, Step.NORTH_EAST };\nImPoint p = new ImPoint(10, 10);\nImPoint[] points = { p, p, p };\nfor (int i = 0; i < points.length; i++) {\nChangeTrackPieceCompositeMove move = ChangeTrackPieceCompositeMove\n.generateBuildTrackMove(points[i], vectors[i], rule, rule,\nworld, MapFixtureFactory.TEST_PRINCIPAL);\nMoveStatus ms = move.doMove(world, Player.AUTHORITATIVE);\nassertTrue(ms.ok);\n}\n}\npublic void testGetFirstVectorToTry() {\nsetUp();\nPositionOnTrack p = PositionOnTrack.createComingFrom(10, 10,\nStep.SOUTH_WEST);\nFlatTrackExplorer fte = new FlatTrackExplorer(world, p);\nStep v = fte.getFirstVectorToTry();\nassertEquals(Step.EAST, v);\n}\n/**\n* Tests that the track explorer at point 10,10 tells us that we can move\n* west, east, or northeast.\n*/\npublic void testGetPossibleDirections() {\nsetUp();\nFlatTrackExplorer fte;\nPositionOnTrack p = PositionOnTrack.createComingFrom(10, 10,\nStep.SOUTH_WEST);\nfte = new FlatTrackExplorer(world, p);\n// There should be 3 branches.\nassertTrue(fte.hasNextEdge());\nfte.nextEdge();\np.setValuesFromInt(fte.getVertexConnectedByEdge());\nassertEquals(Step.EAST, p.cameFrom());\nassertTrue(fte.hasNextEdge());\nfte.nextEdge();\np.setValuesFromInt(fte.getVertexConnectedByEdge());\nassertEquals(Step.WEST, p.cameFrom());\nassertTrue(fte.hasNextEdge());\nfte.nextEdge();\np.setValuesFromInt(fte.getVertexConnectedByEdge());\nassertEquals(Step.NORTH_EAST, p.cameFrom());\nassertTrue(!fte.hasNextEdge());\n}\n/**\n* Tests that we can move the track explorer at point 10,10 northeast, and\n* that when we have done this, we can move it back again.\n*/\npublic void testMoveTrackExplorer() {\nsetUp();\nFlatTrackExplorer fte;\nPositionOnTrack p = PositionOnTrack.createComingFrom(10, 10, Step.EAST);\nfte = new FlatTrackExplorer(world, p);\nPositionOnTrack pos = new PositionOnTrack(fte.getPosition());\nassertEquals(10, pos.getX());\nassertEquals(10, pos.getY());\nassertTrue(fte.hasNextEdge());\nfte.nextEdge();\npos.setValuesFromInt(fte.getVertexConnectedByEdge());\nassertEquals(Step.NORTH_EAST, pos.cameFrom());\nassertEquals(11, pos.getX());\nassertEquals(9, pos.getY());\nint branchPosition = fte.getVertexConnectedByEdge();\nfte.moveForward();\nassertEquals(branchPosition, fte.getPosition());\npos.setValuesFromInt(fte.getPosition());\nassertEquals(11, pos.getX());\nassertEquals(9, pos.getY());\nassertTrue(fte.hasNextEdge());\nfte.nextEdge();\nassertEquals(Step.SOUTH_WEST, fte.currentBranch.cameFrom());\nassertTrue(!fte.hasNextEdge());\nfte.moveForward();\npos.setValuesFromInt(fte.getPosition());\nassertEquals(10, pos.getX());\nassertEquals(10, pos.getY());\n}\npublic void testHasNext() {\nsetUp();\nFlatTrackExplorer explorer = new FlatTrackExplorer(world,\nPositionOnTrack.createComingFrom(10, 10, Step.EAST));\nassertTrue(explorer.hasNextEdge());\n}\npublic void testGetPossiblePositions() {\nsetUp();\nPositionOnTrack[] positions = FlatTrackExplorer.getPossiblePositions(\nworld, new ImPoint(10, 10));\nassertNotNull(positions);\nassertEquals(3, positions.length);\nHashSet<Step> directions = new HashSet<Step>();\ndirections.add(Step.WEST);\ndirections.add(Step.EAST);\ndirections.add(Step.SOUTH_WEST);\nHashSet<Step> directions2 = new HashSet<Step>();\nfor (int i = 0; i < positions.length; i++) {\ndirections2.add(positions[i].cameFrom());\n}\nassertEquals(directions, directions2);\n}\n}"}
{"className":"jfreerails.controller.MoveTrainPreMove2ndTest","javaDoc":"/** Unit test for MoveTrainPreMove, tests stopping at stations. */","code":"/** Unit test for MoveTrainPreMove, tests stopping at stations. */\npublic class MoveTrainPreMove2ndTest extends AbstractMoveTestCase {\nTrackMoveProducer trackBuilder;\nStationBuilder stationBuilder;\nFreerailsPrincipal principal;\nprivate ImPoint station0Location;\nprivate ImPoint station1Location;\nprivate ImPoint station2Location;\nImmutableSchedule defaultSchedule;\n@Override\n/** <ol>\n* <li>Obtains a map from MapFixtureFactory2</li>\n* <li>Builds a track from (10,10) to (30, 10).</li>\n* <li>Builds stations at (10,10), (20, 10), and (28,10).</li>\n* <li>Builds a train with two wagons of type #0 and places it at (10, 10)</li>\n* <li>Schedules the train to move between stations 0 and 2 without changing consist</li>\n* </ol>\n*/\nprotected void setUp() throws Exception {\nworld = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(world, 0);\nprincipal = me.getPrincipal();\nModelRoot mr = new ModelRootImpl();\ntrackBuilder = new TrackMoveProducer(me, world, mr);\nstationBuilder = new StationBuilder(me);\n// Build track.\nstationBuilder.setStationType(stationBuilder.getTrackTypeID(\"terminal\"));\nStep[] track = new Step[20];\nfor (int i = 0; i < track.length; i++) {\ntrack[i] = EAST;\n}\nstation0Location = new ImPoint(10, 10);\nMoveStatus ms0 = trackBuilder.buildTrack(station0Location, track);\nassertTrue(ms0.ok);\n// Build 2 stations.\nMoveStatus ms1 = stationBuilder.buildStation(station0Location);\nassertTrue(ms1.ok);\nstation1Location = new ImPoint(20, 10);\nMoveStatus ms2 = stationBuilder.buildStation(station1Location);\nassertTrue(ms2.ok);\nstation2Location = new ImPoint(28, 10);\nMoveStatus ms3 = stationBuilder.buildStation(station2Location);\nassertTrue(ms3.ok);\nTrainOrdersModel order0 = new TrainOrdersModel(2, null, false, false);\nTrainOrdersModel order1 = new TrainOrdersModel(0, null, false, false);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\ndefaultSchedule = s.toImmutableSchedule();\nImPoint start = new ImPoint(10, 10);\nAddTrainPreMove preMove = new AddTrainPreMove(0, new ImInts(0, 0), start, principal,\ndefaultSchedule);\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, principal);\nassertTrue(ms.ok);\n}\npublic void testPathFinding() {\n// setTargetAsStation2();\nStep step = nextStep();\nassertEquals(EAST, step);\nmoveTrain();\nassertEquals(EAST, nextStep());\nmoveTrain();\nassertEquals(EAST, nextStep());\n}\nprivate Step nextStep() {\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nStep step = preMove.nextStep(world);\nreturn step;\n}\n/** Test that when the train arrives at a non station tile it keeps moving. */\npublic void testStops1() {\nfor (int i = 0; i < 5; i++) {\nTrainMotion tm = moveTrain();\nPositionOnTrack pot = tm.getFinalPosition();\nassertEquals(14 + i, pot.getX());\nassertEquals(READY, tm.getActivity());\nassertTrue(tm.getSpeedAtEnd() > 0);\n}\n}\nprivate TrainMotion moveTrain() {\nincrTime(world, principal);\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, principal);\nassertTrue(ms.message, ms.ok);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nTrainMotion tm = ta.findCurrentMotion(Integer.MAX_VALUE);\nreturn tm;\n}\n/**\n* Test that when the train arrives at a non scheduled station tile it stops,\n* drops off and picks up cargo, then continues\n*/\npublic void testStops2() {\n// Check that there two stations on the schedule: station0 and station2;\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nImmutableSchedule schedule = ta.getSchedule();\nassertEquals(2, schedule.getNumOrders());\nassertEquals(2, schedule.getOrder(0).getStationID());\n// Check the train should have 2 wagons for cargo #0\nImInts expectedConsist = new ImInts(0, 0);\nImInts actualConsist = ta.getTrain().getConsist();\nassertEquals(expectedConsist, actualConsist);\naddCargoAtStation(1, 800);\n// Move the train to just before station 1.\nPositionOnTrack pot;\nTrainMotion tm;\ndo {\ntm = moveTrain();\npot = tm.getFinalPosition();\n} while (pot.getX() < station1Location.x);\nassertEquals(station1Location.x, pot.getX());\nassertEquals(station1Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n// The next train motion should represent the stop at the station.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station1Location.x, pot.getX());\nassertEquals(station1Location.y, pot.getY());\nassertEquals(STOPPED_AT_STATION, tm.getActivity());\n// 80 Units of cargo should have been transferred to the train!\nCargoBundle onTrain = ta.getCargoBundle();\nint amount = onTrain.getAmount(0);\nassertEquals(80, amount);\n// Then the train should continue.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station1Location.x + 1, pot.getX());\nassertEquals(station1Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n}\n/** Adds the specified amount of cargo #0 to the specified station. */\nprivate void addCargoAtStation(int stationId, int amount) {\nCargoBatch cb = new CargoBatch(0, 6, 6, 0, stationId);\nMutableCargoBundle mb = new MutableCargoBundle();\nmb.addCargo(cb, amount);\nStationModel station1Model = (StationModel) world.get(principal, KEY.STATIONS, stationId);\nImmutableCargoBundle cargoAtStationBefore = mb.toImmutableCargoBundle();\nint station1BundleId = station1Model.getCargoBundleID();\nworld.set(principal, KEY.CARGO_BUNDLES, station1BundleId, cargoAtStationBefore);\n}\n/**\n* Test that when the train arrives at a scheduled station tile it stops,\n* updates its schedule and transfers cargo and starts moving again.\n*/\npublic void testStops3() {\n// Add cargo to station 2\naddCargoAtStation(2, 800);\n// Keep moving train until it reaches station 2\nPositionOnTrack pot;\nTrainMotion tm;\nint x;\ndo {\ntm = moveTrain();\npot = tm.getFinalPosition();\nx = pot.getX();\n} while (x < station2Location.x);\nassertEquals(station2Location.x, x);\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n// The train should be heading for station 1.\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nSchedule schedule1 = ta.getSchedule();\nassertEquals(0, schedule1.getOrderToGoto());\nassertEquals(2, schedule1.getStationToGoto());\nImPoint expectedTarget = new ImPoint(station2Location.x, station2Location.y);\nassertEquals(expectedTarget, ta.getTarget());\n// The next train motion should represent the stop at the station.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station2Location.x, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(STOPPED_AT_STATION, tm.getActivity());\n// The train should be heading for station 0.\nSchedule schedule2 = ta.getSchedule();\nassertFalse(schedule2.equals(schedule1));\nassertEquals(1, schedule2.getOrderToGoto());\nassertEquals(0, schedule2.getStationToGoto());\n// 80 Units of cargo should have been transferred to the train!\nCargoBundle onTrain = ta.getCargoBundle();\nint amount = onTrain.getAmount(0);\nassertEquals(80, amount);\n// Then the train should continue.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station2Location.x - 1, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n}\n/**\n* Test that when the train <b>is</b> scheduled to wait for full load, it\n* waits.\n*/\npublic void testStops5() {\nPositionOnTrack pot;\nTrainMotion tm;\nputTrainAtStationWaiting4FullLoad();\n// Add enough cargo to fill up the train.\naddCargoAtStation(2, 70);\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station2Location.x - 1, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n}\nprivate void putTrainAtStationWaiting4FullLoad() {\n// Set wait until full on schedule.\nImInts newConsist = new ImInts(0, 0);\nTrainOrdersModel order0 = new TrainOrdersModel(2, newConsist, true, false);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nMutableSchedule schedule = new MutableSchedule(ta.getSchedule());\nschedule.setOrder(0, order0);\nImmutableSchedule imSchedule = schedule.toImmutableSchedule();\nworld.set(principal, KEY.TRAIN_SCHEDULES, 0, imSchedule);\nassertEquals(0, ta.getSchedule().getOrderToGoto());\nassertTrue(ta.getSchedule().getOrder(0).waitUntilFull);\n// Add some cargo to station #2, but not enough to fill the train.\naddCargoAtStation(2, 20);\n// Move the train to just before station 2.\nPositionOnTrack pot;\nTrainMotion tm;\ndo {\ntm = moveTrain();\npot = tm.getFinalPosition();\n} while (pot.getX() < station2Location.x);\nassertEquals(station2Location.x, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n// The train should now stop at the station\n// and wait for a full load.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station2Location.y, pot.getY());\nassertEquals(WAITING_FOR_FULL_LOAD, tm.getActivity());\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nassertFalse(\"The train isn't full and there is no cargo to add, so we should be able to generate a move.\", preMove.isUpdateDue(world));\n}\n/** Test that a waiting train whose orders change behaves correctly. */\npublic void testStops6() {\nPositionOnTrack pot;\nTrainMotion tm;\nputTrainAtStationWaiting4FullLoad();\n// Now change the train's orders.\nImInts newConsist = new ImInts(0, 0);\nTrainOrdersModel order0 = new TrainOrdersModel(2, newConsist, false, false);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nMutableSchedule schedule = new MutableSchedule(ta.getSchedule());\nschedule.setOrder(0, order0);\nImmutableSchedule imSchedule = schedule.toImmutableSchedule();\nworld.set(principal, KEY.TRAIN_SCHEDULES, 0, imSchedule);\nassertEquals(0, ta.getSchedule().getOrderToGoto());\nassertFalse(ta.getSchedule().getOrder(0).waitUntilFull);\n// Then the train should continue.\ntm = moveTrain();\npot = tm.getFinalPosition();\nassertEquals(station2Location.x - 1, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\n}\n/** Tests that a train with 'select wagons automatically' enable behaves correctly.*/\npublic void ignoreTestAutoConsist(){\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\n//Remove all wagons from the train.\nTrainModel model = ta.getTrain();\nmodel = model.getNewInstance(model.getEngineType(), new ImInts());\nworld.set(principal, KEY.TRAINS, 0, model);\n//Change trains schedule to auto consist.\nTrainOrdersModel order0 = new TrainOrdersModel(1, null, false, true);\nTrainOrdersModel order1 = new TrainOrdersModel(2, null, false, true);\nMutableSchedule s = new MutableSchedule();\ns.addOrder(order0);\ns.addOrder(order1);\nworld.set(principal, KEY.TRAIN_SCHEDULES, 0, s.toImmutableSchedule());\nassertEquals(0, ta.getSchedule().getOrderToGoto());\n//Add 35 unit of cargo #0 to station 1.\nStationModel station0 = (StationModel)world.get(principal, KEY.STATIONS, 1);\nint cargoBundleId = station0.getCargoBundleID();\nMutableCargoBundle mcb = new MutableCargoBundle();\nfinal int AMOUNT_OF_CARGO = 35;\nmcb.addCargo(new CargoBatch(0, 0,0, 0, 0), AMOUNT_OF_CARGO);\nworld.set(principal, KEY.CARGO_BUNDLES, cargoBundleId, mcb.toImmutableCargoBundle());\n//Make station2 demand cargo #0;\nboolean[] boolArray = new boolean[world.size(SKEY.CARGO_TYPES)];\nboolArray[0] = true;\nDemand4Cargo demand = new Demand4Cargo(boolArray);\nStationModel station2 = (StationModel)world.get(principal, KEY.STATIONS, 2);\nStationModel stationWithNewDemand = new StationModel(station2, demand);\nworld.set(principal, KEY.STATIONS, 2, stationWithNewDemand);\n//The train should be bound for station 1.\nassertEquals(1, ta.getSchedule().getStationToGoto());\n//Make train call at station 1.\nPositionOnTrack pot;\nTrainMotion tm;\ndo {\ntm = moveTrain();\npot = tm.getFinalPosition();\n} while (pot.getX() < station1Location.x);\nassertEquals(station1Location.x, pot.getX());\nassertEquals(station1Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\ntm = moveTrain();\npot = tm.getFinalPosition();\n//The train should be bound for station 2.\nassertEquals(2, ta.getSchedule().getStationToGoto());\n//Check that the train has picked up the cargo.\n//The train should have one wagon of type #0\nassertEquals(new ImInts(0), ta.getTrain().getConsist());\nassertEquals(AMOUNT_OF_CARGO, ta.getCargoBundle().getAmount(0));\n}\npublic void testCanGenerateMove() {\nMoveTrainPreMove preMove = new MoveTrainPreMove(0, principal);\nassertTrue(preMove.isUpdateDue(world));\nMove m = preMove.generateMove(world);\nMoveStatus ms = m.doMove(world, principal);\nassertTrue(ms.message, ms.ok);\nassertFalse(preMove.isUpdateDue(world));\n}\nstatic void incrTime(World w, FreerailsPrincipal p) {\nActivityIterator ai = w.getActivities(p, 0);\nwhile (ai.hasNext())\nai.nextActivity();\ndouble finishTime = ai.getFinishTime();\nGameTime newTime = new GameTime((int) Math.floor(finishTime));\nw.setTime(newTime);\n}\n/**\n* Tests that when extra wagons are added, the TrainMotion lengthens to\n* accommodate them.\n*/\npublic void testLengtheningTrain() {\n// Set the train to add wagons at station2.\nImInts newConsist = new ImInts(0, 0, 0, 0, 0, 0);\nTrainOrdersModel order0 = new TrainOrdersModel(2, newConsist, false, false);\nTrainAccessor ta = new TrainAccessor(world, principal, 0);\nMutableSchedule schedule = new MutableSchedule(ta.getSchedule());\nschedule.setOrder(0, order0);\nImmutableSchedule imSchedule = schedule.toImmutableSchedule();\nworld.set(principal, KEY.TRAIN_SCHEDULES, 0, imSchedule);\nassertEquals(0, ta.getSchedule().getOrderToGoto());\n// Move the train to the station.\nPositionOnTrack pot;\nTrainMotion tm;\ndo {\ntm = moveTrain();\npot = tm.getFinalPosition();\n} while (pot.getX() < station2Location.x);\nassertEquals(station2Location.x, pot.getX());\nassertEquals(station2Location.y, pot.getY());\nassertEquals(READY, tm.getActivity());\nTrainModel train = ta.getTrain();\nassertEquals(2, train.getNumberOfWagons());\nassertTrue(tm.getInitialPosition() >= train.getLength());\ntm = moveTrain();\ntm = moveTrain();\ntrain = ta.getTrain();\nassertEquals(6, ta.getTrain().getNumberOfWagons());\nassertTrue(tm.getInitialPosition() >= train.getLength());\n}\n}"}
{"className":"jfreerails.controller.StationBuilderTest","javaDoc":"/**\n* A Junit test.\n*\n* @author Luke Lindsay\n*\n*\n*/","code":"/**\n* A Junit test.\n*\n* @author Luke Lindsay\n*\n*\n*/\npublic class StationBuilderTest extends TestCase {\nWorld w;\nTrackMoveProducer trackBuilder;\nStationBuilder stationBuilder;\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\nw = MapFixtureFactory2.getCopy();\nMoveExecutor me = new SimpleMoveExecutor(w, 0);\nModelRoot mr = new ModelRootImpl();\ntrackBuilder = new TrackMoveProducer(me, w, mr);\nstationBuilder = new StationBuilder(me);\n}\npublic void testCanBuiltStationHere() {\n}\npublic void testBuildStation() {\nstationBuilder\n.setStationType(stationBuilder.getTrackTypeID(\"terminal\"));\nStep[] track = { EAST, EAST, EAST };\nMoveStatus ms = trackBuilder.buildTrack(new ImPoint(10, 10), track);\nassertTrue(ms.ok);\nassertTrue(stationBuilder.tryBuildingStation(new ImPoint(10, 10)).ok);\nassertTrue(stationBuilder.tryBuildingStation(new ImPoint(13, 10)).ok);\nMoveStatus ms1 = stationBuilder.buildStation(new ImPoint(10, 10));\nassertTrue(ms1.ok);\nMoveStatus ms2 = stationBuilder.buildStation(new ImPoint(13, 10));\nassertFalse(ms2.ok);\n}\n}"}
{"className":"jfreerails.controller.SimpleAStarPathFinderTest","javaDoc":"/**\n* JUnit test for SimpleAStarPathFinder. 27-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* JUnit test for SimpleAStarPathFinder. 27-Nov-2002\n*\n* @author Luke Lindsay\n*\n*/\npublic class SimpleAStarPathFinderTest extends TestCase {\nprivate Map map;\nprivate SimpleAStarPathFinder pathFinder;\n/**\n* Constructor for SimpleAStarPathFinderTest.\n*\n* @param arg0\n*/\npublic SimpleAStarPathFinderTest(String arg0) {\nsuper(arg0);\n}\n@Override\nprotected void setUp() {\nthis.map = new Map();\npathFinder = new SimpleAStarPathFinder();\n}\npublic void testFindpath() {\nsetUp();\nint i = pathFinder.findstep(0, new int[] { 1 }, map);\nassertEquals(1, i);\ni = pathFinder.findstep(0, new int[] { 5 }, map);\nassertEquals(1, i);\ni = pathFinder.findstep(0, new int[] { 4 }, map);\nassertEquals(1, i);\ni = pathFinder.findstep(5, new int[] { 7 }, map);\nassertEquals(6, i);\ni = pathFinder.findstep(4, new int[] { 1 }, map);\nassertEquals(2, i);\ni = pathFinder.findstep(5, new int[] { 0, 7 }, map);\nassertEquals(6, i);\ni = pathFinder.findstep(5, new int[] { 4 }, map);\nassertEquals(2, i);\ni = pathFinder.findstep(4, new int[] { 4 }, map);\nassertEquals(IncrementalPathFinder.PATH_NOT_FOUND, i);\ni = pathFinder.findstep(2, new int[] { 1 }, map);\nassertEquals(1, i);\n}\npublic void testExplorer() {\nsetUp();\nassertEquals(0, map.getPosition());\nassertTrue(map.hasNextEdge());\nmap.nextEdge();\nassertTrue(!map.hasNextEdge());\nassertEquals(1, map.getVertexConnectedByEdge());\nassertEquals(11, map.getEdgeCost());\nmap.moveForward();\nassertEquals(1, map.getPosition());\nassertTrue(map.hasNextEdge());\nmap.nextEdge();\nassertEquals(0, map.getVertexConnectedByEdge());\n// now try jumping to a different position.\nmap.setPosition(2);\nassertEquals(2, map.getPosition());\nassertTrue(map.hasNextEdge());\nmap.nextEdge();\nassertEquals(5, map.getVertexConnectedByEdge());\n}\n}"}
{"className":"jfreerails.controller.Node","javaDoc":null,"code":"class Node {\nint[] edges;\nint[] distances;\nNode(int[] e, int[] d) {\nif (e.length != d.length) {\nthrow new IllegalArgumentException(\"e.length=\" + e.length\n+ \", e.length=\" + e.length);\n}\nedges = e;\ndistances = d;\n}\n}"}
{"className":"jfreerails.controller.Map","javaDoc":null,"code":"class Map implements GraphExplorer {\n// Look at SimpleAStarPathFinderTest.svg to see it\nprivate final Node[] nodes = new Node[] {\nnew Node(new int[] { 1 }, new int[] { 11 }), // 0\nnew Node(new int[] { 0, 5, 2 }, new int[] { 11, 4, 8 }), // 1 //\n// try\n// {11,4,4}\nnew Node(new int[] { 5, 3, 4, 1 }, new int[] { 5, 10, 12, 8 }), // 2\n// //try{5,10,12,4}\nnew Node(new int[] { 2 }, new int[] { 10 }), // 3\nnew Node(new int[] { 5, 2 }, new int[] { 18, 12 }), // 4\nnew Node(new int[] { 1, 6, 4, 2 }, new int[] { 4, 3, 18, 5 }), // 5\nnew Node(new int[] { 5, 7 }, new int[] { 3, 4 }), // 6\nnew Node(new int[] { 6 }, new int[] { 4 }), // 7\n};\nprivate int position = 0;\nprivate int branch = -1;\npublic void setPosition(int i) {\nthis.position = i;\nthis.branch = -1;\n}\npublic int getPosition() {\nreturn this.position;\n}\npublic void nextEdge() {\nif (hasNextEdge()) {\nbranch++;\n} else {\nthrow new NoSuchElementException();\n}\n}\npublic int getVertexConnectedByEdge() {\nreturn nodes[position].edges[branch];\n}\npublic int getEdgeCost() {\nreturn nodes[position].distances[branch];\n}\npublic boolean hasNextEdge() {\nif (nodes[position].edges.length > (branch + 1)) {\nreturn true;\n}\nreturn false;\n}\npublic void moveForward() {\nthis.setPosition(this.getVertexConnectedByEdge());\n}\npublic int getH() {\n// TODO Auto-generated method stub\nreturn 0;\n}\n}"}
{"className":"jfreerails.controller.DropOffAndPickupCargoMoveGeneratorTest","javaDoc":"/**\n* This Junit TestCase tests whether a train picks up and drops off the right\n* cargo at a station.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This Junit TestCase tests whether a train picks up and drops off the right\n* cargo at a station.\n*\n* @author Luke Lindsay\n*\n*/\npublic class DropOffAndPickupCargoMoveGeneratorTest extends TestCase {\nprivate World w;\nprivate final CargoBatch cargoType0FromStation2 = new CargoBatch(0, 0, 0,\n0, 2);\nprivate final CargoBatch cargoType1FromStation2 = new CargoBatch(1, 0, 0,\n0, 2);\nprivate final CargoBatch cargoType0FromStation0 = new CargoBatch(0, 0, 0,\n0, 0);\n@Override\nprotected void setUp() throws Exception {\n// Set up the world object with three cargo types, one station, and one\n// train.\nw = new WorldImpl();\nw.addPlayer(MapFixtureFactory.TEST_PLAYER);\n// set up the cargo types.\nw.add(SKEY.CARGO_TYPES, new CargoType(0, \"Mail\", Categories.Mail));\nw.add(SKEY.CARGO_TYPES, new CargoType(0, \"Passengers\",\nCategories.Passengers));\nw.add(SKEY.CARGO_TYPES, new CargoType(0, \"Goods\",\nCategories.Fast_Freight));\n// Set up station\nint x = 10;\nint y = 10;\nint stationCargoBundleId = w.add(MapFixtureFactory.TEST_PRINCIPAL,\nKEY.CARGO_BUNDLES,\nImmutableCargoBundle.EMPTY_BUNDLE);\nString stationName = \"Station 1\";\nStationModel station = new StationModel(x, y, stationName, w\n.size(SKEY.CARGO_TYPES), stationCargoBundleId);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, station);\n// Set up train\nint trainCargoBundleId = w.add(MapFixtureFactory.TEST_PRINCIPAL,\nKEY.CARGO_BUNDLES,\nImmutableCargoBundle.EMPTY_BUNDLE);\n// 3 wagons to carry cargo type 0.\nImInts wagons = new ImInts(0, 0, 0);\nTrainModel train = new TrainModel(wagons, trainCargoBundleId);\nw.add(MapFixtureFactory.TEST_PRINCIPAL, KEY.TRAINS, train);\n}\n/** Tests picking up cargo from a station. */\npublic void testPickUpCargo1() {\n// Set up the variables for this test.\nMutableCargoBundle cargoBundleWith2CarloadsOfCargo0 = new MutableCargoBundle();\n// cargoBundleWith2CarloadsOfCargo0.setAmount(cargoType0FromStation2,\n// 2);\ncargoBundleWith2CarloadsOfCargo0.setAmount(cargoType0FromStation2, 80);\nassertEquals(\"There shouldn't be any cargo at the station yet\",\nImmutableCargoBundle.EMPTY_BUNDLE, getCargoAtStation());\nassertEquals(\"There shouldn't be any cargo on the train yet\",\nImmutableCargoBundle.EMPTY_BUNDLE, getCargoOnTrain());\n// Now add 2 carloads of cargo type 0 to the station.\n// getCargoAtStation().setAmount(cargoType0FromStation2, 2);\nsetCargoAtStation(cargoType0FromStation2, 80);\n// The train should pick up this cargo, since it has three wagons\n// capable of carrying cargo type 0.\nstopAtStation();\n// The train should now have the two car loads of cargo and there should\n// be no cargo at the station.\nassertEquals(\"There should no longer be any cargo at the station\",\nImmutableCargoBundle.EMPTY_BUNDLE, getCargoAtStation());\nassertEquals(\"The train should now have the two car loads of cargo\",\ncargoBundleWith2CarloadsOfCargo0.toImmutableCargoBundle(),\ngetCargoOnTrain());\n}\n/**\n* Tests picking up cargo when the there is too much cargo at the station\n* for the train to carry.\n*/\npublic void testPickUpCargo2() {\nsetCargoAtStation(this.cargoType0FromStation2, 200);\nstopAtStation();\n// The train has 3 wagons, each wagon carries 40 units of cargo, so\n// the train should pickup 120 units of cargo.\nMutableCargoBundle expectedOnTrain = new MutableCargoBundle();\nexpectedOnTrain.setAmount(this.cargoType0FromStation2, 120);\n// The remaining 80 units of cargo should be left at the station.\nMutableCargoBundle expectedAtStation = new MutableCargoBundle();\nexpectedAtStation.setAmount(this.cargoType0FromStation2, 80);\n// Test the expected values against the actuals..\nassertEquals(expectedOnTrain.toImmutableCargoBundle(),\ngetCargoOnTrain());\nassertEquals(expectedAtStation.toImmutableCargoBundle(),\ngetCargoAtStation());\n}\n/**\n* Tests that a train takes into account how much cargo it already has and\n* the type of wagons it has when it is picking up cargo.\n*/\npublic void testPickUpCargo3() {\nImInts wagons = new ImInts(0, 0, 2, 2);\n// 2 wagons for cargo type 0; 2 wagons for cargo type 2.\naddWagons(wagons);\n// Set cargo on train.\nsetCargoOnTrain(this.cargoType0FromStation2, 30);\n// Set cargo at station.\nsetCargoAtStation(this.cargoType0FromStation0, 110);\n// Check that station does not demand cargo type 0.\nStationModel station = (StationModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\n0);\nassertFalse(station.getDemand().isCargoDemanded(0));\n// Stop at station.\nstopAtStation();\n/*\n* The train has 2 wagons for cargo type 0 but had 30 units of cargo\n* type 0 before stopping so it can only pick up 50 units.\n*/\nMutableCargoBundle expectedAtStation = new MutableCargoBundle();\nexpectedAtStation.setAmount(cargoType0FromStation0, 60);\nMutableCargoBundle expectedOnTrain = new MutableCargoBundle();\nexpectedOnTrain.setAmount(this.cargoType0FromStation2, 30);\nexpectedOnTrain.setAmount(this.cargoType0FromStation0, 50);\nassertEquals(expectedAtStation.toImmutableCargoBundle(),\ngetCargoAtStation());\nassertEquals(expectedOnTrain.toImmutableCargoBundle(),\ngetCargoOnTrain());\n}\n/**\n* Tests that a train drops of cargo that a station demands and does not\n* drop off cargo that is not demanded unless it has to.\n*/\npublic void testDropOffCargo() {\n// Set the station to demand cargo type 0.\nStationModel station = (StationModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\n0);\nDemand4Cargo demand = new Demand4Cargo(new boolean[] { true,\nfalse, false, false });\nstation = new StationModel(station, demand);\nw.set(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, 0, station);\n// Check that the station demands what we think it does.\nassertTrue(\"The station should demand cargo type 0.\", station\n.getDemand().isCargoDemanded(0));\nassertFalse(\"The station shouldn't demand cargo type 1.\", station\n.getDemand().isCargoDemanded(1));\n// Add 2 wagons for cargo type 0 and 1 for cargo type 1 to train.\nImInts wagons = new ImInts(0, 0, 1, 1);\naddWagons(wagons);\n// Add quantities of cargo type 0 and 2 to the train.\nsetCargoOnTrain(this.cargoType0FromStation2, 50);\nsetCargoOnTrain(this.cargoType1FromStation2, 40);\nstopAtStation();\n/*\n* The train should have dropped of the 50 units cargo of type 0 since\n* the station demands it but not the 40 units of cargo type 1 which is\n* does not demand.\n*/\nMutableCargoBundle expectedOnTrain = new MutableCargoBundle();\nexpectedOnTrain.setAmount(this.cargoType1FromStation2, 40);\nassertEquals(expectedOnTrain.toImmutableCargoBundle(),\ngetCargoOnTrain());\nassertEquals(ImmutableCargoBundle.EMPTY_BUNDLE, getCargoAtStation());\n// Now remove the wagons from the train.\nremoveAllWagonsFromTrain();\nstopAtStation();\n/*\n* This time the train has no wagons, so has to drop the 40 units of\n* cargo type 1 even though the station does not demand it. Since ths\n* station does not demand it, it is added to the cargo waiting at the\n* station.\n*/\nMutableCargoBundle expectedAtStation = new MutableCargoBundle();\nexpectedAtStation.setAmount(this.cargoType1FromStation2, 40);\nassertEquals(expectedAtStation.toImmutableCargoBundle(),\ngetCargoAtStation());\nassertEquals(ImmutableCargoBundle.EMPTY_BUNDLE, getCargoOnTrain());\n}\n/**\n* Tests that a train does not drop cargo off at its station of origin\n* unless it has to.\n*/\npublic void testDontDropOffCargo() {\n// Set station to\nsetCargoOnTrain(cargoType0FromStation0, 50);\nsetCargoOnTrain(cargoType0FromStation2, 50);\nstopAtStation();\n// The train shouldn't have dropped anything off.\nMutableCargoBundle expectedOnTrain = new MutableCargoBundle();\nexpectedOnTrain.setAmount(cargoType0FromStation0, 50);\nexpectedOnTrain.setAmount(cargoType0FromStation2, 50);\nassertEquals(expectedOnTrain.toImmutableCargoBundle(),\ngetCargoOnTrain());\nassertEquals(ImmutableCargoBundle.EMPTY_BUNDLE, getCargoAtStation());\n// Now remove the wagons from the train.\nremoveAllWagonsFromTrain();\nstopAtStation();\n/*\n* The train now has no wagons, so must drop off the cargo whether the\n* station demands it or not. Since the station does not demand it, the\n* cargo should get added to the cargo waiting at the station.\n*/\nMutableCargoBundle expectedAtStation = new MutableCargoBundle();\nexpectedAtStation.setAmount(cargoType0FromStation0, 50);\nexpectedAtStation.setAmount(cargoType0FromStation2, 50);\nassertEquals(expectedAtStation.toImmutableCargoBundle(),\ngetCargoAtStation());\nassertEquals(ImmutableCargoBundle.EMPTY_BUNDLE, getCargoOnTrain());\n}\n/**\n* Tests that a train drops off any cargo before picking up cargo.\n*/\npublic void testPickUpAndDropOffSameCargoType() {\n// Set cargo at station and on train.\nsetCargoOnTrain(this.cargoType0FromStation2, 120);\nsetCargoAtStation(this.cargoType0FromStation0, 200);\n// Set station to demand cargo 0.\nStationModel station = (StationModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\n0);\nDemand4Cargo demand = new Demand4Cargo(new boolean[] { true,\nfalse, false, false });\nstation = new StationModel(station, demand);\nw.set(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS, 0, station);\nassertTrue(station.getDemand().isCargoDemanded(0));\nstopAtStation();\nMutableCargoBundle expectedOnTrain = new MutableCargoBundle();\nexpectedOnTrain.setAmount(this.cargoType0FromStation0, 120);\nMutableCargoBundle expectedAtStation = new MutableCargoBundle();\nexpectedAtStation.setAmount(this.cargoType0FromStation0, 80);\nassertEquals(expectedOnTrain.toImmutableCargoBundle(),\ngetCargoOnTrain());\nassertEquals(expectedAtStation.toImmutableCargoBundle(),\ngetCargoAtStation());\n}\nprivate void removeAllWagonsFromTrain() {\naddWagons(new ImInts());\n}\nprivate void addWagons(ImInts wagons) {\nTrainModel train = (TrainModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.TRAINS,\n0);\nTrainModel newTrain = train.getNewInstance(train.getEngineType(),\nwagons);\nw.set(MapFixtureFactory.TEST_PRINCIPAL, KEY.TRAINS, 0, newTrain);\n}\nprivate void stopAtStation() {\nDropOffAndPickupCargoMoveGenerator moveGenerator = new DropOffAndPickupCargoMoveGenerator(\n0, 0, w, MapFixtureFactory.TEST_PRINCIPAL, false, false);\nMove m = moveGenerator.generateMove();\nif(null != m){\nMoveStatus ms = m.doMove(w, Player.AUTHORITATIVE);\nassertEquals(MoveStatus.MOVE_OK, ms);\n}\n}\n/**\n* Retrieves the cargo bundle that is waiting at the station from the world\n* object.\n*/\nprivate ImmutableCargoBundle getCargoAtStation() {\nStationModel station = (StationModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\n0);\nImmutableCargoBundle cargoAtStation = (ImmutableCargoBundle) w.get(\nMapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES,\nstation.getCargoBundleID());\nreturn cargoAtStation;\n}\n/**\n* Retrieves the cargo bundle that the train is carrying from the world\n* object.\n*/\nprivate ImmutableCargoBundle getCargoOnTrain() {\nTrainModel train = (TrainModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.TRAINS,\n0);\nImmutableCargoBundle cargoOnTrain = (ImmutableCargoBundle) w.get(\nMapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES,\ntrain.getCargoBundleID());\nreturn cargoOnTrain;\n}\nprivate void setCargoAtStation(CargoBatch cb, int amount) {\nStationModel station = (StationModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.STATIONS,\n0);\nMutableCargoBundle bundle = new MutableCargoBundle(getCargoAtStation());\nbundle.setAmount(cb, amount);\nw.set(MapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES, station.getCargoBundleID(), bundle\n.toImmutableCargoBundle());\n}\nprivate void setCargoOnTrain(CargoBatch cb, int amount) {\nTrainModel train = (TrainModel) w.get(MapFixtureFactory.TEST_PRINCIPAL, KEY.TRAINS,\n0);\nMutableCargoBundle bundle = new MutableCargoBundle(getCargoOnTrain());\nbundle.setAmount(cb, amount);\nw.set(MapFixtureFactory.TEST_PRINCIPAL, KEY.CARGO_BUNDLES, train.getCargoBundleID(), bundle\n.toImmutableCargoBundle());\n}\npublic static void main(java.lang.String[] args) {\njunit.textui.TestRunner.run(suite());\n}\nprivate static junit.framework.Test suite() {\njunit.framework.TestSuite testSuite = new junit.framework.TestSuite(\nDropOffAndPickupCargoMoveGeneratorTest.class);\nreturn testSuite;\n}\n}"}
{"className":"jfreerails.controller.TrackPathFinderTest","javaDoc":"/**\n* JUnit test for TrackPathFinder.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for TrackPathFinder.\n*\n* @author Luke\n*\n*/\npublic class TrackPathFinderTest extends TestCase {\nprivate WorldImpl world;\nprivate Player testPlayer = new Player(\"test\", 0);\n@Override\nprotected void setUp() throws Exception {\nworld = new WorldImpl(20, 20);\nworld.addPlayer(testPlayer);\nworld.set(ITEM.GAME_RULES, GameRules.NO_RESTRICTIONS);\nMapFixtureFactory.generateTrackRuleList(world);\n}\npublic void testGeneratePath() {\ntry {\nBuildTrackStrategy bts = BuildTrackStrategy.getSingleRuleInstance(\n0, world);\nTrackPathFinder pathFinder = new TrackPathFinder(world, testPlayer\n.getPrincipal());\nList l = pathFinder.generatePath(new ImPoint(0, 0), new ImPoint(0,\n5), bts);\nassertEquals(5, l.size());\nList list2 = pathFinder.generatePath(new ImPoint(5, 5),\nnew ImPoint(5, 10), bts);\nassertEquals(5, list2.size());\nlist2 = pathFinder.generatePath(new ImPoint(5, 10), new ImPoint(5,\n5), bts);\nassertEquals(5, list2.size());\n} catch (PathNotFoundException e) {\nfail();\n}\n}\n}"}
{"className":"jfreerails.controller.OpenListTest","javaDoc":null,"code":"public class OpenListTest extends TestCase {\npublic void testGetF() {\n}\npublic void testContains() {\nOpenList openList = new OpenList();\nassertFalse(openList.contains(0));\nopenList.add(0, 4);\nassertTrue(openList.contains(0));\nassertFalse(openList.contains(4));\nopenList.popNodeWithSmallestF();\nassertFalse(openList.contains(0));\n}\npublic void testSmallestF() {\nOpenList openList = new OpenList();\nopenList.add(0, 4);\nassertEquals(4, openList.smallestF());\nopenList.add(1, 5);\nassertEquals(4, openList.smallestF());\nopenList.add(5, 1);\nassertEquals(1, openList.smallestF());\nopenList.popNodeWithSmallestF();\nassertEquals(4, openList.smallestF());\nopenList.popNodeWithSmallestF();\nassertEquals(5, openList.smallestF());\n}\npublic void testSize() {\nOpenList openList = new OpenList();\nassertEquals(0, openList.size());\nopenList.add(0, 4);\nassertEquals(1, openList.size());\nopenList.popNodeWithSmallestF();\nassertEquals(0, openList.size());\n}\npublic void testAdd() {\nOpenList openList = new OpenList();\nopenList.add(1, 4);\nassertEquals(1, openList.size());\nassertEquals(4, openList.smallestF());\nopenList.add(1, 6);\nassertEquals(1, openList.size());\nassertEquals(6, openList.smallestF());\n}\n}"}
{"className":"jfreerails.controller.StockPriceCalculatorTest","javaDoc":null,"code":"public class StockPriceCalculatorTest extends TestCase {\nWorld w;\nStockPriceCalculator calc;\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\nw = MapFixtureFactory2.getCopy();\ncalc = new StockPriceCalculator(w);\n}\n/*\n* Test method for\n* 'jfreerails.controller.StockPriceCalculator.isFirstYear(int)'\n*/\npublic void testIsFirstYear() {\nassertTrue(calc.isFirstYear(0));\nGameCalendar calendar = (GameCalendar) w.get(ITEM.CALENDAR);\nint tpy = calendar.getTicksPerYear();\nint currentTicks = w.currentTime().getTicks();\nGameTime newTime = new GameTime(currentTicks + tpy + 1);\nw.setTime(newTime);\nassertFalse(calc.isFirstYear(0));\nnewTime = new GameTime(currentTicks + tpy - 1);\nw.setTime(newTime);\nassertTrue(calc.isFirstYear(0));\n}\n/*\n* Test method for\n* 'jfreerails.controller.StockPriceCalculator.netWorth(int)'\n*/\npublic void testNetWorth() {\nlong initialNetworth = 500000;\nassertEquals(initialNetworth, calc.netWorth(0));\nint currentTicks = w.currentTime().getTicks();\nGameTime newTime = new GameTime(currentTicks + 1);\nw.setTime(newTime);\nCargoBatch batch = new CargoBatch(0, 0, 0, 0, 0);\nlong income = 100000;\nTransaction t = new DeliverCargoReceipt(new Money(income), 10, 0,\nbatch, 0);\nFreerailsPrincipal princ = w.getPlayer(0).getPrincipal();\nw.addTransaction(princ, t);\nassertEquals(initialNetworth, calc.netWorth(0));\nGameCalendar calendar = (GameCalendar) w.get(ITEM.CALENDAR);\nint tpy = calendar.getTicksPerYear();\ncurrentTicks = w.currentTime().getTicks();\nnewTime = new GameTime(currentTicks + tpy);\nw.setTime(newTime);\nlong expectedNetWorth = initialNetworth + income;\nassertEquals(expectedNetWorth, calc.netWorth(0));\n}\nprivate void advanceTimeOneTick() {\nint currentTicks = w.currentTime().getTicks();\nGameTime newTime = new GameTime(currentTicks + 1);\nw.setTime(newTime);\n}\nprivate void advanceTimeOneYear() {\nGameCalendar calendar = (GameCalendar) w.get(ITEM.CALENDAR);\nint tpy = calendar.getTicksPerYear();\nint currentTicks = w.currentTime().getTicks();\nGameTime newTime = new GameTime(currentTicks + tpy);\nw.setTime(newTime);\n}\n/*\n* Test method for\n* 'jfreerails.controller.StockPriceCalculator.profitsLastYear(int)'\n*/\npublic void testProfitsLastYear() {\nassertEquals(0, calc.profitsLastYear(0));\nint currentTicks = w.currentTime().getTicks();\nGameTime newTime = new GameTime(currentTicks + 10);\nw.setTime(newTime);\nassertEquals(0, calc.profitsLastYear(0));\nlong income = 100000;\naddIncome(income);\nassertEquals(0, calc.profitsLastYear(0));\nadvanceTimeOneYear();\nassertEquals(income, calc.profitsLastYear(0));\n}\nprivate void addIncome(long income) {\nCargoBatch batch = new CargoBatch(0, 0, 0, 0, 0);\nTransaction t = new DeliverCargoReceipt(new Money(income), 10, 0,\nbatch, 0);\nFreerailsPrincipal princ = w.getPlayer(0).getPrincipal();\nw.addTransaction(princ, t);\n}\npublic void testCalculate() {\nMoney stockPrice = calc.calculate()[0].currentPrice;\nassertEquals(new Money(10), stockPrice);\nadvanceTimeOneTick();\naddIncome(100000);\ncalc.calculate();\nstockPrice = calc.calculate()[0].currentPrice;\nassertEquals(new Money(10), stockPrice);\nadvanceTimeOneYear();\ncalc.calculate();\nstockPrice = calc.calculate()[0].currentPrice;\nassertEquals(new Money(11), stockPrice);\n}\n}"}
{"className":"experimental.GenerateDependenciesXmlAndHtmlTest","javaDoc":"/**\n* JUnit test for GenerateDependenciesXmlAndHtml.\n*\n* @author Luke\n*\n*/","code":"/**\n* JUnit test for GenerateDependenciesXmlAndHtml.\n*\n* @author Luke\n*\n*/\npublic class GenerateDependenciesXmlAndHtmlTest extends TestCase {\npublic void testIsPackageNameOk() {\nassertTrue(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/*\"));\nassertFalse(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails.*\"));\nassertTrue(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/trees/*\"));\nassertFalse(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/trees/branches*\"));\nassertTrue(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/trees/branches/*\"));\nassertFalse(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/trees/branches/**/\"));\nassertTrue(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"jfreerails/trees/branches/**/*\"));\nassertTrue(GenerateDependenciesXmlAndHtml\n.isPackageNameOk(\"it/unimi/dsi/fastUtil/*\")); // note upper\n// case in\n// package name.\n}\n}"}
{"className":"jfreerails.world.common.PositionOnTrack","javaDoc":"/**\n* A <b>mutable</b> class that stores the coordinates of the tile on entity is\n* standing on and the direction in which the entity is facing (usually the\n* direction the entity as just been moving - the opposite to the direction it\n* came from), it provides methods to encode and decode its field values to and\n* from a single int.\n*\n* @author Luke\n*/","code":"/**\n* A <b>mutable</b> class that stores the coordinates of the tile on entity is\n* standing on and the direction in which the entity is facing (usually the\n* direction the entity as just been moving - the opposite to the direction it\n* came from), it provides methods to encode and decode its field values to and\n* from a single int.\n*\n* @author Luke\n*/\npublic final class PositionOnTrack implements FreerailsMutableSerializable {\nprivate static final int BITS_FOR_COORDINATE = 14;\nprivate static final int BITS_FOR_DIRECTION = 3;\npublic static final int MAX_COORDINATE = (1 << BITS_FOR_COORDINATE) - 1;\npublic static final int MAX_DIRECTION = (1 << BITS_FOR_DIRECTION) - 1;\nprivate static final long serialVersionUID = 3257853198755707184L;\npublic static PositionOnTrack createComingFrom(int x, int y, Step direction) {\nreturn new PositionOnTrack(x, y, direction);\n}\npublic static PositionOnTrack createFacing(int x, int y, Step direction) {\nreturn new PositionOnTrack(x, y, direction.getOpposite());\n}\npublic static PositionOnTrack[] fromInts(int[] ints) {\nPositionOnTrack[] returnValue = new PositionOnTrack[ints.length];\nfor (int i = 0; i < ints.length; i++) {\nPositionOnTrack p = new PositionOnTrack(ints[i]);\nreturnValue[i] = p;\n}\nreturn returnValue;\n}\npublic static int[] toInts(PositionOnTrack[] pos) {\nint[] returnValue = new int[pos.length];\nfor (int i = 0; i < pos.length; i++) {\nreturnValue[i] = pos[i].toInt();\n}\nreturn returnValue;\n}\n/** The direction from which we entered the tile. */\nprivate Step cameFrom = Step.NORTH;\nprivate int x = 0;\nprivate int y = 0;\npublic PositionOnTrack() {\n}\npublic PositionOnTrack(int i) {\nthis.setValuesFromInt(i);\n}\nprivate PositionOnTrack(int x, int y, Step direction) {\nif (x > MAX_COORDINATE || x < 0) {\nthrow new IllegalArgumentException(\"x=\" + x);\n}\nif (y > MAX_COORDINATE || y < 0) {\nthrow new IllegalArgumentException(\"y=\" + y);\n}\nthis.x = x;\nthis.y = y;\nthis.cameFrom = direction;\n}\n/**\n* @return The direction the entity came from.\n*/\npublic Step cameFrom() {\nreturn cameFrom;\n}\n@Override\npublic boolean equals(Object o) {\nif (null == o) {\nreturn false;\n}\nif (o instanceof PositionOnTrack) {\nPositionOnTrack other = (PositionOnTrack) o;\nif (other.cameFrom() == this.cameFrom()\n&& other.getX() == this.getX()\n&& other.getY() == this.getY()) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\n/**\n* @return The direction the entity is facing.\n*/\npublic Step facing() {\nreturn cameFrom.getOpposite();\n}\n/**\n* @return the position on the track which is in the opposite direction.\n*/\npublic PositionOnTrack getOpposite() {\nint newX = this.getX() - this.cameFrom.deltaX;\nint newY = this.getY() - this.cameFrom.deltaY;\nStep newDirection = this.cameFrom.getOpposite();\nreturn createComingFrom(newX, newY, newDirection);\n}\npublic int getX() {\nreturn x;\n}\npublic int getY() {\nreturn y;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = x;\nresult = 29 * result + y;\nresult = 29 * result + cameFrom.hashCode();\nreturn result;\n}\npublic void setCameFrom(Step v) {\nthis.cameFrom = v;\n}\npublic void setFacing(Step v) {\nthis.cameFrom = v.getOpposite();\n}\npublic void setValuesFromInt(int i) {\nx = i & MAX_COORDINATE;\nint shiftedY = i & (MAX_COORDINATE << BITS_FOR_COORDINATE);\ny = shiftedY >> BITS_FOR_COORDINATE;\nint shiftedDirection = i & (MAX_DIRECTION << (2 * BITS_FOR_COORDINATE));\nint directionAsInt = shiftedDirection >> (2 * BITS_FOR_COORDINATE);\ncameFrom = Step.getInstance(directionAsInt);\n}\npublic void setX(int x) {\nthis.x = x;\n}\npublic void setY(int y) {\nthis.y = y;\n}\npublic void move(Step step) {\nthis.x += step.deltaX;\nthis.y += step.deltaY;\nthis.cameFrom = step.getOpposite();\n}\n/**\n* @return an integer representing this PositionOnTrack object\n*/\npublic int toInt() {\nint i = x | (y << BITS_FOR_COORDINATE);\nint directionAsInt = cameFrom.getID();\nint shiftedDirection = (directionAsInt << (2 * BITS_FOR_COORDINATE));\ni = i | shiftedDirection;\nreturn i;\n}\npublic static int toInt(int x, int y) {\nint i = x | (y << BITS_FOR_COORDINATE);\nreturn i;\n}\n@Override\npublic String toString() {\nString s = \"PositionOnTrack: \" + x + \", \" + y + \" facing \"\n+ cameFrom.getOpposite().toString();\nreturn s;\n}\n}"}
{"className":"jfreerails.world.common.Step","javaDoc":"/**\n* This class represents a movement from a tile to any one of the surrounding\n* eight tiles.\n*\n* @author Luke\n*/","code":"/**\n* This class represents a movement from a tile to any one of the surrounding\n* eight tiles.\n*\n* @author Luke\n*/\n@jfreerails.util.InstanceControlled\nfinal public class Step implements FlatTrackTemplate {\nprivate static final long serialVersionUID = 3256444698640921912L;\npublic static final int TILE_DIAMETER = Constants.TILE_SIZE;\npublic static final double TILE_DIAGONAL = StrictMath.hypot(TILE_DIAMETER,\nTILE_DIAMETER);\n/** North. */\npublic static final Step NORTH;\n/** West. */\npublic static final Step WEST;\n/** South East. */\npublic static final Step SOUTH_EAST;\n/** North-East. */\npublic static final Step NORTH_EAST;\n/** East. */\npublic static final Step EAST;\n/** South. */\npublic static final Step SOUTH;\n/** South West. */\npublic static final Step SOUTH_WEST;\n/** North West. */\npublic static final Step NORTH_WEST;\n/**\n* A 3x3 array of OneTileMoveVectors, representing vectors to eight adjacent\n* tiles plus a zero-distance vector.\n*/\nprivate static final Step[][] vectors;\n/**\n* Another array of OneTileMoveVectors representing the 8 compass directions\n* going clockwise from North.\n*/\nprivate static Step[] list;\nstatic {\nvectors = setupVectors();\nNORTH = getInstance(0, -1);\nWEST = getInstance(-1, 0);\nSOUTH_EAST = getInstance(1, 1);\nNORTH_EAST = getInstance(1, -1);\nEAST = getInstance(1, 0);\nSOUTH = getInstance(0, 1);\nSOUTH_WEST = getInstance(-1, 1);\nNORTH_WEST = getInstance(-1, -1);\nlist = new Step[8];\nlist[0] = NORTH;\nlist[1] = NORTH_EAST;\nlist[2] = EAST;\nlist[3] = SOUTH_EAST;\nlist[4] = SOUTH;\nlist[5] = SOUTH_WEST;\nlist[6] = WEST;\nlist[7] = NORTH_WEST;\n}\nprivate static Step[][] setupVectors() {\nint t = 1;\nStep[][] tvectors = new Step[3][3];\nfor (int y = -1; y <= 1; y++) {\nfor (int x = -1; x <= 1; x++) {\nif ((0 != x) || (0 != y)) {\ntvectors[x + 1][y + 1] = new Step(x, y, t);\n}\nt = t << 1;\n}\n}\nreturn tvectors;\n}\npublic static ImPoint move(ImPoint p, Step... path) {\nint x = p.x;\nint y = p.y;\nfor (Step v : path) {\nx += v.deltaX;\ny += v.deltaY;\n}\nreturn new ImPoint(x, y);\n}\n/** The X and Y components of the vector. */\npublic final int deltaX;\n/** The X and Y components of the vector. */\npublic final int deltaY;\nprivate final int flatTrackTemplate;\nprivate final double length;\n/** Returns the X component of the vector. */\npublic int getDx() {\nreturn deltaX;\n}\n/** Returns the Y component of the vector. */\npublic int getDy() {\nreturn deltaY;\n}\n/**\n* Returns a new oneTileMoveVector whose direction is opposite to that the\n* current one.\n*\n* @return A oneTileMoveVector.\n*/\npublic Step getOpposite() {\nreturn getInstance(this.deltaX * -1, this.deltaY * -1);\n}\n/**\n* Returns the name of the vector. E.g. \"north-east\"\n*\n* @return the name.\n*/\n@Override\npublic String toString() {\nString name;\nswitch (deltaY) {\ncase 1:\nname = \" south\";\nbreak;\ncase -1:\nname = \" north\";\nbreak;\ndefault:\nname = \"\";\nbreak;\n}\nswitch (deltaX) {\ncase 1:\nname += \" east\";\nbreak;\ncase -1:\nname += \" west\";\nbreak;\ndefault:\nbreak;\n}\nreturn name;\n}\npublic String toAbrvString() {\nString name;\nswitch (deltaY) {\ncase 1:\nname = \"s\";\nbreak;\ncase -1:\nname = \"n\";\nbreak;\ndefault:\nname = \"\";\nbreak;\n}\nswitch (deltaX) {\ncase 1:\nname += \"e\";\nbreak;\ncase -1:\nname += \"w\";\nbreak;\ndefault:\nbreak;\n}\nreturn name;\n}\n/**\n* Create a new OneTileMoveVector. N.B Private constructor to enforce enum\n* property, use getInstance(x,y) instead. Pass values for delta X and Y:\n* they must be in the range -1 to 1 and cannot both be equal to 0.\n*\n* @param x\n* Tile coordinate.\n* @param y\n* Tile coordinate\n* @param t\n* an integer representing the track template this vector\n* corresponds to.\n*/\nprivate Step(int x, int y, int t) {\ndeltaX = x;\ndeltaY = y;\nflatTrackTemplate = t;\nlength = (x * y) == 0 ? TILE_DIAMETER : TILE_DIAGONAL;\n}\npublic static Step getInstance(int number) {\nreturn list[number];\n}\npublic static boolean checkValidity(ImPoint a, ImPoint b) {\nint dx = b.x - a.x;\nint dy = b.y - a.y;\nreturn checkValidity(dx, dy);\n}\npublic static Step getInstance(int dx, int dy) {\nif ((((dx < -1) || (dx > 1)) || ((dy < -1) || (dy > 1)))\n|| ((dx == 0) && (dy == 0))) {\nthrow new IllegalArgumentException(\ndx\n+ \" and \"\n+ dy\n+ \": The values passed both must be integers in the range -1 to 1, and not both equal 0.\");\n}\nreturn vectors[dx + 1][dy + 1];\n}\n/**\n* Returns true if the values passed could be used to create a valid vector.\n*/\npublic static boolean checkValidity(int x, int y) {\nif ((((x < -1) || (x > 1)) || ((y < -1) || (y > 1)))\n|| ((x == 0) && (y == 0))) {\nreturn false;\n}\nreturn true;\n}\npublic ImPoint createRelocatedPoint(ImPoint from) {\nreturn new ImPoint(from.x + deltaX, from.y + deltaY);\n}\npublic boolean contains(FlatTrackTemplate ftt) {\nif (ftt.get9bitTemplate() == this.flatTrackTemplate) {\nreturn true;\n}\nreturn false;\n}\npublic int get9bitTemplate() {\nreturn flatTrackTemplate;\n}\n/**\n* @return a copy of the list of 8 OneTileMoveVectors going clockwise from\n* North.\n*/\npublic static Step[] getList() {\nreturn list.clone(); // defensive copy.\n}\n/**\n* @return the length of this vector. Each tile is 100 units x 100 units.\n*/\npublic double getLength() {\nreturn length;\n}\n/**\n*\n* @return compass bearing in radians.\n*/\npublic double getDirection() {\nint i = 0;\nwhile (this != list[i]) {\ni++;\n}\nreturn 2 * Math.PI / 8 * i;\n}\n/**\n* @return a number representing the compass point this vector indicates,\n* with 0 representing North, 1 NorthEast, 2 East and so on.\n*/\npublic int getID() {\nint i = 0;\nwhile (this != list[i]) {\ni++;\n}\nreturn i;\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn Step.getInstance(this.deltaX, this.deltaY);\n}\n/**\n* @return the OneTileMoveVector nearest in orientation to the specified dx,\n* dy\n*/\npublic static Step getNearestVector(int dx, int dy) {\nif (0 == dx * dy) {\nif (dx > 0) {\nreturn EAST;\n} else if (dx != 0) {\nreturn WEST;\n} else if (dy > 0) {\nreturn SOUTH;\n} else {\nreturn NORTH;\n}\n}\ndouble gradient = dy;\ngradient = gradient / dx;\ndouble B = 2;\ndouble A = 0.5;\ndouble C = -2;\ndouble D = -0.5;\nif (gradient > B) {\nif (dy < 0) {\nreturn NORTH;\n}\nreturn SOUTH;\n} else if (gradient > A) {\nif (dy > 0) {\nreturn SOUTH_EAST;\n}\nreturn NORTH_WEST;\n} else if (gradient > D) {\nif (dx > 0) {\nreturn EAST;\n}\nreturn WEST;\n} else if (gradient > C) {\nif (dx < 0) {\nreturn SOUTH_WEST;\n}\nreturn NORTH_EAST;\n} else {\nif (dy > 0) {\nreturn SOUTH;\n}\nreturn NORTH;\n}\n}\npublic boolean isDiagonal() {\nreturn 0 != deltaX * deltaY;\n}\npublic int get8bitTemplate() {\nreturn 1 << this.getID();\n}\n}"}
{"className":"jfreerails.world.common.ImSet","javaDoc":"/**\n* An immutable set.\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable set.\n*\n* @author Luke\n*\n*/\n@Immutable\npublic final class ImSet<E extends FreerailsSerializable> implements\nFreerailsSerializable {\nprivate static final long serialVersionUID = -8075637749158447780L;\nprivate final HashSet<E> hashSet;\npublic ImSet(Set<E> data) {\nhashSet = new HashSet<E>(data);\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImSet))\nreturn false;\nfinal ImSet imSet = (ImSet) o;\nif (!hashSet.equals(imSet.hashSet))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn hashSet.hashCode();\n}\npublic boolean contains(E element) {\nreturn hashSet.contains(element);\n}\n}"}
{"className":"jfreerails.world.common.ImInts","javaDoc":"/**\n* An immutable list of ints.\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable list of ints.\n*\n* @author Luke\n*\n*/\n@Immutable\npublic class ImInts implements FreerailsSerializable {\nprivate static final long serialVersionUID = -7171552118713000676L;\nprivate final int ints[];\npublic ImInts(int... i) {\nthis.ints = i.clone();\n}\npublic static ImInts fromBoolean(boolean... i) {\nint[] ii = new int[i.length];\nfor (int j = 0; j < i.length; j++) {\nii[j] = i[j] ? 1 : 0;\n}\nreturn new ImInts(ii);\n}\npublic int size() {\nreturn ints.length;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImInts))\nreturn false;\nfinal ImInts other = (ImInts) o;\nif (!Arrays.equals(ints, other.ints))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn ints.length;\n}\npublic int get(int i) {\nreturn ints[i];\n}\npublic ImInts removeLast() {\nint[] newInts = new int[ints.length - 1];\nSystem.arraycopy(ints, 0, newInts, 0, newInts.length);\nreturn new ImInts(newInts);\n}\npublic ImInts append(int... extra) {\nint[] newInts = new int[ints.length + extra.length];\nSystem.arraycopy(ints, 0, newInts, 0, ints.length);\nSystem.arraycopy(extra, 0, newInts, ints.length, extra.length);\nreturn new ImInts(newInts);\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer(getClass().getName());\nsb.append(\"[\");\nfor (int i = 0; i < ints.length; i++) {\nsb.append(ints[i]);\nif (i + 1 < ints.length)\nsb.append(\", \");\n}\nsb.append(\"]\");\nreturn sb.toString();\n}\n/** Returns the sum of the ints stored in the list.*/\npublic int sum(){\nint sum = 0;\nfor (int i = 0; i < ints.length; i++) {\nsum+=ints[i];\n}\nreturn sum;\n}\n}"}
{"className":"jfreerails.world.common.ImList","javaDoc":"/**\n* An immutable List\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable List\n*\n* @author Luke\n*\n*/\n@Immutable\npublic final class ImList<E extends FreerailsSerializable> implements\nFreerailsSerializable {\nprivate static final long serialVersionUID = 2669191159273299313L;\nprivate final E[] elementData;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImList))\nreturn false;\nfinal ImList imList = (ImList) o;\nif (!Arrays.equals(elementData, imList.elementData))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn elementData.length;\n}\n@SuppressWarnings(\"unchecked\")\npublic ImList(E... items) {\nelementData = (E[]) new FreerailsSerializable[items.length];\nfor (int i = 0; i < items.length; i++) {\nelementData[i] = items[i];\n}\n}\n@SuppressWarnings(\"unchecked\")\npublic ImList(List<E> list) {\nelementData = (E[]) new FreerailsSerializable[list.size()];\nfor (int i = 0; i < list.size(); i++) {\nelementData[i] = list.get(i);\n}\n}\npublic void checkForNulls() throws NullPointerException {\nfor (int i = 0; i < elementData.length; i++) {\nif (null == elementData[i])\nthrow new NullPointerException();\n}\n}\npublic int size() {\nreturn elementData.length;\n}\npublic E get(int i) {\nreturn elementData[i];\n}\n}"}
{"className":"jfreerails.world.common.FreerailsPathIterator","javaDoc":"/**\n* This interface lets the caller retrieve a path made up of a series of\n* straight lines. E.g. it lets the path a train takes across a section of track\n* be retrieved without revealing the underlying objects that represent the\n* track.\n*\n* @author luke\n*/","code":"/**\n* This interface lets the caller retrieve a path made up of a series of\n* straight lines. E.g. it lets the path a train takes across a section of track\n* be retrieved without revealing the underlying objects that represent the\n* track.\n*\n* @author luke\n*/\npublic interface FreerailsPathIterator extends FreerailsMutableSerializable {\n/**\n* Tests whether the path has another segment.\n*/\nboolean hasNext();\n/**\n* Gets the next segment of the path and places its coordinates in the\n* specified IntLine; then moves the iterator forwards by one path segment.\n* (The coordinates are placed the passed-in IntLine rather than a new\n* object to avoid the cost of object creation.)\n*\n* @param line\n*/\nvoid nextSegment(IntLine line);\n}"}
{"className":"jfreerails.world.common.Activity","javaDoc":null,"code":"public interface Activity<E extends FreerailsSerializable> extends\nFreerailsSerializable {\ndouble duration();\nE getState(double dt);\n}"}
{"className":"jfreerails.world.common.FreerailsPathIteratorImpl","javaDoc":"/**\n* Lets the caller access a series of Points as a series of IntLines.\n*\n* @author Luke Lindsay\n*/","code":"/**\n* Lets the caller access a series of Points as a series of IntLines.\n*\n* @author Luke Lindsay\n*/\npublic class FreerailsPathIteratorImpl implements FreerailsPathIterator {\nprivate static final long serialVersionUID = 3258411750679720758L;\npublic static FreerailsPathIterator forwardsIterator(List<Point> l) {\nreturn new FreerailsPathIteratorImpl(l, true);\n}\npublic static FreerailsPathIterator backwardsIterator(List<Point> l) {\nreturn new FreerailsPathIteratorImpl(l, false);\n}\n/** Creates new FreerailsPathIteratorImpl */\npublic FreerailsPathIteratorImpl(List<Point> l, boolean f) {\npoints = l;\nforwards = f;\nif (forwards) {\nthis.position = 0;\n} else {\nthis.position = l.size() - 1; // The last element of a list of\n// size 7 is at position 6.\n}\n}\nprivate final boolean forwards;\nprivate int position;\nprivate final List<Point> points;\npublic boolean hasNext() {\nif (forwards) {\nreturn (position + 1) < points.size();\n}\nreturn (position - 1) >= 0;\n}\npublic void nextSegment(IntLine line) {\nif (hasNext()) {\nPoint a;\nPoint b;\nif (forwards) {\nposition++;\na = points.get(position - 1);\nb = points.get(position);\n} else {\nposition--;\na = points.get(position + 1);\nb = points.get(position);\n}\nline.x1 = a.x;\nline.y1 = a.y;\nline.x2 = b.x;\nline.y2 = b.y;\n} else {\nthrow new NoSuchElementException();\n}\n}\n}"}
{"className":"jfreerails.world.common.Money","javaDoc":"/**\n* Represents an amount of Money.\n*\n* @author Luke\n*/","code":"/**\n* Represents an amount of Money.\n*\n* @author Luke\n*/\nfinal public class Money implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3258697615163338805L;\npublic static final Money ZERO = new Money(0);\nprivate static final DecimalFormat df = new DecimalFormat(\"#,###\");\nprivate final long amount;\npublic long getAmount() {\nreturn amount;\n}\n@Override\npublic int hashCode() {\nreturn (int) (amount ^ (amount >>> 32));\n}\n@Override\npublic String toString() {\nreturn df.format(amount);\n}\npublic Money(long amount) {\nthis.amount = amount;\n}\npublic Money changeSign() {\nreturn new Money(-amount);\n}\n@Override\npublic boolean equals(Object obj) {\nif (obj instanceof Money) {\nMoney test = (Money) obj;\nreturn test.amount == this.amount;\n}\nreturn false;\n}\n}"}
{"className":"jfreerails.world.common.IntLine","javaDoc":"/**\n* This class defines a straight line between two points. Units are arbitrary.\n*\n* @author Luke\n*/","code":"/**\n* This class defines a straight line between two points. Units are arbitrary.\n*\n* @author Luke\n*/\npublic class IntLine implements Serializable {\nprivate static final long serialVersionUID = 3257853198755705393L;\nprivate final static int MAX_SQUAREROOTS = 64 * 256;\nprivate final static double squareRoots[];\nstatic {\nsquareRoots = new double[MAX_SQUAREROOTS];\nfor (int i = 0; i < MAX_SQUAREROOTS; i++) {\nsquareRoots[i] = Math.sqrt(i);\n}\n}\npublic int x1;\npublic int x2;\npublic int y1;\npublic int y2;\n@Override\npublic int hashCode() {\nint result;\nresult = x1;\nresult = 29 * result + x2;\nresult = 29 * result + y1;\nresult = 29 * result + y2;\nreturn result;\n}\n/**\n* @return the length of the line\n*/\npublic double getLength() {\nint sumOfSquares = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\nif(sumOfSquares < MAX_SQUAREROOTS) {\nreturn squareRoots[sumOfSquares];\n}\nreturn Math.sqrt(sumOfSquares);\n}\n/**\n* @param xx1\n* x of the first point\n* @param yy1\n* y of the first point\n* @param xx2\n* x of the second point\n* @param yy2\n* y of the second point\n*/\npublic IntLine(int xx1, int yy1, int xx2, int yy2) {\nx1 = xx1;\ny1 = yy1;\nx2 = xx2;\ny2 = yy2;\n}\n/**\n* Default constructor - defines a dot at 0,0.\n*/\npublic IntLine() {\n}\n@Override\npublic boolean equals(Object o) {\nif (null == o) {\nreturn false;\n}\nif (o == this) {\nreturn true;\n}\nif (o instanceof IntLine) {\nIntLine line = (IntLine) o;\nif (line.x1 == this.x1 && line.x2 == this.x2 && line.y1 == this.y1\n&& line.y2 == this.y2) {\nreturn true;\n}\nreturn false;\n}\nreturn false;\n}\n@Override\npublic String toString() {\nreturn \"(\" + x1 + \", \" + y1 + \", \" + x2 + \", \" + y2 + \")\";\n}\n}"}
{"className":"jfreerails.world.common.FreerailsMutableSerializable","javaDoc":"/**\n* This interface tags mutable serializable classes.\n*\n* @author Luke\n*/","code":"/**\n* This interface tags mutable serializable classes.\n*\n* @author Luke\n*/\npublic interface FreerailsMutableSerializable extends Serializable {\n}"}
{"className":"jfreerails.world.common.GameCalendar","javaDoc":"/**\n* This class converts time measured in ticks since the game began into time\n* represented as <i>Month, Year</i> and <i>hour:minute</i>.\n*\n* @author Luke\n*/","code":"/**\n* This class converts time measured in ticks since the game began into time\n* represented as <i>Month, Year</i> and <i>hour:minute</i>.\n*\n* @author Luke\n*/\nfinal public class GameCalendar implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257568421033226805L;\nprivate static final DecimalFormat decimalFormat = new DecimalFormat(\"00\");\nprivate final int ticksPerYear;\nprivate final int startYear;\n@Override\npublic int hashCode() {\nint result;\nresult = ticksPerYear;\nresult = 29 * result + startYear;\nreturn result;\n}\npublic GameTime getStartOfYear(GameTime t) {\nint year = getYear(t.getTicks());\nint ticks = getTicks(year);\nreturn new GameTime(ticks);\n}\npublic String getYearAsString(int ticks) {\nint i = getYear(ticks);\nreturn String.valueOf(i);\n}\npublic int getYear(int ticks) {\nreturn startYear + (ticks / ticksPerYear);\n}\npublic int getTicks(int year) {\nint deltaYear = year - startYear;\nreturn deltaYear * ticksPerYear;\n}\n/**\n* Returns the time of day as a string, note that a year is made up of a\n* representative day, so 1st June is equivalent to 12 noon.\n*/\npublic String getTimeOfDay(int i) {\nint ticksPerHour = ticksPerYear / 24;\nint hour = ticksPerHour == 0 ? 0 : (i % ticksPerYear) / ticksPerHour;\nint ticksPerMinute = ticksPerYear / (24 * 60);\nint minute = ticksPerMinute == 0 ? 0 : (i % (ticksPerMinute * 60));\nreturn decimalFormat.format(hour) + \":\" + decimalFormat.format(minute);\n}\npublic String getYearAndMonth(int i) {\nint month = getMonth(i);\nString monthAbrev = null;\nswitch (month) {\ncase 0: {\nmonthAbrev = \"Jan\";\nbreak;\n}\ncase 1: {\nmonthAbrev = \"Feb\";\nbreak;\n}\ncase 2: {\nmonthAbrev = \"Mar\";\nbreak;\n}\ncase 3: {\nmonthAbrev = \"Apr\";\nbreak;\n}\ncase 4: {\nmonthAbrev = \"May\";\nbreak;\n}\ncase 5: {\nmonthAbrev = \"Jun\";\nbreak;\n}\ncase 6: {\nmonthAbrev = \"Jul\";\nbreak;\n}\ncase 7: {\nmonthAbrev = \"Aug\";\nbreak;\n}\ncase 8: {\nmonthAbrev = \"Sep\";\nbreak;\n}\ncase 9: {\nmonthAbrev = \"Oct\";\nbreak;\n}\ncase 10: {\nmonthAbrev = \"Nov\";\nbreak;\n}\ncase 11: {\nmonthAbrev = \"Dec\";\nbreak;\n}\n}\nreturn monthAbrev + \" \" + getYearAsString(i);\n}\n/** Returns the month, 0=Jan, 1=Feb, etc. */\npublic int getMonth(int i) {\nint ticksPerMonth = ticksPerYear / 12;\nreturn (i % ticksPerYear) / ticksPerMonth;\n}\npublic GameCalendar(int ticksPerYear, int startYear) {\nthis.ticksPerYear = ticksPerYear;\nthis.startYear = startYear;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof GameCalendar) {\nGameCalendar test = (GameCalendar) o;\nif (this.startYear != test.startYear\n|| this.ticksPerYear != test.ticksPerYear) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}\npublic int getTicksPerYear() {\nreturn ticksPerYear;\n}\n}"}
{"className":"jfreerails.world.common.ActivityIterator","javaDoc":null,"code":"public interface ActivityIterator {\nboolean hasNext();\nvoid nextActivity() throws NoSuchElementException;\n/** Returns the time the current activity starts. */\ndouble getStartTime();\n/** Returns the time the current activity ends. */\ndouble getFinishTime();\ndouble getDuration();\n/**\n* Converts an absolute time value to a time value relative to the start of\n* the current activity. If absoluteTime > getFinishTime(), getDuration() is\n* returned.\n*/\ndouble absolute2relativeTime(double absoluteTime);\nFreerailsSerializable getState(double absoluteTime);\nActivity getActivity();\nvoid gotoLastActivity();\nvoid previousActivity() throws NoSuchElementException;\nboolean hasPrevious();\n}"}
{"className":"jfreerails.world.common.FlatTrackTemplate","javaDoc":"/**\n* Defines methods that encode a track configuration as an int.\n*\n* @author Luke\n*/","code":"/**\n* Defines methods that encode a track configuration as an int.\n*\n* @author Luke\n*/\npublic interface FlatTrackTemplate extends FreerailsSerializable {\n/**\n* @param ftt\n* the FlatTrackTemplate which may be a subset of this\n* FlatTrackTemplate.\n* @return true if the vectors represented by this FlatTrackTemplate are a\n* superset of the vectors of the specified FlatTrackTemplate\n*/\nboolean contains(FlatTrackTemplate ftt);\n/**\n* @return the integer representing the vector(s) of this object.\n*/\nint get9bitTemplate();\n}"}
{"className":"jfreerails.world.common.ImHashSet","javaDoc":null,"code":"@Immutable\npublic class ImHashSet<E extends FreerailsSerializable> implements\nFreerailsSerializable {\nprivate static final long serialVersionUID = -4098862905501171517L;\nprivate final HashSet<E> hashSet;\npublic ImHashSet(HashSet<E> hashSet) {\nthis.hashSet = new HashSet<E>(hashSet);\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImHashSet))\nreturn false;\nfinal ImHashSet imHashSet = (ImHashSet) o;\nif (!hashSet.equals(imHashSet.hashSet))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn hashSet.hashCode();\n}\npublic ImHashSet(E... values) {\nthis.hashSet = new HashSet<E>();\nfor (E e : values) {\nhashSet.add(e);\n}\n}\npublic ImHashSet(List<E> values) {\nthis.hashSet = new HashSet<E>();\nfor (E e : values) {\nhashSet.add(e);\n}\n}\npublic boolean contains(E e) {\nreturn hashSet.contains(e);\n}\npublic Iterator<E> iterator() {\nreturn new Iterator<E>() {\nIterator<E> it = hashSet.iterator();\npublic boolean hasNext() {\nreturn it.hasNext();\n}\npublic E next() {\nreturn it.next();\n}\npublic void remove() {\nthrow new UnsupportedOperationException();\n}\n};\n}\n}"}
{"className":"jfreerails.world.common.GameTime","javaDoc":"/**\n* This class represents a specific instant in time during a game.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents a specific instant in time during a game.\n*\n* @author Luke\n*\n*/\npublic class GameTime implements FreerailsSerializable, Comparable<GameTime> {\nprivate static final long serialVersionUID = 3691035461301055541L;\n/** The first possible time. */\npublic static final GameTime BIG_BANG = new GameTime(Integer.MIN_VALUE);\n/** The last possible time. */\npublic static final GameTime END_OF_THE_WORLD = new GameTime(\nInteger.MAX_VALUE);\nprivate final int ticks;\n@Override\npublic String toString() {\nreturn \"GameTime:\" + String.valueOf(ticks);\n}\n@Override\npublic int hashCode() {\nreturn ticks;\n}\npublic GameTime(int l) {\nthis.ticks = l;\n}\npublic GameTime nextTick() {\nreturn new GameTime(ticks + 1);\n}\npublic int getTicks() {\nreturn ticks;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof GameTime) {\nGameTime test = (GameTime) o;\nreturn this.ticks == test.ticks;\n}\nreturn false;\n}\n/**\n* Compares two GameTimes for ordering.\n*\n* @param t\n* @return 0 if t is equal to this GameTime; a value less than 0 if this\n* GameTime is before t; and a value greater than 0 if this GameTime\n* is after t.\n*/\npublic int compareTo(GameTime t) {\nreturn ticks - t.ticks;\n}\n}"}
{"className":"jfreerails.world.common.ImStringList","javaDoc":"/**\n* An immutable list of Strings.\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable list of Strings.\n*\n* @author Luke\n*\n*/\n@Immutable\npublic class ImStringList implements FreerailsSerializable {\nprivate static final long serialVersionUID = 5211786598838212188L;\nprivate final String[] strings;\npublic ImStringList(String... strings) {\nthis.strings = strings.clone();\n}\npublic String get(int i) {\nreturn strings[i];\n}\npublic int size() {\nreturn strings.length;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImStringList))\nreturn false;\nfinal ImStringList imStringList = (ImStringList) o;\nif (!Arrays.equals(strings, imStringList.strings))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn strings.length;\n}\n}"}
{"className":"jfreerails.world.common.GameSpeed","javaDoc":"/**\n* This class represents actual game speed. If the game speed <code>speed</code>\n* is lesser then zero, game is paused. After unpausing, the speed should be\n* <code>-speed</code>.\n*\n* I.e. pausing/unpausing is equal to multiply the speed by -1.\n*\n* @author MystiqueAgent\n*\n*/","code":"/**\n* This class represents actual game speed. If the game speed <code>speed</code>\n* is lesser then zero, game is paused. After unpausing, the speed should be\n* <code>-speed</code>.\n*\n* I.e. pausing/unpausing is equal to multiply the speed by -1.\n*\n* @author MystiqueAgent\n*\n*/\npublic class GameSpeed implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257562901983081783L;\nprivate final int speed;\n@Override\npublic String toString() {\nreturn \"GameSpeed:\" + String.valueOf(speed);\n}\npublic GameSpeed(int speed) {\nthis.speed = speed;\n}\npublic int getSpeed() {\nreturn speed;\n}\npublic boolean isPaused(){\nreturn speed < 1;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof GameSpeed) {\nGameSpeed test = (GameSpeed) o;\nreturn this.speed == test.speed;\n}\nreturn false;\n}\n@Override\npublic int hashCode() {\nreturn speed;\n}\n}"}
{"className":"jfreerails.world.common.FreerailsSerializable","javaDoc":"/**\n* This interface tags classes that can be sent between the client and the\n* server.\n*\n* <b>\n* <p>\n* Every class that implements this interface should be immutable. </b>\n*\n* @author Luke\n*/","code":"/**\n* This interface tags classes that can be sent between the client and the\n* server.\n*\n* <b>\n* <p>\n* Every class that implements this interface should be immutable. </b>\n*\n* @author Luke\n*/\npublic interface FreerailsSerializable extends Serializable {\n}"}
{"className":"jfreerails.world.common.ImPoint","javaDoc":"/**\n* An immutable point.\n*\n* @author Luke\n*\n*/","code":"/**\n* An immutable point.\n*\n* @author Luke\n*\n*/\n@Immutable\npublic final class ImPoint implements FreerailsSerializable, Comparable<ImPoint> {\nprivate static final long serialVersionUID = -3053020239886388576L;\npublic final int x, y;\npublic ImPoint() {\nx = 0;\ny = 0;\n}\npublic ImPoint(Point p) {\nx = p.x;\ny = p.y;\n}\npublic ImPoint(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof ImPoint))\nreturn false;\nfinal ImPoint imPoint = (ImPoint) o;\nif (x != imPoint.x)\nreturn false;\nif (y != imPoint.y)\nreturn false;\nreturn true;\n}\npublic Point toPoint() {\nreturn new Point(x, y);\n}\n@Override\npublic int hashCode() {\nreturn x * 1000 + y;\n}\n@Override\npublic String toString() {\nreturn \"ImPoint{\" + x + \", \" + y + \"}\";\n}\npublic int compareTo(ImPoint o) {\nif (o.y != y)\nreturn y - o.y;\nelse\nreturn x - o.x;\n}\n}"}
{"className":"jfreerails.world.player.PlayerPrincipal","javaDoc":"/**\n* FreerailsPrincipal that is a player in the game.\n*\n* @author rob\n*/","code":"/**\n* FreerailsPrincipal that is a player in the game.\n*\n* @author rob\n*/\npublic class PlayerPrincipal extends FreerailsPrincipal {\nprivate static final long serialVersionUID = 3257563997099537459L;\nprivate final int id;\nprivate final String name;\npublic PlayerPrincipal(int id, String name) {\nsuper(id);\nthis.id = id;\nthis.name = name;\n}\npublic String getName() {\nreturn name;\n}\n@Override\npublic int hashCode() {\nreturn id;\n}\n@Override\npublic String toString() {\nreturn \"Player \" + id;\n}\n/**\n* @return an integer unique to this PlayerPrincipal\n*/\npublic int getId() {\nreturn id;\n}\n@Override\npublic boolean equals(Object o) {\nif (!(o instanceof PlayerPrincipal)) {\nreturn false;\n}\nreturn id == ((PlayerPrincipal) o).id;\n}\n}"}
{"className":"jfreerails.world.player.Player","javaDoc":"/**\n* Represents a player within the game. The player model is such that a user can\n* start a client, create a new player on the server and start playing. They can\n* disconnect from the server, which may continue running with other players\n* still active. The server can then save the list of players and be stopped and\n* restarted again, the clients can then authenticate themselves to the server\n* and continue their sessions where they left off.\n*\n* XXX the player is only authenticated when the connection is opened, and\n* subsequent exchanges are not authenticated.\n*\n* TODO implement a more complete authentication system using certificates\n* rather than public keys.\n*\n* @author rtuck99@users.sourceforge.net\n*/","code":"/**\n* Represents a player within the game. The player model is such that a user can\n* start a client, create a new player on the server and start playing. They can\n* disconnect from the server, which may continue running with other players\n* still active. The server can then save the list of players and be stopped and\n* restarted again, the clients can then authenticate themselves to the server\n* and continue their sessions where they left off.\n*\n* XXX the player is only authenticated when the connection is opened, and\n* subsequent exchanges are not authenticated.\n*\n* TODO implement a more complete authentication system using certificates\n* rather than public keys.\n*\n* @author rtuck99@users.sourceforge.net\n*/\npublic class Player implements FreerailsSerializable {\nprivate static final long serialVersionUID = 1;\n/** A FreerailsPrincipal that is not a player. */\nprivate static class WorldPrincipal extends FreerailsPrincipal {\nprivate static final long serialVersionUID = 1;\nprivate final String principalName;\npublic WorldPrincipal(String name) {\nsuper(-1);\nthis.principalName = name;\n}\npublic String getName() {\nreturn principalName;\n}\n@Override\npublic String toString() {\nreturn principalName;\n}\n@Override\npublic int hashCode() {\nreturn principalName.hashCode();\n}\n@Override\npublic boolean equals(Object o) {\nif (!(o instanceof WorldPrincipal)) {\nreturn false;\n}\nreturn (principalName.equals(((WorldPrincipal) o).principalName));\n}\n}\nprivate FreerailsPrincipal principal;\n/**\n* This Principal can be granted all permissions.\n*/\npublic static final FreerailsPrincipal AUTHORITATIVE = new WorldPrincipal(\n\"Authoritative Server\");\n/**\n* This Principal has no permissions.\n*/\npublic static final FreerailsPrincipal NOBODY = new WorldPrincipal(\"Nobody\");\n/**\n* Name of the player.\n*/\nprivate final String name;\n/**\n* Used by the client to generate a player with a particular name.\n*/\npublic Player(String name) {\nthis.name = name;\nKeyPairGenerator kpg;\n/* generate our key pair */\ntry {\nkpg = KeyPairGenerator.getInstance(\"DSA\");\nkpg.initialize(1024);\n} catch (NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n}\n}\n/**\n* Used by the server to generate a player with a particular name and public\n* key.\n*\n*/\npublic Player(String name, int id) {\nthis.name = name;\n// this.publicKey = publicKey;\n// privateData = new PrivateData();\nthis.principal = new PlayerPrincipal(id, name);\n}\n@Override\npublic boolean equals(Object o) {\nif (o == null) {\nreturn false;\n}\nif (!(o instanceof Player)) {\nreturn false;\n}\n// return (name.equals(((Player) o).name) && keysEqual);\nreturn (name.equals(((Player) o).name));\n}\n@Override\npublic int hashCode() {\nreturn name.hashCode();\n}\n@Override\npublic String toString() {\nreturn name;\n}\npublic String getName() {\nreturn name;\n}\n/**\n* TODO save this player's private data so that they can be re-connected to\n* the server at a later point in time.\n*/\npublic void saveSession(ObjectOutputStream out) throws IOException {\n// out.writeObject(privateData);\n}\n/**\n* Called by the client to reconstitute the data from a saved game.\n*/\npublic void loadSession(ObjectInputStream in) throws IOException {\n// try {\n// privateData = (PrivateData) in.readObject();\n// } catch (ClassNotFoundException e) {\n// throw new IOException(\"Couldn't find class:\" + e);\n// }\n}\npublic FreerailsPrincipal getPrincipal() {\nreturn principal;\n}\n}"}
{"className":"jfreerails.world.player.FreerailsPrincipal","javaDoc":"/**\n* This interface identifies a principal. This interface may be extended in the\n* future in order to provide faster lookups, rather than using name\n* comparisons.\n*\n* A principal represents an entity which can view or alter the game world. A\n* principal usually corresponds to a player's identity, but may also represent\n* an authoritative server, or a another game entity such as a corporation.\n* All entities which may own game world objects must be represented by a\n* principal.\n*\n* @author rob\n*/","code":"/**\n* This interface identifies a principal. This interface may be extended in the\n* future in order to provide faster lookups, rather than using name\n* comparisons.\n*\n* A principal represents an entity which can view or alter the game world. A\n* principal usually corresponds to a player's identity, but may also represent\n* an authoritative server, or a another game entity such as a corporation.\n* All entities which may own game world objects must be represented by a\n* principal.\n*\n* @author rob\n*/\npublic abstract class FreerailsPrincipal implements Principal,\nFreerailsSerializable {\nprivate static final long serialVersionUID = -1689464560504992959L;\nprivate int worldIndex;\npublic FreerailsPrincipal(int worldIndex) {\nthis.worldIndex = worldIndex;\n}\n/**\n* returns -1 if it's not a player\n* @return the index in the world structures\n*/\npublic int getWorldIndex() {\nreturn worldIndex;\n}\n}"}
{"className":"jfreerails.world.station.Demand4Cargo","javaDoc":"/**\n* This class represents the demand for cargo at a station.\n*\n* @author Luke\n*/","code":"/**\n* This class represents the demand for cargo at a station.\n*\n* @author Luke\n*/\npublic class Demand4Cargo implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3257565088071038009L;\nprivate final ImInts demand;\npublic Demand4Cargo(boolean[] demandArray) {\ndemand = ImInts.fromBoolean(demandArray);\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof Demand4Cargo))\nreturn false;\nfinal Demand4Cargo demandAtStation = (Demand4Cargo) o;\nif (!demand.equals(demandAtStation.demand))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result = 0;\nfor (int i = 0; i < demand.size(); i++) {\nresult = 29 * result + demand.get(i);\n}\nreturn result;\n}\npublic boolean isCargoDemanded(int cargoNumber) {\nreturn demand.get(cargoNumber) == 1;\n}\n}"}
{"className":"jfreerails.world.station.PlannedTrain","javaDoc":"/**\n* This class represents the blue print for what an engine shop is producing.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents the blue print for what an engine shop is producing.\n*\n* @author Luke\n*\n*/\npublic class PlannedTrain implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3545515106038592057L;\nprivate final int engineType;\nprivate final ImInts wagonTypes;\npublic PlannedTrain(int e, int[] wagons) {\nengineType = e;\nwagonTypes = new ImInts(wagons);\n}\n@Override\npublic int hashCode() {\nreturn engineType;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof PlannedTrain))\nreturn false;\nfinal PlannedTrain productionAtEngineShop = (PlannedTrain) o;\nif (engineType != productionAtEngineShop.engineType)\nreturn false;\nif (!wagonTypes.equals(productionAtEngineShop.wagonTypes))\nreturn false;\nreturn true;\n}\npublic int getEngineType() {\nreturn engineType;\n}\npublic ImInts getWagonTypes() {\nreturn wagonTypes;\n}\n@Override\npublic String toString() {\nreturn \"engine type: \" + this.engineType + \", with \"\n+ wagonTypes.size() + \"wagons\";\n}\n}"}
{"className":"jfreerails.world.station.ConvertedAtStation","javaDoc":"/**\n* Records which cargos are converted to other cargos at a station.\n*\n* @author Luke\n*/","code":"/**\n* Records which cargos are converted to other cargos at a station.\n*\n* @author Luke\n*/\npublic class ConvertedAtStation implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3690754012076978231L;\nprivate static final int NOT_CONVERTED = Integer.MIN_VALUE;\nprivate final ImInts convertedTo;\npublic ConvertedAtStation(int[] convertedTo) {\nthis.convertedTo = new ImInts(convertedTo);\n}\npublic static ConvertedAtStation emptyInstance(int numberOfCargoTypes) {\nint[] convertedTo = emptyConversionArray(numberOfCargoTypes);\nreturn new ConvertedAtStation(convertedTo);\n}\npublic static int[] emptyConversionArray(int numberOfCargoTypes) {\nint[] convertedTo = new int[numberOfCargoTypes];\nfor (int i = 0; i < numberOfCargoTypes; i++) {\nconvertedTo[i] = NOT_CONVERTED;\n}\nreturn convertedTo;\n}\npublic boolean isCargoConverted(int cargoNumber) {\nif (NOT_CONVERTED == convertedTo.get(cargoNumber)) {\nreturn false;\n}\nreturn true;\n}\npublic int getConversion(int cargoNumber) {\nreturn convertedTo.get(cargoNumber);\n}\n@Override\npublic int hashCode() {\nint result = 0;\nfor (int i = 0; i < convertedTo.size(); i++) {\nresult = 29 * result + convertedTo.get(i);\n}\nreturn result;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof ConvertedAtStation) {\nConvertedAtStation test = (ConvertedAtStation) o;\nif (this.convertedTo.size() != test.convertedTo.size()) {\nreturn false;\n}\nfor (int i = 0; i < convertedTo.size(); i++) {\nif (convertedTo.get(i) != test.convertedTo.get(i)) {\nreturn false;\n}\n}\nreturn true;\n}\nreturn false;\n}\n}"}
{"className":"jfreerails.world.station.StationModel","javaDoc":"/**\n* This class represents a station.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents a station.\n*\n* @author Luke\n*\n*/\npublic class StationModel implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3256442503979874355L;\npublic final int x;\npublic final int y;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof StationModel))\nreturn false;\nfinal StationModel stationModel = (StationModel) o;\nif (cargoBundleNumber != stationModel.cargoBundleNumber)\nreturn false;\nif (x != stationModel.x)\nreturn false;\nif (y != stationModel.y)\nreturn false;\nif (converted != null ? !converted.equals(stationModel.converted)\n: stationModel.converted != null)\nreturn false;\nif (demand != null ? !demand.equals(stationModel.demand)\n: stationModel.demand != null)\nreturn false;\nif (!name.equals(stationModel.name))\nreturn false;\nif (production != null ? !production.equals(stationModel.production)\n: stationModel.production != null)\nreturn false;\nif (supply != null ? !supply.equals(stationModel.supply)\n: stationModel.supply != null)\nreturn false;\nreturn true;\n}\nprivate final String name;\nprivate final SupplyAtStation supply;\nprivate final Demand4Cargo demand;\nprivate final ConvertedAtStation converted;\nprivate final int cargoBundleNumber;\n/** What this station is building. */\nprivate final ImList<PlannedTrain> production;\npublic ConvertedAtStation getConverted() {\nreturn converted;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = x;\nresult = 29 * result + y;\nresult = 29 * result + (name != null ? name.hashCode() : 0);\nresult = 29 * result + (supply != null ? supply.hashCode() : 0);\nresult = 29 * result + (demand != null ? demand.hashCode() : 0);\nresult = 29 * result + (converted != null ? converted.hashCode() : 0);\nresult = 29 * result + cargoBundleNumber;\nresult = 29 * result + production.size();\nreturn result;\n}\npublic StationModel(StationModel s, ConvertedAtStation converted) {\nthis.converted = converted;\nthis.cargoBundleNumber = s.cargoBundleNumber;\nthis.demand = s.demand;\nthis.name = s.name;\nthis.production = s.production;\nthis.supply = s.supply;\nthis.x = s.x;\nthis.y = s.y;\n}\npublic StationModel(int x, int y, String stationName,\nint numberOfCargoTypes, int cargoBundle) {\nthis.name = stationName;\nthis.x = x;\nthis.y = y;\nproduction = new ImList<PlannedTrain>();\nsupply = new SupplyAtStation(new int[numberOfCargoTypes]);\ndemand = new Demand4Cargo(new boolean[numberOfCargoTypes]);\nconverted = ConvertedAtStation.emptyInstance(numberOfCargoTypes);\ncargoBundleNumber = cargoBundle;\n}\npublic StationModel() {\nthis.name = \"No name\";\nx = 0;\ny = 0;\nthis.demand = new Demand4Cargo(new boolean[0]);\nthis.supply = new SupplyAtStation(new int[0]);\nthis.converted = new ConvertedAtStation(new int[0]);\nproduction = new ImList<PlannedTrain>();\nthis.cargoBundleNumber = 0;\n}\npublic String getStationName() {\nreturn name;\n}\npublic int getStationX() {\nreturn x;\n}\npublic int getStationY() {\nreturn y;\n}\npublic ImPoint getLocation(){\nreturn new ImPoint(x, y);\n}\npublic ImList<PlannedTrain> getProduction() {\nreturn production;\n}\npublic StationModel(StationModel s, ImList<PlannedTrain> production) {\nthis.production = production;\nthis.demand = s.demand;\nthis.cargoBundleNumber = s.cargoBundleNumber;\nthis.converted = s.converted;\nthis.name = s.name;\nthis.supply = s.supply;\nthis.x = s.x;\nthis.y = s.y;\n}\npublic Demand4Cargo getDemand() {\nreturn demand;\n}\npublic SupplyAtStation getSupply() {\nreturn supply;\n}\npublic StationModel(StationModel s, Demand4Cargo demand) {\nthis.demand = demand;\nthis.cargoBundleNumber = s.cargoBundleNumber;\nthis.converted = s.converted;\nthis.name = s.name;\nthis.production = s.production;\nthis.supply = s.supply;\nthis.x = s.x;\nthis.y = s.y;\n}\npublic StationModel(StationModel s, SupplyAtStation supply) {\nthis.supply = supply;\nthis.demand = s.demand;\nthis.cargoBundleNumber = s.cargoBundleNumber;\nthis.converted = s.converted;\nthis.name = s.name;\nthis.production = s.production;\nthis.x = s.x;\nthis.y = s.y;\n}\npublic int getCargoBundleID() {\nreturn cargoBundleNumber;\n}\n}"}
{"className":"jfreerails.world.station.SupplyAtStation","javaDoc":"/**\n* This class represents the supply at a station.\n*\n* @author Luke\n*/","code":"/**\n* This class represents the supply at a station.\n*\n* @author Luke\n*/\npublic class SupplyAtStation implements FreerailsSerializable {\nprivate static final long serialVersionUID = 4049918272826847286L;\nprivate final ImInts supply;\npublic SupplyAtStation(int[] cargoWaiting) {\nsupply = new ImInts(cargoWaiting);\n}\n/**\n* Returns the number of car loads of the specified cargo that the station\n* supplies per year.\n*/\npublic int getSupply(int cargoType) {\nreturn supply.get(cargoType);\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof SupplyAtStation))\nreturn false;\nfinal SupplyAtStation supplyAtStation = (SupplyAtStation) o;\nif (!supply.equals(supplyAtStation.supply))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nreturn supply.hashCode();\n}\n}"}
{"className":"jfreerails.world.terrain.TerrainType","javaDoc":"/**\n* Defines the methods to access the properties of a type of terrains.\n*\n*\n* @author Luke\n*/","code":"/**\n* Defines the methods to access the properties of a type of terrains.\n*\n*\n* @author Luke\n*/\npublic interface TerrainType extends FreerailsSerializable {\nenum Category implements FreerailsSerializable {\nUrban, River, Ocean, Hill, Country, Special, Industry, Resource\n}\nString getTerrainTypeName();\nCategory getCategory();\nMoney getBuildCost();\nint getRightOfWay();\nint getRGB();\nImList<Production> getProduction();\nImList<Consumption> getConsumption();\nImList<Conversion> getConversion();\nString getDisplayName();\n}"}
{"className":"jfreerails.world.terrain.NullTerrainType","javaDoc":null,"code":"@InstanceControlled\npublic class NullTerrainType implements TerrainType {\npublic static final TerrainType INSTANCE = new NullTerrainType();\nprivate NullTerrainType() {\n}\nprivate static final long serialVersionUID = 3834874680581369912L;\npublic ImList<Production> getProduction() {\nreturn new ImList<Production>();\n}\npublic ImList<Consumption> getConsumption() {\nreturn new ImList<Consumption>();\n}\npublic ImList<Conversion> getConversion() {\nreturn new ImList<Conversion>();\n}\npublic String getTerrainTypeName() {\nreturn \"null\";\n}\npublic Category getCategory() {\nreturn Category.Country;\n}\npublic int getRGB() {\nreturn 0;\n}\npublic int getRightOfWay() {\nreturn 0;\n}\npublic String getDisplayName() {\nreturn \"\";\n}\nprivate Object readResolve() throws ObjectStreamException {\nreturn INSTANCE;\n}\npublic Money getBuildCost() {\nreturn new Money(0);\n}\n}"}
{"className":"jfreerails.world.terrain.CityModel","javaDoc":"/**\n* A city.\n*\n* @author Luke\n*/","code":"/**\n* A city.\n*\n* @author Luke\n*/\npublic class CityModel implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3256720697500709428L;\nprivate final String name;\nprivate final int x;\nprivate final int y;\npublic CityModel(String s, int xx, int yy) {\nname = s;\nx = xx;\ny = yy;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof CityModel))\nreturn false;\nfinal CityModel cityModel = (CityModel) o;\nif (x != cityModel.x)\nreturn false;\nif (y != cityModel.y)\nreturn false;\nif (!name.equals(cityModel.name))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = name.hashCode();\nresult = 29 * result + x;\nresult = 29 * result + y;\nreturn result;\n}\npublic String getCityName() {\nreturn name;\n}\npublic int getCityX() {\nreturn x;\n}\npublic int getCityY() {\nreturn y;\n}\npublic ImPoint getLocation(){\nreturn new ImPoint(x, y);\n}\n@Override\npublic String toString() {\nreturn name+\" \"+x+\", \"+y;\n}\n}"}
{"className":"jfreerails.world.terrain.TerrainTile","javaDoc":"/**\n* Defines the interface of a terrain tile.\n*\n* @author Luke\n*/","code":"/**\n* Defines the interface of a terrain tile.\n*\n* @author Luke\n*/\npublic interface TerrainTile extends FreerailsSerializable {\nint getTerrainTypeID();\n}"}
{"className":"jfreerails.world.terrain.Consumption","javaDoc":"/**\n* This class represents the demand for a certain cargo for consumption.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents the demand for a certain cargo for consumption.\n*\n* @author Luke\n*\n*/\npublic class Consumption implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3258133565631051064L;\nprivate final int cargoType;\n/**\n* The number of tiles that must be within the station radius before the\n* station demands the cargo.\n*/\nprivate final int prerequisite;\npublic Consumption(int ct, int pq) {\ncargoType = ct;\nprerequisite = pq; // default value.\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof Consumption))\nreturn false;\nfinal Consumption consumption = (Consumption) o;\nif (cargoType != consumption.cargoType)\nreturn false;\nif (prerequisite != consumption.prerequisite)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = cargoType;\nresult = 29 * result + prerequisite;\nreturn result;\n}\npublic int getCargoType() {\nreturn cargoType;\n}\npublic int getPrerequisite() {\nreturn prerequisite;\n}\n}"}
{"className":"jfreerails.world.terrain.Conversion","javaDoc":"/**\n* This class represents the conversion of one cargo type to another one a tile.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents the conversion of one cargo type to another one a tile.\n*\n* @author Luke\n*\n*/\npublic class Conversion implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3546356219414853689L;\nprivate final int input;\nprivate final int output;\npublic Conversion(int in, int out) {\ninput = in;\noutput = out;\n}\npublic int getInput() {\nreturn input;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof Conversion))\nreturn false;\nfinal Conversion conversion = (Conversion) o;\nif (input != conversion.input)\nreturn false;\nif (output != conversion.output)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = input;\nresult = 29 * result + output;\nreturn result;\n}\npublic int getOutput() {\nreturn output;\n}\n}"}
{"className":"jfreerails.world.terrain.Production","javaDoc":"/**\n* This class represents the production of a raw material on a tile.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class represents the production of a raw material on a tile.\n*\n* @author Luke\n*\n*/\npublic class Production implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3258125847641536052L;\nprivate final int cargoType;\n/** The number of units per year (40 units = 1 car load). */\nprivate final int rate;\npublic Production(int type, int r) {\ncargoType = type;\nrate = r;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof Production))\nreturn false;\nfinal Production production = (Production) o;\nif (cargoType != production.cargoType)\nreturn false;\nif (rate != production.rate)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = cargoType;\nresult = 29 * result + rate;\nreturn result;\n}\npublic int getCargoType() {\nreturn cargoType;\n}\npublic int getRate() {\nreturn rate;\n}\n}"}
{"className":"jfreerails.world.terrain.TileTypeImpl","javaDoc":"/**\n* Represents a type of terrain.\n*\n* @author Luke Lindsay 16 August 2001\n*/","code":"/**\n* Represents a type of terrain.\n*\n* @author Luke Lindsay 16 August 2001\n*/\nfinal public class TileTypeImpl implements TerrainType {\nprivate static final long serialVersionUID = 4049919380945253945L;\nprivate final ImList<Consumption> consumption;\nprivate final ImList<Conversion> conversion;\nprivate final ImList<Production> production;\nprivate final int rgb;\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TileTypeImpl))\nreturn false;\nfinal TileTypeImpl tileType = (TileTypeImpl) o;\nif (rgb != tileType.rgb)\nreturn false;\nif (rightOfWay != tileType.rightOfWay)\nreturn false;\nif (!consumption.equals(tileType.consumption))\nreturn false;\nif (!conversion.equals(tileType.conversion))\nreturn false;\nif (!production.equals(tileType.production))\nreturn false;\nif (!terrainCategory.equals(tileType.terrainCategory))\nreturn false;\nif (!terrainType.equals(tileType.terrainType))\nreturn false;\nif (tileBuildCost != null ? !tileBuildCost\n.equals(tileType.tileBuildCost)\n: tileType.tileBuildCost != null)\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = consumption.hashCode();\nresult = 29 * result + conversion.hashCode();\nresult = 29 * result + production.hashCode();\nresult = 29 * result + rgb;\nresult = 29 * result + rightOfWay;\nresult = 29 * result + terrainCategory.hashCode();\nresult = 29 * result + terrainType.hashCode();\nresult = 29 * result\n+ (tileBuildCost != null ? tileBuildCost.hashCode() : 0);\nreturn result;\n}\nprivate final int rightOfWay;\nprivate final TerrainType.Category terrainCategory;\nprivate final String terrainType;\n/**\n* Cost to build a tile of this terrain type or null if this type is not\n* buildable.\n*/\nprivate final Money tileBuildCost;\npublic TileTypeImpl(int rgb, TerrainType.Category terrainCategory,\nString terrainType, int rightOfWay, Production[] production,\nConsumption[] consumption, Conversion[] conversion,\nint tileBuildCost) {\nthis.terrainType = terrainType;\nthis.terrainCategory = terrainCategory;\nthis.rgb = rgb;\nthis.rightOfWay = rightOfWay;\nthis.production = new ImList<Production>(production);\nthis.consumption = new ImList<Consumption>(consumption);\nthis.conversion = new ImList<Conversion>(conversion);\nif (tileBuildCost > 0) {\nthis.tileBuildCost = new Money(tileBuildCost);\n} else {\nthis.tileBuildCost = null;\n}\n}\n/**\n* Lets unit tests create terrain types without bothering with all the\n* details.\n*/\npublic TileTypeImpl(TerrainType.Category terrainCategory, String terrainType) {\nthis.terrainType = terrainType;\nthis.terrainCategory = terrainCategory;\nthis.rgb = 0;\nthis.rightOfWay = 0;\nthis.production = new ImList<Production>();\nthis.consumption = new ImList<Consumption>();\nthis.conversion = new ImList<Conversion>();\nthis.tileBuildCost = null;\n}\npublic Money getBuildCost() {\nreturn tileBuildCost;\n}\npublic Category getCategory() {\nreturn terrainCategory;\n}\npublic ImList<Consumption> getConsumption() {\nreturn consumption;\n}\npublic ImList<Conversion> getConversion() {\nreturn conversion;\n}\n/** Returns the name, replacing any underscores with spaces. */\npublic String getDisplayName() {\nreturn terrainType.replace('_', ' ');\n}\npublic ImList<Production> getProduction() {\nreturn production;\n}\n/**\n* @return The RGB value mapped to this terrain type.\n*/\npublic int getRGB() {\nreturn rgb;\n}\npublic int getRightOfWay() {\nreturn rightOfWay;\n}\npublic String getTerrainTypeName() {\nreturn terrainType;\n}\n}"}
{"className":"jfreerails.world.accounts.BondTransaction","javaDoc":"/**\n* A Transaction that adds or removes a Bond.\n*\n* @author Luke\n*\n*/","code":"/**\n* A Transaction that adds or removes a Bond.\n*\n* @author Luke\n*\n*/\npublic class BondTransaction extends AddItemTransaction {\nprivate static final long serialVersionUID = 3257562923491473465L;\npublic static final Money BOND_VALUE_ISSUE = new Money(500000);\npublic static final Money BOND_VALUE_REPAY = new Money(-500000);\nprivate BondTransaction(Category category, int type, int quantity,\nMoney amount) {\nsuper(category, type, quantity, amount);\n}\npublic static BondTransaction issueBond(int interestRate) {\nreturn new BondTransaction(Category.BOND, interestRate, 1,\nBOND_VALUE_ISSUE);\n}\npublic static BondTransaction repayBond(int interestRate) {\nreturn new BondTransaction(Category.BOND, interestRate, -1,\nBOND_VALUE_REPAY);\n}\n}"}
{"className":"jfreerails.world.accounts.Receipt","javaDoc":"/**\n* A credit.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* A credit.\n*\n* @author Luke Lindsay\n*\n*/\npublic class Receipt implements Transaction {\nprivate static final long serialVersionUID = 3617576007066924596L;\nprivate final Money amount;\nprivate final Category category;\npublic Receipt(Money m, Category category) {\nthis.amount = m;\nthis.category = category;\n}\npublic Money deltaAssets() {\nreturn amount.changeSign();\n}\npublic Money deltaCash() {\nreturn amount;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof Receipt) {\nReceipt test = (Receipt) o;\nreturn test.amount.equals(amount) && category == test.category;\n}\nreturn false;\n}\npublic Category getCategory() {\nreturn category;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = amount.hashCode();\nresult = 29 * result + category.hashCode();\nreturn result;\n}\n}"}
{"className":"jfreerails.world.accounts.AddItemTransaction","javaDoc":"/**\n* This Transaction represents the charge/credit for buying/selling an item.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* This Transaction represents the charge/credit for buying/selling an item.\n*\n* @author Luke Lindsay\n*\n*/\npublic class AddItemTransaction implements Transaction {\nprivate static final long serialVersionUID = 3690471411852326457L;\nprivate final Money amount;\n/** For example track. */\nprivate final Category category;\n/** For example, 4 tiles. */\nprivate final int quantity;\n/** For example, standard track. */\nprivate final int type;\npublic AddItemTransaction(Category category, int type, int quantity,\nMoney amount) {\nthis.category = category;\nthis.type = type;\nthis.quantity = quantity;\nthis.amount = amount;\n}\npublic Money deltaAssets() {\nreturn amount.changeSign();\n}\npublic Money deltaCash() {\nreturn amount;\n}\n@Override\npublic boolean equals(Object obj) {\nif (obj instanceof AddItemTransaction) {\nAddItemTransaction test = (AddItemTransaction) obj;\nreturn this.amount.equals(test.amount) && category == test.category\n&& type == test.type && quantity == test.quantity;\n}\nreturn false;\n}\npublic Category getCategory() {\nreturn category;\n}\npublic int getQuantity() {\nreturn quantity;\n}\npublic int getType() {\nreturn type;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = category.hashCode();\nresult = 29 * result + type;\nresult = 29 * result + quantity;\nresult = 29 * result + amount.hashCode();\nreturn result;\n}\n@Override\npublic String toString() {\nStringBuffer sb = new StringBuffer();\nsb.append(\"AddItemTransaction \");\nsb.append(category);\nsb.append(\", type \");\nsb.append(type);\nsb.append(\", quantity \");\nsb.append(quantity);\nsb.append(\", amount \");\nsb.append(amount);\nreturn sb.toString();\n}\n}"}
{"className":"jfreerails.world.accounts.EconomicClimate","javaDoc":"/**\n* Represents the state of the economy.\n*\n* @author Luke\n*\n*/","code":"/**\n* Represents the state of the economy.\n*\n* @author Luke\n*\n*/\npublic class EconomicClimate implements FreerailsSerializable {\nprivate static final long serialVersionUID = 3834025840475321136L;\nprivate static int i = 2;\nprivate final String name;\npublic static final EconomicClimate BOOM = new EconomicClimate(i++, \"BOOM\");\npublic static final EconomicClimate PROSPERITY = new EconomicClimate(i++,\n\"PROSPERITY\");\npublic static final EconomicClimate MODERATION = new EconomicClimate(i++,\n\"MODERATION\");\npublic static final EconomicClimate RECESSION = new EconomicClimate(i++,\n\"RECESSION\");\npublic static final EconomicClimate PANIC = new EconomicClimate(i++,\n\"PANIC\");\npublic int getBaseInterestRate() {\nreturn baseInterestRate;\n}\nprivate final int baseInterestRate;\n@Override\npublic boolean equals(Object o) {\nif (this == o) {\nreturn true;\n}\nif (!(o instanceof EconomicClimate)) {\nreturn false;\n}\nfinal EconomicClimate economicClimate = (EconomicClimate) o;\nif (baseInterestRate != economicClimate.baseInterestRate) {\nreturn false;\n}\nif (name != null ? !name.equals(economicClimate.name)\n: economicClimate.name != null) {\nreturn false;\n}\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = (name != null ? name.hashCode() : 0);\nresult = 29 * result + baseInterestRate;\nreturn result;\n}\nprivate EconomicClimate(int r, String s) {\nbaseInterestRate = r;\nname = s;\n}\n}"}
{"className":"jfreerails.world.accounts.TransactionAndTimeStamp","javaDoc":null,"code":"public class TransactionAndTimeStamp implements FreerailsSerializable {\nprivate static final long serialVersionUID = 1540065347606694456L;\nprivate final Transaction t;\nprivate final GameTime timeStamp;\npublic TransactionAndTimeStamp(Transaction t, GameTime stamp) {\nthis.t = t;\ntimeStamp = stamp;\n}\n@Override\npublic boolean equals(Object o) {\nif (this == o)\nreturn true;\nif (!(o instanceof TransactionAndTimeStamp))\nreturn false;\nfinal TransactionAndTimeStamp transactionAndTimeStamp = (TransactionAndTimeStamp) o;\nif (!t.equals(transactionAndTimeStamp.t))\nreturn false;\nif (!timeStamp.equals(transactionAndTimeStamp.timeStamp))\nreturn false;\nreturn true;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = t.hashCode();\nresult = 29 * result + timeStamp.hashCode();\nreturn result;\n}\npublic Transaction getT() {\nreturn t;\n}\npublic GameTime getTimeStamp() {\nreturn timeStamp;\n}\n}"}
{"className":"jfreerails.world.accounts.StockTransaction","javaDoc":"/**\n* A transaction that occurs when a new company is founded or when a company\n* issues additional shares.\n*\n* @author Luke\n* @author smackay\n*/","code":"/**\n* A transaction that occurs when a new company is founded or when a company\n* issues additional shares.\n*\n* @author Luke\n* @author smackay\n*/\npublic class StockTransaction extends AddItemTransaction {\nprivate static final long serialVersionUID = 3256441412924224824L;\npublic static final int STOCK_BUNDLE_SIZE = 10000;\nprivate StockTransaction(Category category, int playerId, int quantity,\nMoney amount) {\nsuper(category, playerId, quantity, amount);\nif (playerId < 0)\nthrow new IllegalArgumentException();\n}\npublic static StockTransaction issueStock(int playerId, int quantity,\nMoney pricePerShare) {\n// Issue Stock of the Player\nlong temp = (pricePerShare.getAmount() * quantity);\ntemp = temp - temp - temp;\nMoney amount = new Money(temp).changeSign();\nreturn new StockTransaction(Transaction.Category.ISSUE_STOCK, playerId,\nquantity, amount);\n}\npublic static StockTransaction buyOrSellStock(int playerId, int quantity,\nMoney stockPrice) {\n// Buys another Players Stock, Uses another Category\nMoney value = new Money(stockPrice.getAmount() * quantity * -1);\nreturn new StockTransaction(Transaction.Category.TRANSFER_STOCK,\nplayerId, quantity, value);\n}\npublic static StockTransaction issueStock(int quantity, long pricePerShare) {\nMoney amount = new Money(pricePerShare * quantity);\nreturn new StockTransaction(quantity, amount);\n}\nprivate StockTransaction(int quantity, Money amount) {\nsuper(Transaction.Category.ISSUE_STOCK, -1, quantity, amount);\n}\n}"}
{"className":"jfreerails.world.accounts.Transaction","javaDoc":"/**\n* A Transaction is a change in a player's bank balance and/or assets.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* A Transaction is a change in a player's bank balance and/or assets.\n*\n* @author Luke Lindsay\n*\n*/\npublic interface Transaction extends FreerailsSerializable {\npublic enum Category {\nBOND, BRIDGES, CARGO_DELIVERY, INDUSTRIES, INTEREST_CHARGE, ISSUE_STOCK, MISC_INCOME, STATION_MAINTENANCE, STATIONS, TRACK, TRACK_MAINTENANCE, TRAIN, TRAIN_MAINTENANCE, TRANSFER_STOCK\n}\nMoney deltaAssets();\n/** Positive means credit. */\nMoney deltaCash();\nCategory getCategory();\n}"}
{"className":"jfreerails.world.accounts.Bill","javaDoc":"/**\n* For example, the cost of buying a trains.\n*\n* @author Luke Lindsay\n*\n*/","code":"/**\n* For example, the cost of buying a trains.\n*\n* @author Luke Lindsay\n*\n*/\npublic class Bill implements Transaction {\nprivate static final long serialVersionUID = 3258416144497782835L;\nprivate final Money amount;\nprivate final Category category;\npublic Bill(Money amount, Category category) {\nthis.amount = new Money(-amount.getAmount());\nthis.category = category;\n}\npublic Money deltaAssets() {\nreturn amount.changeSign();\n}\npublic Money deltaCash() {\nreturn amount;\n}\n@Override\npublic boolean equals(Object o) {\nif (o instanceof Bill) {\nBill test = (Bill) o;\nreturn test.amount.equals(amount) && category == test.category;\n}\nreturn false;\n}\npublic Category getCategory() {\nreturn category;\n}\n@Override\npublic int hashCode() {\nint result;\nresult = amount.hashCode();\nresult = 29 * result + category.hashCode();\nreturn result;\n}\n}"}
{"className":"jfreerails.world.accounts.DeliverCargoReceipt","javaDoc":"/**\n* A credit for delivering cargo.\n*\n* @author Luke\n*\n*/","code":"/**\n* A credit for delivering cargo.\n*\n* @author Luke\n*\n*/\npublic class DeliverCargoReceipt extends Receipt {\nprivate static final long serialVersionUID = 3257009851963160372L;\nprivate final CargoBatch cb;\nprivate final int quantity;\nprivate final int stationId;\nprivate final int trainId;\npublic DeliverCargoReceipt(Money m, int quantity, int stationId,\nCargoBatch cb, int trainId) {\nsuper(m, Category.CARGO_DELIVERY);\nthis.stationId = stationId;\nthis.quantity = quantity;\nthis.cb = cb;\nthis.trainId = trainId;\n}\npublic int getTrainId() {\nreturn trainId;\n}\npublic CargoBatch getCb() {\nreturn cb;\n}\npublic int getQuantity() {\nreturn quantity;\n}\npublic int getStationId() {\nreturn stationId;\n}\n}"}
{"className":"jfreerails.client.top.GameLoop","javaDoc":"/**\n* This thread updates the GUI Client window.\n*\n* @author Luke\n*/","code":"/**\n* This thread updates the GUI Client window.\n*\n* @author Luke\n*/\nfinal public class GameLoop implements Runnable {\nprivate static final Logger logger = Logger.getLogger(GameLoop.class\n.getName());\nprivate final static boolean LIMIT_FRAME_RATE = false;\nprivate boolean gameNotDone = false;\nprivate final ScreenHandler screenHandler;\nprivate final static int TARGET_FPS = 40;\nprivate FPScounter fPScounter;\nprivate long frameStartTime;\nprivate final GameModel[] model;\nprivate final Integer loopMonitor = new Integer(0);\npublic GameLoop(ScreenHandler s) {\nscreenHandler = s;\nmodel = new GameModel[0];\n}\npublic GameLoop(ScreenHandler s, GameModel[] gm) {\nscreenHandler = s;\nmodel = gm;\nif (null == model) {\nthrow new NullPointerException();\n}\n}\npublic void run() {\ntry {\nSynchronizedEventQueue.use();\nRepaintManagerForActiveRendering.addJFrame(screenHandler.frame);\nRepaintManagerForActiveRendering.setAsCurrentManager();\nif (!screenHandler.isInUse()) {\nscreenHandler.apply();\n}\ngameNotDone = true;\nfPScounter = new FPScounter();\n/*\n* Reduce this threads priority to avoid starvation of the input\n* thread on Windows.\n*/\ntry {\nThread.currentThread().setPriority(Thread.NORM_PRIORITY - 1);\n} catch (SecurityException e) {\nlogger.warning(\"Couldn't lower priority of redraw thread\");\n}\nwhile (true) {\n// stats.record();\nframeStartTime = System.currentTimeMillis();\n/*\n* Flush all redraws in the underlying toolkit. This reduces X11\n* lag when there isn't much happening, but is expensive under\n* Windows\n*/\nToolkit.getDefaultToolkit().sync();\nsynchronized (SynchronizedEventQueue.MUTEX) {\nif (!gameNotDone) {\nSynchronizedEventQueue.MUTEX.notify();\nbreak;\n}\nfor (int i = 0; i < model.length; i++) {\nmodel[i].update();\n}\nif (!screenHandler.isMinimised()) {\nif (screenHandler.isInUse()) {\nboolean contentsRestored = false;\ndo {\nGraphics g = screenHandler.getDrawGraphics();\ntry {\nscreenHandler.frame.paintComponents(g);\nboolean showFps = Boolean\n.parseBoolean(System\n.getProperty(\"SHOWFPS\"));\nif (showFps) {\nfPScounter.drawFPS((Graphics2D) g);\n}\n} catch (RuntimeException re) {\n/*\n* We are not expecting a RuntimeException\n* here. If something goes wrong, lets kill\n* the game straight away to avoid\n* hard-to-track-down bugs.\n*/\nReportBugTextGenerator\n.unexpectedException(re);\n} finally {\ng.dispose();\n}\ncontentsRestored = screenHandler\n.contentsRestored();\n} while (contentsRestored);\nscreenHandler.swapScreens();\nfPScounter.updateFPSCounter();\n}\n}\n}\nif (screenHandler.isMinimised()) {\ntry {\n// The window is minimised so we don't need to keep\n// updating.\nThread.sleep(200);\n} catch (Exception e) {\n// do nothing.\n}\n} else if (LIMIT_FRAME_RATE) {\nlong deltatime = System.currentTimeMillis()\n- frameStartTime;\nwhile (deltatime < (1000 / TARGET_FPS)) {\ntry {\nlong sleeptime = (1000 / TARGET_FPS) - deltatime;\nThread.sleep(sleeptime);\n} catch (Exception e) {\ne.printStackTrace();\n}\ndeltatime = System.currentTimeMillis() - frameStartTime;\n}\n}\n// remove all events from a event queue (max 5ms)\nlong startEventWaitTime = System.currentTimeMillis() + 4;\nwhile (SynchronizedEventQueue.getInstance().peekEvent() != null) {\n// we have events\nThread.yield();\nif (startEventWaitTime < System.currentTimeMillis()) {\nbreak;\n}\n}\n}\n/* signal that we are done */\nsynchronized (loopMonitor) {\nloopMonitor.notify();\n}\n} catch (Exception e) {\nReportBugTextGenerator.unexpectedException(e);\n}\n}\n}"}
{"className":"jfreerails.client.top.UserMessageGenerator","javaDoc":"/**\n* This class inspects incoming moves and generates a user message if\n* appropriate. It is also used to trigger sounds.\n*\n* @author Luke\n*\n*/","code":"/**\n* This class inspects incoming moves and generates a user message if\n* appropriate. It is also used to trigger sounds.\n*\n* @author Luke\n*\n*/\npublic class UserMessageGenerator implements MoveReceiver {\nprivate ModelRoot modelRoot;\nprivate ActionRoot actionRoot;\nprivate final DecimalFormat formatter = new DecimalFormat(\"#,###,###\");\nprivate SoundManager soundManager = SoundManager.getSoundManager();\npublic UserMessageGenerator(ModelRoot mr, ActionRoot actionRoot) {\nif (null == mr || null == actionRoot) {\nthrow new NullPointerException();\n}\nthis.actionRoot = actionRoot;\nthis.modelRoot = mr;\n}\npublic void processMove(Move move) {\nif (move instanceof CompositeMove) {\nImList<Move> moves = ((CompositeMove) move).getMoves();\nfor (int i = 0; i < moves.size(); i++) {\nprocessMove(moves.get(i));\n}\n}\nif (move instanceof WorldDiffMove) {\nWorldDiffMove wdm = (WorldDiffMove) move;\nif (wdm.getCause().equals(WorldDiffMove.Cause.TrainArrives)) {\ntrainArrives(wdm);\n}\n} else if (move instanceof ChangeGameSpeedMove) {\nlogSpeed();\n}\n}\n/** Generates a message giving details of any cargo delivered and plays\n* a cash register sound to indicate that revenue is coming in.\n*/\nprivate void trainArrives(WorldDiffMove wdm) {\nArrayList<DeliverCargoReceipt> cargoDelivered = new ArrayList<DeliverCargoReceipt>();\nCompositeMove listChanges = wdm.getListChanges();\nfor (int i = 0; i < listChanges.size(); i++) {\nMove m = listChanges.getMoves().get(i);\nif (m instanceof AddTransactionMove) {\nAddTransactionMove atm = (AddTransactionMove) m;\nif(!atm.getPrincipal().equals(modelRoot.getPrincipal())){\n//We don't want to know about other players' income!\nreturn;\n}\nTransaction t = atm.getTransaction();\nif (t instanceof DeliverCargoReceipt) {\nDeliverCargoReceipt receipt = (DeliverCargoReceipt) t;\ncargoDelivered.add(receipt);\n}\n}\n}\nif (cargoDelivered.size() > 0) {\nReadOnlyWorld world = modelRoot.getWorld();\nStringBuffer message = new StringBuffer();\nDeliverCargoReceipt first = cargoDelivered.get(0);\nint stationId = first.getStationId();\nint trainId = first.getTrainId();\nmessage.append(\"Train #\");\nmessage.append(trainId + 1); // So that the first train\n// is #1, not #0.\nmessage.append(\" arrives at \");\nStationModel station = (StationModel) world.get(modelRoot\n.getPrincipal(), KEY.STATIONS, stationId);\nmessage.append(station.getStationName());\nmessage.append(\"\\n\");\nlong revenue = 0;\nint[] cargoQuantities = new int[modelRoot.getWorld().size(\nSKEY.CARGO_TYPES)];\nfor (DeliverCargoReceipt receipt : cargoDelivered) {\nCargoBatch batch = receipt.getCb();\nrevenue += receipt.deltaCash().getAmount();\ncargoQuantities[batch.getCargoType()] = receipt\n.getQuantity();\n}\nfor (int i = 0; i < cargoQuantities.length; i++) {\nint j = cargoQuantities[i];\nif (j > 0) {\nCargoType cargoType = (CargoType) world.get(\nSKEY.CARGO_TYPES, i);\nmessage.append(j);\nmessage.append(\" \");\nmessage.append(cargoType.getDisplayName());\nmessage.append(\"\\n\");\n}\n}\nmessage.append(\"Revenue $\");\nmessage.append(formatter.format(revenue));\nmodelRoot.setProperty(Property.QUICK_MESSAGE, message\n.toString());\n// Play the sound of cash coming in. The greater the\n// revenue,\n// the more loops of the sample we play.\nint loops = (int) revenue / 4000;\ntry {\nsoundManager.playSound(\n\"/jfreerails/client/sounds/cash.wav\", loops);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}\npublic void logSpeed() {\nReadOnlyWorld world = modelRoot.getWorld();\nGameSpeed speed = ((GameSpeed) world.get(ITEM.GAME_SPEED));\nint gameSpeed = speed.getSpeed();\nif (gameSpeed <= 0) {\nmodelRoot\n.setProperty(Property.PERMANENT_MESSAGE, \"Game is paused.\");\n/*\n* Also hide any other message. It looks silly if it says \"Game is\n* paused.\" and \"Game speed: fast\" on screen at the same time!\n*/\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"\");\n} else {\nmodelRoot.setProperty(Property.PERMANENT_MESSAGE, null);\nString gameSpeedDesc = actionRoot.getServerControls()\n.getGameSpeedDesc(gameSpeed);\nmodelRoot.setProperty(Property.QUICK_MESSAGE, \"Game speed: \"\n+ gameSpeedDesc);\n}\n}\n}"}
{"className":"jfreerails.client.top.StationTypesPopup","javaDoc":"/**\n* This JPopupMenu displays the list of station types that are available and\n* builds the type that is selected.\n*\n* @author Luke Lindsay 08-Nov-2002\n*\n*/","code":"/**\n* This JPopupMenu displays the list of station types that are available and\n* builds the type that is selected.\n*\n* @author Luke Lindsay 08-Nov-2002\n*\n*/\npublic class StationTypesPopup extends JPopupMenu {\nprivate static final long serialVersionUID = 3258415040658093364L;\nprivate Point tileToBuildStationOn;\nprivate StationRadiusRenderer stationRadiusRenderer;\nprivate PopupMenuListener popupMenuListener;\nprivate StationBuildModel stationBuildModel;\nprivate ModelRoot modelRoot;\npublic StationTypesPopup() {\n}\npublic boolean canBuiltStationHere(Point p) {\nstationBuildModel.getStationBuildAction().putValue(\nStationBuildModel.StationBuildAction.STATION_POSITION_KEY, p);\nFreerailsTile tile = (FreerailsTile) modelRoot.getWorld().getTile(p.x,\np.y);\nreturn tile.hasTrack();\n}\nprivate class StationBuildMenuItem extends JMenuItem {\nprivate static final long serialVersionUID = 3256721792751120946L;\n@Override\npublic void configurePropertiesFromAction(Action a) {\nsuper.configurePropertiesFromAction(a);\n}\n}\npublic void setup(ModelRoot mr, ActionRoot actionRoot,\nStationRadiusRenderer srr) {\nmodelRoot = mr;\nstationBuildModel = actionRoot.getStationBuildModel();\nstationRadiusRenderer = srr;\nthis.removeAll();\nthis.removePopupMenuListener(popupMenuListener);\npopupMenuListener = new PopupMenuListener() {\npublic void popupMenuCanceled(PopupMenuEvent e) {\n}\npublic void popupMenuWillBecomeInvisible(PopupMenuEvent e) {\nstationRadiusRenderer.hide();\nstationBuildModel.getStationCancelAction().actionPerformed(\nnew ActionEvent(StationTypesPopup.this,\nActionEvent.ACTION_PERFORMED, \"\"));\n}\npublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\nstationRadiusRenderer.setPosition(tileToBuildStationOn.x,\ntileToBuildStationOn.y);\nstationBuildModel\n.getStationBuildAction()\n.putValue(\nStationBuildModel.StationBuildAction.STATION_POSITION_KEY,\ntileToBuildStationOn);\n}\n};\nthis.addPopupMenuListener(popupMenuListener);\nfinal Action[] stationChooseActions = stationBuildModel\n.getStationChooseActions();\nfor (int i = 0; i < stationChooseActions.length; i++) {\nfinal StationBuildMenuItem rbMenuItem = new StationBuildMenuItem();\nfinal int index = i;\nrbMenuItem.configurePropertiesFromAction(stationChooseActions[i]);\nrbMenuItem.setIcon(null);\n// Show the relevant station radius when the station type's\n// menu item gets focus.\nrbMenuItem.addChangeListener(new ChangeListener() {\nprivate boolean armed = false;\npublic void stateChanged(ChangeEvent e) {\nif (rbMenuItem.isArmed() && (rbMenuItem.isArmed() != armed)) {\nstationChooseActions[index]\n.actionPerformed(new ActionEvent(rbMenuItem,\nActionEvent.ACTION_PERFORMED, \"\"));\n}\narmed = rbMenuItem.isArmed();\n}\n});\nrbMenuItem.addActionListener(stationBuildModel\n.getStationBuildAction());\nadd(rbMenuItem);\n}\nstationBuildModel.getStationBuildAction().addPropertyChangeListener(\nnew PropertyChangeListener() {\npublic void propertyChange(PropertyChangeEvent e) {\nif (e\n.getPropertyName()\n.equals(\nStationBuildModel.StationBuildAction.STATION_RADIUS_KEY)) {\nint newRadius = ((Integer) e.getNewValue())\n.intValue();\nstationRadiusRenderer.setRadius(newRadius);\n}\nif (stationBuildModel.getStationBuildAction()\n.isEnabled()) {\nstationRadiusRenderer.show();\n} else {\nstationRadiusRenderer.hide();\n}\n}\n});\n}\npublic void showMenu(Component invoker, int x, int y, Point tile) {\ntileToBuildStationOn = tile;\nsuper.show(invoker, x, y);\n}\n@Override\npublic void setVisible(boolean b) {\n// If this popup is visible, we don't want the station's position to\n// follow the mouse.\nstationBuildModel.setPositionFollowsMouse(!b);\nsuper.setVisible(b);\n}\n}"}
{"className":"jfreerails.client.top.GUIComponentFactoryImpl","javaDoc":"/**\n* Creates and wires up the GUI components.\n*\n* @author Luke\n*/","code":"/**\n* Creates and wires up the GUI components.\n*\n* @author Luke\n*/\npublic class GUIComponentFactoryImpl implements GUIComponentFactory,\nWorldMapListener, WorldListListener {\n/** Whether to show certain 'cheat' menus used for testing. */\nprivate static final boolean CHEAT = (System.getProperty(\"cheat\") != null);\nprivate static final Logger logger = Logger\n.getLogger(GUIComponentFactoryImpl.class.getName());\nprivate final ActionRoot actionRoot;\nprivate final BuildMenu buildMenu;\nprivate final CashJLabel cashjLabel;\nprivate final ClientJFrame clientJFrame;\nprivate final DateJLabel datejLabel;\nprivate final DialogueBoxController dialogueBoxController;\nprivate JMenu displayMenu;\nprivate JMenu helpMenu;\nprivate JMenu brokerMenu;\nprivate boolean isSetup = false;\nprivate JMenuItem leaderBoardJMenuItem;\nprivate DetailMapRenderer mainMap;\nprivate final JScrollPane mainMapScrollPane1;\nprivate final MapViewJComponentConcrete mapViewJComponent;\nprivate final ModelRootImpl modelRoot;\nprivate JMenuItem networthGraphJMenuItem;\nprivate MapRenderer overviewMap;\nprivate final JPanel overviewMapContainer;\nprivate final Rectangle r = new Rectangle(10, 10, 10, 10);\nprivate JMenu reportsMenu;\nprivate ServerControlModel sc;\nprivate ActionAdapter speedActions;\nprivate JMenuItem stationInfoJMenuItem;\nprivate final StationTypesPopup stationTypesPopup;\nprivate JMenuItem trainListJMenuItem;\nprivate JMenuItem trainOrdersJMenuItem;\nprivate JMenuItem callBrokerJMenuItem;\n/**\n* This is the panel at the bottom right of the screen.\n*/\nprivate final RHSJTabPane trainsJTabPane;\nprivate final UserInputOnMapController userInputOnMapController;\nprivate UserMessageGenerator userMessageGenerator;\nprivate RenderersRoot renderers;\nprivate ReadOnlyWorld world;\npublic GUIComponentFactoryImpl(ModelRootImpl mr, ActionRoot ar) {\nmodelRoot = mr;\nactionRoot = ar;\nuserInputOnMapController = new UserInputOnMapController(modelRoot, ar);\nbuildMenu = new jfreerails.client.top.BuildMenu();\nmapViewJComponent = new MapViewJComponentConcrete();\nmainMapScrollPane1 = new JScrollPane();\noverviewMapContainer = new OverviewMapJComponent(r);\nstationTypesPopup = new StationTypesPopup();\nMainMapAndOverviewMapMediator mediator = new MainMapAndOverviewMapMediator();\nmediator.setup(overviewMapContainer, mainMapScrollPane1.getViewport(),\nmapViewJComponent, r);\ntrainsJTabPane = new RHSJTabPane();\ndatejLabel = new DateJLabel();\ncashjLabel = new CashJLabel();\nclientJFrame = new ClientJFrame(this);\ndialogueBoxController = new DialogueBoxController(clientJFrame,\nmodelRoot);\nactionRoot.setDialogueBoxController(dialogueBoxController);\nmodelRoot.addSplitMoveReceiver(new MoveReceiver() {\npublic void processMove(Move move) {\nif (move instanceof ChangeGameSpeedMove) {\nChangeGameSpeedMove speedMove = (ChangeGameSpeedMove) move;\nfor (Enumeration<Action> actionsEnum = speedActions\n.getActions(); actionsEnum.hasMoreElements();) {\nAction action = actionsEnum.nextElement();\nString actionName = (String) action\n.getValue(Action.NAME);\nif (actionName.equals(actionRoot.getServerControls()\n.getGameSpeedDesc(speedMove.getNewSpeed()))) {\nspeedActions.setSelectedItem(actionName);\n}\nbreak;\n}\n}\n}\n});\nuserMessageGenerator = new UserMessageGenerator(this.modelRoot,\nthis.actionRoot);\nmodelRoot.addCompleteMoveReceiver(userMessageGenerator);\n}\nprivate void countStations() {\nNonNullElements stations = new NonNullElements(KEY.STATIONS, modelRoot\n.getWorld(), modelRoot.getPrincipal());\nboolean enabled;\nif (stations.size() > 0) {\nenabled = true;\n} else {\nenabled = false;\n}\nthis.trainsJTabPane.setStationTabEnabled(enabled);\nthis.stationInfoJMenuItem.setEnabled(enabled);\n}\nprivate void countTrains() {\nNonNullElements trains = new NonNullElements(KEY.TRAINS, modelRoot\n.getWorld(), modelRoot.getPrincipal());\nboolean enabled;\nif (trains.size() > 0) {\nenabled = true;\n} else {\nenabled = false;\n}\nthis.trainsJTabPane.setTrainTabEnabled(enabled);\nthis.trainListJMenuItem.setEnabled(enabled);\nthis.trainOrdersJMenuItem.setEnabled(enabled);\n}\npublic JMenu createBuildMenu() {\nreturn buildMenu;\n}\npublic JLabel createCashJLabel() {\nreturn cashjLabel;\n}\npublic JFrame createClientJFrame(String title) {\nclientJFrame.setTitle(title);\nreturn clientJFrame;\n}\npublic JLabel createDateJLabel() {\nreturn datejLabel;\n}\npublic JMenu createBrokerMenu() {\nbrokerMenu = new JMenu(\"Broker\");\ncallBrokerJMenuItem = new JMenuItem(\"Call Broker\");\ncallBrokerJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showBrokerScreen();\n}\n});\nbrokerMenu.add(callBrokerJMenuItem);\nreturn brokerMenu;\n}\npublic JMenu createDisplayMenu() {\ndisplayMenu = new JMenu(\"Display\");\ndisplayMenu.setMnemonic(68);\ntrainOrdersJMenuItem = new JMenuItem(\"Train Orders\");\ntrainOrdersJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showTrainOrders();\n}\n});\nstationInfoJMenuItem = new JMenuItem(\"Station Info\");\nstationInfoJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showStationInfo(0);\n}\n});\ntrainListJMenuItem = new JMenuItem(\"Train List\");\ntrainListJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showTrainList();\n}\n});\ndisplayMenu.add(trainOrdersJMenuItem);\ndisplayMenu.add(stationInfoJMenuItem);\ndisplayMenu.add(trainListJMenuItem);\ndisplayMenu.addSeparator();\n// Add menu items to control what gets displayed on the map.\nfinal JCheckBoxMenuItem showCargoMenuItem = new JCheckBoxMenuItem(\n\"Show cargo at stations\", true);\ndisplayMenu.add(showCargoMenuItem);\nshowCargoMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nmodelRoot.setProperty(\nModelRoot.Property.SHOW_CARGO_AT_STATIONS, new Boolean(\nshowCargoMenuItem.isSelected()));\nmapViewJComponent.refreshAll();\n}\n});\nfinal JCheckBoxMenuItem showStationNamesMenuItem = new JCheckBoxMenuItem(\n\"Show station names\", true);\ndisplayMenu.add(showStationNamesMenuItem);\nshowStationNamesMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nmodelRoot.setProperty(ModelRoot.Property.SHOW_STATION_NAMES,\nnew Boolean(showStationNamesMenuItem.isSelected()));\nmapViewJComponent.refreshAll();\n}\n});\nfinal JCheckBoxMenuItem showStationBordersMenuItem = new JCheckBoxMenuItem(\n\"Show sphere-of-influence around stations\", true);\ndisplayMenu.add(showStationBordersMenuItem);\nshowStationBordersMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nmodelRoot.setProperty(ModelRoot.Property.SHOW_STATION_BORDERS,\nnew Boolean(showStationBordersMenuItem.isSelected()));\nmapViewJComponent.refreshAll();\n}\n});\nfinal JCheckBoxMenuItem playSoundsMenuItem = new JCheckBoxMenuItem(\n\"Play sounds\", true);\ndisplayMenu.add(playSoundsMenuItem);\nplaySoundsMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nmodelRoot.setProperty(ModelRoot.Property.PLAY_SOUNDS,\nnew Boolean(playSoundsMenuItem.isSelected()));\n}\n});\n;\nboolean showFps = Boolean.parseBoolean(System.getProperty(\"SHOWFPS\"));\nfinal JCheckBoxMenuItem showFPSMenuItem = new JCheckBoxMenuItem(\n\"Show FPS stats\", showFps);\ndisplayMenu.add(showFPSMenuItem);\nshowFPSMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nString newValue = String.valueOf(showFPSMenuItem.isSelected());\nSystem.setProperty(\"SHOWFPS\", newValue);\n}\n});\nreturn displayMenu;\n}\npublic JMenu createGameMenu() {\nsc = actionRoot.getServerControls();\nJMenu gameMenu = new JMenu(\"Game\");\ngameMenu.setMnemonic(71);\nJMenuItem quitJMenuItem = new JMenuItem(\"Exit Game\");\nquitJMenuItem.setMnemonic(88);\nquitJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\nSystem.exit(0);\n}\n});\nfinal JMenu newGameJMenu = new JMenu(sc.getNewGameAction());\nnewGameJMenu.addMenuListener(new MenuListener() {\npublic void menuCanceled(MenuEvent e) {\n}\npublic void menuDeselected(MenuEvent e) {\n}\npublic void menuSelected(MenuEvent e) {\nnewGameJMenu.removeAll();\nEnumeration<Action> actions = sc.getMapNames().getActions();\nwhile (actions.hasMoreElements()) {\nJMenuItem mi = new JMenuItem(actions.nextElement());\nnewGameJMenu.add(mi);\n}\n}\n});\nJMenuItem saveGameJMenuItem = new JMenuItem(sc.getSaveGameAction());\nJMenuItem loadGameJMenuItem = new JMenuItem(sc.getLoadGameAction());\n// Fix bug 1102806 Newspaper does nothing, so hide it.\n// JMenuItem newspaperJMenuItem = new JMenuItem(\"Newspaper\");\n// newspaperJMenuItem.setMnemonic(78);\n// newspaperJMenuItem.addActionListener(new ActionListener() {\n// public void actionPerformed(ActionEvent e) {\n// dialogueBoxController.showNewspaper(\"Headline\");\n// //glassPanel.setVisible(true);\n// }\n// });\n// Set up the game speed sub-menu.\nJMenu gameSpeedSubMenu = new JMenu(\"Game Speed\");\nButtonGroup group = new ButtonGroup();\nspeedActions = sc.getSetTargetTickPerSecondActions();\nEnumeration<MappedButtonModel> buttonModels = speedActions\n.getButtonModels();\nEnumeration<Action> actions = speedActions.getActions();\nwhile (buttonModels.hasMoreElements()) {\nJRadioButtonMenuItem mi = new JRadioButtonMenuItem(actions\n.nextElement());\nmi.setModel(buttonModels.nextElement());\ngroup.add(mi);\ngameSpeedSubMenu.add(mi);\n}\ngameMenu.add(newGameJMenu);\ngameMenu.addSeparator();\ngameMenu.add(loadGameJMenuItem);\ngameMenu.add(saveGameJMenuItem);\ngameMenu.addSeparator();\ngameMenu.add(gameSpeedSubMenu);\n// gameMenu.add(newspaperJMenuItem);\ngameMenu.addSeparator();\ngameMenu.add(quitJMenuItem);\nif (CHEAT) {\n/** For testing. */\nfinal ActionListener build200trains = new ActionListener() {\npublic void actionPerformed(ActionEvent arg0) {\nWorldIterator wi = new NonNullElements(KEY.STATIONS,\nmodelRoot.getWorld(), modelRoot.getPrincipal());\nif (wi.next()) {\nRandom randy = new Random();\nStationModel station = (StationModel) wi.getElement();\nImList<PlannedTrain> before = station\n.getProduction();\nint numberOfEngineTypes = modelRoot.getWorld().size(\nSKEY.ENGINE_TYPES) - 1;\nint numberOfcargoTypes = modelRoot.getWorld().size(\nSKEY.CARGO_TYPES) - 1;\nPlannedTrain[] temp = new PlannedTrain[200];\nfor (int i = 0; i < temp.length; i++) {\nint engineType = randy.nextInt(numberOfEngineTypes);\nint[] wagonTypes = new int[] {\nrandy.nextInt(numberOfcargoTypes),\nrandy.nextInt(numberOfcargoTypes),\nrandy.nextInt(numberOfcargoTypes) };\nPlannedTrain plannedTrain = new PlannedTrain(engineType, wagonTypes);\ntemp[i] = plannedTrain;\n}\nImList<PlannedTrain> after = new ImList<PlannedTrain>(temp);\nMove m = new ChangeProductionAtEngineShopMove(before,\nafter, wi.getIndex(), modelRoot.getPrincipal());\nmodelRoot.doMove(m);\n}\n}\n};\nJMenuItem build200TrainsMenuItem = new JMenuItem(\n\"Build 200 trains!\");\nbuild200TrainsMenuItem.addActionListener(build200trains);\ngameMenu.add(build200TrainsMenuItem);\n}\nreturn gameMenu;\n}\npublic JMenu createHelpMenu() {\nhelpMenu = new javax.swing.JMenu(\"Help\");\nJMenuItem about = new JMenuItem(\"About\");\nabout.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showAbout();\n}\n});\nJMenuItem how2play = new JMenuItem(\"Getting started\");\nhow2play.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showHow2Play();\n}\n});\nJMenuItem showControls = new JMenuItem(\"Show game controls\");\nshowControls.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showGameControls();\n}\n});\nJMenuItem showJavaProperties = new JMenuItem(\"Show Java Properties\");\nshowJavaProperties\n.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showJavaProperties();\n}\n});\nJMenuItem showReportBug = new JMenuItem(\"Report Bug\");\nshowReportBug.addActionListener(new java.awt.event.ActionListener() {\npublic void actionPerformed(java.awt.event.ActionEvent evt) {\ndialogueBoxController.showReportBug();\n}\n});\nhelpMenu.add(showControls);\nhelpMenu.add(how2play);\nhelpMenu.add(showJavaProperties);\nhelpMenu.add(showReportBug);\nhelpMenu.add(about);\nreturn helpMenu;\n}\npublic JScrollPane createMainMap() {\nreturn mainMapScrollPane1;\n}\npublic JPanel createOverviewMap() {\nreturn overviewMapContainer;\n}\npublic JMenu createReportsMenu() {\nreportsMenu = new javax.swing.JMenu(\"Reports\");\nJMenuItem incomeStatementJMenuItem = new JMenuItem(\"Income Statement\");\nincomeStatementJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showIncomeStatement();\n}\n});\nJMenuItem balanceSheetJMenuItem = new JMenuItem(\"Balance Sheet\");\nbalanceSheetJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showBalanceSheet();\n}\n});\nleaderBoardJMenuItem = new JMenuItem(\"Leaderboard\");\nleaderBoardJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showLeaderBoard();\n}\n});\nnetworthGraphJMenuItem = new JMenuItem(\"Networth Graph\");\nnetworthGraphJMenuItem.addActionListener(new ActionListener() {\npublic void actionPerformed(ActionEvent e) {\ndialogueBoxController.showNetworthGraph();\n}\n});\nreportsMenu.add(balanceSheetJMenuItem);\nreportsMenu.add(incomeStatementJMenuItem);\nreportsMenu.add(leaderBoardJMenuItem);\nreportsMenu.add(networthGraphJMenuItem);\nreturn reportsMenu;\n}\npublic JTabbedPane createTrainsJTabPane() {\nreturn trainsJTabPane;\n}\npublic BuildTrackController getBuildTrackController() {\nreturn mainMap.getBuildTrackController();\n}\npublic boolean isSetup() {\nreturn isSetup;\n}\npublic void itemAdded(KEY key, int index, FreerailsPrincipal principal) {\nboolean rightPrincipal = principal\n.equals(this.modelRoot.getPrincipal());\nif (KEY.TRAINS == key && rightPrincipal) {\ncountTrains();\n} else if (KEY.STATIONS == key && rightPrincipal) {\ncountStations();\n}\n}\npublic void itemRemoved(KEY key, int index, FreerailsPrincipal principal) {\n// do nothing\n}\npublic void listUpdated(KEY key, int index, FreerailsPrincipal principal) {\nboolean rightPrincipal = principal\n.equals(this.modelRoot.getPrincipal());\nif (KEY.TRAINS == key && rightPrincipal) {\ncountTrains();\n} else if (KEY.STATIONS == key && rightPrincipal) {\ncountStations();\n}\n}\n/**\n* Called when a new game is started or a game is loaded.\n* <p>\n* <b>Be extremely careful with the references of objects allocated in this\n* method to avoid memory leaks - see bug 967677 (OutOfMemoryError after\n* starting several new games). </b>\n* </p>\n*/\npublic void setup(RenderersRoot vl, ReadOnlyWorld w) throws IOException {\n/*\n* Set the cursor position. The initial cursor position is 0,0. However,\n* if a game is loaded or a new game is started and the map size is the\n* same as the last map size, then the cursor should take the position\n* it had on the last map.\n*/\nImPoint cursorPosition = new ImPoint(0, 0);\nif (null != world) {\nif (w.getMapWidth() == world.getMapWidth()\n&& w.getMapHeight() == world.getMapHeight()) {\ncursorPosition = (ImPoint) modelRoot\n.getProperty(ModelRoot.Property.CURSOR_POSITION);\n}\n}\nrenderers = vl;\nworld = w;\nmodelRoot.addMapListener(this);\nmodelRoot.addListListener(this);\nif (!vl.validate(world)) {\nthrow new IllegalArgumentException(\"The specified\"\n+ \" RenderersRoot are not compatible with the clients\"\n+ \"world!\");\n}\n// create the main and overview maps\nmainMap = new DetailMapRenderer(world, renderers, modelRoot);\nTrainRenderer trainRenderer = mainMap.getTrainRenderer();\nDimension maxSize = new Dimension(200, 200);\noverviewMap = ZoomedOutMapRenderer.getInstance(world, maxSize);\nstationTypesPopup.setup(modelRoot, actionRoot, mainMap\n.getStationRadius());\nmapViewJComponent\n.setup(mainMap, modelRoot, renderers);\n// setup the the main and overview map JComponents\ndialogueBoxController.setDefaultFocusOwner(mapViewJComponent);\nuserInputOnMapController.setup(mapViewJComponent, actionRoot\n.getTrackMoveProducer(), stationTypesPopup, this.modelRoot,\ndialogueBoxController, mapViewJComponent.getMapCursor(),\ngetBuildTrackController(), trainRenderer);\nbuildMenu.setup(actionRoot);\nmainMapScrollPane1.setViewportView(this.mapViewJComponent);\n((OverviewMapJComponent) overviewMapContainer).setup(overviewMap);\ndatejLabel.setup(modelRoot, vl, null);\ncashjLabel.setup(modelRoot, vl, null);\ntrainsJTabPane.setup(actionRoot, vl, modelRoot);\ndialogueBoxController.setup(modelRoot, vl);\nStationPlacementCursor.wireUp(actionRoot, mainMap.getStationRadius(),\nmapViewJComponent);\nint gameSpeed = ((GameSpeed) world.get(ITEM.GAME_SPEED)).getSpeed();\n/* Set the selected game speed radio button. */\nString actionName = actionRoot.getServerControls().getGameSpeedDesc(\ngameSpeed);\nspeedActions.setSelectedItem(actionName);\nuserMessageGenerator.logSpeed();\n/*\n* Count stations and trains to determine if we need to display the\n* station and train menu items and tabs.3\n*/\ncountStations();\ncountTrains();\nString name = modelRoot.getPrincipal().getName();\nString serverDetails = (String) modelRoot\n.getProperty(ModelRoot.Property.SERVER);\nString frameTitle;\nif (serverDetails.equals(LocalConnection.SERVER_IN_SAME_JVM)) {\nframeTitle = name + \" - Freerails\";\n} else {\nframeTitle = name + \" - \" + serverDetails + \" - Freerails\";\n}\nclientJFrame.setTitle(frameTitle);\nisSetup = true;\nmodelRoot.setProperty(ModelRoot.Property.CURSOR_POSITION,\ncursorPosition);\nmapViewJComponent.requestFocus();\n}\n/**\n* Listens for changes on the map, for instance when track is built, and\n* refreshes the map views.\n*/\npublic void tilesChanged(Rectangle tilesChanged) {\nlogger.fine(\"TilesChanged = \" + tilesChanged);\n// If lots of tiles have changed, do a complete refresh.\nint size = tilesChanged.width * tilesChanged.height;\nif (size > 100) {\nmainMap.refreshAll();\noverviewMap.refreshAll();\n} else {\nPoint tile = new Point();\n// Fix for bug 967673 (Crash when building track close to edge of\n// map).\nRectangle mapRect = new Rectangle(0, 0, world.getMapWidth(), world\n.getMapHeight());\ntilesChanged = tilesChanged.intersection(mapRect);\nfor (tile.x = tilesChanged.x; tile.x < (tilesChanged.x + tilesChanged.width); tile.x++) {\nfor (tile.y = tilesChanged.y; tile.y < (tilesChanged.y + tilesChanged.height); tile.y++) {\nmainMap.refreshTile(tile.x, tile.y);\noverviewMap.refreshTile(tile.x, tile.y);\n}\n}\n}\n}\n}"}
{"className":"jfreerails.client.top.FPScounter","javaDoc":"/**\n* Provides a method that draws a String showing the average FPS over the last\n* complete 5000ms interval.\n*\n* @author Luke\n*\n*/","code":"/**\n* Provides a method that draws a String showing the average FPS over the last\n* complete 5000ms interval.\n*\n* @author Luke\n*\n*/\npublic class FPScounter {\nprivate final double[] fpsValues = new double[400];\nprivate int newFrameCount = 0;\nprivate String newFPSstr = \"starting..\";\nprivate long lastFrameTime;\nprivate final int fontSize;\nprivate final Color bgColor;\nFPScounter() {\nthis.fontSize = 10;\nbgColor = new Color(0, 0, 128);\n}\n// Display the average number of FPS.\nvoid updateFPSCounter() {\nlong currentTime = System.nanoTime();\nif (newFrameCount == 0) {\nlastFrameTime = currentTime;\n}\ndouble dt = currentTime - lastFrameTime;\ndouble fps = 1000000000d / dt;\nfpsValues[newFrameCount % fpsValues.length] = fps;\nnewFrameCount++;\nint n = fpsValues.length;\nif (newFrameCount > fpsValues.length) {\ndouble min = Double.MAX_VALUE;\ndouble max = Double.MIN_VALUE;\ndouble mean = 0;\nfor (int i = 0; i < fpsValues.length; i++) {\nmin = Math.min(min, fpsValues[i]);\nmax = Math.max(max, fpsValues[i]);\nmean += fpsValues[i];\n}\nmean = mean / n;\nif (mean > max)\nthrow new IllegalStateException();\nif (mean < min)\nthrow new IllegalStateException();\ndouble variance = 0;\nfor (int i = 0; i < fpsValues.length; i++) {\ndouble xMinusU = fpsValues[i] - mean;\nvariance += xMinusU * xMinusU;\n}\nvariance = variance / n;\nif (newFrameCount % 20 == 0) {\nStringBuffer sb = new StringBuffer();\nsb.append(\"FPS\\n\");\nsb.append(\" n \");\nsb.append(n);\nsb.append('\\n');\nsb.append(\" \\u03BC \");\nsb.append(Math.round(mean));\nsb.append('\\n');\nsb.append(\" \\u03C3 \");\nsb.append(Math.round(Math.sqrt(variance)));\nsb.append('\\n');\nsb.append(\" min \");\nsb.append(Math.round(min));\nsb.append('\\n');\nsb.append(\" max \");\nsb.append(Math.round(max));\nsb.append('\\n');\nnewFPSstr = sb.toString();\n}\n}\n// g.setColor(Color.WHITE);\n// g.fillRect(50, 50, 50, 20);\n// g.setColor(Color.BLACK);\n// g.drawString(newFPSstr, 50, 65);\nlastFrameTime = currentTime;\n}\nvoid drawFPS(Graphics2D g) {\nint rectWidth;\nint rectHeight;\nint rectX;\nint rectY;\nint positionX = 50;\nint positionY = 70;\nColor textColor = Color.WHITE;\nString[] lines = newFPSstr.split(\"\\n\");\nrectWidth = 60;\nrectHeight = (int) ((fontSize + 1) * 1.2 * lines.length);\nrectY = (int) (positionY - fontSize * 1.2);\nrectX = positionX;\ng.setColor(bgColor);\ng.fillRect(rectX, rectY, rectWidth, rectHeight);\ng.setColor(textColor);\n// g.setFont(font);\nfor (String s : lines) {\ng.drawString(s, positionX, positionY);\npositionY += fontSize * 1.2;\n}\n}\n}"}
